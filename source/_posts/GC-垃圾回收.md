---
title: GC 垃圾回收
date: 2022-07-18 20:04:18
tags: JS
---

### GC 是什么

Garbage Collection，程序工作过程中会产生很多垃圾，这些垃圾是程序不用的内存或者是之前用过了，以后不会再用的空间，而 GC 负责回收。不是所有的语言都有 GC，Java、JavaScript、Python 自带 GC；再比如 C、C++ 没有 GC，需要手动管理内存，相对麻烦

### 垃圾产生&为何回收

我们知道写代码时创建一个基本类型、对象、函数……都是需要占用内存的

```jsx
let test = {
  name: "psilo",
};

test = [1, 2, 3, 4, 5];
```

我们知道 JavaScript 的引用数据类型是保存在堆内存中，然后在栈内存中保存一个对堆内存中实际对象的引用。上图所示，{ name: 'psilo' } 对象没有了引用关系，如果不清理（回收），内存会越来越大。

<!-- more -->

![figure](1.png)

### 垃圾回收策略

在 JavaScript 中，垃圾回收的机制是定期找出不再用到的内存（变量），然后释放其内存。

常见策略：

1. 标记清除
2. 引用计数

### 标记清除（Mark-Sweep）

在 JavaScript 是最常用的，分别 标记 和 清除 两个阶段，标记阶段为所有活动对象做上标记，清除阶段则把没有标记的对象销毁。

引擎在执行 GC 时，需要从出发点去遍历内存中所有的对象打标记，而这个出发点有很多，我们称之为一组 根 对象，而所谓的根对象，其实在浏览器环境中包括又不止于全局 Window 对象、文档 DOM 树 等。整个算法过程大致如下：

- 垃圾收集器在运行时会给内存中的所有变量都加上一个标记，假设内存中所有对象都是垃圾，全标记为 0
- 然后从各个根对象开始遍历，把不是垃圾的节点改成 1
- 清理所有标记为 0 的垃圾，销毁并回收它们所占用的内存空间
- 把所有内存中对象标记修改为 0，等待下一轮垃圾回收

**优点：**

实现比较简单，只需要一个二进制（0 和 1）位就可以标记

**缺点：**

清除后剩余对象的内存位置是不变的，导致空闲内存空间是不连续的，出现了 内存碎片，这就牵扯除了内存分配问题

![figure](2.png)

假设我们新建对象分配内存时需要大小为 size，由于空闲内存是间断的、不连续的，则需要对空间内存列表进行一次单向遍历找出大于等于 size 的块才能为其分配

![figure](3.png)

那如何找到合适的块呢？有三种分配策略：

- First-fit，找到大于等于 size 的块立即返回
- Best-fit，遍历整个空闲列表，返回大于等于 size 的最小分块
- Worst-fit，遍历整个空闲列表，找到最大的分块，然后切成两部分，一部分 size 大小，并将该部分返回

看起来 Worst-fit 的空间利用率最合理，但实际上切分之后会造成更多的小块（回收后），形成内存碎片。对于 First-fit 和 Best-fit 来说，考虑分配的速度和效率 First-fit 才是更名明智的选择。

综上所述，标记清除算法有两个缺点：

- **内存碎片化，**空闲内存块是不连续的，容易出现很多空闲内存块
- **分配速度慢，**即便是 First-fit，其操作仍是一个 O(n) 的操作

归根结底，标记清除的缺点在于内存碎片化，**标记整理（Mark-Compact）**就可以有效地解决：在标记结束后，标记整理会将活着的对象向内存的一端移动，最后清理掉边界的内存

![figure](4.png)

### 引用计数（Reference Counting）

因为它问题很多，目前很少使用这种算法了。策略是跟踪记录每个变量值被使用的次数

- 当声明一个变量并且将一个引用类型赋值给该变量的时候这个值的引用次数就为 1
- 如果同一个值又被赋给另一个变量，那么引用数加 1
- 如果该变量的值被其他的值覆盖了，则引用次数减 1
- 当这个值引用次数变为 0 的时候，说明没有变量在使用，这个值没法被访问了，回收

```jsx
let a = new Object() 	// 此对象的引用计数为 1（a引用）
let b = a 		// 此对象的引用计数是 2（a,b引用）
a = null  		// 此对象的引用计数为 1（b引用）
b = null 	 	// 此对象的引用计数为 0（无引用）
...			// GC 回收此对象
```

虽然看起来简单，但是有一个很严重的问题：循环引用，即：

```jsx
function test() {
  let A = new Object();
  let B = new Object();

  A.b = B;
  B.a = A;
}
```

按照上文的引用计数策略，对象 A 和 B 的引用数量都为 2，但是在 test 函数执行完是需要被清理的

**优点**

在引用值为 0 的时候可以立即被回收，而标记清除需要每隔一段时间进行，而且需要 JS 脚本暂停去执行 GC

**缺点**

需要一个很大内存的计数器，因为我们不知道被引用数量的上限；循环引用问题无法解决

### V8 对 GC 的优化

V8 是基于标记清除算法，但是也做了一些优化

**分代式垃圾回收**

标记清除在每次回收时都要检查内存中所有对象，分代进行 GC 效率会更好，且一些大、老、存活时间厂的对象来说不需要频繁进行清理。

V8 将堆内存分为新生代和老生代两区域，采用不同的 GC 策略管理

新生代的对象为存活时间较短的对象，简单来说就是新产生的对象，通常只支持 1 ～ 8M 的容量，而老生代的对象为存活事件较长或常驻内存的对象。

![figure](5.png)

**新生代垃圾回收**

通过一个 Scavenge 算法进行垃圾回收，将堆内存一分为二，一个是处于使用状态的空间我们暂且称为 使用区，一个是处于闲置状态的空间称之为 空闲区

![figure](6.png)

新加入的对象都会存放到使用区，当使用区快被写满时，就需要执行一次垃圾清理操作

开始回收时，新生代垃圾回收器会对使用区中的活动对象做标记，标记完成后将使用区的活动对象复制进空闲区并进行排序，随后进入垃圾清理阶段，即将非活动对象占用的空间清理掉。最后进行角色互换，把原来的使用区变成空闲区，把原来的空闲区变成使用区

当一个对象经过多次复制后依赖存活，它将会被认为是生命周期较长的对象，随后会被移动到老生代中，采用老生代的垃圾回收策略进行管理

当复制一个对象到空闲区时，空闲区空间占用超过 25%，那么这个对象会被直接移动到老生代空间中，因为两个区域互换的时候，如果占比较大，会影响后续内存分配。

**老生代垃圾回收**

标记清除 + 标记整理

**为什么需要分代式**

分代式机制把一些新、小、存活时间短的对象作为新生代，采用一小块内存频率较高的快速清理，而一些大、老、存活时间较长的对象作为老生代，使其很少接受检查，新老生代的回收机制及频率是不同的，可以说此机制的出现很大程序提高了垃圾回收机制的效率

**并行回收（Parallel）**

在介绍并行之前，要了解 全停顿（Stop-The-World）概念，我们都知道 JavaScript 是一门单线程的语言，它是运行在主线程上的，那在进行垃圾回收时就会阻塞 JavaScript 脚本的执行，需等待垃圾回收完毕后再恢复脚本执行，称为全停顿

比如一次 GC 需要 60ms，那我们的应用逻辑就得暂停 60ms，所谓并行，指的是垃圾回收器在主线程上执行的过程中，开启多个辅助线程，同时执行同样的回收工作

![figure](7.png)

简单来说，使用并行回收，加入本来主线程一个人干活，它需要 3s，现在叫上 2 个辅助线程一起干活，加上多人协同（同步开销）的时间（0.5s），本来需要 3s 的活现在 1.5s 就可以干完

新生代对象空间就采用并行策略，在执行垃圾回收的过程中，会启动多个线程来负责新生代中的垃圾清理操作，这些线程同时将对象空间中的数据移动到空闲区域，这个过程中由于数据地址会发生改变，所以还需要同步更新引用这些对象的指针，即并行回收

**增量标记与惰性清理**

并行策略虽然可以增加垃圾回收的效率，对于新生代垃圾回收器能够有很好的优化，但是其实它还是一种全停顿式的垃圾回收方式，对于老生代来说，它的内部存放的都是一些比较大的对象，对于这些大的对象 GC 时哪怕我们使用并行策略依然会消耗大量时间

所以为了减少全停顿的时间，在 2011 年，V8 对老生代的标记进行老优化，从全停顿标记切换到增量标记

**什么是增量标记**

增量就是将一次 GC 标记的过程，分成了很多小步，每执行完一小步就让应用逻辑执行一会，这样交替多次后完成一轮 GC

![figure](8.png)

将一次完整的 GC 标记分次执行，那么在每一小次 GC 标记执行完后如何暂停下来去执行任务程序，而后又怎么恢复呢？假如我们在一次完整的 GC 标记分块暂停后，执行任务程序时内存中标记好的对象引用关系被修改老又怎么办呢？V8 针对这两个问题对应的解决方案分别是 三色标记法 和 写屏障

**三色标记法**

我们知道老生代是采用标记清理算法，而上文的标记清理中我们说过，也就是在没有采用增量算法前，单纯使用黑色和白色来标记数据就可以来，在执行一次完整的 GC 标记前，垃圾回收器会将所有的数据置为白色，然后垃圾回收器在从一组根对象触发，将所有能访问到的数据标记为黑色，遍历结束后，标记为白色的对象就是待清理对象

如果采用这种非黑即白的标记策略，那么在垃圾回收器执行来一段增量回收后，暂停启用主线程去执行应用程序中的一段 JavaScript 代码，随后当垃圾回收器再次被启动，这时候内存中黑白色都有，我们无法得知下一步走到哪里了

三色标记法使用每个对象的两个标记位和一个标记工作表来实现标记，两个标记位编码三种颜色：白、灰、黑

- 白色指的是未被标记的对象
- 灰色指的是自身被标记，成员变量（该对象的引用对象）未被标记
- 黑色指自身和成员皆被标记

![figure](9.png)

直到没有可标记灰色的对象时，那么剩下的白色对象就是无法到达的，等待回收（如上图 C、E）

**写屏障（增量中修改引用）**

一次完整的 GC 标记分块暂停后，执行任务程序时内存中标记好的对象引用关系被修改了

![figure](10.png)

修改后，没有灰色对象，新修改的白色对象 D 将在次轮 GC 的清理阶段被回收。为了解决这个问题， V8 增量回收使用 写屏障（Write-barrier）机制，一旦又黑色对象引用白色对象，该机制会强制将引用的白色对象改为灰色，保证下一次增量 GC 标记阶段可以正确标记，这个机制也称做 强三色不变性

**惰性清理**

增量标记其实只是对活动对象和非活动对象进行标记，对于真正的清理释放内存 V8 采用的是惰性清理（Lazy Sweeping）

增量标记完成后，惰性清理就开始了。当增量标记完成后，假如当前的可用内存足以让我们快速的执行代码，其实我们是没必要立即清理内存的，可将清理过程稍微延迟一下，让 JavaScript 脚本代码先执行，也无需一次性清理完所有非活动对象的内存，可用按需逐一进行清理直到所有的非活动对象内存都清理完毕，后面再接着执行增量标记

**增量标记与惰性清理的优缺**

增量标记与惰性清理的出现，使得主线程的停顿时间大大减少了，让用户与浏览器交互的过程变得更加流畅。但是由于每个小的增量标记之间执行了 JavaScript 代码，堆中的对象指针可能发生变化，需要使用写屏障计数来记录引用关系的变化，所以增量标记缺点也很明显：

首先是并没有减少主线程的总暂停时间，甚至会略微增加，其次由于写屏障机制的成本，增量标记可能会降低应用程序的吞吐量

### 并发回收（Concurrent）

并行回收依然会阻塞主线程，增量标记也会增加总暂停时间、降低应用程序吞吐量两个缺点。并发回收能在主线程执行 JavaScript 过程中，辅助线程能够在后台完成执行垃圾回收的操作，辅助线程在执行垃圾回收的时候，主线程也可以自由执行而不会被挂起

![figure](11.png)

辅助线程在执行垃圾回收的时候，主线程也可以自由执行而不会被挂起，这是并发的优点也是并发实现的难点，因为它需要考虑主线程在执行 JavaScript 时，堆中对象引用关系随时都有可能发生变化，这时辅助线程之前做的一些标记活着正在进行的标记就会有所改变，所以它需要额外实现一些读写锁机制来控制

**V8 中 GC 优化**

我们说过新生代垃圾回收器，使用并行回收可以很好的增加垃圾回收的效率，那老生代垃圾回收器是用哪种策略呢？上面说来并行回收、增量标记与惰性清理、并发回收这几种回收方式来提高效率、优化体验，其实老生代垃圾回收器都是融合使用的。

老生代主要使用并发标记，主线程在开始执行 JavaScript 时，辅助线程也同时执行标记操作

标记完成后，再执行并行清理操作

同时，清理的任务会采用增量的方式分批在各个 JavaScript 任务间执行
