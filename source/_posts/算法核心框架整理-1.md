---
title: 算法核心框架整理(1)
date: 2022-03-16 19:17:33
tags: [算法]
---

##### 写在前面

如今算法已经越发成为程序员的必修功法，本文旨在归纳各经典算法。阅读本文后，相信可以对十大算法有进一步的理解。

# 算法

**是否稳定**：如果 a 原本在 b 前面，且 a=b，排序之后 a 仍然在 b 的前面，则为稳定算法

**内排序**：所有排序操作都在内存中完成

**外排序**：由于数据太大，把数据放在磁盘中，排序通过磁盘和内存的数据传输进行

<!-- more -->

**时间复杂度**：算法执行所耗费的时间

**空间复杂度**：运行完一个程序所需内存的大小

**算法总结**


![summary](summary.png)

上图名词解释：n 数据规模；k “桶”的个数；In-place 占用常数内存，不占用额外内存；Out-place 占用额外内存

**分类**

![type](type.png)

### 冒泡排序（Bubble Sort）

通过两层循环重复遍历数据，一次比较两个相邻元素，如果排序错误就交换。该算法的名字由来是因为越小的元素会经由交换慢慢“浮”到数据的顶端

**实现（升序）**

1. 比较相邻的元素，如果第一个比第二个大，交换位置
2. 对每一对相邻元素作相同的工作，从开始第一对到结尾的最后一对，这样在最后的元素就是最大的数
3. 针对所有的元素重复以上步骤，除了最后一个
4. 重复步骤 1 ～ 3

**稳定性**

即使两个元素相等也不会交换，前后顺序没有改变，所以冒泡排序是稳定排序算法

![bubble_1](bubble_1.png)

![bubble_2](bubble_2.png)

![bubble_3](bubble_3.png)

**时间复杂度分析**

- 最佳情况：T(n) = O(n)
- 最差情况：T(n) = O(n²)
- 平均情况：T(n) = O(n²)

### 选择排序

首先在未排序的数据中找到最小（大）元素，存放到数据的起始位置，然后再从剩余未排序元素中继续寻找最小（大）元素，放到已排序数据的末尾，以此类推

**实现（升序）**

1. 初始状态：无序区为 R[1..n]，有序区为空
2. 第 i 趟排序（i=1,2,3...n-1）开始时，当前有序区和无序区分别为 R[1..i-1] 和 R[i..n]，该趟排序从当前无序区中选出最小的数据 R[k]，将它与无序区的第 1 个数据 R 交换，使 R[1..i] 和 R[i+1..n] 分别为记录个数增加 1 个 的新有序区和记录个数减少 1 个的新无序区
3. n - 1 趟结束，数据有序化

**稳定性**

举个例子：序列 [5, 8, 5, 2, 9]，第一遍选择第一个元素 5 和第四个元素 2 交换，那么原序列中 2 个 5 的相对顺序就被破坏了，所以选择排序不是稳定排序算法

![selection_1](selection_1.png)

**时间复杂度分析**

- 最佳情况：T(n) = O(n²)
- 最差情况：T(n) = O(n²)
- 平均情况：T(n) = O(n²)

### 插入排序

通过构建有序序列，对于未排序数据，在已排序序列中从后向前扫面，找到相应位置并插入。在实现上通常采用 In-place 排序。

**实现**

1. 从第一个元素开始，该元素认为已经被排序
2. 取出下一个元素，在已经排序的元素序列中从后向前扫描
3. 如果该元素（已排序）大于新元素，将该元素移到下一位置
4. 重复步骤 3，直到找到已排序的元素小于或者等于新元素的位置
5. 将新元素插入到该位置后
6. 重复步骤 2 ～ 5

**稳定性**

插入排序是在一个已经有序的小序列上，从末尾每次插入一个元素，所以插入排序是稳定排序算法

![insertion_1](insertion_1.png)

**时间复杂度分析**

- 最佳情况：T(n) = O(n)
- 最坏情况：T(n) = O(n²)
- 平均情况：T(n) = O(n²)

### 希尔排序

间隔序列的设定。既可以提前设定好间隔序列，也可以动态的定义间隔序列。希尔排序又叫缩小增量排序

**实现**

1. 选择一个增量序列 t1, t2, ..., tk，其中 ti > tj, tk = 1
2. 按增量序列个数 k, 对序列进行 k 趟 排序
3. 每趟排序，根据对应的增量 ti，将待排序列分割成若干长度为 m 的子序列，分别对各子表

**稳定性**

举个例子，序列 [1, 2, 2, 1]，排序完为 [1, 1, 2, 2]，两个 2 的相对顺序被破坏，所以希尔排序是不稳定的排序算法

![shell_1](shell_1.png)

**时间复杂度分析**

- 最佳情况：T(n) = $O(nlog^2n)$
- 最坏情况：T(n) = $O(nlog^2n)$)
- 平均情况：T(n) = $O(nlogn)$

### 归并排序

是建立在归并操作上的一种有效的排序算法。该算法采用分治法，利用空间来换时间。它是稳定的排序方法。将已有序的子序列合并，得到完全有序的序列。若将两个有序表合并成一个有序表，成为 2-路归并。归并排序非常适合链表排序

**实现**

1. 将长度为 n 的输入序列分为两个长度为 n/2 的子序列
2. 将两个子序列分别采用归并排序
3. 将两个排序好的子序列合并成一个最终的排序序列

**稳定性**

归并排序是吧序列递归地分成短序列，没有涉及到元素相等的交换，所以是稳定的排序

![merge_1](merge_1.png)

**时间复杂度分析**

- 最佳情况：T(n) = O(n)
- 最差情况：T(n) = $O(nlogn)$
- 平均情况：T(n) = $O(nlogn)$

### 快速排序

分而治之的思想，通过一趟排序将待排记录分割成独立的两部分，其中一部分记录的关键字均比另一部分的关键字小，则可分别对两部分记录继续进行排序，以打到整个序列有序

**实现**

1. 将数列中挑出一个元素，成为“基准”（pivot）
2. 重新排序序列，所有元素比基准值小的摆放在基准前面，大的摆放在基准后面。在这个分区退出之后，该基准就处于数列的中间位置。成为分区（partition）操作
3. 递归地（recursive）把小于基准值元素的子数列和大于基准值元素的子数列排序

**稳定性**

不考虑额外空间：基准与双指针 i, j 进行双向遍历，举个例子 [5 3 3 4 3 8 9 10 11]，基准 5 会与第五个元素 3 交换，破坏了 3 的相对顺序，所以是不稳定排序

考虑额外空间：如下图代码所示，是稳定排序

![quick_1](quick_1.png)

**空间负责度分析**

- 最佳情况：T(n) = O(nlogn)
- 最差情况：T(n) = $O(n^2)$
- 平均情况：T(n) = O(nlogn)

### 堆排序

利用堆数据结构的一种排序算法。堆积是一个近似完全二叉树的结构，并同事满足堆积的性质：即父节点的键值或索引总是大于（小于）它的左右子节点，称为大顶堆（小顶堆）

**实现**

1. 将初始待排序关键字序列（R1, R2...Rn）构成大顶堆，此堆为初始的无序区
2. 将顶堆元素 R[1] 与最后一个元素 R[n] 交换，此时得到新的无序区（R1, R2, ...R(n-1)）和新的有序区（Rn），且满足 R[1, 2, ...n-1] ≤ R[n]
3. 由于交换后新的堆顶 R[1] 可以违反堆的性质，因此需要对当前无序区（R1, R2, ...R(n-1)）调整为新堆，然后再次将 R[1] 与无序区最后一个元素交换，得到新的无序区（R1, R2, ...R(n-2)）和新的有序区（R(n-1), Rn）。不断重复此过程直到有序区的元素个数为 n-1，则整个排序过程完成

**稳定性**

涉及到没有额外空间的位置交换，就是不稳定排序

![heap_1](heap_1.png)

**时间复杂度分析**

- 最佳情况：T(n) = O(nlogn)
- 最差情况：T(n) = O(nlogn)
- 平均情况：T(n) = O(nlogn)

### 计数排序

使用一个额外的数组 C，其中第 i 个元素是待排序数组 A 中值等于 i 的元素个数。然后根据数据 C 来将 A 中的元素排到正确的位置。它只能对整数进行排序，如果数据范围比要排序的数据大很多，则不适用

**实现**

1. 找出待排序的数组中最小值
2. 统计数组中每个值为 i 的元素出现的次数，结合最小值存入数组 C 的第 i 项（存在则加 1，不存在则赋值为 1）
3. 反向填充目标数组：将每个元素 i 放在新数组的第 C(i) 项，每放一个元素就将 C(i) 减去 1

**稳定性**

按顺序 push 进各自统计数组，所以是稳定排序算法

![counting_1](counting_1.png)

**时间复杂度分析**

- 最佳情况：T(n) = O(n+k)
- 最差情况：T(n) = O(n+k)
- 平均情况：T(n) = O(n+k)

### 桶排序（Bucket sort）

是计数排序的升级版。假设输入数据服从均匀分布，将数据分到有限数量的桶里，每个桶再分别排序（有可能再使用别的排序算法或是以递归方式继续使用桶排序）

**实现**

1. 设置一个定量的数组当作空桶
2. 遍历输入数据，并且把数据一个一个放到对应的桶里
3. 对每个不是空的桶进行排序
4. 从不是空的桶里把排序好的数据拼接起来

**稳定型**

按顺序 push 进各自桶数组，无涉及位置交换，所以是稳定的排序算法

![bucket_1](bucket_1.png)

**时间复杂度分析**

- 最佳情况：T(n) = O(n+k)
- 最差情况：T(n) = $O(n^2)$
- 平均情况：T(n) = O(n+k)

### 基数排序（Radix Sort）（也称鸽巢排序）

是非比较的排序算法。每个数值都要大于等于 0，数据范围建议小于 1000。基数排序是按照低位先排序，收集；再按照高位排序，收集；以此类推，直到最高位。基于分别排序，分别收集，所以是稳定的。（LSD：从低位开始排序；MSD：从高位开始排序）

**实现**

1. 取得数组中的最大数，并取得位数
2. arr 为原始数组，从最低位开始取每个位组成 radix 数组
3. 对 radix 进行计数排序（利用计数排序适合于小范围数的特点）

**稳定性**

没有设计位置交换，是稳定排序算法

![radix_1](radix_1.png)

**时间复杂度分析**

- 最佳情况：T(n) = O(n \* k)
- 最差情况：T(n) = O(n \* k)
- 平均情况：T(n) = O(n \* k)

### **基数排序 vs 计数排序 vs 桶排序**

这三种排序算法都利用了桶的概念，但对桶的使用方法上有明显差异：

1. 基数排序：根据键值的每位数字来分配桶
2. 计数排序：每个桶只存储单一键值
3. 桶排序：每个桶存储一定范围的数值
