{"meta":{"version":1,"warehouse":"2.2.0"},"models":{"Asset":[{"_id":"themes/yilia/source/main.b3331d.css","path":"main.b3331d.css","modified":1,"renderable":1},{"_id":"themes/yilia/source/slider.445162.js","path":"slider.445162.js","modified":1,"renderable":1},{"_id":"themes/yilia/source/main.b3331d.js","path":"main.b3331d.js","modified":1,"renderable":1},{"_id":"themes/yilia/source/mobile.8d90af.js","path":"mobile.8d90af.js","modified":1,"renderable":1},{"_id":"themes/yilia/source/fonts/default-skin.b257fa.svg","path":"fonts/default-skin.b257fa.svg","modified":1,"renderable":1},{"_id":"themes/yilia/source/fonts/iconfont.6e162c.woff","path":"fonts/iconfont.6e162c.woff","modified":1,"renderable":1},{"_id":"themes/yilia/source/fonts/iconfont.9abe9f.svg","path":"fonts/iconfont.9abe9f.svg","modified":1,"renderable":1},{"_id":"themes/yilia/source/fonts/tooltip.4004ff.svg","path":"fonts/tooltip.4004ff.svg","modified":1,"renderable":1},{"_id":"themes/yilia/source/fonts/iconfont.3a9902.eot","path":"fonts/iconfont.3a9902.eot","modified":1,"renderable":1},{"_id":"themes/yilia/source/img/default-skin.png","path":"img/default-skin.png","modified":1,"renderable":1},{"_id":"themes/yilia/source/img/preloader.gif","path":"img/preloader.gif","modified":1,"renderable":1},{"_id":"themes/yilia/source/fonts/iconfont.d0da7e.ttf","path":"fonts/iconfont.d0da7e.ttf","modified":1,"renderable":1},{"_id":"themes/yilia/source/img/header.jpg","path":"img/header.jpg","modified":1,"renderable":1},{"_id":"themes/yilia/source/img/scrollbar_arrow.png","path":"img/scrollbar_arrow.png","modified":1,"renderable":1},{"_id":"themes/yilia/source/img/site.ico","path":"img/site.ico","modified":1,"renderable":1},{"_id":"themes/yilia/source/img/2.png","path":"img/2.png","modified":1,"renderable":1}],"Cache":[{"_id":"source/.DS_Store","hash":"fee6209270d31a832ffad433a503787e89cdfd6f","modified":1625206180271},{"_id":"themes/yilia/.babelrc","hash":"b1b76475ac17dc9e2fa50af96c9e31eea2d0f2b4","modified":1625196030684},{"_id":"themes/yilia/.editorconfig","hash":"da6d022b8f4d9c961e2f8f80677e92af8de0db4d","modified":1625196030684},{"_id":"themes/yilia/.gitignore","hash":"9c4b7d27a1e3e5efa0c8ed143a032a85d586b03b","modified":1625196030684},{"_id":"themes/yilia/README.md","hash":"a6aea7cf499638187bb5d005526d6c0fc213f697","modified":1625196030685},{"_id":"themes/yilia/_config.yml","hash":"c24af8a3af5bd4ba01b995e21f3af865f12fd398","modified":1625196030685},{"_id":"themes/yilia/.eslintrc.js","hash":"5696ae049de010ed3786768b0c359f14c05b5ec6","modified":1625196030684},{"_id":"themes/yilia/package.json","hash":"367cb9579d35968a942c243ab248a5f5ebfaf462","modified":1625196030691},{"_id":"themes/yilia/webpack.config.js","hash":"da7657347109ddb4ab8602b219778117254677fe","modified":1625196030706},{"_id":"themes/yilia/.eslintignore","hash":"df0a50b13cc00acb749226fee3cee6e0351fb1d9","modified":1625196030684},{"_id":"themes/yilia/.gitattributes","hash":"e0f24dceeb1e6878a1dd9b01a2b9df1bc037a867","modified":1625196030684},{"_id":"source/_posts/2017年书单推荐.md","hash":"9da7d1d5a078b7197101102bef6572f472eb19dd","modified":1637116419772},{"_id":"source/_posts/2018年书单推荐.md","hash":"ba7911f48ba263802f65f484b21be06f95a5603e","modified":1625196030649},{"_id":"source/_posts/2019年书单推荐.md","hash":"33dec603c4688223356478d9442a49d553cb38c7","modified":1625196030649},{"_id":"source/_posts/2019年面试总结.md","hash":"1530f667a475b0a9e1a1495cf5d80e2f65f0389e","modified":1625196030649},{"_id":"source/_posts/2020年书单推荐.md","hash":"1a670ca0e87b716969d7f2da797028d8260bf1b7","modified":1625196030650},{"_id":"source/_posts/.DS_Store","hash":"ba2a91afcf5692cf2fce1413d0aa1184f148154e","modified":1646016505261},{"_id":"source/_posts/2021年书单推荐.md","hash":"05e77bc64fa233290bae46a85ef3eed94b2d104d","modified":1644159168794},{"_id":"source/_posts/2022年书单推荐.md","hash":"201da101d3fd7ad54748b89b118edc35649c0fbb","modified":1644159285659},{"_id":"source/_posts/GC-垃圾回收.md","hash":"af82134283d079f8569b88799a1aecf5cde89c99","modified":1658146408178},{"_id":"source/_posts/JSON必知必会.md","hash":"04a16cf73ab927713c5d7e26c9b2d75121660451","modified":1625196030650},{"_id":"source/_posts/console命令大全.md","hash":"d9a8e6fbf54ab9bc4a39a81a490a4b9ec5704bac","modified":1625196030651},{"_id":"source/_posts/hexo d时遇到的新错误.md","hash":"63b97f62c557263439e24c32ee6fddf4ef672d85","modified":1625196030655},{"_id":"source/_posts/indexedDB浅析.md","hash":"cafea5a62c84ff41bcf5448ab2b29ce5529a5fcb","modified":1625205443366},{"_id":"source/_posts/vscode-extension初探.md","hash":"824d07124077023a6aa7aa2e7cf09fdc2a256a3a","modified":1625539012104},{"_id":"source/_posts/从线性渐变属性探究-CSS-数据类型的重要性.md","hash":"2e424e0cb64753a68ccda9fa0ac97660634869b3","modified":1631500878246},{"_id":"source/_posts/关于Flex布局的使用指南.md","hash":"b577628f0248713429a71ce4582401899b73da0d","modified":1625196030656},{"_id":"source/_posts/关于Grid布局的使用指南.md","hash":"f41f2cada6a001503067cf8cb805cdbe06177282","modified":1625196030658},{"_id":"source/_posts/写给自己的Markdown基本语法.md","hash":"2463bd965b7d5c0ba49068cf4deecb74f4385007","modified":1625196030661},{"_id":"source/_posts/图片格式选择.md","hash":"926e9a59e514a8d6a0bd02ac74ecdb5cc1a70d06","modified":1658243265474},{"_id":"source/_posts/基于Inquirer实现命令行文件新增.md","hash":"0be860a99dc3d6da39461d60fcfb9097d5258897","modified":1625207001443},{"_id":"source/_posts/微信小程序-mpVue-部分踩坑实录.md","hash":"9812348dff367f811aeba362d2456fe173b52509","modified":1625196030661},{"_id":"source/_posts/我搭建java后台遇到的一些难题.md","hash":"fa1aa66e36a91d255c540e38b49e6e1153588c79","modified":1625196030661},{"_id":"source/_posts/我收集的一些基础面试题.md","hash":"ebcb790b3421d8f19ca892465e8073d01757cf22","modified":1625196030662},{"_id":"source/_posts/我花三个月汉化了一个文档.md","hash":"57d639e5ba65ff3ae23759ae9c8bfe60717a7e53","modified":1625196030662},{"_id":"source/_posts/我认为的Vue官方文档重点-1.md","hash":"34adeb017db279d7d53039909fd8cdb29bf2f689","modified":1625196030662},{"_id":"source/_posts/我认为的Vue官方文档重点-2.md","hash":"d1b3fb4f0eec01f32bbf33e95020e6d457926bf5","modified":1625196030664},{"_id":"source/_posts/搭建hexo的坑.md","hash":"76d7eea22cb432dc2cf58e8cfc33c352e7963165","modified":1625196030664},{"_id":"source/_posts/浅析CSS实现Footer置底的几种方式.md","hash":"a1ac05b4492cae8fa22129a74f1c41ab25b7e9db","modified":1625196030664},{"_id":"source/_posts/浅析Js的for循环方法.md","hash":"2a89259888aee10f1e47ed3e1995699ae84f9618","modified":1625196030665},{"_id":"source/_posts/浅析Vuex.md","hash":"e60aa0af8664580bed89b31a709c0570d4030999","modified":1625196030665},{"_id":"source/_posts/浅析axios.md","hash":"d6704cd6048abc56b848e6899dfd753d10cbad85","modified":1625196030665},{"_id":"source/_posts/浅述CSS实现垂直居中水平居中的方法.md","hash":"227a37ded36900e540ac242da263ccd32e22a4c7","modified":1625196030665},{"_id":"source/_posts/深入浅出正则匹配.md","hash":"27338ec7b05b850a514a47f02701681936e1bf3a","modified":1653997256163},{"_id":"source/_posts/简述CSS3的一些属性(1).md","hash":"3906e88a61644a5c507efe5cb4c00b568fa0151d","modified":1625196030666},{"_id":"source/_posts/简述CSS3的一些属性(2).md","hash":"f083cc788b0e84176facf63f4f1631fc5643e2b9","modified":1625196030666},{"_id":"source/_posts/简述CSS3的一些属性(3).md","hash":"49eb4122fb776cbcdc221e5ef5c23bdb96c40a8d","modified":1625196030666},{"_id":"source/_posts/简述CSS3的一些属性-4.md","hash":"8c1d4e1e254876b47da965ac9d9c24d921f5f168","modified":1625196030666},{"_id":"source/_posts/简述CSS3的一些属性-5.md","hash":"c7e81a0d78a4d73aa9fbe1d6cbc77185e6a3141e","modified":1625196030667},{"_id":"source/_posts/算法核心框架整理-1.md","hash":"9a47d60a421fbcd41f60529ce63e5632a8d79023","modified":1654049868103},{"_id":"source/_posts/算法核心框架整理-2.md","hash":"35adc973a1561fd428609f188c080d772e33c1cc","modified":1654072235211},{"_id":"themes/yilia/languages/default.yml","hash":"3083f319b352d21d80fc5e20113ddf27889c9d11","modified":1625196030685},{"_id":"themes/yilia/languages/fr.yml","hash":"84ab164b37c6abf625473e9a0c18f6f815dd5fd9","modified":1625196030685},{"_id":"themes/yilia/languages/nl.yml","hash":"12ed59faba1fc4e8cdd1d42ab55ef518dde8039c","modified":1625196030685},{"_id":"themes/yilia/languages/no.yml","hash":"965a171e70347215ec726952e63f5b47930931ef","modified":1625196030685},{"_id":"themes/yilia/languages/ru.yml","hash":"4fda301bbd8b39f2c714e2c934eccc4b27c0a2b0","modified":1625196030685},{"_id":"themes/yilia/languages/zh-CN.yml","hash":"ca40697097ab0b3672a80b455d3f4081292d1eed","modified":1625196030686},{"_id":"themes/yilia/languages/zh-tw.yml","hash":"53ce3000c5f767759c7d2c4efcaa9049788599c3","modified":1625196030686},{"_id":"themes/yilia/layout/category.ejs","hash":"765426a9c8236828dc34759e604cc2c52292835a","modified":1625196030690},{"_id":"themes/yilia/layout/index.ejs","hash":"a35dc900203f9d8dd863ea4c1722198d6d457ec8","modified":1625196030690},{"_id":"themes/yilia/layout/layout.ejs","hash":"0a332bdbd3b86c231d690614687f5b97186b85d5","modified":1625196030690},{"_id":"themes/yilia/layout/page.ejs","hash":"7d80e4e36b14d30a7cd2ac1f61376d9ebf264e8b","modified":1625196030690},{"_id":"themes/yilia/layout/post.ejs","hash":"7d80e4e36b14d30a7cd2ac1f61376d9ebf264e8b","modified":1625196030690},{"_id":"themes/yilia/layout/tag.ejs","hash":"eaa7b4ccb2ca7befb90142e4e68995fb1ea68b2e","modified":1625196030690},{"_id":"themes/yilia/source/main.b3331d.css","hash":"7d0162a4618e8026bd23779f3120c09c83197b9f","modified":1625196030702},{"_id":"themes/yilia/source/slider.445162.js","hash":"a727717abfd319c5de84b425331f55aa709c9276","modified":1625196030706},{"_id":"themes/yilia/source-src/css.ejs","hash":"94dbdb02ca11849e415d54fb28546a598f2cffb1","modified":1625196030691},{"_id":"themes/yilia/source-src/script.ejs","hash":"c21381e1317db7bb157f1d182b8c088cb7cba411","modified":1625196030699},{"_id":"themes/yilia/layout/archive.ejs","hash":"2703b07cc8ac64ae46d1d263f4653013c7e1666b","modified":1625196030690},{"_id":"themes/yilia/source/main.b3331d.js","hash":"5fcc25cc1650f4ebe5d29ac9744f6d2d3a8be677","modified":1625196030704},{"_id":"themes/yilia/source/mobile.8d90af.js","hash":"0873195fea8d34db7233dab3591d41558fb7388b","modified":1625196030705},{"_id":"source/_posts/2021年书单推荐/head_first.jpeg","hash":"39e5a61fd61021ff0794460da0c44cbd03942650","modified":1626145401532},{"_id":"source/_posts/2021年书单推荐/regexp.jpeg","hash":"b0246ee0aa7fb4a34f862a1d2e260f5ad89a7597","modified":1644158945285},{"_id":"source/_posts/2021年书单推荐/svg.jpeg","hash":"924c889cfb5257a913a629913415b952998e8450","modified":1644158881864},{"_id":"source/_posts/2022年书单推荐/design.jpeg","hash":"f0287a4a2257150f882a9fdc285956a569d14c45","modified":1644159146436},{"_id":"source/_posts/2022年书单推荐/.DS_Store","hash":"ff63f76e98d286c2b0287820e7638707a8183ce7","modified":1654048844138},{"_id":"source/_posts/console命令大全/assert_1.jpg","hash":"9559da36dd1abd2bf836c1dcf5ea6f5d21e0c5ba","modified":1625196030651},{"_id":"source/_posts/console命令大全/assert_2.jpg","hash":"353b90c2da83181e96f3bd347ee7e22844aca1e7","modified":1625196030652},{"_id":"source/_posts/console命令大全/count_1.jpg","hash":"34febe687d159520e0a8c141cb89236bfc498df9","modified":1625196030652},{"_id":"source/_posts/console命令大全/dir_1.jpg","hash":"ae3ab20509d2de9785b4c1051331e45e850442ea","modified":1625196030652},{"_id":"source/_posts/console命令大全/dir_2.jpg","hash":"9929aa966bc78f8cec721058f89da4dbf46e7d4d","modified":1625196030652},{"_id":"source/_posts/console命令大全/dir_3.jpg","hash":"9f7e2c2667a0e3cb3516d2c7cfc8f6866b7ef0b8","modified":1625196030653},{"_id":"source/_posts/console命令大全/group_1.jpg","hash":"5f182cbef548b16c9e5050e242e0f8d27fb04947","modified":1625196030653},{"_id":"source/_posts/console命令大全/group_2.jpg","hash":"16549b05908f196ad540c676787efcc0c4a8838c","modified":1625196030653},{"_id":"source/_posts/console命令大全/log_1.jpg","hash":"587435a45004273600882eeffc78d0da159889c2","modified":1625196030653},{"_id":"source/_posts/console命令大全/log_2.jpg","hash":"39837b56ca62b605d437cc003cf6e41dc5256534","modified":1625196030653},{"_id":"source/_posts/console命令大全/log_3.jpg","hash":"bb24b597b498fc2a8d9fade48936aa5883d36ed4","modified":1625196030654},{"_id":"source/_posts/console命令大全/log_4.jpg","hash":"b08097803667bf6a242f0086e64883dec5f14892","modified":1625196030654},{"_id":"source/_posts/console命令大全/log_5.jpg","hash":"f618f0a7e71667e3545d3d5f26219d8ac307cd6b","modified":1625196030654},{"_id":"source/_posts/console命令大全/table_1.jpg","hash":"3013b021255ff9bb81424d51acbb399846d6d723","modified":1625196030654},{"_id":"source/_posts/console命令大全/table_2.jpg","hash":"d8550a41abf57b74edce446fb76bcc66479a093b","modified":1625196030655},{"_id":"source/_posts/console命令大全/table_3.jpg","hash":"6fc644da945110d42e244ea309e38d399c44fe2d","modified":1625196030655},{"_id":"source/_posts/console命令大全/time_1.jpg","hash":"22707457dac7e7afdad3fadc871e06b3244b5c91","modified":1625196030655},{"_id":"source/_posts/console命令大全/trace_1.jpg","hash":"f3882246c8215a06aa5e09508637b7350f7e528b","modified":1625196030655},{"_id":"source/_posts/vscode-extension初探/activation_event_1.png","hash":"146cd4de6ae7401580073fff022c14c92c571262","modified":1625535065481},{"_id":"source/_posts/vscode-extension初探/activation_event_2.png","hash":"7490ba9efb1fb1273d1f209ab90959636411940b","modified":1625535059087},{"_id":"source/_posts/vscode-extension初探/activation_event_3.png","hash":"382fbeb19c3c7113df3982c814e3c5696c66cc5a","modified":1625535048386},{"_id":"source/_posts/vscode-extension初探/cli-builded.png","hash":"1ab604c1445bc15e4ceeaa8be026859dd94199f8","modified":1625044638147},{"_id":"source/_posts/indexedDB浅析/.DS_Store","hash":"578a1a05b69f9f36b5594f1dc6eddeb946a76c76","modified":1625206180271},{"_id":"source/_posts/vscode-extension初探/contribution_points_3.png","hash":"d5d1a9fb1c2f8b6b0fafe715c12530d9ed6d6abf","modified":1625535949939},{"_id":"source/_posts/vscode-extension初探/contribution_points_4.png","hash":"d2ead5ac38f8428ef3d5a1f362bf75a6ea2c76ae","modified":1625535983789},{"_id":"source/_posts/vscode-extension初探/dap.png","hash":"43dd1871f8e4003617b988623e44c1143655499d","modified":1624970259573},{"_id":"source/_posts/vscode-extension初探/.DS_Store","hash":"df2fbeb1400acda0909a32c1cf6bf492f1121e07","modified":1625537817233},{"_id":"source/_posts/vscode-extension初探/marketplace.png","hash":"b103c70011b500714cb80b89db56abcfd2f8f3f9","modified":1625045686415},{"_id":"source/_posts/vscode-extension初探/vscode.png","hash":"d334b21c38436437f667f1f37fe74b17d2ac77dd","modified":1624970591582},{"_id":"source/_posts/关于Flex布局的使用指南/1_space-around.jpg","hash":"e7463ec2cb19add7b20d276e0a54dcff30c7a189","modified":1625196030656},{"_id":"source/_posts/关于Flex布局的使用指南/1_space-between.jpg","hash":"8e728443d293d55ff7413199562b7aee5cc54c9c","modified":1625196030656},{"_id":"source/_posts/关于Flex布局的使用指南/2_baseline.jpg","hash":"d4f57533961a74a9c3bc5314c10d61223b8cee87","modified":1625196030657},{"_id":"source/_posts/关于Flex布局的使用指南/2_flex-start.jpg","hash":"072e3256174cfe8d2b5fd60f24ae1c5e9fb1a232","modified":1625196030657},{"_id":"source/_posts/关于Flex布局的使用指南/3_space-around.jpg","hash":"82bf03a4626da330ae2b6f46e86fdaec5d30c5d6","modified":1625196030657},{"_id":"source/_posts/关于Flex布局的使用指南/3_stretch.jpg","hash":"2655289197f8a89cd1d7ad1d9ec87f4b39756e3b","modified":1625196030657},{"_id":"source/_posts/关于Flex布局的使用指南/4_flex-grow.jpg","hash":"39378d2cf07e475dbb8158c077eaab9f97a31f77","modified":1625196030657},{"_id":"source/_posts/关于Flex布局的使用指南/5_flex-shrink.jpg","hash":"6cd0ed743113fa60ad022d5c72422c4db3120ba0","modified":1625196030657},{"_id":"source/_posts/关于Flex布局的使用指南/6_align-self.jpg","hash":"6123566014c51e8e46accbf2c706ec25ef053822","modified":1625196030657},{"_id":"source/_posts/关于Grid布局的使用指南/grid-area.jpg","hash":"fb46fe0f54e1a4ad23b771874fece29a7fab2009","modified":1625196030658},{"_id":"source/_posts/关于Grid布局的使用指南/grid-gap.jpg","hash":"77575e84ce8d7f52174847911e6ac44bc8bc4341","modified":1625196030659},{"_id":"source/_posts/关于Grid布局的使用指南/grid-template-areas.jpg","hash":"c3357368047814c840113ea315ccec8a3b4b6b29","modified":1625196030659},{"_id":"source/_posts/关于Grid布局的使用指南/grid-template_auto.jpg","hash":"4d105462dd4ad8cf4010fb3c9d266714f0847aad","modified":1625196030659},{"_id":"source/_posts/关于Grid布局的使用指南/grid-with-gap.jpg","hash":"5252be6fa8f4e086561f838f3325e6568507f1f8","modified":1625196030659},{"_id":"source/_posts/关于Grid布局的使用指南/origin.jpg","hash":"2fe0bcf5f59e9949d3ff0ece377359a385198f76","modified":1625196030659},{"_id":"source/_posts/图片格式选择/1.png","hash":"32e571763ad4d5ae30986d42ec696fb630ad9ffb","modified":1658243077056},{"_id":"source/_posts/基于Inquirer实现命令行文件新增/Inquirer_icon.png","hash":"63d80409748aadb9fd21e203ba23f7afb344b32f","modified":1625205775053},{"_id":"source/_posts/基于Inquirer实现命令行文件新增/code_1.png","hash":"4bbbc72d43cff7dbed20ba53c2c67c113222c279","modified":1625206508395},{"_id":"source/_posts/基于Inquirer实现命令行文件新增/code_2.png","hash":"c030adcc91e3b09d5c0b7b495da18a9d232fa219","modified":1625206515164},{"_id":"source/_posts/基于Inquirer实现命令行文件新增/code_3.png","hash":"3d0e727989bc9aa9a3341d11c1dc9acb2a426ea8","modified":1625206532646},{"_id":"source/_posts/基于Inquirer实现命令行文件新增/example_1.png","hash":"33f106847fd96d3f09ec57e65d828d01bb62dbaa","modified":1625205838208},{"_id":"source/_posts/基于Inquirer实现命令行文件新增/result.png","hash":"e78428f568b91a440be04a7f254370308d315c2a","modified":1625206406496},{"_id":"source/_posts/基于Inquirer实现命令行文件新增/situation_1.png","hash":"7b6d1771760ff16092715aabf8e45a61c83dcb04","modified":1625206286228},{"_id":"source/_posts/基于Inquirer实现命令行文件新增/situation_2.png","hash":"250dc54a9821b9c41eed818d74777183d6a04ecb","modified":1625206293764},{"_id":"source/_posts/基于Inquirer实现命令行文件新增/situation_3.png","hash":"f24a27bd5a81c775be450d9ee026c751effacc3f","modified":1625206300438},{"_id":"source/_posts/我认为的Vue官方文档重点-1/1_newPropertyHaventGetterAndSetter.jpg","hash":"d0b574ab0ff0b53de38be82912799849793087d3","modified":1625196030663},{"_id":"source/_posts/我认为的Vue官方文档重点-1/1_textarea_1.jpg","hash":"a7576e18ed8ea2b217803c43406be25c86d5661f","modified":1625196030663},{"_id":"source/_posts/我认为的Vue官方文档重点-1/1_textarea_2.jpg","hash":"0d3b447ffed8991cb0bc1471c86d32922a7194cc","modified":1625196030663},{"_id":"source/_posts/我认为的Vue官方文档重点-1/2_vHtmlUsage.jpg","hash":"e234d52c8feb666b4dc0dc1bdbbdbfb5a42571a7","modified":1625196030663},{"_id":"source/_posts/我认为的Vue官方文档重点-1/3_template_code.jpg","hash":"6ddc0c3b0638625bb9e4fc0da5d41b02b88a6875","modified":1625196030663},{"_id":"source/_posts/我认为的Vue官方文档重点-1/3_template_show.jpg","hash":"d1aeb04a43681f740a9595b826156478b51d8fd0","modified":1625196030663},{"_id":"source/_posts/我认为的Vue官方文档重点-2/2_transition.jpg","hash":"b0087456f012c7b2cbe80368db1370af97103e0c","modified":1625196030664},{"_id":"source/_posts/算法核心框架整理-1/bubble_1.png","hash":"c3146631bfbc61d16028fe3ada3ef2d77e69898c","modified":1653996717784},{"_id":"source/_posts/算法核心框架整理-1/counting_1.png","hash":"0840a6dbbaa9582a5cbe77180b2330a9f46bde52","modified":1653996717891},{"_id":"source/_posts/算法核心框架整理-1/insertion_1.png","hash":"e9a01d8a27cba08e45c6679738112e6bb9bd34ce","modified":1653996717987},{"_id":"source/_posts/算法核心框架整理-1/quick_1.png","hash":"68b46517dbe421f66474051a32a00533e718a1bc","modified":1653996718078},{"_id":"source/_posts/算法核心框架整理-1/selection_1.png","hash":"1430cda4125340f2031142f1ef05ffa59886b7d0","modified":1653996718123},{"_id":"source/_posts/算法核心框架整理-1/shell_1.png","hash":"8ecf5e46a188fbe48405c734e372e0821f482943","modified":1653996718158},{"_id":"themes/yilia/layout/_partial/after-footer.ejs","hash":"143710485f734c5a997e0b1c26192bbba2982bcc","modified":1625196030686},{"_id":"themes/yilia/layout/_partial/archive.ejs","hash":"a6e94061ac55b9eb55275f87b608d62f6ea35659","modified":1653997267618},{"_id":"themes/yilia/layout/_partial/article.ejs","hash":"7547bc40b533d9db62f430c43dc0e595c9caa5b6","modified":1625196030686},{"_id":"themes/yilia/layout/_partial/baidu-analytics.ejs","hash":"f0e6e88f9f7eb08b8fe51449a8a3016273507924","modified":1625196030687},{"_id":"themes/yilia/layout/_partial/css.ejs","hash":"f8a42263edeeb3ccf6115cea5f96f551ed1e76e5","modified":1625196030687},{"_id":"themes/yilia/layout/_partial/footer.ejs","hash":"9a3afad3ccbb585ea109a0d68c4609cb81804840","modified":1626144665447},{"_id":"themes/yilia/layout/_partial/google-analytics.ejs","hash":"f921e7f9223d7c95165e0f835f353b2938e40c45","modified":1625196030687},{"_id":"themes/yilia/layout/_partial/head.ejs","hash":"64f092186b5a744aa1603ce22bb1d44a34446add","modified":1625196030687},{"_id":"themes/yilia/layout/_partial/header.ejs","hash":"6387a93dad7c3d778eb91e3821852fbf6813880c","modified":1625196030687},{"_id":"themes/yilia/layout/_partial/left-col.ejs","hash":"2387d91cf94b0b36e8a36841992a5fce63ebd069","modified":1625196030687},{"_id":"themes/yilia/layout/_partial/mathjax.ejs","hash":"151a1ef2173ba7b6789d349f0f8da89616cc1394","modified":1625196030687},{"_id":"themes/yilia/layout/_partial/mobile-nav.ejs","hash":"7fbbfabf5e29525b24ada14613c21a26789132b4","modified":1625196030687},{"_id":"themes/yilia/layout/_partial/archive-post.ejs","hash":"1f7d4819b7f67602c4a1b99871808d2160b60978","modified":1625196030686},{"_id":"themes/yilia/layout/_partial/tools.ejs","hash":"c41341b9618e591538e1136a2d1637587c1bbd90","modified":1625196030690},{"_id":"themes/yilia/layout/_partial/viewer.ejs","hash":"e495790b2abe2290875817e42bd505bc611d3e26","modified":1625196030690},{"_id":"themes/yilia/source/fonts/default-skin.b257fa.svg","hash":"2ac727c9e092331d35cce95af209ccfac6d4c7c7","modified":1625196030699},{"_id":"themes/yilia/source/fonts/iconfont.6e162c.woff","hash":"709373d566526ad4bdb330757a3915e3c5e37b66","modified":1625196030700},{"_id":"themes/yilia/source/fonts/iconfont.9abe9f.svg","hash":"772383b62548e2a4fa560d589e05929b9f6f7f7b","modified":1625196030700},{"_id":"themes/yilia/source/fonts/tooltip.4004ff.svg","hash":"a5e9fe67e0604c24279281d9fdd2ce1f4536d3e5","modified":1625196030701},{"_id":"themes/yilia/source/fonts/iconfont.3a9902.eot","hash":"51d4e8d333ae7867915037983ea5d4b2ad971930","modified":1625196030700},{"_id":"themes/yilia/source/img/default-skin.png","hash":"ed95a8e40a2c3478c5915376acb8e5f33677f24d","modified":1625196030701},{"_id":"themes/yilia/source/img/preloader.gif","hash":"6342367c93c82da1b9c620e97c84a389cc43d96d","modified":1625196030702},{"_id":"themes/yilia/source/fonts/iconfont.d0da7e.ttf","hash":"53ea5a5027a2fab93bcdad18cad6dc5f1b728726","modified":1625196030700},{"_id":"themes/yilia/source/img/header.jpg","hash":"a14c8936b6ff68795d812500ca324d4039e23dcb","modified":1625196030702},{"_id":"themes/yilia/source/img/scrollbar_arrow.png","hash":"d64a33c4ddfbdb89deeb6f4e3d36eb84dc4777c0","modified":1625196030702},{"_id":"themes/yilia/source/img/site.ico","hash":"99f5ff89599a2197513afe194a336e83aaa1bc0a","modified":1625196030702},{"_id":"themes/yilia/source-src/css/_core.scss","hash":"24f347a2412abbf58318369152504da9538f8d3b","modified":1625196030691},{"_id":"themes/yilia/source-src/css/_function.scss","hash":"93a50dd19a93485712da1f8d0a1672482dd1eabc","modified":1625196030691},{"_id":"themes/yilia/source-src/css/archive.scss","hash":"7d27e22ac898e8fafec14549e940c73cbea1fba8","modified":1625196030691},{"_id":"themes/yilia/source-src/css/article-inner.scss","hash":"d79f2d35a06de83a2a226ca790b7a0a34789c115","modified":1625196030691},{"_id":"themes/yilia/source-src/css/article-main.scss","hash":"3fad68bd74260326f83090b0974dd80707e7bac7","modified":1625196030691},{"_id":"themes/yilia/source-src/css/article-nav.scss","hash":"43e507f2a48504079afd9471353337e23ca47470","modified":1625196030692},{"_id":"themes/yilia/source-src/css/article.scss","hash":"0f6d61af99ed4db87f8589db1feaea7747b55963","modified":1625196030692},{"_id":"themes/yilia/source-src/css/comment.scss","hash":"e6e83d4863afcc589d4dd2f327e9f396f7d7b343","modified":1625196030692},{"_id":"themes/yilia/source-src/css/fonts.scss","hash":"8423700a65e55f1905c92917b6e91bb8322b76b5","modified":1625196030693},{"_id":"themes/yilia/source-src/css/footer.scss","hash":"7c995410b25baaf61dfc5e148e22ca60330abcd3","modified":1625196030694},{"_id":"themes/yilia/source-src/css/global.scss","hash":"b4cb4f45a55d4250cd9056f76dab2a3c0dabcec4","modified":1625196030694},{"_id":"themes/yilia/source-src/css/grid.scss","hash":"849a29fcd7150214fcf7b9715fa5dc71d1f9b896","modified":1625196030694},{"_id":"themes/yilia/source-src/css/highlight.scss","hash":"3719994c2c9393813cc1d42b657205c368a329cb","modified":1625196030695},{"_id":"themes/yilia/source-src/css/left.scss","hash":"0d30c0e7cdb831c3881a017006c782f2214ac195","modified":1625196030695},{"_id":"themes/yilia/source-src/css/main.scss","hash":"ac8c3312182519e33d0f729d157deb36e5f42894","modified":1625196030695},{"_id":"themes/yilia/source-src/css/mobile-slider.scss","hash":"f053c609d84df0dd9eee1d11ddf0c19163a456be","modified":1625196030695},{"_id":"themes/yilia/source-src/css/mobile.scss","hash":"a40400734c6509b9ac6e393a6681ccd8bafed5eb","modified":1625196030696},{"_id":"themes/yilia/source-src/css/page.scss","hash":"bf206bb7f7d0967bc8b7fdf01b7ffc99aff9ba88","modified":1625196030696},{"_id":"themes/yilia/source-src/css/reward.scss","hash":"80a4fcf9171d4a33235da96ac8a2b7dcabc45dfb","modified":1625196030696},{"_id":"themes/yilia/source-src/css/scroll.scss","hash":"9c8dfd1c76854ef063494ca76fac6360b391ed6d","modified":1625196030696},{"_id":"themes/yilia/source-src/css/share.scss","hash":"150c6425f6582e7ec78a873256ce49c9930e8805","modified":1625196030696},{"_id":"themes/yilia/source-src/css/social.scss","hash":"b5324302815491d0a5e63142f1ead2048ad3f72f","modified":1625196030696},{"_id":"themes/yilia/source-src/css/tags-cloud.scss","hash":"c8aa84fca93862d3caae77c552873b8610f33327","modified":1625196030696},{"_id":"themes/yilia/source-src/css/tags.scss","hash":"ac67a3c7097849206244db9b0ba91daaba017ef5","modified":1625196030696},{"_id":"themes/yilia/source-src/css/tools.scss","hash":"17a97f7c38f5dfacc3eadf354b5826d77f1c2bdb","modified":1625196030697},{"_id":"themes/yilia/source-src/css/tooltip.scss","hash":"53d5a554bc2f38e9bb3d26400a47767013c05216","modified":1625196030697},{"_id":"themes/yilia/source-src/js/Q.js","hash":"d011af172064b6c6e0c7051d8f9879373ddac113","modified":1625196030698},{"_id":"themes/yilia/source-src/js/anm.js","hash":"4a4c5d82b09a3063f91a434388e6aa064fd7fd98","modified":1625196030698},{"_id":"themes/yilia/source-src/js/browser.js","hash":"04095b38cfd4316a23f8eb14b1ffaf95f78a4260","modified":1625196030698},{"_id":"themes/yilia/source-src/js/fix.js","hash":"9591a0f61236a56b2a15a541f572bcfd93823a0f","modified":1625196030698},{"_id":"themes/yilia/source-src/js/main.js","hash":"d665f4cf30450984591bc8ad2348a1baf720d04b","modified":1625196030698},{"_id":"themes/yilia/source-src/js/mobile.js","hash":"4d823b039fd296d24a454eae5a798b93c44560cb","modified":1625196030698},{"_id":"themes/yilia/source-src/js/report.js","hash":"4f1d9a18a936ce40b037f636a39127dd19175b6e","modified":1625196030699},{"_id":"themes/yilia/source-src/js/share.js","hash":"b090f82cf80cba7da764753906d9e2cc2acdf30d","modified":1625196030699},{"_id":"themes/yilia/source-src/js/slider.js","hash":"3bf0d70ae171404a0dc73c33ec48927fc2521a54","modified":1625196030699},{"_id":"themes/yilia/source-src/js/util.js","hash":"8456e9d6b19532742582c99b2fb9d09e146e1c58","modified":1625196030699},{"_id":"themes/yilia/source-src/js/viewer.js","hash":"808a2e1ed407984cfdc929b827d3638f70ec9a2a","modified":1625196030699},{"_id":"source/_posts/GC-垃圾回收/7.png","hash":"0446a4b8e24be848920b718ffcb89ae4cdf0b62c","modified":1658146309226},{"_id":"source/_posts/indexedDB浅析/indexedDB_object.png","hash":"89f86403a0026aa5fc85b4174a68ca7f5c279dd6","modified":1625197232069},{"_id":"source/_posts/vscode-extension初探/contribution_points_2.png","hash":"e926ae6796bab7075e1702daa8ba43f85af3cc59","modified":1625535604163},{"_id":"source/_posts/vscode-extension初探/paperang-theme.gif","hash":"e306253383fc358a73d17d2e200cdc0d105b109a","modified":1624931175967},{"_id":"source/_posts/基于Inquirer实现命令行文件新增/code_4.png","hash":"ed2cdc3092fb7ba9ae22e8ae62b22ddba112e5ca","modified":1625206538278},{"_id":"source/_posts/算法核心框架整理-1/bubble_2.png","hash":"98cfdf9c19c384dbafdb0978eafa9a02e7899a23","modified":1653996717816},{"_id":"source/_posts/算法核心框架整理-1/bubble_3.png","hash":"8f0f05534330fa735e2e7e5d15e481ff8965be2f","modified":1653996717845},{"_id":"source/_posts/算法核心框架整理-1/bucket_1.png","hash":"be9721da9461257e793735bfb86f1cfa8a6ad29c","modified":1653996717874},{"_id":"source/_posts/算法核心框架整理-1/heap_1.png","hash":"c7d96681955969067faad9d3a8e35157a78d9686","modified":1653996717930},{"_id":"source/_posts/算法核心框架整理-1/merge_1.png","hash":"2677b83cb7fbbe79b5a545376bef69652ab9548c","modified":1653996718048},{"_id":"source/_posts/算法核心框架整理-1/radix_1.png","hash":"2c78df0e65d474130dfe7d458c41a3190db39171","modified":1653996718106},{"_id":"source/_posts/算法核心框架整理-1/type.png","hash":"fe0455c0aa64d486377c7684636f2a2284fc2b26","modified":1653996718205},{"_id":"themes/yilia/layout/_partial/script.ejs","hash":"6160c13783a7f31dab4fdcc6b752b3a368586d67","modified":1625196030689},{"_id":"source/_posts/GC-垃圾回收/11.png","hash":"f494eadf7c13b0fb0d9f39e031a8f1a42d0d4b70","modified":1658146399069},{"_id":"source/_posts/GC-垃圾回收/8.png","hash":"ce61c752f12eab5402f818c98461924316ffb0d1","modified":1658146359110},{"_id":"source/_posts/indexedDB浅析/compatibility.png","hash":"88c0dd7d7cad510a31623fe6ae9c3ed46e292ee7","modified":1625196730952},{"_id":"source/_posts/vscode-extension初探/contribution_points.png","hash":"78c63ff8f5c83c58a0d3a9a8cf08fd509e2ba2c7","modified":1625535506918},{"_id":"themes/yilia/layout/_partial/post/category.ejs","hash":"c2dccf1a95ec09ceeee5004293ac7edb7e1c9a66","modified":1625196030688},{"_id":"themes/yilia/layout/_partial/post/changyan.ejs","hash":"1ba1d4a4663eae37b1a2b75c47dfdff4fb3cbf52","modified":1625196030688},{"_id":"themes/yilia/layout/_partial/post/date.ejs","hash":"ef71c4081e866a494367575c59610e7e6339ece0","modified":1625196030688},{"_id":"themes/yilia/layout/_partial/post/duoshuo.ejs","hash":"e8399025ed3b980aedb821c92855889f5f12fd5b","modified":1625196030688},{"_id":"themes/yilia/layout/_partial/post/nav.ejs","hash":"1036c8e4e1a7bc935ba173744da735a0d6ed09cd","modified":1625196030688},{"_id":"themes/yilia/layout/_partial/post/share.ejs","hash":"341103df70d0b476e3acd0afbc507a4a120d8f5f","modified":1625196030689},{"_id":"themes/yilia/layout/_partial/post/tag.ejs","hash":"2e783e68755abb852760eb0e627a3fbb50a05a55","modified":1625196030689},{"_id":"themes/yilia/layout/_partial/post/title.ejs","hash":"2f275739b6f1193c123646a5a31f37d48644c667","modified":1625196030689},{"_id":"themes/yilia/layout/_partial/post/wangyiyun.ejs","hash":"7851d961ae172f521ba71e255fdc60f4ca0b45ed","modified":1625196030689},{"_id":"themes/yilia/source/img/2.png","hash":"074143c9733b6ceb433d06a93e2eb5ede9b44e1e","modified":1625196030701},{"_id":"themes/yilia/source-src/css/core/_animation.scss","hash":"63a37f26276f9207405afe0f2d65339ce295bbaf","modified":1625196030692},{"_id":"themes/yilia/source-src/css/core/_media-queries.scss","hash":"491ab3378d5c11005ba65c607608bb36b368a9d5","modified":1625196030692},{"_id":"themes/yilia/source-src/css/core/_mixin.scss","hash":"3bba5c77bad5981eac859fe05c9561d580ba7fa9","modified":1625196030692},{"_id":"themes/yilia/source-src/css/core/_reset.scss","hash":"fab871fa93bd542e76a71a56428f2994a4aaf443","modified":1625196030693},{"_id":"themes/yilia/source-src/css/core/_variables.scss","hash":"fb511c505d1309249f21dc577d4ad2bad99a764f","modified":1625196030693},{"_id":"themes/yilia/source-src/css/fonts/iconfont.eot","hash":"51d4e8d333ae7867915037983ea5d4b2ad971930","modified":1625196030693},{"_id":"themes/yilia/source-src/css/fonts/iconfont.woff","hash":"709373d566526ad4bdb330757a3915e3c5e37b66","modified":1625196030694},{"_id":"themes/yilia/source-src/css/img/checkered-pattern.png","hash":"049262fa0886989d750637b264bed34ab51c23c8","modified":1625196030695},{"_id":"themes/yilia/source-src/css/img/scrollbar_arrow.png","hash":"d64a33c4ddfbdb89deeb6f4e3d36eb84dc4777c0","modified":1625196030695},{"_id":"themes/yilia/source-src/css/img/tooltip.svg","hash":"a5e9fe67e0604c24279281d9fdd2ce1f4536d3e5","modified":1625196030695},{"_id":"source/_posts/基于Inquirer实现命令行文件新增/code_5.png","hash":"96ec25d037449ad5a07755fcbb0bca84bcc05281","modified":1625206548190},{"_id":"source/_posts/基于Inquirer实现命令行文件新增/result_2.png","hash":"11d662318877cd7388a2042fe7b01333606fb602","modified":1625206445647},{"_id":"themes/yilia/source-src/css/fonts/iconfont.svg","hash":"772383b62548e2a4fa560d589e05929b9f6f7f7b","modified":1625196030694},{"_id":"themes/yilia/source-src/css/fonts/iconfont.ttf","hash":"53ea5a5027a2fab93bcdad18cad6dc5f1b728726","modified":1625196030694},{"_id":"source/_posts/基于Inquirer实现命令行文件新增/example_2.png","hash":"56735ece5c48bc1d0fa277e547666e456b3c456e","modified":1625206173639},{"_id":"source/_posts/GC-垃圾回收/10.png","hash":"59e449913af209952ce4f0ead186d1713dba233c","modified":1658146388983},{"_id":"source/_posts/GC-垃圾回收/9.png","hash":"0a4ec9c9154c87ae2f319b8630220dc611c66bb6","modified":1658146374851},{"_id":"source/_posts/vscode-extension初探/lsp.png","hash":"11e5cd50eff9c28897e6b827c5dc1ce8e1987ddd","modified":1624970128825},{"_id":"source/_posts/vscode-extension初探/paperang-pomodoro.gif","hash":"782270824a6b771279f5c1392aa2a14b6d234b7e","modified":1625042586274},{"_id":"source/_posts/GC-垃圾回收/1.png","hash":"8608a42432ee5cfbe02924ab695aadcafacbc982","modified":1658146025030},{"_id":"source/_posts/算法核心框架整理-1/summary.png","hash":"282e126b91e1e8ed4e4ef152945d9728141e40a6","modified":1653996718188},{"_id":"source/_posts/GC-垃圾回收/3.png","hash":"90779a4e02c5a96c428b2eb89669d14c33db2d04","modified":1658146230705},{"_id":"source/_posts/vscode-extension初探/cli.png","hash":"ec46b33d32b07ada2d34ec99e3631edaa6a3fc41","modified":1625044388765},{"_id":"source/_posts/GC-垃圾回收/2.png","hash":"62934e30c1ebbada671c07efbb513b36e7440f62","modified":1658146211361},{"_id":"source/_posts/GC-垃圾回收/5.png","hash":"16f2e66fe2aac12534291c6fd847dd92d58f1160","modified":1658146279445},{"_id":"source/_posts/图片格式选择/2.png","hash":"8a02d6b6ae4172e0b986d5cb47d46f1959b5461e","modified":1658243101765},{"_id":"source/_posts/GC-垃圾回收/6.png","hash":"92b71c6f36e719373620ea398a22f49fe3eb7e7f","modified":1658146294807},{"_id":"source/_posts/2021年书单推荐/design_pattern.image","hash":"9aac33b22d7f132a3b6ad8709854771756ed53e6","modified":1644158842768},{"_id":"source/_posts/GC-垃圾回收/4.png","hash":"b003513d0c52fa2b400995f3973bb47ebcb66a06","modified":1658146245874},{"_id":"source/_posts/vscode-extension初探/local_setup.gif","hash":"3a208e70918ca9fd95b7ae15d9fa83e6104e61a4","modified":1625045057090},{"_id":"public/content.json","hash":"67e029b0ddfa06cda49aabd02f0335edf3f8c2ef","modified":1658243282773},{"_id":"public/CNAME","hash":"062bbc67fdb4634f1e7c10c13854ea651aaade6f","modified":1658243282774},{"_id":"public/2022/06/01/算法核心框架整理-2/index.html","hash":"ac25b61f48d1982b78bcf3518cc1a434f9a6ab4f","modified":1658243284370},{"_id":"public/2022/07/18/GC-垃圾回收/index.html","hash":"f01e88be3f3a12ebe7cd513ce930243204cb336a","modified":1658243284370},{"_id":"public/2022/03/16/算法核心框架整理-1/index.html","hash":"611d628c0829bd4c943fd6a7aba6e00bb5ca82c8","modified":1658243284403},{"_id":"public/2022/02/06/2022年书单推荐/index.html","hash":"2c1eed149d78a32a575c6aa3ba297f4465c24de3","modified":1658243284403},{"_id":"public/2021/11/15/深入浅出正则匹配/index.html","hash":"6056bd4a4d8e6a62a3a55e9473c6bd780959fbc6","modified":1658243284405},{"_id":"public/2021/07/13/2021年书单推荐/index.html","hash":"7c1c5bb72014f67e75b7b7d65576fe5578021c7b","modified":1658243284405},{"_id":"public/2021/09/13/从线性渐变属性探究-CSS-数据类型的重要性/index.html","hash":"5e05bba45c0a50f419d6d75ad265684ec7d090b4","modified":1658243284405},{"_id":"public/2021/07/05/vscode-extension初探/index.html","hash":"40e0daa611013f0eae74d121ef50f0a9f0cc1c5f","modified":1658243284405},{"_id":"public/2021/04/29/基于Inquirer实现命令行文件新增/index.html","hash":"131cc779c5b1049243df3766bb8af81f16967863","modified":1658243284405},{"_id":"public/2021/03/25/indexedDB浅析/index.html","hash":"ee65b8a7662d3f4cceabbeab653e5026d5171af1","modified":1658243284405},{"_id":"public/2020/08/24/我花三个月汉化了一个文档/index.html","hash":"0d8a505f21047e888eef6fa10acfb4edfead4ee3","modified":1658243284405},{"_id":"public/2020/05/28/写给自己的Markdown基本语法/index.html","hash":"3c0d1da278af8405d50c2a7b91e18a8a88eb0f80","modified":1658243284406},{"_id":"public/2019/08/27/2019年面试总结/index.html","hash":"582fabbe7c88beaee3cb353bbf61696e8bcadaf4","modified":1658243284406},{"_id":"public/2020/03/01/2020年书单推荐/index.html","hash":"8bddf3ab4e527f1b5246fd95695eef7bea5dd648","modified":1658243284406},{"_id":"public/2019/06/12/微信小程序-mpVue-部分踩坑实录/index.html","hash":"98b970107cc43963304acb2734a1bdb6388a2622","modified":1658243284406},{"_id":"public/2019/04/12/2019年书单推荐/index.html","hash":"e584bd529407ebfc31fd5fff4c346b01a65032da","modified":1658243284406},{"_id":"public/2018/04/11/浅析axios/index.html","hash":"08bd3feb65fd69a4f26555b250ca1add89088b17","modified":1658243284406},{"_id":"public/2018/05/10/console命令大全/index.html","hash":"4ab5b322539f427861fed07ba21290fd6c727dcf","modified":1658243284406},{"_id":"public/2018/03/27/浅析Vuex/index.html","hash":"1f309ad38896c0197e2bf303994d3090bb028a9c","modified":1658243284406},{"_id":"public/2018/03/03/我认为的Vue官方文档重点-2/index.html","hash":"eaec4c39cab148c54620d67d93d73b7eebfd0293","modified":1658243284407},{"_id":"public/2018/03/01/2018年书单推荐/index.html","hash":"7034928a81f33879f249cf9b92081afe24a255df","modified":1658243284407},{"_id":"public/2018/02/23/关于Flex布局的使用指南/index.html","hash":"d93b8d2ee3f03598dee2036189a43878c44d7f32","modified":1658243284407},{"_id":"public/2018/01/15/我认为的Vue官方文档重点-1/index.html","hash":"8154adbafc304acca1d4385ddf7a2971f3cbac14","modified":1658243284407},{"_id":"public/2017/12/16/关于Grid布局的使用指南/index.html","hash":"e2492db1adcbf99b2386fdaf3dcffce1acfe4a31","modified":1658243284407},{"_id":"public/2017/11/23/我搭建java后台遇到的一些难题/index.html","hash":"82cc83b30f0212b87fcf501aeb24282705aaf96d","modified":1658243284407},{"_id":"public/2017/11/05/浅析CSS实现Footer置底的几种方式/index.html","hash":"9ae04608148cf5527716b3905beedcb086267278","modified":1658243284407},{"_id":"public/2017/10/15/浅析Js的for循环方法/index.html","hash":"44dbc73baa5e5b891f19853127241ef22823fed5","modified":1658243284408},{"_id":"public/2017/09/22/我收集的一些基础面试题/index.html","hash":"6de5d678e96d16ae21d73158946087e428daae0e","modified":1658243284408},{"_id":"public/2017/08/25/简述CSS3的一些属性-5/index.html","hash":"3a3b55ffce9cc5aa414d19079c6a1895fda21ab0","modified":1658243284408},{"_id":"public/2017/09/13/JSON必知必会/index.html","hash":"1f819bc7167fef9442fffb775e561da9d7ab5cb3","modified":1658243284408},{"_id":"public/2017/08/20/简述CSS3的一些属性-4/index.html","hash":"3aa390d2f8656e2ffb2d40cb64fea40034cd83ca","modified":1658243284408},{"_id":"public/2017/08/18/简述CSS3的一些属性(3)/index.html","hash":"b27a7ba262f924c8e710f11ce73c056308d9bf9b","modified":1658243284408},{"_id":"public/2017/08/16/简述CSS3的一些属性(2)/index.html","hash":"136c4afa241eee1368e6d9ec3d8a7ed3d51ae462","modified":1658243284408},{"_id":"public/2017/07/25/浅述CSS实现垂直居中水平居中的方法/index.html","hash":"0511940c98e5a9fe9c881cc881448eda73314c24","modified":1658243284408},{"_id":"public/2017/06/16/简述CSS3的一些属性(1)/index.html","hash":"d8cdc46d119dca74147d47b00063fb473bed65a1","modified":1658243284409},{"_id":"public/2017/05/21/hexo d时遇到的新错误/index.html","hash":"61be331054ac4a30d9e4a32489b235c616149ce6","modified":1658243284409},{"_id":"public/2017/05/13/2017年书单推荐/index.html","hash":"a3e5163c12f24c731e98a01898b1563156f7a3bc","modified":1658243284409},{"_id":"public/2017/05/13/搭建hexo的坑/index.html","hash":"b6fe738a57ec6672a271314ec077cf89662af258","modified":1658243284409},{"_id":"public/archives/index.html","hash":"265fd7fe7fb7462d88cad7beae45d58a827381ca","modified":1658243284409},{"_id":"public/archives/page/2/index.html","hash":"de277d6bf5ae01773ea3240093644ed53b64053e","modified":1658243284409},{"_id":"public/archives/page/3/index.html","hash":"c0a2f594272833c6ce44bb939efef47be5f2eb53","modified":1658243284409},{"_id":"public/archives/page/4/index.html","hash":"dd809a8af535acea6a78ebb414a2f8646ed4eda7","modified":1658243284409},{"_id":"public/archives/2017/index.html","hash":"9650ef47a419839c9eb47a3988e715e104bf8171","modified":1658243284410},{"_id":"public/archives/2017/page/2/index.html","hash":"3099708f0ae99b2f3a9cc60ee5ebd6782594e903","modified":1658243284410},{"_id":"public/archives/2017/05/index.html","hash":"c4dd86767189ceca0c74c0bd6e9a0bc5d45a452b","modified":1658243284410},{"_id":"public/archives/2017/06/index.html","hash":"6d493deab56eb752a675bc6d86f1771e0ae1a098","modified":1658243284410},{"_id":"public/archives/2017/07/index.html","hash":"7d6015318e4ade50e901576040bb8351a09c8972","modified":1658243284410},{"_id":"public/archives/2017/08/index.html","hash":"28d803c2ec8dcfd65d5d061771e19e536b575a93","modified":1658243284410},{"_id":"public/archives/2017/09/index.html","hash":"b392fe25172d4e0d912f784eaaedf69573f11a91","modified":1658243284410},{"_id":"public/archives/2017/10/index.html","hash":"831866a1e1a1f1a89d1b80e41a2ba7b0ba7f73c2","modified":1658243284410},{"_id":"public/archives/2017/11/index.html","hash":"ed5348661cbd19b9de56d0a88265ecf94b720b3a","modified":1658243284410},{"_id":"public/archives/2017/12/index.html","hash":"f110dccb6a0d80d4470c1e356aa5bdaa76320948","modified":1658243284411},{"_id":"public/archives/2018/index.html","hash":"a1d981843460ec9298df6ab23a954e96ef776857","modified":1658243284411},{"_id":"public/archives/2018/01/index.html","hash":"7729c7b0f1ac309196563ca657a79df00ead4982","modified":1658243284411},{"_id":"public/archives/2018/02/index.html","hash":"1b7de35db0c8564f3b33e3a49c3d290a0b7007b6","modified":1658243284411},{"_id":"public/archives/2018/03/index.html","hash":"e514fb49d9682728482d0f83ba55bcebed5d4afa","modified":1658243284411},{"_id":"public/archives/2018/04/index.html","hash":"378b4bf59e5518cacaf14ba792fbb29ee7678c75","modified":1658243284411},{"_id":"public/archives/2018/05/index.html","hash":"a0d0e9e06a7589146a1f02580b5d736b4d42675e","modified":1658243284411},{"_id":"public/archives/2019/index.html","hash":"807912462d5ec9dbd3e9c0fa00751bec87796836","modified":1658243284411},{"_id":"public/archives/2019/04/index.html","hash":"6619deddd4a5f41e018c01e8eae39d31ca289387","modified":1658243284411},{"_id":"public/archives/2019/06/index.html","hash":"7e9811eec274b77052d3d788e799b8a88f272fd7","modified":1658243284412},{"_id":"public/archives/2019/08/index.html","hash":"45b1476a13407994e91a9f7feadeae6d06a88cdc","modified":1658243284412},{"_id":"public/archives/2020/index.html","hash":"f8e52909b4f07040d84b30a27bf2aa5757428c0f","modified":1658243284412},{"_id":"public/archives/2020/03/index.html","hash":"13be85f0d692fd29394aab6ba7fc2e7502395e16","modified":1658243284412},{"_id":"public/archives/2020/05/index.html","hash":"6e2cae9c74371d3d9d7bcc499fb5260f12a7f35a","modified":1658243284412},{"_id":"public/archives/2020/08/index.html","hash":"13cdabbccfbf5bf863fdce10b9932f04d7c133be","modified":1658243284412},{"_id":"public/archives/2021/index.html","hash":"0227a90bd18cc83784a9c5c95847aaad606ef7aa","modified":1658243284412},{"_id":"public/archives/2021/03/index.html","hash":"2ba61b8f587fa9a84db0f0ef1bc3d184643ffb5f","modified":1658243284413},{"_id":"public/archives/2021/04/index.html","hash":"491edcfa91c623cb0125be18aa2edcc422aa7f7a","modified":1658243284413},{"_id":"public/archives/2021/07/index.html","hash":"1a1a442f0ca4fb48c5f67e57cb76bfd8592a028b","modified":1658243284413},{"_id":"public/archives/2021/09/index.html","hash":"0946a28bc991a699fd342b742809124cb286d6df","modified":1658243284413},{"_id":"public/archives/2021/11/index.html","hash":"1c497a399156bdd9057454ee7b9dac4742b85a49","modified":1658243284413},{"_id":"public/archives/2022/index.html","hash":"7e90a45ceb3085625b14fbfb0e87d9199d4e7b9d","modified":1658243284413},{"_id":"public/archives/2022/02/index.html","hash":"ab9a1b38c1f30828d1846fedd5498400385b06ef","modified":1658243284413},{"_id":"public/archives/2022/03/index.html","hash":"293f31e8f9851283ee4bf5a78392531a0ba942f4","modified":1658243284413},{"_id":"public/archives/2022/06/index.html","hash":"e24a219f6d4a5275152e506aa8f2741ceb858970","modified":1658243284414},{"_id":"public/archives/2022/07/index.html","hash":"2c5f0632cadeb6ddb78b4786a4bcfa93c2975b42","modified":1658243284414},{"_id":"public/index.html","hash":"ffa9c575be5f22bbe32482acb4f91a206a799d0d","modified":1658243284414},{"_id":"public/page/2/index.html","hash":"be17f13c8b8741907f6b85755ed12c78304381ef","modified":1658243284414},{"_id":"public/page/3/index.html","hash":"d3e3c21b98e07b9c7fa48669b0a2667e27097c28","modified":1658243284414},{"_id":"public/tags/随笔/index.html","hash":"dc5829a8f8607d39f3b64bff11e2881cd3442dc2","modified":1658243284414},{"_id":"public/page/4/index.html","hash":"57ddae43cb60a9de041ab6e7e97cff2afcd9a039","modified":1658243284414},{"_id":"public/tags/前端/index.html","hash":"cd413979c8e69b71f6269e882aa8901fecfb6c69","modified":1658243284414},{"_id":"public/tags/前端/page/2/index.html","hash":"70a8ccf40433085a6ad9865a662c366c724603d9","modified":1658243284414},{"_id":"public/tags/前端/page/3/index.html","hash":"e7275c12aa32a0ff4aa543df5c410711dab9cfe0","modified":1658243284415},{"_id":"public/tags/HEXO/index.html","hash":"dcc91286f4c826ff6250358f0f190940915cc7de","modified":1658243284415},{"_id":"public/tags/vscode/index.html","hash":"3d418360316388f15702a88e51804500aab47576","modified":1658243284415},{"_id":"public/tags/CSS/index.html","hash":"893322e9ff6aaa30d4815171804679a5058c20d7","modified":1658243284415},{"_id":"public/tags/JS/index.html","hash":"d88a79f2dd190e9293fc7a7f2e18b85951c7d88a","modified":1658243284415},{"_id":"public/tags/小程序/index.html","hash":"f60ccfc711cf733a503c5e044ca1eadddee1a160","modified":1658243284415},{"_id":"public/tags/JAVA/index.html","hash":"aff8c683c51aa0a2f5b43ec347d7bb177aae8042","modified":1658243284415},{"_id":"public/tags/后端/index.html","hash":"88816b5990eb5f29205697e0c1ac281ad8415f69","modified":1658243284415},{"_id":"public/tags/VUE/index.html","hash":"d09b23c1546f7b54a5c91d77d4a87f26f96de922","modified":1658243284416},{"_id":"public/tags/算法/index.html","hash":"a051555c433374daf10f1968ca5eca0dff196f0d","modified":1658243284416},{"_id":"public/tags/面试/index.html","hash":"677f20987fd3d4d83ffb5ec0b18f598cba5f8170","modified":1658243284416},{"_id":"public/tags/JSON/index.html","hash":"ee169030db856cb184820d719845e66f56c50c16","modified":1658243284416},{"_id":"public/2022/04/19/图片格式选择/index.html","hash":"3969589f41563be65d909a737f5365ba3ddcffb3","modified":1658243284429},{"_id":"public/archives/2022/04/index.html","hash":"4a13dc6859aa52629ed3fa0f22f2a895c3fda6dd","modified":1658243284429},{"_id":"public/fonts/default-skin.b257fa.svg","hash":"2ac727c9e092331d35cce95af209ccfac6d4c7c7","modified":1658243284438},{"_id":"public/fonts/iconfont.6e162c.woff","hash":"709373d566526ad4bdb330757a3915e3c5e37b66","modified":1658243284438},{"_id":"public/fonts/iconfont.9abe9f.svg","hash":"772383b62548e2a4fa560d589e05929b9f6f7f7b","modified":1658243284438},{"_id":"public/fonts/tooltip.4004ff.svg","hash":"a5e9fe67e0604c24279281d9fdd2ce1f4536d3e5","modified":1658243284438},{"_id":"public/fonts/iconfont.3a9902.eot","hash":"51d4e8d333ae7867915037983ea5d4b2ad971930","modified":1658243284438},{"_id":"public/img/default-skin.png","hash":"ed95a8e40a2c3478c5915376acb8e5f33677f24d","modified":1658243284438},{"_id":"public/img/preloader.gif","hash":"6342367c93c82da1b9c620e97c84a389cc43d96d","modified":1658243284438},{"_id":"public/fonts/iconfont.d0da7e.ttf","hash":"53ea5a5027a2fab93bcdad18cad6dc5f1b728726","modified":1658243284438},{"_id":"public/img/header.jpg","hash":"a14c8936b6ff68795d812500ca324d4039e23dcb","modified":1658243284438},{"_id":"public/img/scrollbar_arrow.png","hash":"d64a33c4ddfbdb89deeb6f4e3d36eb84dc4777c0","modified":1658243284438},{"_id":"public/img/site.ico","hash":"99f5ff89599a2197513afe194a336e83aaa1bc0a","modified":1658243284438},{"_id":"public/2022/02/06/2022年书单推荐/design.jpeg","hash":"f0287a4a2257150f882a9fdc285956a569d14c45","modified":1658243284438},{"_id":"public/2018/03/03/我认为的Vue官方文档重点-2/2_transition.jpg","hash":"b0087456f012c7b2cbe80368db1370af97103e0c","modified":1658243284438},{"_id":"public/2021/07/13/2021年书单推荐/head_first.jpeg","hash":"39e5a61fd61021ff0794460da0c44cbd03942650","modified":1658243284438},{"_id":"public/2021/07/13/2021年书单推荐/regexp.jpeg","hash":"b0246ee0aa7fb4a34f862a1d2e260f5ad89a7597","modified":1658243284438},{"_id":"public/2017/12/16/关于Grid布局的使用指南/grid-area.jpg","hash":"fb46fe0f54e1a4ad23b771874fece29a7fab2009","modified":1658243284438},{"_id":"public/2017/12/16/关于Grid布局的使用指南/grid-gap.jpg","hash":"77575e84ce8d7f52174847911e6ac44bc8bc4341","modified":1658243284438},{"_id":"public/2017/12/16/关于Grid布局的使用指南/grid-template-areas.jpg","hash":"c3357368047814c840113ea315ccec8a3b4b6b29","modified":1658243284438},{"_id":"public/2017/12/16/关于Grid布局的使用指南/grid-template_auto.jpg","hash":"4d105462dd4ad8cf4010fb3c9d266714f0847aad","modified":1658243284439},{"_id":"public/2017/12/16/关于Grid布局的使用指南/grid-with-gap.jpg","hash":"5252be6fa8f4e086561f838f3325e6568507f1f8","modified":1658243284439},{"_id":"public/2017/12/16/关于Grid布局的使用指南/origin.jpg","hash":"2fe0bcf5f59e9949d3ff0ece377359a385198f76","modified":1658243284439},{"_id":"public/2018/02/23/关于Flex布局的使用指南/1_space-around.jpg","hash":"e7463ec2cb19add7b20d276e0a54dcff30c7a189","modified":1658243284439},{"_id":"public/2018/02/23/关于Flex布局的使用指南/2_baseline.jpg","hash":"d4f57533961a74a9c3bc5314c10d61223b8cee87","modified":1658243284439},{"_id":"public/2018/02/23/关于Flex布局的使用指南/1_space-between.jpg","hash":"8e728443d293d55ff7413199562b7aee5cc54c9c","modified":1658243284439},{"_id":"public/2018/02/23/关于Flex布局的使用指南/3_space-around.jpg","hash":"82bf03a4626da330ae2b6f46e86fdaec5d30c5d6","modified":1658243284439},{"_id":"public/2018/02/23/关于Flex布局的使用指南/2_flex-start.jpg","hash":"072e3256174cfe8d2b5fd60f24ae1c5e9fb1a232","modified":1658243284439},{"_id":"public/2018/02/23/关于Flex布局的使用指南/3_stretch.jpg","hash":"2655289197f8a89cd1d7ad1d9ec87f4b39756e3b","modified":1658243284439},{"_id":"public/2018/02/23/关于Flex布局的使用指南/4_flex-grow.jpg","hash":"39378d2cf07e475dbb8158c077eaab9f97a31f77","modified":1658243284439},{"_id":"public/2018/02/23/关于Flex布局的使用指南/5_flex-shrink.jpg","hash":"6cd0ed743113fa60ad022d5c72422c4db3120ba0","modified":1658243284439},{"_id":"public/2021/04/29/基于Inquirer实现命令行文件新增/Inquirer_icon.png","hash":"63d80409748aadb9fd21e203ba23f7afb344b32f","modified":1658243284439},{"_id":"public/2021/04/29/基于Inquirer实现命令行文件新增/code_1.png","hash":"4bbbc72d43cff7dbed20ba53c2c67c113222c279","modified":1658243284439},{"_id":"public/2018/02/23/关于Flex布局的使用指南/6_align-self.jpg","hash":"6123566014c51e8e46accbf2c706ec25ef053822","modified":1658243284439},{"_id":"public/2021/04/29/基于Inquirer实现命令行文件新增/code_2.png","hash":"c030adcc91e3b09d5c0b7b495da18a9d232fa219","modified":1658243284439},{"_id":"public/2021/04/29/基于Inquirer实现命令行文件新增/example_1.png","hash":"33f106847fd96d3f09ec57e65d828d01bb62dbaa","modified":1658243284439},{"_id":"public/2021/04/29/基于Inquirer实现命令行文件新增/result.png","hash":"e78428f568b91a440be04a7f254370308d315c2a","modified":1658243284439},{"_id":"public/2021/04/29/基于Inquirer实现命令行文件新增/situation_1.png","hash":"7b6d1771760ff16092715aabf8e45a61c83dcb04","modified":1658243284439},{"_id":"public/2021/04/29/基于Inquirer实现命令行文件新增/situation_2.png","hash":"250dc54a9821b9c41eed818d74777183d6a04ecb","modified":1658243284439},{"_id":"public/2021/04/29/基于Inquirer实现命令行文件新增/situation_3.png","hash":"f24a27bd5a81c775be450d9ee026c751effacc3f","modified":1658243284439},{"_id":"public/2021/07/05/vscode-extension初探/activation_event_1.png","hash":"146cd4de6ae7401580073fff022c14c92c571262","modified":1658243284440},{"_id":"public/2021/07/05/vscode-extension初探/activation_event_2.png","hash":"7490ba9efb1fb1273d1f209ab90959636411940b","modified":1658243284440},{"_id":"public/2021/07/05/vscode-extension初探/activation_event_3.png","hash":"382fbeb19c3c7113df3982c814e3c5696c66cc5a","modified":1658243284440},{"_id":"public/2021/07/05/vscode-extension初探/cli-builded.png","hash":"1ab604c1445bc15e4ceeaa8be026859dd94199f8","modified":1658243284440},{"_id":"public/2021/07/05/vscode-extension初探/contribution_points_3.png","hash":"d5d1a9fb1c2f8b6b0fafe715c12530d9ed6d6abf","modified":1658243284440},{"_id":"public/2021/07/05/vscode-extension初探/contribution_points_4.png","hash":"d2ead5ac38f8428ef3d5a1f362bf75a6ea2c76ae","modified":1658243284440},{"_id":"public/2021/07/05/vscode-extension初探/dap.png","hash":"43dd1871f8e4003617b988623e44c1143655499d","modified":1658243284440},{"_id":"public/2021/07/05/vscode-extension初探/marketplace.png","hash":"b103c70011b500714cb80b89db56abcfd2f8f3f9","modified":1658243284440},{"_id":"public/2021/07/13/2021年书单推荐/svg.jpeg","hash":"924c889cfb5257a913a629913415b952998e8450","modified":1658243284440},{"_id":"public/2021/07/05/vscode-extension初探/vscode.png","hash":"d334b21c38436437f667f1f37fe74b17d2ac77dd","modified":1658243284440},{"_id":"public/2018/05/10/console命令大全/assert_1.jpg","hash":"9559da36dd1abd2bf836c1dcf5ea6f5d21e0c5ba","modified":1658243284440},{"_id":"public/2018/05/10/console命令大全/assert_2.jpg","hash":"353b90c2da83181e96f3bd347ee7e22844aca1e7","modified":1658243284440},{"_id":"public/2018/05/10/console命令大全/count_1.jpg","hash":"34febe687d159520e0a8c141cb89236bfc498df9","modified":1658243284440},{"_id":"public/2018/05/10/console命令大全/dir_2.jpg","hash":"9929aa966bc78f8cec721058f89da4dbf46e7d4d","modified":1658243284440},{"_id":"public/2018/05/10/console命令大全/dir_1.jpg","hash":"ae3ab20509d2de9785b4c1051331e45e850442ea","modified":1658243284440},{"_id":"public/2018/05/10/console命令大全/dir_3.jpg","hash":"9f7e2c2667a0e3cb3516d2c7cfc8f6866b7ef0b8","modified":1658243284440},{"_id":"public/2018/05/10/console命令大全/group_1.jpg","hash":"5f182cbef548b16c9e5050e242e0f8d27fb04947","modified":1658243284440},{"_id":"public/2018/05/10/console命令大全/group_2.jpg","hash":"16549b05908f196ad540c676787efcc0c4a8838c","modified":1658243284440},{"_id":"public/2018/05/10/console命令大全/log_1.jpg","hash":"587435a45004273600882eeffc78d0da159889c2","modified":1658243284440},{"_id":"public/2018/05/10/console命令大全/log_2.jpg","hash":"39837b56ca62b605d437cc003cf6e41dc5256534","modified":1658243284440},{"_id":"public/2018/05/10/console命令大全/log_3.jpg","hash":"bb24b597b498fc2a8d9fade48936aa5883d36ed4","modified":1658243284440},{"_id":"public/2018/05/10/console命令大全/log_4.jpg","hash":"b08097803667bf6a242f0086e64883dec5f14892","modified":1658243284441},{"_id":"public/2018/05/10/console命令大全/log_5.jpg","hash":"f618f0a7e71667e3545d3d5f26219d8ac307cd6b","modified":1658243284441},{"_id":"public/2018/05/10/console命令大全/table_1.jpg","hash":"3013b021255ff9bb81424d51acbb399846d6d723","modified":1658243284441},{"_id":"public/2018/05/10/console命令大全/table_3.jpg","hash":"6fc644da945110d42e244ea309e38d399c44fe2d","modified":1658243284441},{"_id":"public/2018/05/10/console命令大全/table_2.jpg","hash":"d8550a41abf57b74edce446fb76bcc66479a093b","modified":1658243284441},{"_id":"public/2018/05/10/console命令大全/time_1.jpg","hash":"22707457dac7e7afdad3fadc871e06b3244b5c91","modified":1658243284441},{"_id":"public/2018/05/10/console命令大全/trace_1.jpg","hash":"f3882246c8215a06aa5e09508637b7350f7e528b","modified":1658243284441},{"_id":"public/2018/01/15/我认为的Vue官方文档重点-1/1_newPropertyHaventGetterAndSetter.jpg","hash":"d0b574ab0ff0b53de38be82912799849793087d3","modified":1658243284441},{"_id":"public/2018/01/15/我认为的Vue官方文档重点-1/1_textarea_1.jpg","hash":"a7576e18ed8ea2b217803c43406be25c86d5661f","modified":1658243284441},{"_id":"public/2018/01/15/我认为的Vue官方文档重点-1/1_textarea_2.jpg","hash":"0d3b447ffed8991cb0bc1471c86d32922a7194cc","modified":1658243284441},{"_id":"public/2018/01/15/我认为的Vue官方文档重点-1/2_vHtmlUsage.jpg","hash":"e234d52c8feb666b4dc0dc1bdbbdbfb5a42571a7","modified":1658243284441},{"_id":"public/2018/01/15/我认为的Vue官方文档重点-1/3_template_code.jpg","hash":"6ddc0c3b0638625bb9e4fc0da5d41b02b88a6875","modified":1658243284441},{"_id":"public/2018/01/15/我认为的Vue官方文档重点-1/3_template_show.jpg","hash":"d1aeb04a43681f740a9595b826156478b51d8fd0","modified":1658243284442},{"_id":"public/2022/03/16/算法核心框架整理-1/bubble_1.png","hash":"c3146631bfbc61d16028fe3ada3ef2d77e69898c","modified":1658243284442},{"_id":"public/2021/04/29/基于Inquirer实现命令行文件新增/code_3.png","hash":"3d0e727989bc9aa9a3341d11c1dc9acb2a426ea8","modified":1658243284442},{"_id":"public/2022/03/16/算法核心框架整理-1/counting_1.png","hash":"0840a6dbbaa9582a5cbe77180b2330a9f46bde52","modified":1658243284442},{"_id":"public/2022/03/16/算法核心框架整理-1/insertion_1.png","hash":"e9a01d8a27cba08e45c6679738112e6bb9bd34ce","modified":1658243284442},{"_id":"public/2022/03/16/算法核心框架整理-1/quick_1.png","hash":"68b46517dbe421f66474051a32a00533e718a1bc","modified":1658243284442},{"_id":"public/2022/03/16/算法核心框架整理-1/shell_1.png","hash":"8ecf5e46a188fbe48405c734e372e0821f482943","modified":1658243284442},{"_id":"public/2022/03/16/算法核心框架整理-1/selection_1.png","hash":"1430cda4125340f2031142f1ef05ffa59886b7d0","modified":1658243284442},{"_id":"public/2022/04/19/图片格式选择/1.png","hash":"32e571763ad4d5ae30986d42ec696fb630ad9ffb","modified":1658243284442},{"_id":"public/2021/04/29/基于Inquirer实现命令行文件新增/code_4.png","hash":"ed2cdc3092fb7ba9ae22e8ae62b22ddba112e5ca","modified":1658243284447},{"_id":"public/2021/07/05/vscode-extension初探/contribution_points_2.png","hash":"e926ae6796bab7075e1702daa8ba43f85af3cc59","modified":1658243284447},{"_id":"public/2021/07/05/vscode-extension初探/paperang-theme.gif","hash":"e306253383fc358a73d17d2e200cdc0d105b109a","modified":1658243284447},{"_id":"public/2021/03/25/indexedDB浅析/indexedDB_object.png","hash":"89f86403a0026aa5fc85b4174a68ca7f5c279dd6","modified":1658243284447},{"_id":"public/2022/07/18/GC-垃圾回收/7.png","hash":"0446a4b8e24be848920b718ffcb89ae4cdf0b62c","modified":1658243284447},{"_id":"public/2022/03/16/算法核心框架整理-1/bubble_2.png","hash":"98cfdf9c19c384dbafdb0978eafa9a02e7899a23","modified":1658243284447},{"_id":"public/2022/03/16/算法核心框架整理-1/bucket_1.png","hash":"be9721da9461257e793735bfb86f1cfa8a6ad29c","modified":1658243284447},{"_id":"public/2022/03/16/算法核心框架整理-1/bubble_3.png","hash":"8f0f05534330fa735e2e7e5d15e481ff8965be2f","modified":1658243284447},{"_id":"public/2022/03/16/算法核心框架整理-1/heap_1.png","hash":"c7d96681955969067faad9d3a8e35157a78d9686","modified":1658243284447},{"_id":"public/2022/03/16/算法核心框架整理-1/merge_1.png","hash":"2677b83cb7fbbe79b5a545376bef69652ab9548c","modified":1658243284447},{"_id":"public/2022/03/16/算法核心框架整理-1/radix_1.png","hash":"2c78df0e65d474130dfe7d458c41a3190db39171","modified":1658243284447},{"_id":"public/2022/03/16/算法核心框架整理-1/type.png","hash":"fe0455c0aa64d486377c7684636f2a2284fc2b26","modified":1658243284448},{"_id":"public/img/2.png","hash":"074143c9733b6ceb433d06a93e2eb5ede9b44e1e","modified":1658243284450},{"_id":"public/2021/04/29/基于Inquirer实现命令行文件新增/code_5.png","hash":"96ec25d037449ad5a07755fcbb0bca84bcc05281","modified":1658243284450},{"_id":"public/2021/04/29/基于Inquirer实现命令行文件新增/result_2.png","hash":"11d662318877cd7388a2042fe7b01333606fb602","modified":1658243284450},{"_id":"public/2021/04/29/基于Inquirer实现命令行文件新增/example_2.png","hash":"56735ece5c48bc1d0fa277e547666e456b3c456e","modified":1658243284450},{"_id":"public/2021/07/05/vscode-extension初探/contribution_points.png","hash":"78c63ff8f5c83c58a0d3a9a8cf08fd509e2ba2c7","modified":1658243284451},{"_id":"public/2021/03/25/indexedDB浅析/compatibility.png","hash":"88c0dd7d7cad510a31623fe6ae9c3ed46e292ee7","modified":1658243284451},{"_id":"public/2022/07/18/GC-垃圾回收/11.png","hash":"f494eadf7c13b0fb0d9f39e031a8f1a42d0d4b70","modified":1658243284451},{"_id":"public/2022/07/18/GC-垃圾回收/8.png","hash":"ce61c752f12eab5402f818c98461924316ffb0d1","modified":1658243284484},{"_id":"public/2022/07/18/GC-垃圾回收/10.png","hash":"59e449913af209952ce4f0ead186d1713dba233c","modified":1658243284503},{"_id":"public/2021/07/05/vscode-extension初探/lsp.png","hash":"11e5cd50eff9c28897e6b827c5dc1ce8e1987ddd","modified":1658243284503},{"_id":"public/slider.445162.js","hash":"e21c3c2cf663d7a4fb0d77f43ae1a148553a7cca","modified":1658243284510},{"_id":"public/2022/03/16/算法核心框架整理-1/summary.png","hash":"282e126b91e1e8ed4e4ef152945d9728141e40a6","modified":1658243284511},{"_id":"public/2022/07/18/GC-垃圾回收/9.png","hash":"0a4ec9c9154c87ae2f319b8630220dc611c66bb6","modified":1658243284514},{"_id":"public/2021/07/05/vscode-extension初探/cli.png","hash":"ec46b33d32b07ada2d34ec99e3631edaa6a3fc41","modified":1658243284515},{"_id":"public/2021/07/05/vscode-extension初探/paperang-pomodoro.gif","hash":"782270824a6b771279f5c1392aa2a14b6d234b7e","modified":1658243284515},{"_id":"public/2022/07/18/GC-垃圾回收/1.png","hash":"8608a42432ee5cfbe02924ab695aadcafacbc982","modified":1658243284516},{"_id":"public/main.b3331d.css","hash":"7d0162a4618e8026bd23779f3120c09c83197b9f","modified":1658243284517},{"_id":"public/2022/07/18/GC-垃圾回收/3.png","hash":"90779a4e02c5a96c428b2eb89669d14c33db2d04","modified":1658243284517},{"_id":"public/main.b3331d.js","hash":"0e98e3674c7687ae4ff7bdcecb05e15434c46e0d","modified":1658243284520},{"_id":"public/2022/07/18/GC-垃圾回收/2.png","hash":"62934e30c1ebbada671c07efbb513b36e7440f62","modified":1658243284531},{"_id":"public/mobile.8d90af.js","hash":"cf2ab659138db5abc70e3e0d7bc64f50d48e834d","modified":1658243284535},{"_id":"public/2022/04/19/图片格式选择/2.png","hash":"8a02d6b6ae4172e0b986d5cb47d46f1959b5461e","modified":1658243284538},{"_id":"public/2022/07/18/GC-垃圾回收/6.png","hash":"92b71c6f36e719373620ea398a22f49fe3eb7e7f","modified":1658243284539},{"_id":"public/2022/07/18/GC-垃圾回收/5.png","hash":"16f2e66fe2aac12534291c6fd847dd92d58f1160","modified":1658243284539},{"_id":"public/2021/07/13/2021年书单推荐/design_pattern.image","hash":"9aac33b22d7f132a3b6ad8709854771756ed53e6","modified":1658243284544},{"_id":"public/2022/07/18/GC-垃圾回收/4.png","hash":"b003513d0c52fa2b400995f3973bb47ebcb66a06","modified":1658243284545},{"_id":"public/2021/07/05/vscode-extension初探/local_setup.gif","hash":"3a208e70918ca9fd95b7ae15d9fa83e6104e61a4","modified":1658243284553}],"Category":[],"Data":[],"Page":[],"Post":[{"title":"2017年书单推荐","date":"2017-05-13T11:58:47.000Z","_content":"##### 写在前面\n2017年读过的一些觉得不错的书 会持续更新至年尾\n\n* 黑客与画家\n个人觉得名气与内容不成正比, 书前部分很好, 适合多看几遍的那种, 后半部分都是作者推荐lisp而写的软文, 实则无味. 但名书毕竟是名书.\n\n* HTML与CSS基础教程/HTML与CSS进阶教程\n-两本书都很好, 适合初学前端的人看, 零基础的那种, 前辈推荐的书. (其实是要买进阶买错了基础, 基础教程我用了10分钟就看完了- - \n\n<!--more-->\n\n* Adam Freeman著的书 \nApress出版的, 个人很喜欢的作者, 特别是他写的Pro AngularJS\n\n* Head First系列\n同样适合初学者看, 会感觉学得很轻松, 每章节都有固定的任务给你做.\n\n* 学习正则表达式 (O'Reilly\n书本身挺薄的, 也是初学者看的, 不过是其他语言涉及得比较多, 个人建议只看前面几章就行了.\n\n* 锋利的jquery\n好书, 看jquery的选择之一, 整本都是干货.\n\n* html & css设计与构建网站/JavaScript & jQuery交互式Web前端开发\n两本都是精品, 特别是交互式后半部分, 有很多实例都对开发很有帮助, 不过也是适合初学者, 前部分都是在讲一些浅的内容, 还是推荐.\n\n* 前端体验设计 H5+C3 终极修炼\n腾讯团队翻译的, 听说想去腾讯WEB这本书是必看的, 还没看(FAUX!是看不懂\n\n* 软技能,代码之外的生存指南\n个人感觉很不错, 不算鸡汤, 看完能改变你的思维.(比黑画好多了\n\n* 红宝书(高程3)\n重中之重的一本基础书, 讲得很全, 后半部分有的个人觉得不适用当前的前端环境了.","source":"_posts/2017年书单推荐.md","raw":"---\ntitle: 2017年书单推荐\ndate: 2017-05-13 19:58:47\ntags: 随笔\n---\n##### 写在前面\n2017年读过的一些觉得不错的书 会持续更新至年尾\n\n* 黑客与画家\n个人觉得名气与内容不成正比, 书前部分很好, 适合多看几遍的那种, 后半部分都是作者推荐lisp而写的软文, 实则无味. 但名书毕竟是名书.\n\n* HTML与CSS基础教程/HTML与CSS进阶教程\n-两本书都很好, 适合初学前端的人看, 零基础的那种, 前辈推荐的书. (其实是要买进阶买错了基础, 基础教程我用了10分钟就看完了- - \n\n<!--more-->\n\n* Adam Freeman著的书 \nApress出版的, 个人很喜欢的作者, 特别是他写的Pro AngularJS\n\n* Head First系列\n同样适合初学者看, 会感觉学得很轻松, 每章节都有固定的任务给你做.\n\n* 学习正则表达式 (O'Reilly\n书本身挺薄的, 也是初学者看的, 不过是其他语言涉及得比较多, 个人建议只看前面几章就行了.\n\n* 锋利的jquery\n好书, 看jquery的选择之一, 整本都是干货.\n\n* html & css设计与构建网站/JavaScript & jQuery交互式Web前端开发\n两本都是精品, 特别是交互式后半部分, 有很多实例都对开发很有帮助, 不过也是适合初学者, 前部分都是在讲一些浅的内容, 还是推荐.\n\n* 前端体验设计 H5+C3 终极修炼\n腾讯团队翻译的, 听说想去腾讯WEB这本书是必看的, 还没看(FAUX!是看不懂\n\n* 软技能,代码之外的生存指南\n个人感觉很不错, 不算鸡汤, 看完能改变你的思维.(比黑画好多了\n\n* 红宝书(高程3)\n重中之重的一本基础书, 讲得很全, 后半部分有的个人觉得不适用当前的前端环境了.","slug":"2017年书单推荐","published":1,"updated":"2021-11-17T02:33:39.772Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl5sb8geb0000xq0rclfhtgai","content":"<h5 id=\"写在前面\"><a href=\"#写在前面\" class=\"headerlink\" title=\"写在前面\"></a>写在前面</h5><p>2017年读过的一些觉得不错的书 会持续更新至年尾</p>\n<ul>\n<li><p>黑客与画家<br>个人觉得名气与内容不成正比, 书前部分很好, 适合多看几遍的那种, 后半部分都是作者推荐lisp而写的软文, 实则无味. 但名书毕竟是名书.</p>\n</li>\n<li><p>HTML与CSS基础教程/HTML与CSS进阶教程</p>\n</li>\n</ul>\n<p>-两本书都很好, 适合初学前端的人看, 零基础的那种, 前辈推荐的书. (其实是要买进阶买错了基础, 基础教程我用了10分钟就看完了- - </p>\n<a id=\"more\"></a>\n\n<ul>\n<li><p>Adam Freeman著的书<br>Apress出版的, 个人很喜欢的作者, 特别是他写的Pro AngularJS</p>\n</li>\n<li><p>Head First系列<br>同样适合初学者看, 会感觉学得很轻松, 每章节都有固定的任务给你做.</p>\n</li>\n<li><p>学习正则表达式 (O’Reilly<br>书本身挺薄的, 也是初学者看的, 不过是其他语言涉及得比较多, 个人建议只看前面几章就行了.</p>\n</li>\n<li><p>锋利的jquery<br>好书, 看jquery的选择之一, 整本都是干货.</p>\n</li>\n<li><p>html &amp; css设计与构建网站/JavaScript &amp; jQuery交互式Web前端开发<br>两本都是精品, 特别是交互式后半部分, 有很多实例都对开发很有帮助, 不过也是适合初学者, 前部分都是在讲一些浅的内容, 还是推荐.</p>\n</li>\n<li><p>前端体验设计 H5+C3 终极修炼<br>腾讯团队翻译的, 听说想去腾讯WEB这本书是必看的, 还没看(FAUX!是看不懂</p>\n</li>\n<li><p>软技能,代码之外的生存指南<br>个人感觉很不错, 不算鸡汤, 看完能改变你的思维.(比黑画好多了</p>\n</li>\n<li><p>红宝书(高程3)<br>重中之重的一本基础书, 讲得很全, 后半部分有的个人觉得不适用当前的前端环境了.</p>\n</li>\n</ul>\n","site":{"data":{}},"excerpt":"<h5 id=\"写在前面\"><a href=\"#写在前面\" class=\"headerlink\" title=\"写在前面\"></a>写在前面</h5><p>2017年读过的一些觉得不错的书 会持续更新至年尾</p>\n<ul>\n<li><p>黑客与画家<br>个人觉得名气与内容不成正比, 书前部分很好, 适合多看几遍的那种, 后半部分都是作者推荐lisp而写的软文, 实则无味. 但名书毕竟是名书.</p>\n</li>\n<li><p>HTML与CSS基础教程/HTML与CSS进阶教程</p>\n</li>\n</ul>\n<p>-两本书都很好, 适合初学前端的人看, 零基础的那种, 前辈推荐的书. (其实是要买进阶买错了基础, 基础教程我用了10分钟就看完了- - </p>","more":"<ul>\n<li><p>Adam Freeman著的书<br>Apress出版的, 个人很喜欢的作者, 特别是他写的Pro AngularJS</p>\n</li>\n<li><p>Head First系列<br>同样适合初学者看, 会感觉学得很轻松, 每章节都有固定的任务给你做.</p>\n</li>\n<li><p>学习正则表达式 (O’Reilly<br>书本身挺薄的, 也是初学者看的, 不过是其他语言涉及得比较多, 个人建议只看前面几章就行了.</p>\n</li>\n<li><p>锋利的jquery<br>好书, 看jquery的选择之一, 整本都是干货.</p>\n</li>\n<li><p>html &amp; css设计与构建网站/JavaScript &amp; jQuery交互式Web前端开发<br>两本都是精品, 特别是交互式后半部分, 有很多实例都对开发很有帮助, 不过也是适合初学者, 前部分都是在讲一些浅的内容, 还是推荐.</p>\n</li>\n<li><p>前端体验设计 H5+C3 终极修炼<br>腾讯团队翻译的, 听说想去腾讯WEB这本书是必看的, 还没看(FAUX!是看不懂</p>\n</li>\n<li><p>软技能,代码之外的生存指南<br>个人感觉很不错, 不算鸡汤, 看完能改变你的思维.(比黑画好多了</p>\n</li>\n<li><p>红宝书(高程3)<br>重中之重的一本基础书, 讲得很全, 后半部分有的个人觉得不适用当前的前端环境了.</p>\n</li>\n</ul>"},{"title":"2018年书单推荐","date":"2018-03-01T08:30:37.000Z","_content":"##### 写在前面\n2018年读过的一些觉得不错的书 会持续更新至年尾\n\n* Css世界\n张鑫旭老师的新作, 我Tm吹爆, 开头序章把css形容成大众更易接受的小说题材, 让读者更容易阅读.\n","source":"_posts/2018年书单推荐.md","raw":"---\ntitle: 2018年书单推荐\ndate: 2018-03-01 16:30:37\ntags: 随笔\n---\n##### 写在前面\n2018年读过的一些觉得不错的书 会持续更新至年尾\n\n* Css世界\n张鑫旭老师的新作, 我Tm吹爆, 开头序章把css形容成大众更易接受的小说题材, 让读者更容易阅读.\n","slug":"2018年书单推荐","published":1,"updated":"2021-07-02T03:20:30.649Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl5sb8gek0001xq0rijzaekk2","content":"<h5 id=\"写在前面\"><a href=\"#写在前面\" class=\"headerlink\" title=\"写在前面\"></a>写在前面</h5><p>2018年读过的一些觉得不错的书 会持续更新至年尾</p>\n<ul>\n<li>Css世界<br>张鑫旭老师的新作, 我Tm吹爆, 开头序章把css形容成大众更易接受的小说题材, 让读者更容易阅读.</li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<h5 id=\"写在前面\"><a href=\"#写在前面\" class=\"headerlink\" title=\"写在前面\"></a>写在前面</h5><p>2018年读过的一些觉得不错的书 会持续更新至年尾</p>\n<ul>\n<li>Css世界<br>张鑫旭老师的新作, 我Tm吹爆, 开头序章把css形容成大众更易接受的小说题材, 让读者更容易阅读.</li>\n</ul>\n"},{"title":"2019年书单推荐","date":"2019-04-12T13:50:40.000Z","_content":"##### 写在前面\n2019年读过的一些觉得不错的书 会持续更新至年尾\n\n* 活着\n接踵而至的厄运让读者都难以喘息，更何况是富贵本人，《活着》是一次人生阅历的阅读，也是一次残忍的阅读。\n\n* 乌合之众\n大众心理学，最近的香港事件更是贴合本书的一些观点，推荐。\n\n* 韩剧如何讲故事\n如何用讲故事的方式更好的沟通交流 也是一门学问。\n\n* CSS选择器世界\n张鑫旭的新作，相比前作少了玩笑式的描述，但也精简了，还是可以学到干货。\n","source":"_posts/2019年书单推荐.md","raw":"---\ntitle: 2019年书单推荐\ndate: 2019-04-12 21:50:40\ntags: 随笔\n---\n##### 写在前面\n2019年读过的一些觉得不错的书 会持续更新至年尾\n\n* 活着\n接踵而至的厄运让读者都难以喘息，更何况是富贵本人，《活着》是一次人生阅历的阅读，也是一次残忍的阅读。\n\n* 乌合之众\n大众心理学，最近的香港事件更是贴合本书的一些观点，推荐。\n\n* 韩剧如何讲故事\n如何用讲故事的方式更好的沟通交流 也是一门学问。\n\n* CSS选择器世界\n张鑫旭的新作，相比前作少了玩笑式的描述，但也精简了，还是可以学到干货。\n","slug":"2019年书单推荐","published":1,"updated":"2021-07-02T03:20:30.649Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl5sb8gen0003xq0r00sqt5ev","content":"<h5 id=\"写在前面\"><a href=\"#写在前面\" class=\"headerlink\" title=\"写在前面\"></a>写在前面</h5><p>2019年读过的一些觉得不错的书 会持续更新至年尾</p>\n<ul>\n<li><p>活着<br>接踵而至的厄运让读者都难以喘息，更何况是富贵本人，《活着》是一次人生阅历的阅读，也是一次残忍的阅读。</p>\n</li>\n<li><p>乌合之众<br>大众心理学，最近的香港事件更是贴合本书的一些观点，推荐。</p>\n</li>\n<li><p>韩剧如何讲故事<br>如何用讲故事的方式更好的沟通交流 也是一门学问。</p>\n</li>\n<li><p>CSS选择器世界<br>张鑫旭的新作，相比前作少了玩笑式的描述，但也精简了，还是可以学到干货。</p>\n</li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<h5 id=\"写在前面\"><a href=\"#写在前面\" class=\"headerlink\" title=\"写在前面\"></a>写在前面</h5><p>2019年读过的一些觉得不错的书 会持续更新至年尾</p>\n<ul>\n<li><p>活着<br>接踵而至的厄运让读者都难以喘息，更何况是富贵本人，《活着》是一次人生阅历的阅读，也是一次残忍的阅读。</p>\n</li>\n<li><p>乌合之众<br>大众心理学，最近的香港事件更是贴合本书的一些观点，推荐。</p>\n</li>\n<li><p>韩剧如何讲故事<br>如何用讲故事的方式更好的沟通交流 也是一门学问。</p>\n</li>\n<li><p>CSS选择器世界<br>张鑫旭的新作，相比前作少了玩笑式的描述，但也精简了，还是可以学到干货。</p>\n</li>\n</ul>\n"},{"title":"2020年书单推荐","date":"2020-03-01T03:16:38.000Z","_content":"\n##### 写在前面\n\n2020 年读过的一些觉得不错的书 会持续更新至年尾\n\n- 被讨厌的勇气\n  讲述阿德勒心理学的基本思想，文体用对话的方式更容易让读者接受。阿德勒心理学否定了弗洛伊德的原因论，主张目的论，主张课题分离，工作课题、爱的课题、交友课题。并宣称一个人想要获得幸福自我接纳、他者信赖和他者贡献，对我来说有的章节需要仔细阅读，有些章节还是对我以前的观念有很大的冲突，所得来说是值得一看的书。\n\n- 穷爸爸富爸爸\n  讲述了作者罗伯特的亲生父亲(穷爸爸)和好朋友的父亲(富爸爸)两个爸爸截然不同的金钱观和财富观对罗伯特的影响，最后权衡利弊踏上了富爸爸的道路，强调财商的重要性，穷人为钱工作，富人让钱为自己工作。对初入理财的小白是一本很好的书，另外该书也是作者理财三部曲的第一部，适合每一个成年人阅读\n","source":"_posts/2020年书单推荐.md","raw":"---\ntitle: 2020年书单推荐\ndate: 2020-03-01 11:16:38\ntags: 随笔\n---\n\n##### 写在前面\n\n2020 年读过的一些觉得不错的书 会持续更新至年尾\n\n- 被讨厌的勇气\n  讲述阿德勒心理学的基本思想，文体用对话的方式更容易让读者接受。阿德勒心理学否定了弗洛伊德的原因论，主张目的论，主张课题分离，工作课题、爱的课题、交友课题。并宣称一个人想要获得幸福自我接纳、他者信赖和他者贡献，对我来说有的章节需要仔细阅读，有些章节还是对我以前的观念有很大的冲突，所得来说是值得一看的书。\n\n- 穷爸爸富爸爸\n  讲述了作者罗伯特的亲生父亲(穷爸爸)和好朋友的父亲(富爸爸)两个爸爸截然不同的金钱观和财富观对罗伯特的影响，最后权衡利弊踏上了富爸爸的道路，强调财商的重要性，穷人为钱工作，富人让钱为自己工作。对初入理财的小白是一本很好的书，另外该书也是作者理财三部曲的第一部，适合每一个成年人阅读\n","slug":"2020年书单推荐","published":1,"updated":"2021-07-02T03:20:30.650Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl5sb8geo0004xq0r6wb76mp9","content":"<h5 id=\"写在前面\"><a href=\"#写在前面\" class=\"headerlink\" title=\"写在前面\"></a>写在前面</h5><p>2020 年读过的一些觉得不错的书 会持续更新至年尾</p>\n<ul>\n<li><p>被讨厌的勇气<br>讲述阿德勒心理学的基本思想，文体用对话的方式更容易让读者接受。阿德勒心理学否定了弗洛伊德的原因论，主张目的论，主张课题分离，工作课题、爱的课题、交友课题。并宣称一个人想要获得幸福自我接纳、他者信赖和他者贡献，对我来说有的章节需要仔细阅读，有些章节还是对我以前的观念有很大的冲突，所得来说是值得一看的书。</p>\n</li>\n<li><p>穷爸爸富爸爸<br>讲述了作者罗伯特的亲生父亲(穷爸爸)和好朋友的父亲(富爸爸)两个爸爸截然不同的金钱观和财富观对罗伯特的影响，最后权衡利弊踏上了富爸爸的道路，强调财商的重要性，穷人为钱工作，富人让钱为自己工作。对初入理财的小白是一本很好的书，另外该书也是作者理财三部曲的第一部，适合每一个成年人阅读</p>\n</li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<h5 id=\"写在前面\"><a href=\"#写在前面\" class=\"headerlink\" title=\"写在前面\"></a>写在前面</h5><p>2020 年读过的一些觉得不错的书 会持续更新至年尾</p>\n<ul>\n<li><p>被讨厌的勇气<br>讲述阿德勒心理学的基本思想，文体用对话的方式更容易让读者接受。阿德勒心理学否定了弗洛伊德的原因论，主张目的论，主张课题分离，工作课题、爱的课题、交友课题。并宣称一个人想要获得幸福自我接纳、他者信赖和他者贡献，对我来说有的章节需要仔细阅读，有些章节还是对我以前的观念有很大的冲突，所得来说是值得一看的书。</p>\n</li>\n<li><p>穷爸爸富爸爸<br>讲述了作者罗伯特的亲生父亲(穷爸爸)和好朋友的父亲(富爸爸)两个爸爸截然不同的金钱观和财富观对罗伯特的影响，最后权衡利弊踏上了富爸爸的道路，强调财商的重要性，穷人为钱工作，富人让钱为自己工作。对初入理财的小白是一本很好的书，另外该书也是作者理财三部曲的第一部，适合每一个成年人阅读</p>\n</li>\n</ul>\n"},{"title":"2021年书单推荐","date":"2021-07-13T02:57:38.000Z","_content":"\n##### 写在前面\n\n2021 年读过的一些觉得不错的书 会持续更新至年尾\n\n* Head First设计模式\nHead First系列一直都比较能让人读懂且读得下去，其一是因为它比较适合入门，其二就是书中的编排比较宽松。该系列的书是我大学时期的心头好，这本设计模式我印象中也看过(- -#)。温故知新，可以加深多种设计模式的概念。\n\n![Head First设计模式](head_first.jpeg)\n\n<!-- more -->\n\n* JavaScript 正则表达式迷你书\n入门正则的佳作之一，通篇通俗易懂，阅读并理解后直接变身正则小王子。\n\n![JavaScript 正则表达式迷你书](regexp.jpeg)\n\n* SVG 精髓\n\n![SVG 精髓](svg.jpeg)\n\n* JavaScript 设计模式核⼼原理与应⽤实践\n适合 JS 的设计模式剖析，作者比较话痨，但也是良苦用心，阅读完后对设计模式有一定的认识提升\n\n![JavaScript 设计模式核⼼原理与应⽤实践](design_pattern.jpeg)\n","source":"_posts/2021年书单推荐.md","raw":"---\ntitle: 2021年书单推荐\ndate: 2021-07-13 10:57:38\ntags: 随笔\n---\n\n##### 写在前面\n\n2021 年读过的一些觉得不错的书 会持续更新至年尾\n\n* Head First设计模式\nHead First系列一直都比较能让人读懂且读得下去，其一是因为它比较适合入门，其二就是书中的编排比较宽松。该系列的书是我大学时期的心头好，这本设计模式我印象中也看过(- -#)。温故知新，可以加深多种设计模式的概念。\n\n![Head First设计模式](head_first.jpeg)\n\n<!-- more -->\n\n* JavaScript 正则表达式迷你书\n入门正则的佳作之一，通篇通俗易懂，阅读并理解后直接变身正则小王子。\n\n![JavaScript 正则表达式迷你书](regexp.jpeg)\n\n* SVG 精髓\n\n![SVG 精髓](svg.jpeg)\n\n* JavaScript 设计模式核⼼原理与应⽤实践\n适合 JS 的设计模式剖析，作者比较话痨，但也是良苦用心，阅读完后对设计模式有一定的认识提升\n\n![JavaScript 设计模式核⼼原理与应⽤实践](design_pattern.jpeg)\n","slug":"2021年书单推荐","published":1,"updated":"2022-02-06T14:52:48.794Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl5sb8ger0005xq0r35jnfjw3","content":"<h5 id=\"写在前面\"><a href=\"#写在前面\" class=\"headerlink\" title=\"写在前面\"></a>写在前面</h5><p>2021 年读过的一些觉得不错的书 会持续更新至年尾</p>\n<ul>\n<li>Head First设计模式<br>Head First系列一直都比较能让人读懂且读得下去，其一是因为它比较适合入门，其二就是书中的编排比较宽松。该系列的书是我大学时期的心头好，这本设计模式我印象中也看过(- -#)。温故知新，可以加深多种设计模式的概念。</li>\n</ul>\n<p><img src=\"//psilocine.github.io/2021/07/13/2021年书单推荐/head_first.jpeg\" alt=\"Head First设计模式\"></p>\n<a id=\"more\"></a>\n\n<ul>\n<li>JavaScript 正则表达式迷你书<br>入门正则的佳作之一，通篇通俗易懂，阅读并理解后直接变身正则小王子。</li>\n</ul>\n<p><img src=\"//psilocine.github.io/2021/07/13/2021年书单推荐/regexp.jpeg\" alt=\"JavaScript 正则表达式迷你书\"></p>\n<ul>\n<li>SVG 精髓</li>\n</ul>\n<p><img src=\"//psilocine.github.io/2021/07/13/2021年书单推荐/svg.jpeg\" alt=\"SVG 精髓\"></p>\n<ul>\n<li>JavaScript 设计模式核⼼原理与应⽤实践<br>适合 JS 的设计模式剖析，作者比较话痨，但也是良苦用心，阅读完后对设计模式有一定的认识提升</li>\n</ul>\n<p><img src=\"//psilocine.github.io/2021/07/13/2021年书单推荐/design_pattern.jpeg\" alt=\"JavaScript 设计模式核⼼原理与应⽤实践\"></p>\n","site":{"data":{}},"excerpt":"<h5 id=\"写在前面\"><a href=\"#写在前面\" class=\"headerlink\" title=\"写在前面\"></a>写在前面</h5><p>2021 年读过的一些觉得不错的书 会持续更新至年尾</p>\n<ul>\n<li>Head First设计模式<br>Head First系列一直都比较能让人读懂且读得下去，其一是因为它比较适合入门，其二就是书中的编排比较宽松。该系列的书是我大学时期的心头好，这本设计模式我印象中也看过(- -#)。温故知新，可以加深多种设计模式的概念。</li>\n</ul>\n<p><img src=\"//psilocine.github.io/2021/07/13/2021年书单推荐/head_first.jpeg\" alt=\"Head First设计模式\"></p>","more":"<ul>\n<li>JavaScript 正则表达式迷你书<br>入门正则的佳作之一，通篇通俗易懂，阅读并理解后直接变身正则小王子。</li>\n</ul>\n<p><img src=\"//psilocine.github.io/2021/07/13/2021年书单推荐/regexp.jpeg\" alt=\"JavaScript 正则表达式迷你书\"></p>\n<ul>\n<li>SVG 精髓</li>\n</ul>\n<p><img src=\"//psilocine.github.io/2021/07/13/2021年书单推荐/svg.jpeg\" alt=\"SVG 精髓\"></p>\n<ul>\n<li>JavaScript 设计模式核⼼原理与应⽤实践<br>适合 JS 的设计模式剖析，作者比较话痨，但也是良苦用心，阅读完后对设计模式有一定的认识提升</li>\n</ul>\n<p><img src=\"//psilocine.github.io/2021/07/13/2021年书单推荐/design_pattern.jpeg\" alt=\"JavaScript 设计模式核⼼原理与应⽤实践\"></p>"},{"title":"2022年书单推荐","date":"2022-02-06T14:41:49.000Z","_content":"\n##### 写在前面\n\n2022 年读过的一些觉得不错的书 会持续更新至年尾\n\n* 写给大家看的设计书\n以前从未觉得设计能如此具像化，该书对开发者来说，阅读也很顺畅，阅读完后不仅可以对自家的 UI 设计的缘由，也能对设计稿指点一二了，哈哈哈\n\n![写给大家看的设计书（第4版）](design.jpeg)\n\n<!-- more -->\n","source":"_posts/2022年书单推荐.md","raw":"---\ntitle: 2022年书单推荐\ndate: 2022-02-06 22:41:49\ntags: 随笔\n---\n\n##### 写在前面\n\n2022 年读过的一些觉得不错的书 会持续更新至年尾\n\n* 写给大家看的设计书\n以前从未觉得设计能如此具像化，该书对开发者来说，阅读也很顺畅，阅读完后不仅可以对自家的 UI 设计的缘由，也能对设计稿指点一二了，哈哈哈\n\n![写给大家看的设计书（第4版）](design.jpeg)\n\n<!-- more -->\n","slug":"2022年书单推荐","published":1,"updated":"2022-02-06T14:54:45.659Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl5sb8gew0008xq0rfxwqiapv","content":"<h5 id=\"写在前面\"><a href=\"#写在前面\" class=\"headerlink\" title=\"写在前面\"></a>写在前面</h5><p>2022 年读过的一些觉得不错的书 会持续更新至年尾</p>\n<ul>\n<li>写给大家看的设计书<br>以前从未觉得设计能如此具像化，该书对开发者来说，阅读也很顺畅，阅读完后不仅可以对自家的 UI 设计的缘由，也能对设计稿指点一二了，哈哈哈</li>\n</ul>\n<p><img src=\"//psilocine.github.io/2022/02/06/2022年书单推荐/design.jpeg\" alt=\"写给大家看的设计书（第4版）\"></p>\n<a id=\"more\"></a>\n","site":{"data":{}},"excerpt":"<h5 id=\"写在前面\"><a href=\"#写在前面\" class=\"headerlink\" title=\"写在前面\"></a>写在前面</h5><p>2022 年读过的一些觉得不错的书 会持续更新至年尾</p>\n<ul>\n<li>写给大家看的设计书<br>以前从未觉得设计能如此具像化，该书对开发者来说，阅读也很顺畅，阅读完后不仅可以对自家的 UI 设计的缘由，也能对设计稿指点一二了，哈哈哈</li>\n</ul>\n<p><img src=\"//psilocine.github.io/2022/02/06/2022年书单推荐/design.jpeg\" alt=\"写给大家看的设计书（第4版）\"></p>","more":""},{"title":"console命令大全","date":"2018-05-10T06:45:18.000Z","_content":"##### 写在前面\nconsole.log, console.time相信大家都不陌生, 平时除了打断点就是打log来调试, 可谓是居家旅行必备神器. 今天就来扒扒除了以上常见的还有哪些可能其貌不扬的命令.\n\n#### log\n1. log是笔者平日里用得最多的命令了, 如下图一, 可以直接打印出我们需要的变量; 可以定死内容打印出来用来知道是否执行至此; 可以结合字符串更清晰地在控制台找到输出内容.\n<!-- more -->\n![log_1](log_1.jpg)\n2. 此命令大家很熟悉了, 只有一点需要注意: 结合字符串时, 除了和对象共用会出现[object Object]而显示不出正确内容外, 和其他的类型都能良好搭配. 这是因为object类型和string类型相加时, 会触发toString()方法(其他类型也会.\n![log_4](log_4.jpg)\n除了log外, 还有info, warn, error, 其实和log本质是一样的, 只不过在输出是加个icon和背景色.\n![log_2](log_2.jpg)\n在Ff火狐下, info也有图标.\n![log_3](log_3.jpg)\n3. log还支持占位符, 如下图. 但只支持字符串（%s）、整数（%d或%i）、浮点数（%f）和对象（%o）\n![log_5](log_5.jpg)\n\n#### time\n1. 此命令可以用来知道一段代码所耗时间, 需要结合console.timeEnd()来闭合代码段. 需要注意的是, 两行命令的参数变量名需要一样, 如下是test, 才能正确判断代码的起始结束位置\n![time_1](time_1.jpg)\n\n#### group\n1. 该命令结合console.groupEnd()可以起到分组的作用.\n![group_1](group_1.jpg)\n2. 有时候代码log太多会眼花缭乱, 有了这个可以快速定位到自己想看的log.\n![group_2](group_2.jpg)\n3. 需要注意的有两点, 结束命令不用像time指令加参数; 其二是如果把\"group\"换成\"groupCollapsed\", 则默认为折叠运行结果.\n\n#### dir\n1. 用来查看对象的信息, 但在chrome浏览器下好像会展示折叠的状态, 因此和log似乎没差? 在Ff下, dir命令可以自动展开, 比较一目了然.\n![dir_2](dir_2.jpg)\n![dir_3](dir_3.jpg)\n2. 如果查看Dom元素, console.log()以HTML的形式输出, 而console.dir()则会以JSON对象的形式输出.(在chrome下, 实测在Ff下都是以json对象输出)\n![dir_1](dir_1.jpg)\n\n#### assert\n1. console.assert()类似于单元测试中的断言, 当表达式为false, 输出错误并抛出一个异常. 但是如果你的代码有多个assert命令, 会显得难以区分. 因此assert还支持传第二个参数, 当有输出时依仗第二个参数的值.\n![assert_1](assert_1.jpg)\n![assert_2](assert_2.jpg)\n\n#### count\n1. 调试代码时，我们经常需要知道一段代码被执行了多少次(当然可以用log), 但是count命令存在的本质就是为了计数. 还有log如果是在一起的话, 会累加成一行.\n2. count命令也可以传值来作为label, 当然不传也会有个default的label.\n![count_1](count_1.jpg)\n\n#### table\n1. table命令能轻松将json表格化, 让开发者更直观地看到数据. 在chrome浏览器下, table head还支持正序倒序的排列, 十分方便.\n![table_1](table_1.jpg)\n2. 值得注意的是, 在chrome下如果json没有该属性会显示空, 值是\"\", 显示\"\", 只有在值是undefined才会显示undefined; 而在Ff下, 没有属性显示undefined, 值是\"\"显示空, 值是undefined显示undefined.\n![table_2](table_2.jpg)\n![table_3](table_3.jpg)\n\n#### trace\nconsole.trace()用来追踪函数的调用轨迹, 可谓是神器, 特别是维护大型项目的时候.\n![trace_1](trace_1.jpg)","source":"_posts/console命令大全.md","raw":"---\ntitle: console命令大全\ndate: 2018-05-10 14:45:18\ntags: 前端\n---\n##### 写在前面\nconsole.log, console.time相信大家都不陌生, 平时除了打断点就是打log来调试, 可谓是居家旅行必备神器. 今天就来扒扒除了以上常见的还有哪些可能其貌不扬的命令.\n\n#### log\n1. log是笔者平日里用得最多的命令了, 如下图一, 可以直接打印出我们需要的变量; 可以定死内容打印出来用来知道是否执行至此; 可以结合字符串更清晰地在控制台找到输出内容.\n<!-- more -->\n![log_1](log_1.jpg)\n2. 此命令大家很熟悉了, 只有一点需要注意: 结合字符串时, 除了和对象共用会出现[object Object]而显示不出正确内容外, 和其他的类型都能良好搭配. 这是因为object类型和string类型相加时, 会触发toString()方法(其他类型也会.\n![log_4](log_4.jpg)\n除了log外, 还有info, warn, error, 其实和log本质是一样的, 只不过在输出是加个icon和背景色.\n![log_2](log_2.jpg)\n在Ff火狐下, info也有图标.\n![log_3](log_3.jpg)\n3. log还支持占位符, 如下图. 但只支持字符串（%s）、整数（%d或%i）、浮点数（%f）和对象（%o）\n![log_5](log_5.jpg)\n\n#### time\n1. 此命令可以用来知道一段代码所耗时间, 需要结合console.timeEnd()来闭合代码段. 需要注意的是, 两行命令的参数变量名需要一样, 如下是test, 才能正确判断代码的起始结束位置\n![time_1](time_1.jpg)\n\n#### group\n1. 该命令结合console.groupEnd()可以起到分组的作用.\n![group_1](group_1.jpg)\n2. 有时候代码log太多会眼花缭乱, 有了这个可以快速定位到自己想看的log.\n![group_2](group_2.jpg)\n3. 需要注意的有两点, 结束命令不用像time指令加参数; 其二是如果把\"group\"换成\"groupCollapsed\", 则默认为折叠运行结果.\n\n#### dir\n1. 用来查看对象的信息, 但在chrome浏览器下好像会展示折叠的状态, 因此和log似乎没差? 在Ff下, dir命令可以自动展开, 比较一目了然.\n![dir_2](dir_2.jpg)\n![dir_3](dir_3.jpg)\n2. 如果查看Dom元素, console.log()以HTML的形式输出, 而console.dir()则会以JSON对象的形式输出.(在chrome下, 实测在Ff下都是以json对象输出)\n![dir_1](dir_1.jpg)\n\n#### assert\n1. console.assert()类似于单元测试中的断言, 当表达式为false, 输出错误并抛出一个异常. 但是如果你的代码有多个assert命令, 会显得难以区分. 因此assert还支持传第二个参数, 当有输出时依仗第二个参数的值.\n![assert_1](assert_1.jpg)\n![assert_2](assert_2.jpg)\n\n#### count\n1. 调试代码时，我们经常需要知道一段代码被执行了多少次(当然可以用log), 但是count命令存在的本质就是为了计数. 还有log如果是在一起的话, 会累加成一行.\n2. count命令也可以传值来作为label, 当然不传也会有个default的label.\n![count_1](count_1.jpg)\n\n#### table\n1. table命令能轻松将json表格化, 让开发者更直观地看到数据. 在chrome浏览器下, table head还支持正序倒序的排列, 十分方便.\n![table_1](table_1.jpg)\n2. 值得注意的是, 在chrome下如果json没有该属性会显示空, 值是\"\", 显示\"\", 只有在值是undefined才会显示undefined; 而在Ff下, 没有属性显示undefined, 值是\"\"显示空, 值是undefined显示undefined.\n![table_2](table_2.jpg)\n![table_3](table_3.jpg)\n\n#### trace\nconsole.trace()用来追踪函数的调用轨迹, 可谓是神器, 特别是维护大型项目的时候.\n![trace_1](trace_1.jpg)","slug":"console命令大全","published":1,"updated":"2021-07-02T03:20:30.651Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl5sb8gez000axq0r56outezj","content":"<h5 id=\"写在前面\"><a href=\"#写在前面\" class=\"headerlink\" title=\"写在前面\"></a>写在前面</h5><p>console.log, console.time相信大家都不陌生, 平时除了打断点就是打log来调试, 可谓是居家旅行必备神器. 今天就来扒扒除了以上常见的还有哪些可能其貌不扬的命令.</p>\n<h4 id=\"log\"><a href=\"#log\" class=\"headerlink\" title=\"log\"></a>log</h4><ol>\n<li>log是笔者平日里用得最多的命令了, 如下图一, 可以直接打印出我们需要的变量; 可以定死内容打印出来用来知道是否执行至此; 可以结合字符串更清晰地在控制台找到输出内容.<a id=\"more\"></a>\n<img src=\"//psilocine.github.io/2018/05/10/console命令大全/log_1.jpg\" alt=\"log_1\"></li>\n<li>此命令大家很熟悉了, 只有一点需要注意: 结合字符串时, 除了和对象共用会出现[object Object]而显示不出正确内容外, 和其他的类型都能良好搭配. 这是因为object类型和string类型相加时, 会触发toString()方法(其他类型也会.<br><img src=\"//psilocine.github.io/2018/05/10/console命令大全/log_4.jpg\" alt=\"log_4\"><br>除了log外, 还有info, warn, error, 其实和log本质是一样的, 只不过在输出是加个icon和背景色.<br><img src=\"//psilocine.github.io/2018/05/10/console命令大全/log_2.jpg\" alt=\"log_2\"><br>在Ff火狐下, info也有图标.<br><img src=\"//psilocine.github.io/2018/05/10/console命令大全/log_3.jpg\" alt=\"log_3\"></li>\n<li>log还支持占位符, 如下图. 但只支持字符串（%s）、整数（%d或%i）、浮点数（%f）和对象（%o）<br><img src=\"//psilocine.github.io/2018/05/10/console命令大全/log_5.jpg\" alt=\"log_5\"></li>\n</ol>\n<h4 id=\"time\"><a href=\"#time\" class=\"headerlink\" title=\"time\"></a>time</h4><ol>\n<li>此命令可以用来知道一段代码所耗时间, 需要结合console.timeEnd()来闭合代码段. 需要注意的是, 两行命令的参数变量名需要一样, 如下是test, 才能正确判断代码的起始结束位置<br><img src=\"//psilocine.github.io/2018/05/10/console命令大全/time_1.jpg\" alt=\"time_1\"></li>\n</ol>\n<h4 id=\"group\"><a href=\"#group\" class=\"headerlink\" title=\"group\"></a>group</h4><ol>\n<li>该命令结合console.groupEnd()可以起到分组的作用.<br><img src=\"//psilocine.github.io/2018/05/10/console命令大全/group_1.jpg\" alt=\"group_1\"></li>\n<li>有时候代码log太多会眼花缭乱, 有了这个可以快速定位到自己想看的log.<br><img src=\"//psilocine.github.io/2018/05/10/console命令大全/group_2.jpg\" alt=\"group_2\"></li>\n<li>需要注意的有两点, 结束命令不用像time指令加参数; 其二是如果把”group”换成”groupCollapsed”, 则默认为折叠运行结果.</li>\n</ol>\n<h4 id=\"dir\"><a href=\"#dir\" class=\"headerlink\" title=\"dir\"></a>dir</h4><ol>\n<li>用来查看对象的信息, 但在chrome浏览器下好像会展示折叠的状态, 因此和log似乎没差? 在Ff下, dir命令可以自动展开, 比较一目了然.<br><img src=\"//psilocine.github.io/2018/05/10/console命令大全/dir_2.jpg\" alt=\"dir_2\"><br><img src=\"//psilocine.github.io/2018/05/10/console命令大全/dir_3.jpg\" alt=\"dir_3\"></li>\n<li>如果查看Dom元素, console.log()以HTML的形式输出, 而console.dir()则会以JSON对象的形式输出.(在chrome下, 实测在Ff下都是以json对象输出)<br><img src=\"//psilocine.github.io/2018/05/10/console命令大全/dir_1.jpg\" alt=\"dir_1\"></li>\n</ol>\n<h4 id=\"assert\"><a href=\"#assert\" class=\"headerlink\" title=\"assert\"></a>assert</h4><ol>\n<li>console.assert()类似于单元测试中的断言, 当表达式为false, 输出错误并抛出一个异常. 但是如果你的代码有多个assert命令, 会显得难以区分. 因此assert还支持传第二个参数, 当有输出时依仗第二个参数的值.<br><img src=\"//psilocine.github.io/2018/05/10/console命令大全/assert_1.jpg\" alt=\"assert_1\"><br><img src=\"//psilocine.github.io/2018/05/10/console命令大全/assert_2.jpg\" alt=\"assert_2\"></li>\n</ol>\n<h4 id=\"count\"><a href=\"#count\" class=\"headerlink\" title=\"count\"></a>count</h4><ol>\n<li>调试代码时，我们经常需要知道一段代码被执行了多少次(当然可以用log), 但是count命令存在的本质就是为了计数. 还有log如果是在一起的话, 会累加成一行.</li>\n<li>count命令也可以传值来作为label, 当然不传也会有个default的label.<br><img src=\"//psilocine.github.io/2018/05/10/console命令大全/count_1.jpg\" alt=\"count_1\"></li>\n</ol>\n<h4 id=\"table\"><a href=\"#table\" class=\"headerlink\" title=\"table\"></a>table</h4><ol>\n<li>table命令能轻松将json表格化, 让开发者更直观地看到数据. 在chrome浏览器下, table head还支持正序倒序的排列, 十分方便.<br><img src=\"//psilocine.github.io/2018/05/10/console命令大全/table_1.jpg\" alt=\"table_1\"></li>\n<li>值得注意的是, 在chrome下如果json没有该属性会显示空, 值是””, 显示””, 只有在值是undefined才会显示undefined; 而在Ff下, 没有属性显示undefined, 值是””显示空, 值是undefined显示undefined.<br><img src=\"//psilocine.github.io/2018/05/10/console命令大全/table_2.jpg\" alt=\"table_2\"><br><img src=\"//psilocine.github.io/2018/05/10/console命令大全/table_3.jpg\" alt=\"table_3\"></li>\n</ol>\n<h4 id=\"trace\"><a href=\"#trace\" class=\"headerlink\" title=\"trace\"></a>trace</h4><p>console.trace()用来追踪函数的调用轨迹, 可谓是神器, 特别是维护大型项目的时候.<br><img src=\"//psilocine.github.io/2018/05/10/console命令大全/trace_1.jpg\" alt=\"trace_1\"></p>\n","site":{"data":{}},"excerpt":"<h5 id=\"写在前面\"><a href=\"#写在前面\" class=\"headerlink\" title=\"写在前面\"></a>写在前面</h5><p>console.log, console.time相信大家都不陌生, 平时除了打断点就是打log来调试, 可谓是居家旅行必备神器. 今天就来扒扒除了以上常见的还有哪些可能其貌不扬的命令.</p>\n<h4 id=\"log\"><a href=\"#log\" class=\"headerlink\" title=\"log\"></a>log</h4><ol>\n<li>log是笔者平日里用得最多的命令了, 如下图一, 可以直接打印出我们需要的变量; 可以定死内容打印出来用来知道是否执行至此; 可以结合字符串更清晰地在控制台找到输出内容.</li></ol>","more":"<img src=\"//psilocine.github.io/2018/05/10/console命令大全/log_1.jpg\" alt=\"log_1\">\n<li>此命令大家很熟悉了, 只有一点需要注意: 结合字符串时, 除了和对象共用会出现[object Object]而显示不出正确内容外, 和其他的类型都能良好搭配. 这是因为object类型和string类型相加时, 会触发toString()方法(其他类型也会.<br><img src=\"//psilocine.github.io/2018/05/10/console命令大全/log_4.jpg\" alt=\"log_4\"><br>除了log外, 还有info, warn, error, 其实和log本质是一样的, 只不过在输出是加个icon和背景色.<br><img src=\"//psilocine.github.io/2018/05/10/console命令大全/log_2.jpg\" alt=\"log_2\"><br>在Ff火狐下, info也有图标.<br><img src=\"//psilocine.github.io/2018/05/10/console命令大全/log_3.jpg\" alt=\"log_3\"></li>\n<li>log还支持占位符, 如下图. 但只支持字符串（%s）、整数（%d或%i）、浮点数（%f）和对象（%o）<br><img src=\"//psilocine.github.io/2018/05/10/console命令大全/log_5.jpg\" alt=\"log_5\"></li>\n\n<h4 id=\"time\"><a href=\"#time\" class=\"headerlink\" title=\"time\"></a>time</h4><ol>\n<li>此命令可以用来知道一段代码所耗时间, 需要结合console.timeEnd()来闭合代码段. 需要注意的是, 两行命令的参数变量名需要一样, 如下是test, 才能正确判断代码的起始结束位置<br><img src=\"//psilocine.github.io/2018/05/10/console命令大全/time_1.jpg\" alt=\"time_1\"></li>\n</ol>\n<h4 id=\"group\"><a href=\"#group\" class=\"headerlink\" title=\"group\"></a>group</h4><ol>\n<li>该命令结合console.groupEnd()可以起到分组的作用.<br><img src=\"//psilocine.github.io/2018/05/10/console命令大全/group_1.jpg\" alt=\"group_1\"></li>\n<li>有时候代码log太多会眼花缭乱, 有了这个可以快速定位到自己想看的log.<br><img src=\"//psilocine.github.io/2018/05/10/console命令大全/group_2.jpg\" alt=\"group_2\"></li>\n<li>需要注意的有两点, 结束命令不用像time指令加参数; 其二是如果把”group”换成”groupCollapsed”, 则默认为折叠运行结果.</li>\n</ol>\n<h4 id=\"dir\"><a href=\"#dir\" class=\"headerlink\" title=\"dir\"></a>dir</h4><ol>\n<li>用来查看对象的信息, 但在chrome浏览器下好像会展示折叠的状态, 因此和log似乎没差? 在Ff下, dir命令可以自动展开, 比较一目了然.<br><img src=\"//psilocine.github.io/2018/05/10/console命令大全/dir_2.jpg\" alt=\"dir_2\"><br><img src=\"//psilocine.github.io/2018/05/10/console命令大全/dir_3.jpg\" alt=\"dir_3\"></li>\n<li>如果查看Dom元素, console.log()以HTML的形式输出, 而console.dir()则会以JSON对象的形式输出.(在chrome下, 实测在Ff下都是以json对象输出)<br><img src=\"//psilocine.github.io/2018/05/10/console命令大全/dir_1.jpg\" alt=\"dir_1\"></li>\n</ol>\n<h4 id=\"assert\"><a href=\"#assert\" class=\"headerlink\" title=\"assert\"></a>assert</h4><ol>\n<li>console.assert()类似于单元测试中的断言, 当表达式为false, 输出错误并抛出一个异常. 但是如果你的代码有多个assert命令, 会显得难以区分. 因此assert还支持传第二个参数, 当有输出时依仗第二个参数的值.<br><img src=\"//psilocine.github.io/2018/05/10/console命令大全/assert_1.jpg\" alt=\"assert_1\"><br><img src=\"//psilocine.github.io/2018/05/10/console命令大全/assert_2.jpg\" alt=\"assert_2\"></li>\n</ol>\n<h4 id=\"count\"><a href=\"#count\" class=\"headerlink\" title=\"count\"></a>count</h4><ol>\n<li>调试代码时，我们经常需要知道一段代码被执行了多少次(当然可以用log), 但是count命令存在的本质就是为了计数. 还有log如果是在一起的话, 会累加成一行.</li>\n<li>count命令也可以传值来作为label, 当然不传也会有个default的label.<br><img src=\"//psilocine.github.io/2018/05/10/console命令大全/count_1.jpg\" alt=\"count_1\"></li>\n</ol>\n<h4 id=\"table\"><a href=\"#table\" class=\"headerlink\" title=\"table\"></a>table</h4><ol>\n<li>table命令能轻松将json表格化, 让开发者更直观地看到数据. 在chrome浏览器下, table head还支持正序倒序的排列, 十分方便.<br><img src=\"//psilocine.github.io/2018/05/10/console命令大全/table_1.jpg\" alt=\"table_1\"></li>\n<li>值得注意的是, 在chrome下如果json没有该属性会显示空, 值是””, 显示””, 只有在值是undefined才会显示undefined; 而在Ff下, 没有属性显示undefined, 值是””显示空, 值是undefined显示undefined.<br><img src=\"//psilocine.github.io/2018/05/10/console命令大全/table_2.jpg\" alt=\"table_2\"><br><img src=\"//psilocine.github.io/2018/05/10/console命令大全/table_3.jpg\" alt=\"table_3\"></li>\n</ol>\n<h4 id=\"trace\"><a href=\"#trace\" class=\"headerlink\" title=\"trace\"></a>trace</h4><p>console.trace()用来追踪函数的调用轨迹, 可谓是神器, 特别是维护大型项目的时候.<br><img src=\"//psilocine.github.io/2018/05/10/console命令大全/trace_1.jpg\" alt=\"trace_1\"></p>"},{"title":"hexo d时遇到的新错误","date":"2017-05-20T17:21:14.000Z","_content":"##### 写在前面\n我发现github pages不能被百度索引, 想解决这一方法, 发现可以用托管到coding.net来解决\n按照网络上的步骤, 我在 _config.yml里repo设置了多个仓库以后, hexo d就出现了如下错误\n\n1. permission denied publickey\n2. fatal: could not read from remote respository\n\n解决方法网上有很多种, 但是我都失败了. 最后是把.ssh的id公钥私钥删掉, 用ssh-keygen -t rsa -C '你的邮箱名'生成新的key, 在github和coding新建后, 发现还是不行, 把repo里的coding仓库删掉以后即可.\n不知道这算不算解决, 不过我还是放弃了同步多个仓库这个想法\n<!--more-->\n\n2017年12月13日\n1. 一个警告 lf will be replaced by crlf xxx\n原因是因为windows和linux平台的空格不一样, lf是linux下的, crlf是windows下的, 我的解决方法是hexo init后即可","source":"_posts/hexo d时遇到的新错误.md","raw":"---\ntitle: 'hexo d时遇到的新错误'\ndate: 2017-05-21 01:21:14\ntags: HEXO\n---\n##### 写在前面\n我发现github pages不能被百度索引, 想解决这一方法, 发现可以用托管到coding.net来解决\n按照网络上的步骤, 我在 _config.yml里repo设置了多个仓库以后, hexo d就出现了如下错误\n\n1. permission denied publickey\n2. fatal: could not read from remote respository\n\n解决方法网上有很多种, 但是我都失败了. 最后是把.ssh的id公钥私钥删掉, 用ssh-keygen -t rsa -C '你的邮箱名'生成新的key, 在github和coding新建后, 发现还是不行, 把repo里的coding仓库删掉以后即可.\n不知道这算不算解决, 不过我还是放弃了同步多个仓库这个想法\n<!--more-->\n\n2017年12月13日\n1. 一个警告 lf will be replaced by crlf xxx\n原因是因为windows和linux平台的空格不一样, lf是linux下的, crlf是windows下的, 我的解决方法是hexo init后即可","slug":"hexo d时遇到的新错误","published":1,"updated":"2021-07-02T03:20:30.655Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl5sb8gf2000dxq0r6j36tklv","content":"<h5 id=\"写在前面\"><a href=\"#写在前面\" class=\"headerlink\" title=\"写在前面\"></a>写在前面</h5><p>我发现github pages不能被百度索引, 想解决这一方法, 发现可以用托管到coding.net来解决<br>按照网络上的步骤, 我在 _config.yml里repo设置了多个仓库以后, hexo d就出现了如下错误</p>\n<ol>\n<li>permission denied publickey</li>\n<li>fatal: could not read from remote respository</li>\n</ol>\n<p>解决方法网上有很多种, 但是我都失败了. 最后是把.ssh的id公钥私钥删掉, 用ssh-keygen -t rsa -C ‘你的邮箱名’生成新的key, 在github和coding新建后, 发现还是不行, 把repo里的coding仓库删掉以后即可.<br>不知道这算不算解决, 不过我还是放弃了同步多个仓库这个想法</p>\n<a id=\"more\"></a>\n\n<p>2017年12月13日</p>\n<ol>\n<li>一个警告 lf will be replaced by crlf xxx<br>原因是因为windows和linux平台的空格不一样, lf是linux下的, crlf是windows下的, 我的解决方法是hexo init后即可</li>\n</ol>\n","site":{"data":{}},"excerpt":"<h5 id=\"写在前面\"><a href=\"#写在前面\" class=\"headerlink\" title=\"写在前面\"></a>写在前面</h5><p>我发现github pages不能被百度索引, 想解决这一方法, 发现可以用托管到coding.net来解决<br>按照网络上的步骤, 我在 _config.yml里repo设置了多个仓库以后, hexo d就出现了如下错误</p>\n<ol>\n<li>permission denied publickey</li>\n<li>fatal: could not read from remote respository</li>\n</ol>\n<p>解决方法网上有很多种, 但是我都失败了. 最后是把.ssh的id公钥私钥删掉, 用ssh-keygen -t rsa -C ‘你的邮箱名’生成新的key, 在github和coding新建后, 发现还是不行, 把repo里的coding仓库删掉以后即可.<br>不知道这算不算解决, 不过我还是放弃了同步多个仓库这个想法</p>","more":"<p>2017年12月13日</p>\n<ol>\n<li>一个警告 lf will be replaced by crlf xxx<br>原因是因为windows和linux平台的空格不一样, lf是linux下的, crlf是windows下的, 我的解决方法是hexo init后即可</li>\n</ol>"},{"title":"vscode extension初探","date":"2021-07-05T09:28:33.000Z","_content":"\n##### 写在前面\n越学习vscode的知识，越觉得vscode这个编辑器的强大，也会感觉越学越多。本文简单地探讨一下vscode的构成和vscode extension的用法。\n\n#### vscode 构成\nvscode的特性之一是跨平台。是因为它是基于Electron构建的，主要有三部分组成：\n\n* [Monaco Editor](https://microsoft.github.io/monaco-editor/)：基于web的代码编辑器\n* [Extension Host](https://code.visualstudio.com/api/advanced-topics/extension-host)：插件管理\n* [Language Server Protocol](https://microsoft.github.io/language-server-protocol/) & [Debug Adapter Protocol](https://microsoft.github.io/debug-adapter-protocol/)：两大协议\n\n还有一个特性是轻量级，因为很多功能都是基于插件实现，插件进程并不影响主进程的渲染速度、UI响应。\n\n<!-- more -->\n\n![vscode](vscode.png)\n\n![LSP](lsp.png)\n\n没有LSP以前，各种语言都要去找各自的IDE：如JAVA要用IntelliJ、Eclipse；Python要用PyCharm；\n有了LSP，开发者只需要编写一次，就可以很快地在IDE之间移植代码\n\n![DAP](dap.png)\n\n#### vscode extension 要点\nvscode插件[能做什么？（官方）](https://code.visualstudio.com/api/extension-capabilities/overview)\n* 使用颜色或图标更改vscode的外观\n* 在UI界面中添加自定义组件和视图\n* 创建一个Webview来显示自定义构建的web页面\n* 支持新的编程语言\n* 支持调试特定的程序\n\n在我看来：\n* 自定义命令、快捷键、菜单选项\n* 自定义跳转、自动补全、悬浮提示\n* 自定义设置\n* 自定义Webview\n* 自定义左侧Tree view\n* 自定义颜色、图标主题\n* 新增语言语法\n* 通知、状态栏\n\n当我们开发vscode插件的时候，只需要注意三个要点，就可以对vscode进行功能增强\n\n* Activation Event\n\n> 插件激活的时机，在package.json中声明。\nkey为activationEvents，value为数组的一组JSON声明。\n值得注意的是，激活的时机可以是多条件的。\n\n* Contribution Points\n\n> 插件配置的声明、增强了vscode的什么功能，在package.json中声明。\nkey为contributes，value为对象的一组JSON声明\n\n* VS Code API\n\n> 普遍在src/extension.ts(js)。\n插件中可以调用的扩展JavaScript API。\n\n##### Activation Event\n* onLanguage:`${language}` 打开特定语言的文件时激活\n\neg: onLanguage:typescript、onLanguage:python\n\n![activation_event_1](activation_event_1.png)\n\n* onCommand:`${command id}` 调用命令时激活\n\neg: onCommand:paperang.helloworld\n\n![activation_event_2](activation_event_2.png)\n\n* onDebug 在启动调试模式时激活\n* workspaceContains 当打开的文件夹至少有一个glob pattern表达式匹配的文件时激活\n\neg: workspaceContains:`**/.editorconfig`、workspaceContains:`**/.prettierrc.js`\n* onFileSystem 当读取的文件或文件夹匹配文件方案时激活\n\neg: onFileSystem:ftp、onFileSystem:ssh\n* onView 左侧栏展开特定view id时激活\n\neg: onView:outline\n* onUri 打开系统级的uri时激活（这个URI协议需要带上vscode 或者 vscode-insiders协议\n\neg:vscode://vscode.git/init、vscode-insiders://vscode.git/init\n* onWebviewPanel 匹配到是viewType的webview时激活（需要配合其他事件、如onCommand来创建webview \n\neg: onWebviewPanel:catCoding\n* onCustomEditor 匹配到是viewType的自定义编辑器时激活\n\n* *（start up）vscode启动时激活（尽量不用\n\n* onStartupFinished vscode启动一段时间后激活（和*相比，不会减慢vscode的启动速度\n\n![activation_event_3](activation_event_3.png)\n\n更多详见[官方文档](https://code.visualstudio.com/api/references/activation-events)\n\n##### Contribution Points\n* configuration:object 将插件的配置内容暴露出来，用户可以通过UI界面或setting.json修改\n```javascript\ntitle:string 插件的展示名称 eg:paperangExtension -> Paperang Extension\nproperties:object 配置项集合\n  [property]:object 配置项\n    type number、string、boolean可以在UI界面展示，其余types只能通过json修改\n    default:any\n    description:string\n    markdownDescription:string\n    enum:array\n    enumDescriptions:array\n```\n\n![contribution_points_example](contribution_points.png)\n\n* commands:Array<Object>\n```javascript\ncommand:string\ntitle:string\ncategory:string 便于分组\n```\n\n![contribution_points_example](contribution_points_2.png)\n\n* menus:object\n```javascript\ncommandPalette:Array<Object> 全局命令面板\nexplorer/context 资源管理器上下文菜单\neditor/context 编辑器上下文菜单\neditor/title 编辑器标题栏右侧\neditor/title/context 编辑器标题栏\ndebug/toolbar 调试工具栏\nscm/title source control manager 右侧\nview/title 标题栏右侧\nview/item/context \n```\n\n![contribution_points_example](contribution_points_3.png)\n\n* keybindings:Array<Object>\n```javascript\ncommand:string\nkey:string\nmac:string\nwhen:string\n```\n\n![contribution_points_example](contribution_points_4.png)\n\n更多详见[官方文档](https://code.visualstudio.com/api/references/contribution-points)\n\n##### VS Code API\nVS Code暴露了大几十种[API](https://code.visualstudio.com/api/references/vscode-api)，下述只罗列几个：\n* commands:\n\nregisterCommand(command:string, callback) 注册command\nexecuteCommand(command) 执行command\n\n* window:\n\ncreateStatusBarItem(alignment?, priority?:number) 底部导航栏item\ncreateTreeView(viewId:string, options) 左侧菜单栏\ncreateWebviewPanel(viewType: string, title: string) 创建新的webview\nsetStatusBarMessage(text: string, hideAfterTimeout: number) 底部状态栏消息\nshow(Error/Infomation/Warning)Message(message: string, ...items: string[]) 底部右侧弹窗，需要交互关闭\n\n* workspace：\n\ngetConfiguration 获取配置对象\neg: vscode.workspace.getConfiguration('pomodoro').get('visible')、\nvscode.workspace.getConfiguration().get('pomodoro.visible')\n\n更多详见[官方文档](https://code.visualstudio.com/api/references/vscode-api)\n\n#### 实践和发布\n1. 安装官方脚手架yo、generator-code\n```terminal\n$ npm install -g yo generator-code\n$ yo code\n```\n![cli](cli.png)\n\n![cli-builded](cli-builded.png)\n\n2. 完成插件的开发和测试\n\ni. 番茄钟\n![paperang-pomodoro](paperang-pomodoro.gif)\nii. 主题色\n![paperang-theme](paperang-theme.gif)\n\n3. 本地打包/发布到vscode插件市场\n\n本地打包：不方便发布到市场的插件。如涉密，团队自用\ni. vsce package\nii. Install from VSIX\n\n![local_setup](local_setup.gif)\n\n发布[市场](https://marketplace.visualstudio.com/vscode)：\ni. 注册[Microsoft账号](https://login.live.com/)\nii. 创建[Azure DevOps](https://aka.ms/SignupAzureDevOps)组织\niii. 创建Token：(security/Personal Access Tokens\n)\niv. 注册成为[发布者](https://aka.ms/vscode-create-publishe)：命令行注册已经失效，需网页注册\nv. vsce publish\nvi. 过几分钟就可以在市场上搜索到了～","source":"_posts/vscode-extension初探.md","raw":"---\ntitle: vscode extension初探\ndate: 2021-07-05 17:28:33\ntags: [前端, vscode]\n---\n\n##### 写在前面\n越学习vscode的知识，越觉得vscode这个编辑器的强大，也会感觉越学越多。本文简单地探讨一下vscode的构成和vscode extension的用法。\n\n#### vscode 构成\nvscode的特性之一是跨平台。是因为它是基于Electron构建的，主要有三部分组成：\n\n* [Monaco Editor](https://microsoft.github.io/monaco-editor/)：基于web的代码编辑器\n* [Extension Host](https://code.visualstudio.com/api/advanced-topics/extension-host)：插件管理\n* [Language Server Protocol](https://microsoft.github.io/language-server-protocol/) & [Debug Adapter Protocol](https://microsoft.github.io/debug-adapter-protocol/)：两大协议\n\n还有一个特性是轻量级，因为很多功能都是基于插件实现，插件进程并不影响主进程的渲染速度、UI响应。\n\n<!-- more -->\n\n![vscode](vscode.png)\n\n![LSP](lsp.png)\n\n没有LSP以前，各种语言都要去找各自的IDE：如JAVA要用IntelliJ、Eclipse；Python要用PyCharm；\n有了LSP，开发者只需要编写一次，就可以很快地在IDE之间移植代码\n\n![DAP](dap.png)\n\n#### vscode extension 要点\nvscode插件[能做什么？（官方）](https://code.visualstudio.com/api/extension-capabilities/overview)\n* 使用颜色或图标更改vscode的外观\n* 在UI界面中添加自定义组件和视图\n* 创建一个Webview来显示自定义构建的web页面\n* 支持新的编程语言\n* 支持调试特定的程序\n\n在我看来：\n* 自定义命令、快捷键、菜单选项\n* 自定义跳转、自动补全、悬浮提示\n* 自定义设置\n* 自定义Webview\n* 自定义左侧Tree view\n* 自定义颜色、图标主题\n* 新增语言语法\n* 通知、状态栏\n\n当我们开发vscode插件的时候，只需要注意三个要点，就可以对vscode进行功能增强\n\n* Activation Event\n\n> 插件激活的时机，在package.json中声明。\nkey为activationEvents，value为数组的一组JSON声明。\n值得注意的是，激活的时机可以是多条件的。\n\n* Contribution Points\n\n> 插件配置的声明、增强了vscode的什么功能，在package.json中声明。\nkey为contributes，value为对象的一组JSON声明\n\n* VS Code API\n\n> 普遍在src/extension.ts(js)。\n插件中可以调用的扩展JavaScript API。\n\n##### Activation Event\n* onLanguage:`${language}` 打开特定语言的文件时激活\n\neg: onLanguage:typescript、onLanguage:python\n\n![activation_event_1](activation_event_1.png)\n\n* onCommand:`${command id}` 调用命令时激活\n\neg: onCommand:paperang.helloworld\n\n![activation_event_2](activation_event_2.png)\n\n* onDebug 在启动调试模式时激活\n* workspaceContains 当打开的文件夹至少有一个glob pattern表达式匹配的文件时激活\n\neg: workspaceContains:`**/.editorconfig`、workspaceContains:`**/.prettierrc.js`\n* onFileSystem 当读取的文件或文件夹匹配文件方案时激活\n\neg: onFileSystem:ftp、onFileSystem:ssh\n* onView 左侧栏展开特定view id时激活\n\neg: onView:outline\n* onUri 打开系统级的uri时激活（这个URI协议需要带上vscode 或者 vscode-insiders协议\n\neg:vscode://vscode.git/init、vscode-insiders://vscode.git/init\n* onWebviewPanel 匹配到是viewType的webview时激活（需要配合其他事件、如onCommand来创建webview \n\neg: onWebviewPanel:catCoding\n* onCustomEditor 匹配到是viewType的自定义编辑器时激活\n\n* *（start up）vscode启动时激活（尽量不用\n\n* onStartupFinished vscode启动一段时间后激活（和*相比，不会减慢vscode的启动速度\n\n![activation_event_3](activation_event_3.png)\n\n更多详见[官方文档](https://code.visualstudio.com/api/references/activation-events)\n\n##### Contribution Points\n* configuration:object 将插件的配置内容暴露出来，用户可以通过UI界面或setting.json修改\n```javascript\ntitle:string 插件的展示名称 eg:paperangExtension -> Paperang Extension\nproperties:object 配置项集合\n  [property]:object 配置项\n    type number、string、boolean可以在UI界面展示，其余types只能通过json修改\n    default:any\n    description:string\n    markdownDescription:string\n    enum:array\n    enumDescriptions:array\n```\n\n![contribution_points_example](contribution_points.png)\n\n* commands:Array<Object>\n```javascript\ncommand:string\ntitle:string\ncategory:string 便于分组\n```\n\n![contribution_points_example](contribution_points_2.png)\n\n* menus:object\n```javascript\ncommandPalette:Array<Object> 全局命令面板\nexplorer/context 资源管理器上下文菜单\neditor/context 编辑器上下文菜单\neditor/title 编辑器标题栏右侧\neditor/title/context 编辑器标题栏\ndebug/toolbar 调试工具栏\nscm/title source control manager 右侧\nview/title 标题栏右侧\nview/item/context \n```\n\n![contribution_points_example](contribution_points_3.png)\n\n* keybindings:Array<Object>\n```javascript\ncommand:string\nkey:string\nmac:string\nwhen:string\n```\n\n![contribution_points_example](contribution_points_4.png)\n\n更多详见[官方文档](https://code.visualstudio.com/api/references/contribution-points)\n\n##### VS Code API\nVS Code暴露了大几十种[API](https://code.visualstudio.com/api/references/vscode-api)，下述只罗列几个：\n* commands:\n\nregisterCommand(command:string, callback) 注册command\nexecuteCommand(command) 执行command\n\n* window:\n\ncreateStatusBarItem(alignment?, priority?:number) 底部导航栏item\ncreateTreeView(viewId:string, options) 左侧菜单栏\ncreateWebviewPanel(viewType: string, title: string) 创建新的webview\nsetStatusBarMessage(text: string, hideAfterTimeout: number) 底部状态栏消息\nshow(Error/Infomation/Warning)Message(message: string, ...items: string[]) 底部右侧弹窗，需要交互关闭\n\n* workspace：\n\ngetConfiguration 获取配置对象\neg: vscode.workspace.getConfiguration('pomodoro').get('visible')、\nvscode.workspace.getConfiguration().get('pomodoro.visible')\n\n更多详见[官方文档](https://code.visualstudio.com/api/references/vscode-api)\n\n#### 实践和发布\n1. 安装官方脚手架yo、generator-code\n```terminal\n$ npm install -g yo generator-code\n$ yo code\n```\n![cli](cli.png)\n\n![cli-builded](cli-builded.png)\n\n2. 完成插件的开发和测试\n\ni. 番茄钟\n![paperang-pomodoro](paperang-pomodoro.gif)\nii. 主题色\n![paperang-theme](paperang-theme.gif)\n\n3. 本地打包/发布到vscode插件市场\n\n本地打包：不方便发布到市场的插件。如涉密，团队自用\ni. vsce package\nii. Install from VSIX\n\n![local_setup](local_setup.gif)\n\n发布[市场](https://marketplace.visualstudio.com/vscode)：\ni. 注册[Microsoft账号](https://login.live.com/)\nii. 创建[Azure DevOps](https://aka.ms/SignupAzureDevOps)组织\niii. 创建Token：(security/Personal Access Tokens\n)\niv. 注册成为[发布者](https://aka.ms/vscode-create-publishe)：命令行注册已经失效，需网页注册\nv. vsce publish\nvi. 过几分钟就可以在市场上搜索到了～","slug":"vscode-extension初探","published":1,"updated":"2021-07-06T02:36:52.104Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl5sb8gf2000fxq0re1z8zwbb","content":"<h5 id=\"写在前面\"><a href=\"#写在前面\" class=\"headerlink\" title=\"写在前面\"></a>写在前面</h5><p>越学习vscode的知识，越觉得vscode这个编辑器的强大，也会感觉越学越多。本文简单地探讨一下vscode的构成和vscode extension的用法。</p>\n<h4 id=\"vscode-构成\"><a href=\"#vscode-构成\" class=\"headerlink\" title=\"vscode 构成\"></a>vscode 构成</h4><p>vscode的特性之一是跨平台。是因为它是基于Electron构建的，主要有三部分组成：</p>\n<ul>\n<li><a href=\"https://microsoft.github.io/monaco-editor/\" target=\"_blank\" rel=\"noopener\">Monaco Editor</a>：基于web的代码编辑器</li>\n<li><a href=\"https://code.visualstudio.com/api/advanced-topics/extension-host\" target=\"_blank\" rel=\"noopener\">Extension Host</a>：插件管理</li>\n<li><a href=\"https://microsoft.github.io/language-server-protocol/\" target=\"_blank\" rel=\"noopener\">Language Server Protocol</a> &amp; <a href=\"https://microsoft.github.io/debug-adapter-protocol/\" target=\"_blank\" rel=\"noopener\">Debug Adapter Protocol</a>：两大协议</li>\n</ul>\n<p>还有一个特性是轻量级，因为很多功能都是基于插件实现，插件进程并不影响主进程的渲染速度、UI响应。</p>\n<a id=\"more\"></a>\n\n<p><img src=\"//psilocine.github.io/2021/07/05/vscode-extension初探/vscode.png\" alt=\"vscode\"></p>\n<p><img src=\"//psilocine.github.io/2021/07/05/vscode-extension初探/lsp.png\" alt=\"LSP\"></p>\n<p>没有LSP以前，各种语言都要去找各自的IDE：如JAVA要用IntelliJ、Eclipse；Python要用PyCharm；<br>有了LSP，开发者只需要编写一次，就可以很快地在IDE之间移植代码</p>\n<p><img src=\"//psilocine.github.io/2021/07/05/vscode-extension初探/dap.png\" alt=\"DAP\"></p>\n<h4 id=\"vscode-extension-要点\"><a href=\"#vscode-extension-要点\" class=\"headerlink\" title=\"vscode extension 要点\"></a>vscode extension 要点</h4><p>vscode插件<a href=\"https://code.visualstudio.com/api/extension-capabilities/overview\" target=\"_blank\" rel=\"noopener\">能做什么？（官方）</a></p>\n<ul>\n<li>使用颜色或图标更改vscode的外观</li>\n<li>在UI界面中添加自定义组件和视图</li>\n<li>创建一个Webview来显示自定义构建的web页面</li>\n<li>支持新的编程语言</li>\n<li>支持调试特定的程序</li>\n</ul>\n<p>在我看来：</p>\n<ul>\n<li>自定义命令、快捷键、菜单选项</li>\n<li>自定义跳转、自动补全、悬浮提示</li>\n<li>自定义设置</li>\n<li>自定义Webview</li>\n<li>自定义左侧Tree view</li>\n<li>自定义颜色、图标主题</li>\n<li>新增语言语法</li>\n<li>通知、状态栏</li>\n</ul>\n<p>当我们开发vscode插件的时候，只需要注意三个要点，就可以对vscode进行功能增强</p>\n<ul>\n<li>Activation Event</li>\n</ul>\n<blockquote>\n<p>插件激活的时机，在package.json中声明。<br>key为activationEvents，value为数组的一组JSON声明。<br>值得注意的是，激活的时机可以是多条件的。</p>\n</blockquote>\n<ul>\n<li>Contribution Points</li>\n</ul>\n<blockquote>\n<p>插件配置的声明、增强了vscode的什么功能，在package.json中声明。<br>key为contributes，value为对象的一组JSON声明</p>\n</blockquote>\n<ul>\n<li>VS Code API</li>\n</ul>\n<blockquote>\n<p>普遍在src/extension.ts(js)。<br>插件中可以调用的扩展JavaScript API。</p>\n</blockquote>\n<h5 id=\"Activation-Event\"><a href=\"#Activation-Event\" class=\"headerlink\" title=\"Activation Event\"></a>Activation Event</h5><ul>\n<li>onLanguage:<code>${language}</code> 打开特定语言的文件时激活</li>\n</ul>\n<p>eg: onLanguage:typescript、onLanguage:python</p>\n<p><img src=\"//psilocine.github.io/2021/07/05/vscode-extension初探/activation_event_1.png\" alt=\"activation_event_1\"></p>\n<ul>\n<li>onCommand:<code>${command id}</code> 调用命令时激活</li>\n</ul>\n<p>eg: onCommand:paperang.helloworld</p>\n<p><img src=\"//psilocine.github.io/2021/07/05/vscode-extension初探/activation_event_2.png\" alt=\"activation_event_2\"></p>\n<ul>\n<li>onDebug 在启动调试模式时激活</li>\n<li>workspaceContains 当打开的文件夹至少有一个glob pattern表达式匹配的文件时激活</li>\n</ul>\n<p>eg: workspaceContains:<code>**/.editorconfig</code>、workspaceContains:<code>**/.prettierrc.js</code></p>\n<ul>\n<li>onFileSystem 当读取的文件或文件夹匹配文件方案时激活</li>\n</ul>\n<p>eg: onFileSystem:ftp、onFileSystem:ssh</p>\n<ul>\n<li>onView 左侧栏展开特定view id时激活</li>\n</ul>\n<p>eg: onView:outline</p>\n<ul>\n<li>onUri 打开系统级的uri时激活（这个URI协议需要带上vscode 或者 vscode-insiders协议</li>\n</ul>\n<p>eg:vscode://vscode.git/init、vscode-insiders://vscode.git/init</p>\n<ul>\n<li>onWebviewPanel 匹配到是viewType的webview时激活（需要配合其他事件、如onCommand来创建webview </li>\n</ul>\n<p>eg: onWebviewPanel:catCoding</p>\n<ul>\n<li><p>onCustomEditor 匹配到是viewType的自定义编辑器时激活</p>\n</li>\n<li><p>*（start up）vscode启动时激活（尽量不用</p>\n</li>\n<li><p>onStartupFinished vscode启动一段时间后激活（和*相比，不会减慢vscode的启动速度</p>\n</li>\n</ul>\n<p><img src=\"//psilocine.github.io/2021/07/05/vscode-extension初探/activation_event_3.png\" alt=\"activation_event_3\"></p>\n<p>更多详见<a href=\"https://code.visualstudio.com/api/references/activation-events\" target=\"_blank\" rel=\"noopener\">官方文档</a></p>\n<h5 id=\"Contribution-Points\"><a href=\"#Contribution-Points\" class=\"headerlink\" title=\"Contribution Points\"></a>Contribution Points</h5><ul>\n<li>configuration:object 将插件的配置内容暴露出来，用户可以通过UI界面或setting.json修改<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">title:string 插件的展示名称 eg:paperangExtension -&gt; Paperang Extension</span><br><span class=\"line\">properties:object 配置项集合</span><br><span class=\"line\">  [property]:object 配置项</span><br><span class=\"line\">    type number、string、boolean可以在UI界面展示，其余types只能通过json修改</span><br><span class=\"line\">    <span class=\"keyword\">default</span>:any</span><br><span class=\"line\">    description:string</span><br><span class=\"line\">    markdownDescription:string</span><br><span class=\"line\">    enum:array</span><br><span class=\"line\">    enumDescriptions:array</span><br></pre></td></tr></table></figure>\n\n</li>\n</ul>\n<p><img src=\"//psilocine.github.io/2021/07/05/vscode-extension初探/contribution_points.png\" alt=\"contribution_points_example\"></p>\n<ul>\n<li>commands:Array<object><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">command:string</span><br><span class=\"line\">title:string</span><br><span class=\"line\">category:string 便于分组</span><br></pre></td></tr></table></figure>\n\n</object></li>\n</ul>\n<p><img src=\"//psilocine.github.io/2021/07/05/vscode-extension初探/contribution_points_2.png\" alt=\"contribution_points_example\"></p>\n<ul>\n<li>menus:object<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">commandPalette:<span class=\"built_in\">Array</span>&lt;<span class=\"built_in\">Object</span>&gt; 全局命令面板</span><br><span class=\"line\">explorer/context 资源管理器上下文菜单</span><br><span class=\"line\">editor/context 编辑器上下文菜单</span><br><span class=\"line\">editor/title 编辑器标题栏右侧</span><br><span class=\"line\">editor/title/context 编辑器标题栏</span><br><span class=\"line\">debug/toolbar 调试工具栏</span><br><span class=\"line\">scm/title source control manager 右侧</span><br><span class=\"line\">view/title 标题栏右侧</span><br><span class=\"line\">view/item/context</span><br></pre></td></tr></table></figure>\n\n</li>\n</ul>\n<p><img src=\"//psilocine.github.io/2021/07/05/vscode-extension初探/contribution_points_3.png\" alt=\"contribution_points_example\"></p>\n<ul>\n<li>keybindings:Array<object><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">command:string</span><br><span class=\"line\">key:string</span><br><span class=\"line\">mac:string</span><br><span class=\"line\">when:string</span><br></pre></td></tr></table></figure>\n\n</object></li>\n</ul>\n<p><img src=\"//psilocine.github.io/2021/07/05/vscode-extension初探/contribution_points_4.png\" alt=\"contribution_points_example\"></p>\n<p>更多详见<a href=\"https://code.visualstudio.com/api/references/contribution-points\" target=\"_blank\" rel=\"noopener\">官方文档</a></p>\n<h5 id=\"VS-Code-API\"><a href=\"#VS-Code-API\" class=\"headerlink\" title=\"VS Code API\"></a>VS Code API</h5><p>VS Code暴露了大几十种<a href=\"https://code.visualstudio.com/api/references/vscode-api\" target=\"_blank\" rel=\"noopener\">API</a>，下述只罗列几个：</p>\n<ul>\n<li>commands:</li>\n</ul>\n<p>registerCommand(command:string, callback) 注册command<br>executeCommand(command) 执行command</p>\n<ul>\n<li>window:</li>\n</ul>\n<p>createStatusBarItem(alignment?, priority?:number) 底部导航栏item<br>createTreeView(viewId:string, options) 左侧菜单栏<br>createWebviewPanel(viewType: string, title: string) 创建新的webview<br>setStatusBarMessage(text: string, hideAfterTimeout: number) 底部状态栏消息<br>show(Error/Infomation/Warning)Message(message: string, …items: string[]) 底部右侧弹窗，需要交互关闭</p>\n<ul>\n<li>workspace：</li>\n</ul>\n<p>getConfiguration 获取配置对象<br>eg: vscode.workspace.getConfiguration(‘pomodoro’).get(‘visible’)、<br>vscode.workspace.getConfiguration().get(‘pomodoro.visible’)</p>\n<p>更多详见<a href=\"https://code.visualstudio.com/api/references/vscode-api\" target=\"_blank\" rel=\"noopener\">官方文档</a></p>\n<h4 id=\"实践和发布\"><a href=\"#实践和发布\" class=\"headerlink\" title=\"实践和发布\"></a>实践和发布</h4><ol>\n<li>安装官方脚手架yo、generator-code<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ npm install -g yo generator-code</span><br><span class=\"line\">$ yo code</span><br></pre></td></tr></table></figure>\n\n</li>\n</ol>\n<p><img src=\"//psilocine.github.io/2021/07/05/vscode-extension初探/cli.png\" alt=\"cli\"></p>\n<p><img src=\"//psilocine.github.io/2021/07/05/vscode-extension初探/cli-builded.png\" alt=\"cli-builded\"></p>\n<ol start=\"2\">\n<li>完成插件的开发和测试</li>\n</ol>\n<p>i. 番茄钟<br><img src=\"//psilocine.github.io/2021/07/05/vscode-extension初探/paperang-pomodoro.gif\" alt=\"paperang-pomodoro\"><br>ii. 主题色<br><img src=\"//psilocine.github.io/2021/07/05/vscode-extension初探/paperang-theme.gif\" alt=\"paperang-theme\"></p>\n<ol start=\"3\">\n<li>本地打包/发布到vscode插件市场</li>\n</ol>\n<p>本地打包：不方便发布到市场的插件。如涉密，团队自用<br>i. vsce package<br>ii. Install from VSIX</p>\n<p><img src=\"//psilocine.github.io/2021/07/05/vscode-extension初探/local_setup.gif\" alt=\"local_setup\"></p>\n<p>发布<a href=\"https://marketplace.visualstudio.com/vscode\" target=\"_blank\" rel=\"noopener\">市场</a>：<br>i. 注册<a href=\"https://login.live.com/\" target=\"_blank\" rel=\"noopener\">Microsoft账号</a><br>ii. 创建<a href=\"https://aka.ms/SignupAzureDevOps\" target=\"_blank\" rel=\"noopener\">Azure DevOps</a>组织<br>iii. 创建Token：(security/Personal Access Tokens<br>)<br>iv. 注册成为<a href=\"https://aka.ms/vscode-create-publishe\" target=\"_blank\" rel=\"noopener\">发布者</a>：命令行注册已经失效，需网页注册<br>v. vsce publish<br>vi. 过几分钟就可以在市场上搜索到了～</p>\n","site":{"data":{}},"excerpt":"<h5 id=\"写在前面\"><a href=\"#写在前面\" class=\"headerlink\" title=\"写在前面\"></a>写在前面</h5><p>越学习vscode的知识，越觉得vscode这个编辑器的强大，也会感觉越学越多。本文简单地探讨一下vscode的构成和vscode extension的用法。</p>\n<h4 id=\"vscode-构成\"><a href=\"#vscode-构成\" class=\"headerlink\" title=\"vscode 构成\"></a>vscode 构成</h4><p>vscode的特性之一是跨平台。是因为它是基于Electron构建的，主要有三部分组成：</p>\n<ul>\n<li><a href=\"https://microsoft.github.io/monaco-editor/\" target=\"_blank\" rel=\"noopener\">Monaco Editor</a>：基于web的代码编辑器</li>\n<li><a href=\"https://code.visualstudio.com/api/advanced-topics/extension-host\" target=\"_blank\" rel=\"noopener\">Extension Host</a>：插件管理</li>\n<li><a href=\"https://microsoft.github.io/language-server-protocol/\" target=\"_blank\" rel=\"noopener\">Language Server Protocol</a> &amp; <a href=\"https://microsoft.github.io/debug-adapter-protocol/\" target=\"_blank\" rel=\"noopener\">Debug Adapter Protocol</a>：两大协议</li>\n</ul>\n<p>还有一个特性是轻量级，因为很多功能都是基于插件实现，插件进程并不影响主进程的渲染速度、UI响应。</p>","more":"<p><img src=\"//psilocine.github.io/2021/07/05/vscode-extension初探/vscode.png\" alt=\"vscode\"></p>\n<p><img src=\"//psilocine.github.io/2021/07/05/vscode-extension初探/lsp.png\" alt=\"LSP\"></p>\n<p>没有LSP以前，各种语言都要去找各自的IDE：如JAVA要用IntelliJ、Eclipse；Python要用PyCharm；<br>有了LSP，开发者只需要编写一次，就可以很快地在IDE之间移植代码</p>\n<p><img src=\"//psilocine.github.io/2021/07/05/vscode-extension初探/dap.png\" alt=\"DAP\"></p>\n<h4 id=\"vscode-extension-要点\"><a href=\"#vscode-extension-要点\" class=\"headerlink\" title=\"vscode extension 要点\"></a>vscode extension 要点</h4><p>vscode插件<a href=\"https://code.visualstudio.com/api/extension-capabilities/overview\" target=\"_blank\" rel=\"noopener\">能做什么？（官方）</a></p>\n<ul>\n<li>使用颜色或图标更改vscode的外观</li>\n<li>在UI界面中添加自定义组件和视图</li>\n<li>创建一个Webview来显示自定义构建的web页面</li>\n<li>支持新的编程语言</li>\n<li>支持调试特定的程序</li>\n</ul>\n<p>在我看来：</p>\n<ul>\n<li>自定义命令、快捷键、菜单选项</li>\n<li>自定义跳转、自动补全、悬浮提示</li>\n<li>自定义设置</li>\n<li>自定义Webview</li>\n<li>自定义左侧Tree view</li>\n<li>自定义颜色、图标主题</li>\n<li>新增语言语法</li>\n<li>通知、状态栏</li>\n</ul>\n<p>当我们开发vscode插件的时候，只需要注意三个要点，就可以对vscode进行功能增强</p>\n<ul>\n<li>Activation Event</li>\n</ul>\n<blockquote>\n<p>插件激活的时机，在package.json中声明。<br>key为activationEvents，value为数组的一组JSON声明。<br>值得注意的是，激活的时机可以是多条件的。</p>\n</blockquote>\n<ul>\n<li>Contribution Points</li>\n</ul>\n<blockquote>\n<p>插件配置的声明、增强了vscode的什么功能，在package.json中声明。<br>key为contributes，value为对象的一组JSON声明</p>\n</blockquote>\n<ul>\n<li>VS Code API</li>\n</ul>\n<blockquote>\n<p>普遍在src/extension.ts(js)。<br>插件中可以调用的扩展JavaScript API。</p>\n</blockquote>\n<h5 id=\"Activation-Event\"><a href=\"#Activation-Event\" class=\"headerlink\" title=\"Activation Event\"></a>Activation Event</h5><ul>\n<li>onLanguage:<code>${language}</code> 打开特定语言的文件时激活</li>\n</ul>\n<p>eg: onLanguage:typescript、onLanguage:python</p>\n<p><img src=\"//psilocine.github.io/2021/07/05/vscode-extension初探/activation_event_1.png\" alt=\"activation_event_1\"></p>\n<ul>\n<li>onCommand:<code>${command id}</code> 调用命令时激活</li>\n</ul>\n<p>eg: onCommand:paperang.helloworld</p>\n<p><img src=\"//psilocine.github.io/2021/07/05/vscode-extension初探/activation_event_2.png\" alt=\"activation_event_2\"></p>\n<ul>\n<li>onDebug 在启动调试模式时激活</li>\n<li>workspaceContains 当打开的文件夹至少有一个glob pattern表达式匹配的文件时激活</li>\n</ul>\n<p>eg: workspaceContains:<code>**/.editorconfig</code>、workspaceContains:<code>**/.prettierrc.js</code></p>\n<ul>\n<li>onFileSystem 当读取的文件或文件夹匹配文件方案时激活</li>\n</ul>\n<p>eg: onFileSystem:ftp、onFileSystem:ssh</p>\n<ul>\n<li>onView 左侧栏展开特定view id时激活</li>\n</ul>\n<p>eg: onView:outline</p>\n<ul>\n<li>onUri 打开系统级的uri时激活（这个URI协议需要带上vscode 或者 vscode-insiders协议</li>\n</ul>\n<p>eg:vscode://vscode.git/init、vscode-insiders://vscode.git/init</p>\n<ul>\n<li>onWebviewPanel 匹配到是viewType的webview时激活（需要配合其他事件、如onCommand来创建webview </li>\n</ul>\n<p>eg: onWebviewPanel:catCoding</p>\n<ul>\n<li><p>onCustomEditor 匹配到是viewType的自定义编辑器时激活</p>\n</li>\n<li><p>*（start up）vscode启动时激活（尽量不用</p>\n</li>\n<li><p>onStartupFinished vscode启动一段时间后激活（和*相比，不会减慢vscode的启动速度</p>\n</li>\n</ul>\n<p><img src=\"//psilocine.github.io/2021/07/05/vscode-extension初探/activation_event_3.png\" alt=\"activation_event_3\"></p>\n<p>更多详见<a href=\"https://code.visualstudio.com/api/references/activation-events\" target=\"_blank\" rel=\"noopener\">官方文档</a></p>\n<h5 id=\"Contribution-Points\"><a href=\"#Contribution-Points\" class=\"headerlink\" title=\"Contribution Points\"></a>Contribution Points</h5><ul>\n<li>configuration:object 将插件的配置内容暴露出来，用户可以通过UI界面或setting.json修改<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">title:string 插件的展示名称 eg:paperangExtension -&gt; Paperang Extension</span><br><span class=\"line\">properties:object 配置项集合</span><br><span class=\"line\">  [property]:object 配置项</span><br><span class=\"line\">    type number、string、boolean可以在UI界面展示，其余types只能通过json修改</span><br><span class=\"line\">    <span class=\"keyword\">default</span>:any</span><br><span class=\"line\">    description:string</span><br><span class=\"line\">    markdownDescription:string</span><br><span class=\"line\">    enum:array</span><br><span class=\"line\">    enumDescriptions:array</span><br></pre></td></tr></table></figure>\n\n</li>\n</ul>\n<p><img src=\"//psilocine.github.io/2021/07/05/vscode-extension初探/contribution_points.png\" alt=\"contribution_points_example\"></p>\n<ul>\n<li>commands:Array<object><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">command:string</span><br><span class=\"line\">title:string</span><br><span class=\"line\">category:string 便于分组</span><br></pre></td></tr></table></figure>\n\n</object></li>\n</ul>\n<p><img src=\"//psilocine.github.io/2021/07/05/vscode-extension初探/contribution_points_2.png\" alt=\"contribution_points_example\"></p>\n<ul>\n<li>menus:object<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">commandPalette:<span class=\"built_in\">Array</span>&lt;<span class=\"built_in\">Object</span>&gt; 全局命令面板</span><br><span class=\"line\">explorer/context 资源管理器上下文菜单</span><br><span class=\"line\">editor/context 编辑器上下文菜单</span><br><span class=\"line\">editor/title 编辑器标题栏右侧</span><br><span class=\"line\">editor/title/context 编辑器标题栏</span><br><span class=\"line\">debug/toolbar 调试工具栏</span><br><span class=\"line\">scm/title source control manager 右侧</span><br><span class=\"line\">view/title 标题栏右侧</span><br><span class=\"line\">view/item/context</span><br></pre></td></tr></table></figure>\n\n</li>\n</ul>\n<p><img src=\"//psilocine.github.io/2021/07/05/vscode-extension初探/contribution_points_3.png\" alt=\"contribution_points_example\"></p>\n<ul>\n<li>keybindings:Array<object><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">command:string</span><br><span class=\"line\">key:string</span><br><span class=\"line\">mac:string</span><br><span class=\"line\">when:string</span><br></pre></td></tr></table></figure>\n\n</object></li>\n</ul>\n<p><img src=\"//psilocine.github.io/2021/07/05/vscode-extension初探/contribution_points_4.png\" alt=\"contribution_points_example\"></p>\n<p>更多详见<a href=\"https://code.visualstudio.com/api/references/contribution-points\" target=\"_blank\" rel=\"noopener\">官方文档</a></p>\n<h5 id=\"VS-Code-API\"><a href=\"#VS-Code-API\" class=\"headerlink\" title=\"VS Code API\"></a>VS Code API</h5><p>VS Code暴露了大几十种<a href=\"https://code.visualstudio.com/api/references/vscode-api\" target=\"_blank\" rel=\"noopener\">API</a>，下述只罗列几个：</p>\n<ul>\n<li>commands:</li>\n</ul>\n<p>registerCommand(command:string, callback) 注册command<br>executeCommand(command) 执行command</p>\n<ul>\n<li>window:</li>\n</ul>\n<p>createStatusBarItem(alignment?, priority?:number) 底部导航栏item<br>createTreeView(viewId:string, options) 左侧菜单栏<br>createWebviewPanel(viewType: string, title: string) 创建新的webview<br>setStatusBarMessage(text: string, hideAfterTimeout: number) 底部状态栏消息<br>show(Error/Infomation/Warning)Message(message: string, …items: string[]) 底部右侧弹窗，需要交互关闭</p>\n<ul>\n<li>workspace：</li>\n</ul>\n<p>getConfiguration 获取配置对象<br>eg: vscode.workspace.getConfiguration(‘pomodoro’).get(‘visible’)、<br>vscode.workspace.getConfiguration().get(‘pomodoro.visible’)</p>\n<p>更多详见<a href=\"https://code.visualstudio.com/api/references/vscode-api\" target=\"_blank\" rel=\"noopener\">官方文档</a></p>\n<h4 id=\"实践和发布\"><a href=\"#实践和发布\" class=\"headerlink\" title=\"实践和发布\"></a>实践和发布</h4><ol>\n<li>安装官方脚手架yo、generator-code<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ npm install -g yo generator-code</span><br><span class=\"line\">$ yo code</span><br></pre></td></tr></table></figure>\n\n</li>\n</ol>\n<p><img src=\"//psilocine.github.io/2021/07/05/vscode-extension初探/cli.png\" alt=\"cli\"></p>\n<p><img src=\"//psilocine.github.io/2021/07/05/vscode-extension初探/cli-builded.png\" alt=\"cli-builded\"></p>\n<ol start=\"2\">\n<li>完成插件的开发和测试</li>\n</ol>\n<p>i. 番茄钟<br><img src=\"//psilocine.github.io/2021/07/05/vscode-extension初探/paperang-pomodoro.gif\" alt=\"paperang-pomodoro\"><br>ii. 主题色<br><img src=\"//psilocine.github.io/2021/07/05/vscode-extension初探/paperang-theme.gif\" alt=\"paperang-theme\"></p>\n<ol start=\"3\">\n<li>本地打包/发布到vscode插件市场</li>\n</ol>\n<p>本地打包：不方便发布到市场的插件。如涉密，团队自用<br>i. vsce package<br>ii. Install from VSIX</p>\n<p><img src=\"//psilocine.github.io/2021/07/05/vscode-extension初探/local_setup.gif\" alt=\"local_setup\"></p>\n<p>发布<a href=\"https://marketplace.visualstudio.com/vscode\" target=\"_blank\" rel=\"noopener\">市场</a>：<br>i. 注册<a href=\"https://login.live.com/\" target=\"_blank\" rel=\"noopener\">Microsoft账号</a><br>ii. 创建<a href=\"https://aka.ms/SignupAzureDevOps\" target=\"_blank\" rel=\"noopener\">Azure DevOps</a>组织<br>iii. 创建Token：(security/Personal Access Tokens<br>)<br>iv. 注册成为<a href=\"https://aka.ms/vscode-create-publishe\" target=\"_blank\" rel=\"noopener\">发布者</a>：命令行注册已经失效，需网页注册<br>v. vsce publish<br>vi. 过几分钟就可以在市场上搜索到了～</p>"},{"title":"从线性渐变属性探究 CSS 数据类型的重要性","date":"2021-09-13T02:38:59.000Z","_content":"\n## 为什么要关注 CSS 数据类型\n\n首先要知道一个前提，过去 CSS 按照大版本的方式进行迭代，如果有一个 CSS 特性存在争议，就会使该版本的发布时间延后。例如 CSS2.1 的规范在 2002 年开始制定，而一直到 2011 年 4 月才成为标准，效率十分低下。\n\n为了加速没有争议的 CSS 特性的标准化，W3C 的 CSS 工作组决定将 CSS 模块化。带来的好处就是浏览器支持的特性越来越多，越来越快。\n\n所以以后就没有 CSS4 这一说了，其实 CSS3 也已经解体了。\n\n短时间内大量的 CSS 新特性出现，恰恰如果按之前靠死记 key-value 的形式，这将是坏处。好在 CSS 新的特性有了明确的 CSS 数据类型划分，因此只需要记忆 CSS 数据类型即可\n\n<!-- more -->\n\n\n## 什么是 CSS 数据类型\n\n一个 CSS 数据类型和用法由三部分组成：\n\n* 数据类型名称：保守估计有50个，如 gradient、color\n* keyword：关键字，如 to、from、at、ease、auto\n* 符号：分为字面符号，组合符号，数量符号\n\n举个例子， `<gradient>` 的线性渐变 `linear-gradient` 的语法：\n```javascript\nlinear-gradient(\n    [ <angle> | to <side-or-corner> ,]? <color-stop-list>\n)\n```\n\n由上得知，线性渐变的语法包括了三个 CSS 数据类型，包括 `<angle>`、`<side-or-corner>` 和 `<color-stop-list>`。只要我们了解这三个数据类型的用法，哪怕没用过线性渐变属性，也能轻松应对。\n\n![666](//github.com/Psilocine/TechMeme/blob/main/meme/common/666.png?raw=true)\n\n### 符号\n\n为了看懂 CSS 数据类型，我们必须先了解符号的意义\n\n字面符号\n\n|  符号  | 名称  | 描述 |\n|  ----  | ----  | ---- |\n| , | 并列分隔符 |  用来分隔并列值，或者分隔函数的参数值  |\n| / | 缩写分隔符 | 用来分隔一个值的多个部分，在CSS缩写用于分离类型相同且属性不同的值。如 font 缩写的 font-size / line-height |\n\n组合符号\n\n|  符号  | 名称  | 描述 |\n|  ----  | ----  | ---- |\n|  | 并列  | 普通空格字符，表示各部分必须按顺序出现 |\n| && | 与 | 各部分必须出现，但可以不按顺序 |\n| \\|\\| | 或 | 各部分至少出现一个，但可以不按顺序 |\n| \\| | 互斥 | 各部分只能出现一个 |\n| [] | 方括号 | 优先级最高 |\n\n数量符号\n\n|  符号  | 名称  | 描述 |\n|  ----  | ----  | ---- |\n| | 无数量符号 | 出现一次 |\n| * | 星号 | 可以出现任意次数 |\n| + | 加号 | 可以出现 1 次或多次 |\n| ? |问号 |\t可以出现 0 次或 1 次 |\n| {A, B} |\t花括号 |\t出现最少 A 次，最多 B 次 |\n| # |\t井号 |\t可以出现一次或多次，但多次出现必须以逗号分隔 |\n| ! | 感叹号 |\t表示当前分组必须产生一个值，该符号多出现在方括号 [] 的后面 |\n\n![no_technology](https://raw.githubusercontent.com/Psilocine/TechMeme/main/meme/common/common_02.jpg)\n\n## 管中窥豹：`<gradient>`\n\n通过查阅 [MDN](https://developer.mozilla.org/en-US/docs/Web/CSS/gradient) 得知，`<gradient>` 类型有四种值：\n* 线性渐变 linear gradient\n* 径向渐变 radial gradient\n* 重复渐变 repeating gradient\n* 锥形渐变 conic gradient\n\n由于篇幅问题，本文只讨论线性渐变\n\n### 线性渐变 linear gradient\n\n角度默认值为 to bottom。刚刚提过，语法是\n```javascript\nSyntax: linear-gradient(\n\t[ <angle> | to <side-or-corner> ,]? <color-stop-list>\n)\n```\n\n下面学习涉及的 CSS 数据类型：\n\n`<angle>` 表示角度的大小。有正负符号，数值为0时，单位可以省略。单位有：\n* deg（degress, 角度）360deg = 完整的圆\n* rad（radians，弧度）2π * rad = 360deg\n* turn（turns，圈数）1turn = 360deg\n* grad（gradians，百分度）400grad = 360deg\n\n---\n\n`<side-or-corner>` 表示边角类型。主要用在线性渐变中。\n* Syntax：[ left | right ] || [ top | bottom ]\n\n---\n\n`<color-stop-list>` 表示多个 `<linear-color-stop>` 的集合。\n* Syntax: [ `<linear-color-stop`> [, `<color-hint>`? ]? ]#, `<linear-color-stop>`\n\n---\n\n`<linear-color-stop>` 表示颜色断点，多出现在渐变中。\n* Syntax：`<color>` [ `<color-stop-length>` ]?\n\n---\n\n`<color>` 表示色值，可以是：\n* 颜色关键字 blue, transparent, etc.\n* currentColor\n* rgb()、rgba()\n* hsl()、hsla()\n\n---\n\n`<color-hint>` 表示渐变在相邻颜色之间如何进行插值，如果省略，颜色过渡的中点是两个颜色之间的中点。\n\n---\n\n`<color-stop-length>` 表示颜色的数值参数。\n* Syntax：[ `<percentage>` | `<length>` ]{1, 2}\n\n---\n\n`<percentage>` 表示百分比数值。有正负符号。\n\n---\n\n`<length>` 表示距离值。\n* 相对长度单位：em, rem, ch, ex\n* 视区相关长度：vh, vw, vmin, vmax\n* 绝对长度单位：px, cm, mm, in, pc, pt\n\n![can't learn anymore](https://github.com/Psilocine/TechMeme/blob/main/meme/common/common_06.jpg?raw=true)\n\n不知不觉掌握了好多 CSS 数据类型了呢，想想还觉得挺激动的。有了上面的背书，我们就直接下手看这个属性。\n\n1. `background: linear-gradient(pink, skyblue);` 上述有提到默认值是 to bottom，第一个值 pink 的 `<color-stop-length>` 默认值是 0%，最后一个值 skyblue 默认值为 100%，所以效果是这样的：\n![3](https://saas-base.cdnjtzy.com/sns/20210910/3c0167b39676f6f31041f1824ac74abf.png)\n等效于 `background: linear-gradient(to bottom, pink 0%, skyblue 100%);`\n\n2. `background: linear-gradient(0.25turn, pink, skyblue);` 就是`to right`\n![4](https://saas-base.cdnjtzy.com/sns/20210910/080dbea3e84048f6295ce50d3e7807bd.png)\n\n3. `<color-hint>`\n```css\n/* 指定了<color-hint>在 50%，所以能见到明显的分割线，不会有渐变的过程 */\nbackground: linear-gradient(0.25turn, pink 50%, 50%, skyblue);\n/* 等同于 */\nbackground: linear-gradient(0.25turn, pink 50%, skyblue 50% 100%);\n```\n![5](https://saas-base.cdnjtzy.com/sns/20210910/edfc7a26742a3b91ed63bfcac4908b2d.png)\n\n4. 拓展\n```css\nbackground-image: linear-gradient(217deg, rgba(255,0,0,.8), rgba(255,0,0,0) 70.71%),\nlinear-gradient(127deg, rgba(0,255,0,.8), rgba(0,255,0,0) 70.71%),\nlinear-gradient(336deg, rgba(0,0,255,.8), rgba(0,0,255,0) 70.71%);\n```\n![7](https://saas-base.cdnjtzy.com/sns/20210910/1b7fabfbd77ee67f4fec6f6d48097fd4.png)\n\n从上面的例子，我们可以反推 background-image 语法的数据类型可能有 `<gradient>#`，通过查阅 [MDN](https://developer.mozilla.org/en-US/docs/Web/CSS/background-image#bg-image) 得知，确实如此。\n\n![nice](https://github.com/Psilocine/TechMeme/blob/main/meme/common/common_05.jpg?raw=true)\n\n## 结论\nCSS 数据类型能够帮助我们快速知道某个新特性的 value，减少错误赋值，可以说是一大利器。\n\n比如我们不认识下面两个属性，但是通过对 `<color>` 的认识，就可以知道该属性能够赋予的 value 有哪些了～\n1. accent-color: `<color>`\n2. caret-color: `<color>`\n\n![ending](https://github.com/Psilocine/TechMeme/blob/main/meme/common/ending.gif?raw=true)\n\n\n参考资料：\n* [MDN: CSS data types](https://developer.mozilla.org/en-US/docs/Web/CSS/CSS_Types)\n* [张鑫旭](https://www.zhangxinxu.com/wordpress/2019/11/css-value-type/)\n","source":"_posts/从线性渐变属性探究-CSS-数据类型的重要性.md","raw":"---\ntitle: 从线性渐变属性探究 CSS 数据类型的重要性\ndate: 2021-09-13 10:38:59\ntags: [CSS]\n---\n\n## 为什么要关注 CSS 数据类型\n\n首先要知道一个前提，过去 CSS 按照大版本的方式进行迭代，如果有一个 CSS 特性存在争议，就会使该版本的发布时间延后。例如 CSS2.1 的规范在 2002 年开始制定，而一直到 2011 年 4 月才成为标准，效率十分低下。\n\n为了加速没有争议的 CSS 特性的标准化，W3C 的 CSS 工作组决定将 CSS 模块化。带来的好处就是浏览器支持的特性越来越多，越来越快。\n\n所以以后就没有 CSS4 这一说了，其实 CSS3 也已经解体了。\n\n短时间内大量的 CSS 新特性出现，恰恰如果按之前靠死记 key-value 的形式，这将是坏处。好在 CSS 新的特性有了明确的 CSS 数据类型划分，因此只需要记忆 CSS 数据类型即可\n\n<!-- more -->\n\n\n## 什么是 CSS 数据类型\n\n一个 CSS 数据类型和用法由三部分组成：\n\n* 数据类型名称：保守估计有50个，如 gradient、color\n* keyword：关键字，如 to、from、at、ease、auto\n* 符号：分为字面符号，组合符号，数量符号\n\n举个例子， `<gradient>` 的线性渐变 `linear-gradient` 的语法：\n```javascript\nlinear-gradient(\n    [ <angle> | to <side-or-corner> ,]? <color-stop-list>\n)\n```\n\n由上得知，线性渐变的语法包括了三个 CSS 数据类型，包括 `<angle>`、`<side-or-corner>` 和 `<color-stop-list>`。只要我们了解这三个数据类型的用法，哪怕没用过线性渐变属性，也能轻松应对。\n\n![666](//github.com/Psilocine/TechMeme/blob/main/meme/common/666.png?raw=true)\n\n### 符号\n\n为了看懂 CSS 数据类型，我们必须先了解符号的意义\n\n字面符号\n\n|  符号  | 名称  | 描述 |\n|  ----  | ----  | ---- |\n| , | 并列分隔符 |  用来分隔并列值，或者分隔函数的参数值  |\n| / | 缩写分隔符 | 用来分隔一个值的多个部分，在CSS缩写用于分离类型相同且属性不同的值。如 font 缩写的 font-size / line-height |\n\n组合符号\n\n|  符号  | 名称  | 描述 |\n|  ----  | ----  | ---- |\n|  | 并列  | 普通空格字符，表示各部分必须按顺序出现 |\n| && | 与 | 各部分必须出现，但可以不按顺序 |\n| \\|\\| | 或 | 各部分至少出现一个，但可以不按顺序 |\n| \\| | 互斥 | 各部分只能出现一个 |\n| [] | 方括号 | 优先级最高 |\n\n数量符号\n\n|  符号  | 名称  | 描述 |\n|  ----  | ----  | ---- |\n| | 无数量符号 | 出现一次 |\n| * | 星号 | 可以出现任意次数 |\n| + | 加号 | 可以出现 1 次或多次 |\n| ? |问号 |\t可以出现 0 次或 1 次 |\n| {A, B} |\t花括号 |\t出现最少 A 次，最多 B 次 |\n| # |\t井号 |\t可以出现一次或多次，但多次出现必须以逗号分隔 |\n| ! | 感叹号 |\t表示当前分组必须产生一个值，该符号多出现在方括号 [] 的后面 |\n\n![no_technology](https://raw.githubusercontent.com/Psilocine/TechMeme/main/meme/common/common_02.jpg)\n\n## 管中窥豹：`<gradient>`\n\n通过查阅 [MDN](https://developer.mozilla.org/en-US/docs/Web/CSS/gradient) 得知，`<gradient>` 类型有四种值：\n* 线性渐变 linear gradient\n* 径向渐变 radial gradient\n* 重复渐变 repeating gradient\n* 锥形渐变 conic gradient\n\n由于篇幅问题，本文只讨论线性渐变\n\n### 线性渐变 linear gradient\n\n角度默认值为 to bottom。刚刚提过，语法是\n```javascript\nSyntax: linear-gradient(\n\t[ <angle> | to <side-or-corner> ,]? <color-stop-list>\n)\n```\n\n下面学习涉及的 CSS 数据类型：\n\n`<angle>` 表示角度的大小。有正负符号，数值为0时，单位可以省略。单位有：\n* deg（degress, 角度）360deg = 完整的圆\n* rad（radians，弧度）2π * rad = 360deg\n* turn（turns，圈数）1turn = 360deg\n* grad（gradians，百分度）400grad = 360deg\n\n---\n\n`<side-or-corner>` 表示边角类型。主要用在线性渐变中。\n* Syntax：[ left | right ] || [ top | bottom ]\n\n---\n\n`<color-stop-list>` 表示多个 `<linear-color-stop>` 的集合。\n* Syntax: [ `<linear-color-stop`> [, `<color-hint>`? ]? ]#, `<linear-color-stop>`\n\n---\n\n`<linear-color-stop>` 表示颜色断点，多出现在渐变中。\n* Syntax：`<color>` [ `<color-stop-length>` ]?\n\n---\n\n`<color>` 表示色值，可以是：\n* 颜色关键字 blue, transparent, etc.\n* currentColor\n* rgb()、rgba()\n* hsl()、hsla()\n\n---\n\n`<color-hint>` 表示渐变在相邻颜色之间如何进行插值，如果省略，颜色过渡的中点是两个颜色之间的中点。\n\n---\n\n`<color-stop-length>` 表示颜色的数值参数。\n* Syntax：[ `<percentage>` | `<length>` ]{1, 2}\n\n---\n\n`<percentage>` 表示百分比数值。有正负符号。\n\n---\n\n`<length>` 表示距离值。\n* 相对长度单位：em, rem, ch, ex\n* 视区相关长度：vh, vw, vmin, vmax\n* 绝对长度单位：px, cm, mm, in, pc, pt\n\n![can't learn anymore](https://github.com/Psilocine/TechMeme/blob/main/meme/common/common_06.jpg?raw=true)\n\n不知不觉掌握了好多 CSS 数据类型了呢，想想还觉得挺激动的。有了上面的背书，我们就直接下手看这个属性。\n\n1. `background: linear-gradient(pink, skyblue);` 上述有提到默认值是 to bottom，第一个值 pink 的 `<color-stop-length>` 默认值是 0%，最后一个值 skyblue 默认值为 100%，所以效果是这样的：\n![3](https://saas-base.cdnjtzy.com/sns/20210910/3c0167b39676f6f31041f1824ac74abf.png)\n等效于 `background: linear-gradient(to bottom, pink 0%, skyblue 100%);`\n\n2. `background: linear-gradient(0.25turn, pink, skyblue);` 就是`to right`\n![4](https://saas-base.cdnjtzy.com/sns/20210910/080dbea3e84048f6295ce50d3e7807bd.png)\n\n3. `<color-hint>`\n```css\n/* 指定了<color-hint>在 50%，所以能见到明显的分割线，不会有渐变的过程 */\nbackground: linear-gradient(0.25turn, pink 50%, 50%, skyblue);\n/* 等同于 */\nbackground: linear-gradient(0.25turn, pink 50%, skyblue 50% 100%);\n```\n![5](https://saas-base.cdnjtzy.com/sns/20210910/edfc7a26742a3b91ed63bfcac4908b2d.png)\n\n4. 拓展\n```css\nbackground-image: linear-gradient(217deg, rgba(255,0,0,.8), rgba(255,0,0,0) 70.71%),\nlinear-gradient(127deg, rgba(0,255,0,.8), rgba(0,255,0,0) 70.71%),\nlinear-gradient(336deg, rgba(0,0,255,.8), rgba(0,0,255,0) 70.71%);\n```\n![7](https://saas-base.cdnjtzy.com/sns/20210910/1b7fabfbd77ee67f4fec6f6d48097fd4.png)\n\n从上面的例子，我们可以反推 background-image 语法的数据类型可能有 `<gradient>#`，通过查阅 [MDN](https://developer.mozilla.org/en-US/docs/Web/CSS/background-image#bg-image) 得知，确实如此。\n\n![nice](https://github.com/Psilocine/TechMeme/blob/main/meme/common/common_05.jpg?raw=true)\n\n## 结论\nCSS 数据类型能够帮助我们快速知道某个新特性的 value，减少错误赋值，可以说是一大利器。\n\n比如我们不认识下面两个属性，但是通过对 `<color>` 的认识，就可以知道该属性能够赋予的 value 有哪些了～\n1. accent-color: `<color>`\n2. caret-color: `<color>`\n\n![ending](https://github.com/Psilocine/TechMeme/blob/main/meme/common/ending.gif?raw=true)\n\n\n参考资料：\n* [MDN: CSS data types](https://developer.mozilla.org/en-US/docs/Web/CSS/CSS_Types)\n* [张鑫旭](https://www.zhangxinxu.com/wordpress/2019/11/css-value-type/)\n","slug":"从线性渐变属性探究-CSS-数据类型的重要性","published":1,"updated":"2021-09-13T02:41:18.246Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl5sb8gf3000ixq0r9opmppcl","content":"<h2 id=\"为什么要关注-CSS-数据类型\"><a href=\"#为什么要关注-CSS-数据类型\" class=\"headerlink\" title=\"为什么要关注 CSS 数据类型\"></a>为什么要关注 CSS 数据类型</h2><p>首先要知道一个前提，过去 CSS 按照大版本的方式进行迭代，如果有一个 CSS 特性存在争议，就会使该版本的发布时间延后。例如 CSS2.1 的规范在 2002 年开始制定，而一直到 2011 年 4 月才成为标准，效率十分低下。</p>\n<p>为了加速没有争议的 CSS 特性的标准化，W3C 的 CSS 工作组决定将 CSS 模块化。带来的好处就是浏览器支持的特性越来越多，越来越快。</p>\n<p>所以以后就没有 CSS4 这一说了，其实 CSS3 也已经解体了。</p>\n<p>短时间内大量的 CSS 新特性出现，恰恰如果按之前靠死记 key-value 的形式，这将是坏处。好在 CSS 新的特性有了明确的 CSS 数据类型划分，因此只需要记忆 CSS 数据类型即可</p>\n<a id=\"more\"></a>\n\n\n<h2 id=\"什么是-CSS-数据类型\"><a href=\"#什么是-CSS-数据类型\" class=\"headerlink\" title=\"什么是 CSS 数据类型\"></a>什么是 CSS 数据类型</h2><p>一个 CSS 数据类型和用法由三部分组成：</p>\n<ul>\n<li>数据类型名称：保守估计有50个，如 gradient、color</li>\n<li>keyword：关键字，如 to、from、at、ease、auto</li>\n<li>符号：分为字面符号，组合符号，数量符号</li>\n</ul>\n<p>举个例子， <code>&lt;gradient&gt;</code> 的线性渐变 <code>linear-gradient</code> 的语法：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">linear-gradient(</span><br><span class=\"line\">    [ &lt;angle&gt; | to &lt;side-or-corner&gt; ,]? &lt;color-stop-list&gt;</span><br><span class=\"line\">)</span><br></pre></td></tr></table></figure>\n\n<p>由上得知，线性渐变的语法包括了三个 CSS 数据类型，包括 <code>&lt;angle&gt;</code>、<code>&lt;side-or-corner&gt;</code> 和 <code>&lt;color-stop-list&gt;</code>。只要我们了解这三个数据类型的用法，哪怕没用过线性渐变属性，也能轻松应对。</p>\n<p><img src=\"//github.com/Psilocine/TechMeme/blob/main/meme/common/666.png?raw=true\" alt=\"666\"></p>\n<h3 id=\"符号\"><a href=\"#符号\" class=\"headerlink\" title=\"符号\"></a>符号</h3><p>为了看懂 CSS 数据类型，我们必须先了解符号的意义</p>\n<p>字面符号</p>\n<table>\n<thead>\n<tr>\n<th>符号</th>\n<th>名称</th>\n<th>描述</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>,</td>\n<td>并列分隔符</td>\n<td>用来分隔并列值，或者分隔函数的参数值</td>\n</tr>\n<tr>\n<td>/</td>\n<td>缩写分隔符</td>\n<td>用来分隔一个值的多个部分，在CSS缩写用于分离类型相同且属性不同的值。如 font 缩写的 font-size / line-height</td>\n</tr>\n</tbody></table>\n<p>组合符号</p>\n<table>\n<thead>\n<tr>\n<th>符号</th>\n<th>名称</th>\n<th>描述</th>\n</tr>\n</thead>\n<tbody><tr>\n<td></td>\n<td>并列</td>\n<td>普通空格字符，表示各部分必须按顺序出现</td>\n</tr>\n<tr>\n<td>&amp;&amp;</td>\n<td>与</td>\n<td>各部分必须出现，但可以不按顺序</td>\n</tr>\n<tr>\n<td>||</td>\n<td>或</td>\n<td>各部分至少出现一个，但可以不按顺序</td>\n</tr>\n<tr>\n<td>|</td>\n<td>互斥</td>\n<td>各部分只能出现一个</td>\n</tr>\n<tr>\n<td>[]</td>\n<td>方括号</td>\n<td>优先级最高</td>\n</tr>\n</tbody></table>\n<p>数量符号</p>\n<table>\n<thead>\n<tr>\n<th>符号</th>\n<th>名称</th>\n<th>描述</th>\n</tr>\n</thead>\n<tbody><tr>\n<td></td>\n<td>无数量符号</td>\n<td>出现一次</td>\n</tr>\n<tr>\n<td>*</td>\n<td>星号</td>\n<td>可以出现任意次数</td>\n</tr>\n<tr>\n<td>+</td>\n<td>加号</td>\n<td>可以出现 1 次或多次</td>\n</tr>\n<tr>\n<td>?</td>\n<td>问号</td>\n<td>可以出现 0 次或 1 次</td>\n</tr>\n<tr>\n<td>{A, B}</td>\n<td>花括号</td>\n<td>出现最少 A 次，最多 B 次</td>\n</tr>\n<tr>\n<td>#</td>\n<td>井号</td>\n<td>可以出现一次或多次，但多次出现必须以逗号分隔</td>\n</tr>\n<tr>\n<td>!</td>\n<td>感叹号</td>\n<td>表示当前分组必须产生一个值，该符号多出现在方括号 [] 的后面</td>\n</tr>\n</tbody></table>\n<p><img src=\"https://raw.githubusercontent.com/Psilocine/TechMeme/main/meme/common/common_02.jpg\" alt=\"no_technology\"></p>\n<h2 id=\"管中窥豹：-lt-gradient-gt\"><a href=\"#管中窥豹：-lt-gradient-gt\" class=\"headerlink\" title=\"管中窥豹：&lt;gradient&gt;\"></a>管中窥豹：<code>&lt;gradient&gt;</code></h2><p>通过查阅 <a href=\"https://developer.mozilla.org/en-US/docs/Web/CSS/gradient\" target=\"_blank\" rel=\"noopener\">MDN</a> 得知，<code>&lt;gradient&gt;</code> 类型有四种值：</p>\n<ul>\n<li>线性渐变 linear gradient</li>\n<li>径向渐变 radial gradient</li>\n<li>重复渐变 repeating gradient</li>\n<li>锥形渐变 conic gradient</li>\n</ul>\n<p>由于篇幅问题，本文只讨论线性渐变</p>\n<h3 id=\"线性渐变-linear-gradient\"><a href=\"#线性渐变-linear-gradient\" class=\"headerlink\" title=\"线性渐变 linear gradient\"></a>线性渐变 linear gradient</h3><p>角度默认值为 to bottom。刚刚提过，语法是</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Syntax: linear-gradient(</span><br><span class=\"line\">hexo[ &lt;angle&gt; | to &lt;side-or-corner&gt; ,]? &lt;color-stop-list&gt;</span><br><span class=\"line\">)</span><br></pre></td></tr></table></figure>\n\n<p>下面学习涉及的 CSS 数据类型：</p>\n<p><code>&lt;angle&gt;</code> 表示角度的大小。有正负符号，数值为0时，单位可以省略。单位有：</p>\n<ul>\n<li>deg（degress, 角度）360deg = 完整的圆</li>\n<li>rad（radians，弧度）2π * rad = 360deg</li>\n<li>turn（turns，圈数）1turn = 360deg</li>\n<li>grad（gradians，百分度）400grad = 360deg</li>\n</ul>\n<hr>\n<p><code>&lt;side-or-corner&gt;</code> 表示边角类型。主要用在线性渐变中。</p>\n<ul>\n<li>Syntax：[ left | right ] || [ top | bottom ]</li>\n</ul>\n<hr>\n<p><code>&lt;color-stop-list&gt;</code> 表示多个 <code>&lt;linear-color-stop&gt;</code> 的集合。</p>\n<ul>\n<li>Syntax: [ <code>&lt;linear-color-stop</code>&gt; [, <code>&lt;color-hint&gt;</code>? ]? ]#, <code>&lt;linear-color-stop&gt;</code></li>\n</ul>\n<hr>\n<p><code>&lt;linear-color-stop&gt;</code> 表示颜色断点，多出现在渐变中。</p>\n<ul>\n<li>Syntax：<code>&lt;color&gt;</code> [ <code>&lt;color-stop-length&gt;</code> ]?</li>\n</ul>\n<hr>\n<p><code>&lt;color&gt;</code> 表示色值，可以是：</p>\n<ul>\n<li>颜色关键字 blue, transparent, etc.</li>\n<li>currentColor</li>\n<li>rgb()、rgba()</li>\n<li>hsl()、hsla()</li>\n</ul>\n<hr>\n<p><code>&lt;color-hint&gt;</code> 表示渐变在相邻颜色之间如何进行插值，如果省略，颜色过渡的中点是两个颜色之间的中点。</p>\n<hr>\n<p><code>&lt;color-stop-length&gt;</code> 表示颜色的数值参数。</p>\n<ul>\n<li>Syntax：[ <code>&lt;percentage&gt;</code> | <code>&lt;length&gt;</code> ]{1, 2}</li>\n</ul>\n<hr>\n<p><code>&lt;percentage&gt;</code> 表示百分比数值。有正负符号。</p>\n<hr>\n<p><code>&lt;length&gt;</code> 表示距离值。</p>\n<ul>\n<li>相对长度单位：em, rem, ch, ex</li>\n<li>视区相关长度：vh, vw, vmin, vmax</li>\n<li>绝对长度单位：px, cm, mm, in, pc, pt</li>\n</ul>\n<p><img src=\"https://github.com/Psilocine/TechMeme/blob/main/meme/common/common_06.jpg?raw=true\" alt=\"can&#39;t learn anymore\"></p>\n<p>不知不觉掌握了好多 CSS 数据类型了呢，想想还觉得挺激动的。有了上面的背书，我们就直接下手看这个属性。</p>\n<ol>\n<li><p><code>background: linear-gradient(pink, skyblue);</code> 上述有提到默认值是 to bottom，第一个值 pink 的 <code>&lt;color-stop-length&gt;</code> 默认值是 0%，最后一个值 skyblue 默认值为 100%，所以效果是这样的：<br><img src=\"https://saas-base.cdnjtzy.com/sns/20210910/3c0167b39676f6f31041f1824ac74abf.png\" alt=\"3\"><br>等效于 <code>background: linear-gradient(to bottom, pink 0%, skyblue 100%);</code></p>\n</li>\n<li><p><code>background: linear-gradient(0.25turn, pink, skyblue);</code> 就是<code>to right</code><br><img src=\"https://saas-base.cdnjtzy.com/sns/20210910/080dbea3e84048f6295ce50d3e7807bd.png\" alt=\"4\"></p>\n</li>\n<li><p><code>&lt;color-hint&gt;</code></p>\n<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/* 指定了&lt;color-hint&gt;在 50%，所以能见到明显的分割线，不会有渐变的过程 */</span></span><br><span class=\"line\"><span class=\"selector-tag\">background</span>: <span class=\"selector-tag\">linear-gradient</span>(0<span class=\"selector-class\">.25turn</span>, <span class=\"selector-tag\">pink</span> 50%, 50%, <span class=\"selector-tag\">skyblue</span>);</span><br><span class=\"line\"><span class=\"comment\">/* 等同于 */</span></span><br><span class=\"line\"><span class=\"selector-tag\">background</span>: <span class=\"selector-tag\">linear-gradient</span>(0<span class=\"selector-class\">.25turn</span>, <span class=\"selector-tag\">pink</span> 50%, <span class=\"selector-tag\">skyblue</span> 50% 100%);</span><br></pre></td></tr></table></figure>\n\n</li>\n</ol>\n<p><img src=\"https://saas-base.cdnjtzy.com/sns/20210910/edfc7a26742a3b91ed63bfcac4908b2d.png\" alt=\"5\"></p>\n<ol start=\"4\">\n<li>拓展<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-tag\">background-image</span>: <span class=\"selector-tag\">linear-gradient</span>(217<span class=\"selector-tag\">deg</span>, <span class=\"selector-tag\">rgba</span>(255,0,0,<span class=\"selector-class\">.8</span>), <span class=\"selector-tag\">rgba</span>(255,0,0,0) 70<span class=\"selector-class\">.71</span>%),</span><br><span class=\"line\"><span class=\"selector-tag\">linear-gradient</span>(127<span class=\"selector-tag\">deg</span>, <span class=\"selector-tag\">rgba</span>(0,255,0,<span class=\"selector-class\">.8</span>), <span class=\"selector-tag\">rgba</span>(0,255,0,0) 70<span class=\"selector-class\">.71</span>%),</span><br><span class=\"line\"><span class=\"selector-tag\">linear-gradient</span>(336<span class=\"selector-tag\">deg</span>, <span class=\"selector-tag\">rgba</span>(0,0,255,<span class=\"selector-class\">.8</span>), <span class=\"selector-tag\">rgba</span>(0,0,255,0) 70<span class=\"selector-class\">.71</span>%);</span><br></pre></td></tr></table></figure>\n\n</li>\n</ol>\n<p><img src=\"https://saas-base.cdnjtzy.com/sns/20210910/1b7fabfbd77ee67f4fec6f6d48097fd4.png\" alt=\"7\"></p>\n<p>从上面的例子，我们可以反推 background-image 语法的数据类型可能有 <code>&lt;gradient&gt;#</code>，通过查阅 <a href=\"https://developer.mozilla.org/en-US/docs/Web/CSS/background-image#bg-image\" target=\"_blank\" rel=\"noopener\">MDN</a> 得知，确实如此。</p>\n<p><img src=\"https://github.com/Psilocine/TechMeme/blob/main/meme/common/common_05.jpg?raw=true\" alt=\"nice\"></p>\n<h2 id=\"结论\"><a href=\"#结论\" class=\"headerlink\" title=\"结论\"></a>结论</h2><p>CSS 数据类型能够帮助我们快速知道某个新特性的 value，减少错误赋值，可以说是一大利器。</p>\n<p>比如我们不认识下面两个属性，但是通过对 <code>&lt;color&gt;</code> 的认识，就可以知道该属性能够赋予的 value 有哪些了～</p>\n<ol>\n<li>accent-color: <code>&lt;color&gt;</code></li>\n<li>caret-color: <code>&lt;color&gt;</code></li>\n</ol>\n<p><img src=\"https://github.com/Psilocine/TechMeme/blob/main/meme/common/ending.gif?raw=true\" alt=\"ending\"></p>\n<p>参考资料：</p>\n<ul>\n<li><a href=\"https://developer.mozilla.org/en-US/docs/Web/CSS/CSS_Types\" target=\"_blank\" rel=\"noopener\">MDN: CSS data types</a></li>\n<li><a href=\"https://www.zhangxinxu.com/wordpress/2019/11/css-value-type/\" target=\"_blank\" rel=\"noopener\">张鑫旭</a></li>\n</ul>\n","site":{"data":{}},"excerpt":"<h2 id=\"为什么要关注-CSS-数据类型\"><a href=\"#为什么要关注-CSS-数据类型\" class=\"headerlink\" title=\"为什么要关注 CSS 数据类型\"></a>为什么要关注 CSS 数据类型</h2><p>首先要知道一个前提，过去 CSS 按照大版本的方式进行迭代，如果有一个 CSS 特性存在争议，就会使该版本的发布时间延后。例如 CSS2.1 的规范在 2002 年开始制定，而一直到 2011 年 4 月才成为标准，效率十分低下。</p>\n<p>为了加速没有争议的 CSS 特性的标准化，W3C 的 CSS 工作组决定将 CSS 模块化。带来的好处就是浏览器支持的特性越来越多，越来越快。</p>\n<p>所以以后就没有 CSS4 这一说了，其实 CSS3 也已经解体了。</p>\n<p>短时间内大量的 CSS 新特性出现，恰恰如果按之前靠死记 key-value 的形式，这将是坏处。好在 CSS 新的特性有了明确的 CSS 数据类型划分，因此只需要记忆 CSS 数据类型即可</p>","more":"<h2 id=\"什么是-CSS-数据类型\"><a href=\"#什么是-CSS-数据类型\" class=\"headerlink\" title=\"什么是 CSS 数据类型\"></a>什么是 CSS 数据类型</h2><p>一个 CSS 数据类型和用法由三部分组成：</p>\n<ul>\n<li>数据类型名称：保守估计有50个，如 gradient、color</li>\n<li>keyword：关键字，如 to、from、at、ease、auto</li>\n<li>符号：分为字面符号，组合符号，数量符号</li>\n</ul>\n<p>举个例子， <code>&lt;gradient&gt;</code> 的线性渐变 <code>linear-gradient</code> 的语法：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">linear-gradient(</span><br><span class=\"line\">    [ &lt;angle&gt; | to &lt;side-or-corner&gt; ,]? &lt;color-stop-list&gt;</span><br><span class=\"line\">)</span><br></pre></td></tr></table></figure>\n\n<p>由上得知，线性渐变的语法包括了三个 CSS 数据类型，包括 <code>&lt;angle&gt;</code>、<code>&lt;side-or-corner&gt;</code> 和 <code>&lt;color-stop-list&gt;</code>。只要我们了解这三个数据类型的用法，哪怕没用过线性渐变属性，也能轻松应对。</p>\n<p><img src=\"//github.com/Psilocine/TechMeme/blob/main/meme/common/666.png?raw=true\" alt=\"666\"></p>\n<h3 id=\"符号\"><a href=\"#符号\" class=\"headerlink\" title=\"符号\"></a>符号</h3><p>为了看懂 CSS 数据类型，我们必须先了解符号的意义</p>\n<p>字面符号</p>\n<table>\n<thead>\n<tr>\n<th>符号</th>\n<th>名称</th>\n<th>描述</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>,</td>\n<td>并列分隔符</td>\n<td>用来分隔并列值，或者分隔函数的参数值</td>\n</tr>\n<tr>\n<td>/</td>\n<td>缩写分隔符</td>\n<td>用来分隔一个值的多个部分，在CSS缩写用于分离类型相同且属性不同的值。如 font 缩写的 font-size / line-height</td>\n</tr>\n</tbody></table>\n<p>组合符号</p>\n<table>\n<thead>\n<tr>\n<th>符号</th>\n<th>名称</th>\n<th>描述</th>\n</tr>\n</thead>\n<tbody><tr>\n<td></td>\n<td>并列</td>\n<td>普通空格字符，表示各部分必须按顺序出现</td>\n</tr>\n<tr>\n<td>&amp;&amp;</td>\n<td>与</td>\n<td>各部分必须出现，但可以不按顺序</td>\n</tr>\n<tr>\n<td>||</td>\n<td>或</td>\n<td>各部分至少出现一个，但可以不按顺序</td>\n</tr>\n<tr>\n<td>|</td>\n<td>互斥</td>\n<td>各部分只能出现一个</td>\n</tr>\n<tr>\n<td>[]</td>\n<td>方括号</td>\n<td>优先级最高</td>\n</tr>\n</tbody></table>\n<p>数量符号</p>\n<table>\n<thead>\n<tr>\n<th>符号</th>\n<th>名称</th>\n<th>描述</th>\n</tr>\n</thead>\n<tbody><tr>\n<td></td>\n<td>无数量符号</td>\n<td>出现一次</td>\n</tr>\n<tr>\n<td>*</td>\n<td>星号</td>\n<td>可以出现任意次数</td>\n</tr>\n<tr>\n<td>+</td>\n<td>加号</td>\n<td>可以出现 1 次或多次</td>\n</tr>\n<tr>\n<td>?</td>\n<td>问号</td>\n<td>可以出现 0 次或 1 次</td>\n</tr>\n<tr>\n<td>{A, B}</td>\n<td>花括号</td>\n<td>出现最少 A 次，最多 B 次</td>\n</tr>\n<tr>\n<td>#</td>\n<td>井号</td>\n<td>可以出现一次或多次，但多次出现必须以逗号分隔</td>\n</tr>\n<tr>\n<td>!</td>\n<td>感叹号</td>\n<td>表示当前分组必须产生一个值，该符号多出现在方括号 [] 的后面</td>\n</tr>\n</tbody></table>\n<p><img src=\"https://raw.githubusercontent.com/Psilocine/TechMeme/main/meme/common/common_02.jpg\" alt=\"no_technology\"></p>\n<h2 id=\"管中窥豹：-lt-gradient-gt\"><a href=\"#管中窥豹：-lt-gradient-gt\" class=\"headerlink\" title=\"管中窥豹：&lt;gradient&gt;\"></a>管中窥豹：<code>&lt;gradient&gt;</code></h2><p>通过查阅 <a href=\"https://developer.mozilla.org/en-US/docs/Web/CSS/gradient\" target=\"_blank\" rel=\"noopener\">MDN</a> 得知，<code>&lt;gradient&gt;</code> 类型有四种值：</p>\n<ul>\n<li>线性渐变 linear gradient</li>\n<li>径向渐变 radial gradient</li>\n<li>重复渐变 repeating gradient</li>\n<li>锥形渐变 conic gradient</li>\n</ul>\n<p>由于篇幅问题，本文只讨论线性渐变</p>\n<h3 id=\"线性渐变-linear-gradient\"><a href=\"#线性渐变-linear-gradient\" class=\"headerlink\" title=\"线性渐变 linear gradient\"></a>线性渐变 linear gradient</h3><p>角度默认值为 to bottom。刚刚提过，语法是</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Syntax: linear-gradient(</span><br><span class=\"line\">hexo[ &lt;angle&gt; | to &lt;side-or-corner&gt; ,]? &lt;color-stop-list&gt;</span><br><span class=\"line\">)</span><br></pre></td></tr></table></figure>\n\n<p>下面学习涉及的 CSS 数据类型：</p>\n<p><code>&lt;angle&gt;</code> 表示角度的大小。有正负符号，数值为0时，单位可以省略。单位有：</p>\n<ul>\n<li>deg（degress, 角度）360deg = 完整的圆</li>\n<li>rad（radians，弧度）2π * rad = 360deg</li>\n<li>turn（turns，圈数）1turn = 360deg</li>\n<li>grad（gradians，百分度）400grad = 360deg</li>\n</ul>\n<hr>\n<p><code>&lt;side-or-corner&gt;</code> 表示边角类型。主要用在线性渐变中。</p>\n<ul>\n<li>Syntax：[ left | right ] || [ top | bottom ]</li>\n</ul>\n<hr>\n<p><code>&lt;color-stop-list&gt;</code> 表示多个 <code>&lt;linear-color-stop&gt;</code> 的集合。</p>\n<ul>\n<li>Syntax: [ <code>&lt;linear-color-stop</code>&gt; [, <code>&lt;color-hint&gt;</code>? ]? ]#, <code>&lt;linear-color-stop&gt;</code></li>\n</ul>\n<hr>\n<p><code>&lt;linear-color-stop&gt;</code> 表示颜色断点，多出现在渐变中。</p>\n<ul>\n<li>Syntax：<code>&lt;color&gt;</code> [ <code>&lt;color-stop-length&gt;</code> ]?</li>\n</ul>\n<hr>\n<p><code>&lt;color&gt;</code> 表示色值，可以是：</p>\n<ul>\n<li>颜色关键字 blue, transparent, etc.</li>\n<li>currentColor</li>\n<li>rgb()、rgba()</li>\n<li>hsl()、hsla()</li>\n</ul>\n<hr>\n<p><code>&lt;color-hint&gt;</code> 表示渐变在相邻颜色之间如何进行插值，如果省略，颜色过渡的中点是两个颜色之间的中点。</p>\n<hr>\n<p><code>&lt;color-stop-length&gt;</code> 表示颜色的数值参数。</p>\n<ul>\n<li>Syntax：[ <code>&lt;percentage&gt;</code> | <code>&lt;length&gt;</code> ]{1, 2}</li>\n</ul>\n<hr>\n<p><code>&lt;percentage&gt;</code> 表示百分比数值。有正负符号。</p>\n<hr>\n<p><code>&lt;length&gt;</code> 表示距离值。</p>\n<ul>\n<li>相对长度单位：em, rem, ch, ex</li>\n<li>视区相关长度：vh, vw, vmin, vmax</li>\n<li>绝对长度单位：px, cm, mm, in, pc, pt</li>\n</ul>\n<p><img src=\"https://github.com/Psilocine/TechMeme/blob/main/meme/common/common_06.jpg?raw=true\" alt=\"can&#39;t learn anymore\"></p>\n<p>不知不觉掌握了好多 CSS 数据类型了呢，想想还觉得挺激动的。有了上面的背书，我们就直接下手看这个属性。</p>\n<ol>\n<li><p><code>background: linear-gradient(pink, skyblue);</code> 上述有提到默认值是 to bottom，第一个值 pink 的 <code>&lt;color-stop-length&gt;</code> 默认值是 0%，最后一个值 skyblue 默认值为 100%，所以效果是这样的：<br><img src=\"https://saas-base.cdnjtzy.com/sns/20210910/3c0167b39676f6f31041f1824ac74abf.png\" alt=\"3\"><br>等效于 <code>background: linear-gradient(to bottom, pink 0%, skyblue 100%);</code></p>\n</li>\n<li><p><code>background: linear-gradient(0.25turn, pink, skyblue);</code> 就是<code>to right</code><br><img src=\"https://saas-base.cdnjtzy.com/sns/20210910/080dbea3e84048f6295ce50d3e7807bd.png\" alt=\"4\"></p>\n</li>\n<li><p><code>&lt;color-hint&gt;</code></p>\n<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/* 指定了&lt;color-hint&gt;在 50%，所以能见到明显的分割线，不会有渐变的过程 */</span></span><br><span class=\"line\"><span class=\"selector-tag\">background</span>: <span class=\"selector-tag\">linear-gradient</span>(0<span class=\"selector-class\">.25turn</span>, <span class=\"selector-tag\">pink</span> 50%, 50%, <span class=\"selector-tag\">skyblue</span>);</span><br><span class=\"line\"><span class=\"comment\">/* 等同于 */</span></span><br><span class=\"line\"><span class=\"selector-tag\">background</span>: <span class=\"selector-tag\">linear-gradient</span>(0<span class=\"selector-class\">.25turn</span>, <span class=\"selector-tag\">pink</span> 50%, <span class=\"selector-tag\">skyblue</span> 50% 100%);</span><br></pre></td></tr></table></figure>\n\n</li>\n</ol>\n<p><img src=\"https://saas-base.cdnjtzy.com/sns/20210910/edfc7a26742a3b91ed63bfcac4908b2d.png\" alt=\"5\"></p>\n<ol start=\"4\">\n<li>拓展<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-tag\">background-image</span>: <span class=\"selector-tag\">linear-gradient</span>(217<span class=\"selector-tag\">deg</span>, <span class=\"selector-tag\">rgba</span>(255,0,0,<span class=\"selector-class\">.8</span>), <span class=\"selector-tag\">rgba</span>(255,0,0,0) 70<span class=\"selector-class\">.71</span>%),</span><br><span class=\"line\"><span class=\"selector-tag\">linear-gradient</span>(127<span class=\"selector-tag\">deg</span>, <span class=\"selector-tag\">rgba</span>(0,255,0,<span class=\"selector-class\">.8</span>), <span class=\"selector-tag\">rgba</span>(0,255,0,0) 70<span class=\"selector-class\">.71</span>%),</span><br><span class=\"line\"><span class=\"selector-tag\">linear-gradient</span>(336<span class=\"selector-tag\">deg</span>, <span class=\"selector-tag\">rgba</span>(0,0,255,<span class=\"selector-class\">.8</span>), <span class=\"selector-tag\">rgba</span>(0,0,255,0) 70<span class=\"selector-class\">.71</span>%);</span><br></pre></td></tr></table></figure>\n\n</li>\n</ol>\n<p><img src=\"https://saas-base.cdnjtzy.com/sns/20210910/1b7fabfbd77ee67f4fec6f6d48097fd4.png\" alt=\"7\"></p>\n<p>从上面的例子，我们可以反推 background-image 语法的数据类型可能有 <code>&lt;gradient&gt;#</code>，通过查阅 <a href=\"https://developer.mozilla.org/en-US/docs/Web/CSS/background-image#bg-image\" target=\"_blank\" rel=\"noopener\">MDN</a> 得知，确实如此。</p>\n<p><img src=\"https://github.com/Psilocine/TechMeme/blob/main/meme/common/common_05.jpg?raw=true\" alt=\"nice\"></p>\n<h2 id=\"结论\"><a href=\"#结论\" class=\"headerlink\" title=\"结论\"></a>结论</h2><p>CSS 数据类型能够帮助我们快速知道某个新特性的 value，减少错误赋值，可以说是一大利器。</p>\n<p>比如我们不认识下面两个属性，但是通过对 <code>&lt;color&gt;</code> 的认识，就可以知道该属性能够赋予的 value 有哪些了～</p>\n<ol>\n<li>accent-color: <code>&lt;color&gt;</code></li>\n<li>caret-color: <code>&lt;color&gt;</code></li>\n</ol>\n<p><img src=\"https://github.com/Psilocine/TechMeme/blob/main/meme/common/ending.gif?raw=true\" alt=\"ending\"></p>\n<p>参考资料：</p>\n<ul>\n<li><a href=\"https://developer.mozilla.org/en-US/docs/Web/CSS/CSS_Types\" target=\"_blank\" rel=\"noopener\">MDN: CSS data types</a></li>\n<li><a href=\"https://www.zhangxinxu.com/wordpress/2019/11/css-value-type/\" target=\"_blank\" rel=\"noopener\">张鑫旭</a></li>\n</ul>"},{"title":"关于Flex布局的使用指南","date":"2018-02-23T15:56:51.000Z","_content":"\n##### 写在前面\n\nflex 布局, 在移动端也是一大布局利器之一, 跟笔者复习一遍吧.\n\n#### 基本布局\n\n```css\n<div class='father'> // flex container\n  <div calss='son son-1'>1</div> // flex item\n  <div calss='son son-2'>2</div>\n</div>\n\n.father {\n  display: flex;\n}\n```\n\n#### flex container 属性\n\nflex 规定 flex container 的横向为主轴(main axis), 纵向为交叉轴(cross axis)\n1.flex-direction 指定 flex item 是如何布局的. 默认为 row, 即 flex item 从左至右横向排列\n\n```css\n.father {\n  ...;\n  flex-direction: row / row-reverse / column / column-reverse;\n                        (横向右至左) (纵向上至下) (纵向下至上)\n}\n```\n\n<!-- more -->\n\n2.flex-wrap 指定 flex-item 能否自动换行. 默认为 nowrap, 即子元素不换行排列\n\n```css\n.father {\n  ...;\n  flex-wrap: nowrap / wrap / wrap-reverse ;\n                  (多行显示) (多行显示,从下至上显示成多行)\n}\n```\n\n3.flex-flow 是 flex-direction 和 flex-wrap 的缩写\n\n```css\n.father {\n  ...;\n  flex-flow: row nowrap;\n}\n```\n\n4.jusitfy-content 指定 flex item 在主轴线上的对齐方式, 即水平方向. 默认为 flex-start, 子元素靠左对齐.\n\n```css\n.father {\n  ...;\n  justify-content: flex-start / flex-end / center / space-between / space-around;\n                                (靠右对齐)  (居中)\n  space-between: 等间距排列, firstChild和lastChild靠两侧边缘, 如图一\n  space-around: 等间距排列, firstChild和lastChild与两侧边缘也有间隔, 如图二\n}\n```\n\n图一 space-between![space-between](1_space-between.jpg)\n图二 space-around![space-around](1_space-around.jpg)\n\n5.align-items 指定 flex item 在交叉轴上的对齐方式, 即垂直方向. 默认为 stretch, 子元素如无定义高度, 将被拉伸以适应父容器(默认 flex-direction 为 row)\n\n```css\n.father {\n  ...;\n  align-items: stretch / center / flex-start / flex-end / baseline (垂直对齐) (在交叉轴起始对齐)\n    (于底对齐) (按照子元素里的文本基线对齐);\n}\n```\n\nflex-start![flex-start](2_flex-start.jpg)\nbaseline![baseline](2_baseline.jpg)\n\n6.align-content 指定交叉轴上多余空间 默认值为 stretch\n\n```css\n.father {\n  ...;\n  align-content: stretch / center / flex-start / flex-end / space-between / space-around\n  center: (居中对齐, 没有多余空间)\n  flex-start: (在交叉轴起始对齐,没有行行多余空间)\n  flex-end: (于底对齐,没有多余空间)\n  space-between: (各行之间留有空白)\n  space-around: (各行之前之间之后都留有空白)\n}\n```\n\nstretch![stretch](3_stretch.jpg)\nspace-around![space-around](3_space-around.jpg)\n\n#### flex item 属性\n\n1.order 指定排列顺序, 可正可负, 值越小排越前. 默认都是 0\n\n```css\n.son-2 {\n  order: -1 // 排在son-1前面;\n}\n```\n\n2.flex-grow 当父元素存在剩余空间时, 可以用来指定子元素的拉伸比例. 默认值为 0, 负值无效\n![flex-grow](4_flex-grow.jpg)\n3.flex-shrink 当父元素空间不足时, 可以用来指定子元素的收缩比例. 负值无效, 默认为 1, 即会收缩.\n如果设置为 0, 就不收缩将保持原来的大小.\n![flex-shrink](5_flex-shrink.jpg)\n4.flex-basis 为子元素分配初始大小, 默认值为 auto\n\n```css\n.son-2 {\n  ...,\n  flex-grow: 0;\n  flex-skrink: 0;\n  flex-basis: 400px; // 结合上两个属性, 该元素400px宽度不会变化.\n}\n```\n\n5.flex 是 flex-grow flex-skrink flex-basis 的缩写, 此属性比较常用\n\n```css\n.son-1 {\n  flex: 0 0 100px;\n}\n.son-2 {\n  flex: 1 1 auto;\n}\n// son-1固定宽度100px, son-2自适应\n```\n\n6.align-self 指定单个 flex-item 允许更改交叉轴的对齐方式, 即垂直方向.\n![align-self](6_align-self.jpg)\n\n#### 注意事项\n\n1.伪元素::first-line ::first-letter 在 flex-container 不起作用\n2.float clear vertical-align 在 flex-item 不起作用\n","source":"_posts/关于Flex布局的使用指南.md","raw":"---\ntitle: 关于Flex布局的使用指南\ndate: 2018-02-23 23:56:51\ntags: [CSS, 前端]\n---\n\n##### 写在前面\n\nflex 布局, 在移动端也是一大布局利器之一, 跟笔者复习一遍吧.\n\n#### 基本布局\n\n```css\n<div class='father'> // flex container\n  <div calss='son son-1'>1</div> // flex item\n  <div calss='son son-2'>2</div>\n</div>\n\n.father {\n  display: flex;\n}\n```\n\n#### flex container 属性\n\nflex 规定 flex container 的横向为主轴(main axis), 纵向为交叉轴(cross axis)\n1.flex-direction 指定 flex item 是如何布局的. 默认为 row, 即 flex item 从左至右横向排列\n\n```css\n.father {\n  ...;\n  flex-direction: row / row-reverse / column / column-reverse;\n                        (横向右至左) (纵向上至下) (纵向下至上)\n}\n```\n\n<!-- more -->\n\n2.flex-wrap 指定 flex-item 能否自动换行. 默认为 nowrap, 即子元素不换行排列\n\n```css\n.father {\n  ...;\n  flex-wrap: nowrap / wrap / wrap-reverse ;\n                  (多行显示) (多行显示,从下至上显示成多行)\n}\n```\n\n3.flex-flow 是 flex-direction 和 flex-wrap 的缩写\n\n```css\n.father {\n  ...;\n  flex-flow: row nowrap;\n}\n```\n\n4.jusitfy-content 指定 flex item 在主轴线上的对齐方式, 即水平方向. 默认为 flex-start, 子元素靠左对齐.\n\n```css\n.father {\n  ...;\n  justify-content: flex-start / flex-end / center / space-between / space-around;\n                                (靠右对齐)  (居中)\n  space-between: 等间距排列, firstChild和lastChild靠两侧边缘, 如图一\n  space-around: 等间距排列, firstChild和lastChild与两侧边缘也有间隔, 如图二\n}\n```\n\n图一 space-between![space-between](1_space-between.jpg)\n图二 space-around![space-around](1_space-around.jpg)\n\n5.align-items 指定 flex item 在交叉轴上的对齐方式, 即垂直方向. 默认为 stretch, 子元素如无定义高度, 将被拉伸以适应父容器(默认 flex-direction 为 row)\n\n```css\n.father {\n  ...;\n  align-items: stretch / center / flex-start / flex-end / baseline (垂直对齐) (在交叉轴起始对齐)\n    (于底对齐) (按照子元素里的文本基线对齐);\n}\n```\n\nflex-start![flex-start](2_flex-start.jpg)\nbaseline![baseline](2_baseline.jpg)\n\n6.align-content 指定交叉轴上多余空间 默认值为 stretch\n\n```css\n.father {\n  ...;\n  align-content: stretch / center / flex-start / flex-end / space-between / space-around\n  center: (居中对齐, 没有多余空间)\n  flex-start: (在交叉轴起始对齐,没有行行多余空间)\n  flex-end: (于底对齐,没有多余空间)\n  space-between: (各行之间留有空白)\n  space-around: (各行之前之间之后都留有空白)\n}\n```\n\nstretch![stretch](3_stretch.jpg)\nspace-around![space-around](3_space-around.jpg)\n\n#### flex item 属性\n\n1.order 指定排列顺序, 可正可负, 值越小排越前. 默认都是 0\n\n```css\n.son-2 {\n  order: -1 // 排在son-1前面;\n}\n```\n\n2.flex-grow 当父元素存在剩余空间时, 可以用来指定子元素的拉伸比例. 默认值为 0, 负值无效\n![flex-grow](4_flex-grow.jpg)\n3.flex-shrink 当父元素空间不足时, 可以用来指定子元素的收缩比例. 负值无效, 默认为 1, 即会收缩.\n如果设置为 0, 就不收缩将保持原来的大小.\n![flex-shrink](5_flex-shrink.jpg)\n4.flex-basis 为子元素分配初始大小, 默认值为 auto\n\n```css\n.son-2 {\n  ...,\n  flex-grow: 0;\n  flex-skrink: 0;\n  flex-basis: 400px; // 结合上两个属性, 该元素400px宽度不会变化.\n}\n```\n\n5.flex 是 flex-grow flex-skrink flex-basis 的缩写, 此属性比较常用\n\n```css\n.son-1 {\n  flex: 0 0 100px;\n}\n.son-2 {\n  flex: 1 1 auto;\n}\n// son-1固定宽度100px, son-2自适应\n```\n\n6.align-self 指定单个 flex-item 允许更改交叉轴的对齐方式, 即垂直方向.\n![align-self](6_align-self.jpg)\n\n#### 注意事项\n\n1.伪元素::first-line ::first-letter 在 flex-container 不起作用\n2.float clear vertical-align 在 flex-item 不起作用\n","slug":"关于Flex布局的使用指南","published":1,"updated":"2021-07-02T03:20:30.656Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl5sb8gf4000kxq0rhp7xemuk","content":"<h5 id=\"写在前面\"><a href=\"#写在前面\" class=\"headerlink\" title=\"写在前面\"></a>写在前面</h5><p>flex 布局, 在移动端也是一大布局利器之一, 跟笔者复习一遍吧.</p>\n<h4 id=\"基本布局\"><a href=\"#基本布局\" class=\"headerlink\" title=\"基本布局\"></a>基本布局</h4><figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;div class='father'&gt; // flex container</span><br><span class=\"line\">  &lt;div calss='son son-1'&gt;1&lt;/div&gt; // flex item</span><br><span class=\"line\">  &lt;div calss='son son-2'&gt;2&lt;/div&gt;</span><br><span class=\"line\">&lt;/div&gt;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"selector-class\">.father</span> &#123;</span><br><span class=\"line\">  <span class=\"attribute\">display</span>: flex;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"flex-container-属性\"><a href=\"#flex-container-属性\" class=\"headerlink\" title=\"flex container 属性\"></a>flex container 属性</h4><p>flex 规定 flex container 的横向为主轴(main axis), 纵向为交叉轴(cross axis)<br>1.flex-direction 指定 flex item 是如何布局的. 默认为 row, 即 flex item 从左至右横向排列</p>\n<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-class\">.father</span> &#123;</span><br><span class=\"line\">  ...;</span><br><span class=\"line\">  flex-direction: row / row-reverse / column / column-reverse;</span><br><span class=\"line\">                        (横向右至左) (纵向上至下) (纵向下至上)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<a id=\"more\"></a>\n\n<p>2.flex-wrap 指定 flex-item 能否自动换行. 默认为 nowrap, 即子元素不换行排列</p>\n<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-class\">.father</span> &#123;</span><br><span class=\"line\">  ...;</span><br><span class=\"line\">  flex-wrap: nowrap / wrap / wrap-reverse ;</span><br><span class=\"line\">                  (多行显示) (多行显示,从下至上显示成多行)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>3.flex-flow 是 flex-direction 和 flex-wrap 的缩写</p>\n<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-class\">.father</span> &#123;</span><br><span class=\"line\">  ...;</span><br><span class=\"line\">  <span class=\"selector-tag\">flex-flow</span>: <span class=\"selector-tag\">row</span> <span class=\"selector-tag\">nowrap</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>4.jusitfy-content 指定 flex item 在主轴线上的对齐方式, 即水平方向. 默认为 flex-start, 子元素靠左对齐.</p>\n<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-class\">.father</span> &#123;</span><br><span class=\"line\">  ...;</span><br><span class=\"line\">  justify-content: flex-start / flex-end / center / space-between / space-around;</span><br><span class=\"line\">                                (靠右对齐)  (居中)</span><br><span class=\"line\">  <span class=\"selector-tag\">space-between</span>: 等间距排列, <span class=\"selector-tag\">firstChild</span>和<span class=\"selector-tag\">lastChild</span>靠两侧边缘, 如图一</span><br><span class=\"line\">  <span class=\"selector-tag\">space-around</span>: 等间距排列, <span class=\"selector-tag\">firstChild</span>和<span class=\"selector-tag\">lastChild</span>与两侧边缘也有间隔, 如图二</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>图一 space-between<img src=\"//psilocine.github.io/2018/02/23/关于Flex布局的使用指南/1_space-between.jpg\" alt=\"space-between\"><br>图二 space-around<img src=\"//psilocine.github.io/2018/02/23/关于Flex布局的使用指南/1_space-around.jpg\" alt=\"space-around\"></p>\n<p>5.align-items 指定 flex item 在交叉轴上的对齐方式, 即垂直方向. 默认为 stretch, 子元素如无定义高度, 将被拉伸以适应父容器(默认 flex-direction 为 row)</p>\n<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-class\">.father</span> &#123;</span><br><span class=\"line\">  ...;</span><br><span class=\"line\">  align-items: stretch / center / flex-start / flex-end / baseline (垂直对齐) (在交叉轴起始对齐)</span><br><span class=\"line\">    (于底对齐) (按照子元素里的文本基线对齐);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>flex-start<img src=\"//psilocine.github.io/2018/02/23/关于Flex布局的使用指南/2_flex-start.jpg\" alt=\"flex-start\"><br>baseline<img src=\"//psilocine.github.io/2018/02/23/关于Flex布局的使用指南/2_baseline.jpg\" alt=\"baseline\"></p>\n<p>6.align-content 指定交叉轴上多余空间 默认值为 stretch</p>\n<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-class\">.father</span> &#123;</span><br><span class=\"line\">  ...;</span><br><span class=\"line\">  align-content: stretch / center / flex-start / flex-end / space-between / space-around</span><br><span class=\"line\">  <span class=\"selector-tag\">center</span>: (居中对齐, 没有多余空间)</span><br><span class=\"line\">  <span class=\"selector-tag\">flex-start</span>: (在交叉轴起始对齐,没有行行多余空间)</span><br><span class=\"line\">  <span class=\"selector-tag\">flex-end</span>: (于底对齐,没有多余空间)</span><br><span class=\"line\">  <span class=\"selector-tag\">space-between</span>: (各行之间留有空白)</span><br><span class=\"line\">  <span class=\"selector-tag\">space-around</span>: (各行之前之间之后都留有空白)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>stretch<img src=\"//psilocine.github.io/2018/02/23/关于Flex布局的使用指南/3_stretch.jpg\" alt=\"stretch\"><br>space-around<img src=\"//psilocine.github.io/2018/02/23/关于Flex布局的使用指南/3_space-around.jpg\" alt=\"space-around\"></p>\n<h4 id=\"flex-item-属性\"><a href=\"#flex-item-属性\" class=\"headerlink\" title=\"flex item 属性\"></a>flex item 属性</h4><p>1.order 指定排列顺序, 可正可负, 值越小排越前. 默认都是 0</p>\n<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-class\">.son-2</span> &#123;</span><br><span class=\"line\">  <span class=\"attribute\">order</span>: -<span class=\"number\">1</span> // 排在son-<span class=\"number\">1</span>前面;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>2.flex-grow 当父元素存在剩余空间时, 可以用来指定子元素的拉伸比例. 默认值为 0, 负值无效<br><img src=\"//psilocine.github.io/2018/02/23/关于Flex布局的使用指南/4_flex-grow.jpg\" alt=\"flex-grow\"><br>3.flex-shrink 当父元素空间不足时, 可以用来指定子元素的收缩比例. 负值无效, 默认为 1, 即会收缩.<br>如果设置为 0, 就不收缩将保持原来的大小.<br><img src=\"//psilocine.github.io/2018/02/23/关于Flex布局的使用指南/5_flex-shrink.jpg\" alt=\"flex-shrink\"><br>4.flex-basis 为子元素分配初始大小, 默认值为 auto</p>\n<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-class\">.son-2</span> &#123;</span><br><span class=\"line\">  ...,</span><br><span class=\"line\">  <span class=\"selector-tag\">flex-grow</span>: 0;</span><br><span class=\"line\">  <span class=\"selector-tag\">flex-skrink</span>: 0;</span><br><span class=\"line\">  flex-basis: 400px; // 结合上两个属性, 该元素400px宽度不会变化.</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>5.flex 是 flex-grow flex-skrink flex-basis 的缩写, 此属性比较常用</p>\n<figure class=\"highlight\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-class\">.son-1</span> &#123;</span><br><span class=\"line\">  <span class=\"attribute\">flex</span>: <span class=\"number\">0</span> <span class=\"number\">0</span> <span class=\"number\">100px</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"selector-class\">.son-2</span> &#123;</span><br><span class=\"line\">  <span class=\"attribute\">flex</span>: <span class=\"number\">1</span> <span class=\"number\">1</span> auto;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">// son-1固定宽度100px, son-2自适应</span><br></pre></td></tr></table></figure>\n\n<p>6.align-self 指定单个 flex-item 允许更改交叉轴的对齐方式, 即垂直方向.<br><img src=\"//psilocine.github.io/2018/02/23/关于Flex布局的使用指南/6_align-self.jpg\" alt=\"align-self\"></p>\n<h4 id=\"注意事项\"><a href=\"#注意事项\" class=\"headerlink\" title=\"注意事项\"></a>注意事项</h4><p>1.伪元素::first-line ::first-letter 在 flex-container 不起作用<br>2.float clear vertical-align 在 flex-item 不起作用</p>\n","site":{"data":{}},"excerpt":"<h5 id=\"写在前面\"><a href=\"#写在前面\" class=\"headerlink\" title=\"写在前面\"></a>写在前面</h5><p>flex 布局, 在移动端也是一大布局利器之一, 跟笔者复习一遍吧.</p>\n<h4 id=\"基本布局\"><a href=\"#基本布局\" class=\"headerlink\" title=\"基本布局\"></a>基本布局</h4><figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;div class='father'&gt; // flex container</span><br><span class=\"line\">  &lt;div calss='son son-1'&gt;1&lt;/div&gt; // flex item</span><br><span class=\"line\">  &lt;div calss='son son-2'&gt;2&lt;/div&gt;</span><br><span class=\"line\">&lt;/div&gt;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"selector-class\">.father</span> &#123;</span><br><span class=\"line\">  <span class=\"attribute\">display</span>: flex;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"flex-container-属性\"><a href=\"#flex-container-属性\" class=\"headerlink\" title=\"flex container 属性\"></a>flex container 属性</h4><p>flex 规定 flex container 的横向为主轴(main axis), 纵向为交叉轴(cross axis)<br>1.flex-direction 指定 flex item 是如何布局的. 默认为 row, 即 flex item 从左至右横向排列</p>\n<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-class\">.father</span> &#123;</span><br><span class=\"line\">  ...;</span><br><span class=\"line\">  flex-direction: row / row-reverse / column / column-reverse;</span><br><span class=\"line\">                        (横向右至左) (纵向上至下) (纵向下至上)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>","more":"<p>2.flex-wrap 指定 flex-item 能否自动换行. 默认为 nowrap, 即子元素不换行排列</p>\n<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-class\">.father</span> &#123;</span><br><span class=\"line\">  ...;</span><br><span class=\"line\">  flex-wrap: nowrap / wrap / wrap-reverse ;</span><br><span class=\"line\">                  (多行显示) (多行显示,从下至上显示成多行)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>3.flex-flow 是 flex-direction 和 flex-wrap 的缩写</p>\n<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-class\">.father</span> &#123;</span><br><span class=\"line\">  ...;</span><br><span class=\"line\">  <span class=\"selector-tag\">flex-flow</span>: <span class=\"selector-tag\">row</span> <span class=\"selector-tag\">nowrap</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>4.jusitfy-content 指定 flex item 在主轴线上的对齐方式, 即水平方向. 默认为 flex-start, 子元素靠左对齐.</p>\n<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-class\">.father</span> &#123;</span><br><span class=\"line\">  ...;</span><br><span class=\"line\">  justify-content: flex-start / flex-end / center / space-between / space-around;</span><br><span class=\"line\">                                (靠右对齐)  (居中)</span><br><span class=\"line\">  <span class=\"selector-tag\">space-between</span>: 等间距排列, <span class=\"selector-tag\">firstChild</span>和<span class=\"selector-tag\">lastChild</span>靠两侧边缘, 如图一</span><br><span class=\"line\">  <span class=\"selector-tag\">space-around</span>: 等间距排列, <span class=\"selector-tag\">firstChild</span>和<span class=\"selector-tag\">lastChild</span>与两侧边缘也有间隔, 如图二</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>图一 space-between<img src=\"//psilocine.github.io/2018/02/23/关于Flex布局的使用指南/1_space-between.jpg\" alt=\"space-between\"><br>图二 space-around<img src=\"//psilocine.github.io/2018/02/23/关于Flex布局的使用指南/1_space-around.jpg\" alt=\"space-around\"></p>\n<p>5.align-items 指定 flex item 在交叉轴上的对齐方式, 即垂直方向. 默认为 stretch, 子元素如无定义高度, 将被拉伸以适应父容器(默认 flex-direction 为 row)</p>\n<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-class\">.father</span> &#123;</span><br><span class=\"line\">  ...;</span><br><span class=\"line\">  align-items: stretch / center / flex-start / flex-end / baseline (垂直对齐) (在交叉轴起始对齐)</span><br><span class=\"line\">    (于底对齐) (按照子元素里的文本基线对齐);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>flex-start<img src=\"//psilocine.github.io/2018/02/23/关于Flex布局的使用指南/2_flex-start.jpg\" alt=\"flex-start\"><br>baseline<img src=\"//psilocine.github.io/2018/02/23/关于Flex布局的使用指南/2_baseline.jpg\" alt=\"baseline\"></p>\n<p>6.align-content 指定交叉轴上多余空间 默认值为 stretch</p>\n<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-class\">.father</span> &#123;</span><br><span class=\"line\">  ...;</span><br><span class=\"line\">  align-content: stretch / center / flex-start / flex-end / space-between / space-around</span><br><span class=\"line\">  <span class=\"selector-tag\">center</span>: (居中对齐, 没有多余空间)</span><br><span class=\"line\">  <span class=\"selector-tag\">flex-start</span>: (在交叉轴起始对齐,没有行行多余空间)</span><br><span class=\"line\">  <span class=\"selector-tag\">flex-end</span>: (于底对齐,没有多余空间)</span><br><span class=\"line\">  <span class=\"selector-tag\">space-between</span>: (各行之间留有空白)</span><br><span class=\"line\">  <span class=\"selector-tag\">space-around</span>: (各行之前之间之后都留有空白)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>stretch<img src=\"//psilocine.github.io/2018/02/23/关于Flex布局的使用指南/3_stretch.jpg\" alt=\"stretch\"><br>space-around<img src=\"//psilocine.github.io/2018/02/23/关于Flex布局的使用指南/3_space-around.jpg\" alt=\"space-around\"></p>\n<h4 id=\"flex-item-属性\"><a href=\"#flex-item-属性\" class=\"headerlink\" title=\"flex item 属性\"></a>flex item 属性</h4><p>1.order 指定排列顺序, 可正可负, 值越小排越前. 默认都是 0</p>\n<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-class\">.son-2</span> &#123;</span><br><span class=\"line\">  <span class=\"attribute\">order</span>: -<span class=\"number\">1</span> // 排在son-<span class=\"number\">1</span>前面;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>2.flex-grow 当父元素存在剩余空间时, 可以用来指定子元素的拉伸比例. 默认值为 0, 负值无效<br><img src=\"//psilocine.github.io/2018/02/23/关于Flex布局的使用指南/4_flex-grow.jpg\" alt=\"flex-grow\"><br>3.flex-shrink 当父元素空间不足时, 可以用来指定子元素的收缩比例. 负值无效, 默认为 1, 即会收缩.<br>如果设置为 0, 就不收缩将保持原来的大小.<br><img src=\"//psilocine.github.io/2018/02/23/关于Flex布局的使用指南/5_flex-shrink.jpg\" alt=\"flex-shrink\"><br>4.flex-basis 为子元素分配初始大小, 默认值为 auto</p>\n<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-class\">.son-2</span> &#123;</span><br><span class=\"line\">  ...,</span><br><span class=\"line\">  <span class=\"selector-tag\">flex-grow</span>: 0;</span><br><span class=\"line\">  <span class=\"selector-tag\">flex-skrink</span>: 0;</span><br><span class=\"line\">  flex-basis: 400px; // 结合上两个属性, 该元素400px宽度不会变化.</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>5.flex 是 flex-grow flex-skrink flex-basis 的缩写, 此属性比较常用</p>\n<figure class=\"highlight\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-class\">.son-1</span> &#123;</span><br><span class=\"line\">  <span class=\"attribute\">flex</span>: <span class=\"number\">0</span> <span class=\"number\">0</span> <span class=\"number\">100px</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"selector-class\">.son-2</span> &#123;</span><br><span class=\"line\">  <span class=\"attribute\">flex</span>: <span class=\"number\">1</span> <span class=\"number\">1</span> auto;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">// son-1固定宽度100px, son-2自适应</span><br></pre></td></tr></table></figure>\n\n<p>6.align-self 指定单个 flex-item 允许更改交叉轴的对齐方式, 即垂直方向.<br><img src=\"//psilocine.github.io/2018/02/23/关于Flex布局的使用指南/6_align-self.jpg\" alt=\"align-self\"></p>\n<h4 id=\"注意事项\"><a href=\"#注意事项\" class=\"headerlink\" title=\"注意事项\"></a>注意事项</h4><p>1.伪元素::first-line ::first-letter 在 flex-container 不起作用<br>2.float clear vertical-align 在 flex-item 不起作用</p>"},{"title":"关于Grid布局的使用指南","date":"2017-12-16T15:17:19.000Z","_content":"##### 写在前面\n之前讨论过footer置底的几种方法, 里面谈及到能通过Grid布局实现. 而最近各大浏览器又频频宣布对Grid的支持, 可想而知Grid会是继Flex的强大后起之秀.\n正好笔者也对Grid了解甚少, 正好来个粗略掌握.\n\n#### 术语\n下面例子属性看不懂不要急, 我会慢慢解释\n```html\n/* 第一个例子 */\n.container {\n  display: grid;\n  grid-template-rows: 100px 100px 100px;\n  grid-template-columns: 150px 150px 150px;\n  text-align: center;  \n  font-size: 40px;\n}\n.item {\n  border: 1px solid #000;\n  display: inline-grid;\n  align-items: center;\n}\n\n<div class=\"container\">\n  <div class=\"item item-1\">1</div>\n  <div class=\"item item-2\">2</div>\n  <div class=\"item item-3\">3</div>\n  <div class=\"item item-4\">4</div>\n  <div class=\"item item-5\">5</div>\n  <div class=\"item item-6\">\n    <span class=\"sub-item\">6</span>\n  </div>\n</div>\n```\n<!-- more -->\n* <font size=4>网格容器(Grid Container)</font>\n应用 display: grid布局 的元素就是网格容器, 上述div.container为网格容器\n\n![A Grid Item](origin.jpg)\n* <font size=4>网格项(Grid Item)</font>\n网格容器的第一级子元素, 上述的div.item都是, span.sub-item则不是, 其实很好理解, 如果Grid布局影响所有子元素, 那布局就乱了套.\n\n* <font size=4>网格线(Grid Line)</font>\n细心的同学在上面的图片已经看出, Grid布局就是通过纵横线来定位, 即图中虚线. div.container属性有grid-template来初始网格线的数量. 而grid-template模板的意思, 上述规定有三行/row, 每行高100px; 三列/column, 每列宽150px, 四横线四纵线一共绘制成九格, 网格项按顺序排列. 横纵线起始为1.  \n值得注意的是, 图中虚线是查看dom就能看到的, 而且如果所设grid-template少于网格项的话, 如两行两列, 结果会遵循列数, 宽度不变, 高度只能靠内容撑起了.\n\n* <font size=4>网格单元格(Grid Cell)</font>\n相邻横网格线和相邻列网格线围成的区域就是网格单元格, 上诉指出的div.item-6就是网格单元格.\n\n![A Grid Area](grid-area.jpg)\n* <font size=4>网格区域(Grid Area)</font>\n那不相邻的网格横纵线组成的区域, 就是网格区域, 如图4 5 6彩色区域, 即为行网格线2到3, 列网格线1到4所划区域.\n\n#### 属性\n* <font size=4>grid-template</font>\n用来定义网格的列和行, 可以是像素值, 百分比, fr(等份网格容器中可用空间, eg: grid-template-rows: 1fr 1fr; 会二等分). 也可以auto留出自适应长度.\n```css\n.container{\n    grid-template-columns: 40px auto 50px;\n    grid-template-rows: 25% auto 100px;\n}\n```\n![Grid Template: auto](grid-template_auto.jpg)\n同时支持缩写, grid-template: <rows> / <columns> 上面两行代码可写成 grid-template: 25% auto 100px / 40px auto 50px\n\n* <font size=4>grid-template-areas</font>\n网格项通过 grid-area 属性来定义名字模板, 这时候就能在grid-template-areas里来引用名字模板.\n```html\n/* 在第一个例子基础上 */\n.container {\n  grid-template-areas: \n    \"header header header\"\n    \". main .\"\n    \"footer footer footer\";\n}\n.item-1 {\n  grid-area: header;\n  background: red;\n}\n.item-2 {\n  grid-area: footer;\n  background: green;\n}\n.item-3 {\n  grid-area: main;\n  background: orange;\n}\n```\n![Grid Template Areas](grid-template-areas.jpg)\n可以看出, \".\"代表空的网格单元格, 三个grid-area布完局后, 多余的网络项也按顺序布局, 所以才有div.item-4, div.item-5填充在\".\"里, 同时也能看出多余的网络项高度只能由内容撑起. grid-template-areas属性的出现, 结合grid-template-rows/columns能很方便实现aside/main等复杂布局.\n\n* <font size=4>grid-gap</font>\n用来制定Grid Cell单元格的间距, grid-gap: (grid-row-gap:行与行之间间隙) (grid-column-gap:列与列间隙), 以上是缩写形式, 也可以单独定义.\n```html\n/* 在第一个例子基础上 */\n.container {\n  grid-row-gap: 20px;\n  grid-column-gap: 10px;\n}\n```\n![Grid Gap](grid-gap.jpg)\n如上图可见Grid Cell被隔开了指定距离.\n\n\n","source":"_posts/关于Grid布局的使用指南.md","raw":"---\ntitle: 关于Grid布局的使用指南\ndate: 2017-12-16 23:17:19\ntags: [CSS,前端]\n---\n##### 写在前面\n之前讨论过footer置底的几种方法, 里面谈及到能通过Grid布局实现. 而最近各大浏览器又频频宣布对Grid的支持, 可想而知Grid会是继Flex的强大后起之秀.\n正好笔者也对Grid了解甚少, 正好来个粗略掌握.\n\n#### 术语\n下面例子属性看不懂不要急, 我会慢慢解释\n```html\n/* 第一个例子 */\n.container {\n  display: grid;\n  grid-template-rows: 100px 100px 100px;\n  grid-template-columns: 150px 150px 150px;\n  text-align: center;  \n  font-size: 40px;\n}\n.item {\n  border: 1px solid #000;\n  display: inline-grid;\n  align-items: center;\n}\n\n<div class=\"container\">\n  <div class=\"item item-1\">1</div>\n  <div class=\"item item-2\">2</div>\n  <div class=\"item item-3\">3</div>\n  <div class=\"item item-4\">4</div>\n  <div class=\"item item-5\">5</div>\n  <div class=\"item item-6\">\n    <span class=\"sub-item\">6</span>\n  </div>\n</div>\n```\n<!-- more -->\n* <font size=4>网格容器(Grid Container)</font>\n应用 display: grid布局 的元素就是网格容器, 上述div.container为网格容器\n\n![A Grid Item](origin.jpg)\n* <font size=4>网格项(Grid Item)</font>\n网格容器的第一级子元素, 上述的div.item都是, span.sub-item则不是, 其实很好理解, 如果Grid布局影响所有子元素, 那布局就乱了套.\n\n* <font size=4>网格线(Grid Line)</font>\n细心的同学在上面的图片已经看出, Grid布局就是通过纵横线来定位, 即图中虚线. div.container属性有grid-template来初始网格线的数量. 而grid-template模板的意思, 上述规定有三行/row, 每行高100px; 三列/column, 每列宽150px, 四横线四纵线一共绘制成九格, 网格项按顺序排列. 横纵线起始为1.  \n值得注意的是, 图中虚线是查看dom就能看到的, 而且如果所设grid-template少于网格项的话, 如两行两列, 结果会遵循列数, 宽度不变, 高度只能靠内容撑起了.\n\n* <font size=4>网格单元格(Grid Cell)</font>\n相邻横网格线和相邻列网格线围成的区域就是网格单元格, 上诉指出的div.item-6就是网格单元格.\n\n![A Grid Area](grid-area.jpg)\n* <font size=4>网格区域(Grid Area)</font>\n那不相邻的网格横纵线组成的区域, 就是网格区域, 如图4 5 6彩色区域, 即为行网格线2到3, 列网格线1到4所划区域.\n\n#### 属性\n* <font size=4>grid-template</font>\n用来定义网格的列和行, 可以是像素值, 百分比, fr(等份网格容器中可用空间, eg: grid-template-rows: 1fr 1fr; 会二等分). 也可以auto留出自适应长度.\n```css\n.container{\n    grid-template-columns: 40px auto 50px;\n    grid-template-rows: 25% auto 100px;\n}\n```\n![Grid Template: auto](grid-template_auto.jpg)\n同时支持缩写, grid-template: <rows> / <columns> 上面两行代码可写成 grid-template: 25% auto 100px / 40px auto 50px\n\n* <font size=4>grid-template-areas</font>\n网格项通过 grid-area 属性来定义名字模板, 这时候就能在grid-template-areas里来引用名字模板.\n```html\n/* 在第一个例子基础上 */\n.container {\n  grid-template-areas: \n    \"header header header\"\n    \". main .\"\n    \"footer footer footer\";\n}\n.item-1 {\n  grid-area: header;\n  background: red;\n}\n.item-2 {\n  grid-area: footer;\n  background: green;\n}\n.item-3 {\n  grid-area: main;\n  background: orange;\n}\n```\n![Grid Template Areas](grid-template-areas.jpg)\n可以看出, \".\"代表空的网格单元格, 三个grid-area布完局后, 多余的网络项也按顺序布局, 所以才有div.item-4, div.item-5填充在\".\"里, 同时也能看出多余的网络项高度只能由内容撑起. grid-template-areas属性的出现, 结合grid-template-rows/columns能很方便实现aside/main等复杂布局.\n\n* <font size=4>grid-gap</font>\n用来制定Grid Cell单元格的间距, grid-gap: (grid-row-gap:行与行之间间隙) (grid-column-gap:列与列间隙), 以上是缩写形式, 也可以单独定义.\n```html\n/* 在第一个例子基础上 */\n.container {\n  grid-row-gap: 20px;\n  grid-column-gap: 10px;\n}\n```\n![Grid Gap](grid-gap.jpg)\n如上图可见Grid Cell被隔开了指定距离.\n\n\n","slug":"关于Grid布局的使用指南","published":1,"updated":"2021-07-02T03:20:30.658Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl5sb8gf4000mxq0ru1vwu3b6","content":"<h5 id=\"写在前面\"><a href=\"#写在前面\" class=\"headerlink\" title=\"写在前面\"></a>写在前面</h5><p>之前讨论过footer置底的几种方法, 里面谈及到能通过Grid布局实现. 而最近各大浏览器又频频宣布对Grid的支持, 可想而知Grid会是继Flex的强大后起之秀.<br>正好笔者也对Grid了解甚少, 正好来个粗略掌握.</p>\n<h4 id=\"术语\"><a href=\"#术语\" class=\"headerlink\" title=\"术语\"></a>术语</h4><p>下面例子属性看不懂不要急, 我会慢慢解释</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">/* 第一个例子 */</span><br><span class=\"line\">.container &#123;</span><br><span class=\"line\">  display: grid;</span><br><span class=\"line\">  grid-template-rows: 100px 100px 100px;</span><br><span class=\"line\">  grid-template-columns: 150px 150px 150px;</span><br><span class=\"line\">  text-align: center;  </span><br><span class=\"line\">  font-size: 40px;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">.item &#123;</span><br><span class=\"line\">  border: 1px solid #000;</span><br><span class=\"line\">  display: inline-grid;</span><br><span class=\"line\">  align-items: center;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">class</span>=<span class=\"string\">\"container\"</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">class</span>=<span class=\"string\">\"item item-1\"</span>&gt;</span>1<span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">class</span>=<span class=\"string\">\"item item-2\"</span>&gt;</span>2<span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">class</span>=<span class=\"string\">\"item item-3\"</span>&gt;</span>3<span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">class</span>=<span class=\"string\">\"item item-4\"</span>&gt;</span>4<span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">class</span>=<span class=\"string\">\"item item-5\"</span>&gt;</span>5<span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">class</span>=<span class=\"string\">\"item item-6\"</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">span</span> <span class=\"attr\">class</span>=<span class=\"string\">\"sub-item\"</span>&gt;</span>6<span class=\"tag\">&lt;/<span class=\"name\">span</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n<a id=\"more\"></a>\n<ul>\n<li><font size=\"4\">网格容器(Grid Container)</font><br>应用 display: grid布局 的元素就是网格容器, 上述div.container为网格容器</li>\n</ul>\n<p><img src=\"//psilocine.github.io/2017/12/16/关于Grid布局的使用指南/origin.jpg\" alt=\"A Grid Item\"></p>\n<ul>\n<li><p><font size=\"4\">网格项(Grid Item)</font><br>网格容器的第一级子元素, 上述的div.item都是, span.sub-item则不是, 其实很好理解, 如果Grid布局影响所有子元素, 那布局就乱了套.</p>\n</li>\n<li><p><font size=\"4\">网格线(Grid Line)</font><br>细心的同学在上面的图片已经看出, Grid布局就是通过纵横线来定位, 即图中虚线. div.container属性有grid-template来初始网格线的数量. 而grid-template模板的意思, 上述规定有三行/row, 每行高100px; 三列/column, 每列宽150px, 四横线四纵线一共绘制成九格, 网格项按顺序排列. 横纵线起始为1.<br>值得注意的是, 图中虚线是查看dom就能看到的, 而且如果所设grid-template少于网格项的话, 如两行两列, 结果会遵循列数, 宽度不变, 高度只能靠内容撑起了.</p>\n</li>\n<li><p><font size=\"4\">网格单元格(Grid Cell)</font><br>相邻横网格线和相邻列网格线围成的区域就是网格单元格, 上诉指出的div.item-6就是网格单元格.</p>\n</li>\n</ul>\n<p><img src=\"//psilocine.github.io/2017/12/16/关于Grid布局的使用指南/grid-area.jpg\" alt=\"A Grid Area\"></p>\n<ul>\n<li><font size=\"4\">网格区域(Grid Area)</font><br>那不相邻的网格横纵线组成的区域, 就是网格区域, 如图4 5 6彩色区域, 即为行网格线2到3, 列网格线1到4所划区域.</li>\n</ul>\n<h4 id=\"属性\"><a href=\"#属性\" class=\"headerlink\" title=\"属性\"></a>属性</h4><ul>\n<li><font size=\"4\">grid-template</font><br>用来定义网格的列和行, 可以是像素值, 百分比, fr(等份网格容器中可用空间, eg: grid-template-rows: 1fr 1fr; 会二等分). 也可以auto留出自适应长度.<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-class\">.container</span>&#123;</span><br><span class=\"line\">    <span class=\"attribute\">grid-template-columns</span>: <span class=\"number\">40px</span> auto <span class=\"number\">50px</span>;</span><br><span class=\"line\">    <span class=\"attribute\">grid-template-rows</span>: <span class=\"number\">25%</span> auto <span class=\"number\">100px</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n</li>\n</ul>\n<p><img src=\"//psilocine.github.io/2017/12/16/关于Grid布局的使用指南/grid-template_auto.jpg\" alt=\"Grid Template: auto\"><br>同时支持缩写, grid-template: <rows> / <columns> 上面两行代码可写成 grid-template: 25% auto 100px / 40px auto 50px</columns></rows></p>\n<ul>\n<li><font size=\"4\">grid-template-areas</font><br>网格项通过 grid-area 属性来定义名字模板, 这时候就能在grid-template-areas里来引用名字模板.<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">/* 在第一个例子基础上 */</span><br><span class=\"line\">.container &#123;</span><br><span class=\"line\">  grid-template-areas: </span><br><span class=\"line\">    \"header header header\"</span><br><span class=\"line\">    \". main .\"</span><br><span class=\"line\">    \"footer footer footer\";</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">.item-1 &#123;</span><br><span class=\"line\">  grid-area: header;</span><br><span class=\"line\">  background: red;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">.item-2 &#123;</span><br><span class=\"line\">  grid-area: footer;</span><br><span class=\"line\">  background: green;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">.item-3 &#123;</span><br><span class=\"line\">  grid-area: main;</span><br><span class=\"line\">  background: orange;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n</li>\n</ul>\n<p><img src=\"//psilocine.github.io/2017/12/16/关于Grid布局的使用指南/grid-template-areas.jpg\" alt=\"Grid Template Areas\"><br>可以看出, “.”代表空的网格单元格, 三个grid-area布完局后, 多余的网络项也按顺序布局, 所以才有div.item-4, div.item-5填充在”.”里, 同时也能看出多余的网络项高度只能由内容撑起. grid-template-areas属性的出现, 结合grid-template-rows/columns能很方便实现aside/main等复杂布局.</p>\n<ul>\n<li><font size=\"4\">grid-gap</font><br>用来制定Grid Cell单元格的间距, grid-gap: (grid-row-gap:行与行之间间隙) (grid-column-gap:列与列间隙), 以上是缩写形式, 也可以单独定义.<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">/* 在第一个例子基础上 */</span><br><span class=\"line\">.container &#123;</span><br><span class=\"line\">  grid-row-gap: 20px;</span><br><span class=\"line\">  grid-column-gap: 10px;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n</li>\n</ul>\n<p><img src=\"//psilocine.github.io/2017/12/16/关于Grid布局的使用指南/grid-gap.jpg\" alt=\"Grid Gap\"><br>如上图可见Grid Cell被隔开了指定距离.</p>\n","site":{"data":{}},"excerpt":"<h5 id=\"写在前面\"><a href=\"#写在前面\" class=\"headerlink\" title=\"写在前面\"></a>写在前面</h5><p>之前讨论过footer置底的几种方法, 里面谈及到能通过Grid布局实现. 而最近各大浏览器又频频宣布对Grid的支持, 可想而知Grid会是继Flex的强大后起之秀.<br>正好笔者也对Grid了解甚少, 正好来个粗略掌握.</p>\n<h4 id=\"术语\"><a href=\"#术语\" class=\"headerlink\" title=\"术语\"></a>术语</h4><p>下面例子属性看不懂不要急, 我会慢慢解释</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">/* 第一个例子 */</span><br><span class=\"line\">.container &#123;</span><br><span class=\"line\">  display: grid;</span><br><span class=\"line\">  grid-template-rows: 100px 100px 100px;</span><br><span class=\"line\">  grid-template-columns: 150px 150px 150px;</span><br><span class=\"line\">  text-align: center;  </span><br><span class=\"line\">  font-size: 40px;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">.item &#123;</span><br><span class=\"line\">  border: 1px solid #000;</span><br><span class=\"line\">  display: inline-grid;</span><br><span class=\"line\">  align-items: center;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">class</span>=<span class=\"string\">\"container\"</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">class</span>=<span class=\"string\">\"item item-1\"</span>&gt;</span>1<span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">class</span>=<span class=\"string\">\"item item-2\"</span>&gt;</span>2<span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">class</span>=<span class=\"string\">\"item item-3\"</span>&gt;</span>3<span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">class</span>=<span class=\"string\">\"item item-4\"</span>&gt;</span>4<span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">class</span>=<span class=\"string\">\"item item-5\"</span>&gt;</span>5<span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">class</span>=<span class=\"string\">\"item item-6\"</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">span</span> <span class=\"attr\">class</span>=<span class=\"string\">\"sub-item\"</span>&gt;</span>6<span class=\"tag\">&lt;/<span class=\"name\">span</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br></pre></td></tr></table></figure>","more":"<ul>\n<li><font size=\"4\">网格容器(Grid Container)</font><br>应用 display: grid布局 的元素就是网格容器, 上述div.container为网格容器</li>\n</ul>\n<p><img src=\"//psilocine.github.io/2017/12/16/关于Grid布局的使用指南/origin.jpg\" alt=\"A Grid Item\"></p>\n<ul>\n<li><p><font size=\"4\">网格项(Grid Item)</font><br>网格容器的第一级子元素, 上述的div.item都是, span.sub-item则不是, 其实很好理解, 如果Grid布局影响所有子元素, 那布局就乱了套.</p>\n</li>\n<li><p><font size=\"4\">网格线(Grid Line)</font><br>细心的同学在上面的图片已经看出, Grid布局就是通过纵横线来定位, 即图中虚线. div.container属性有grid-template来初始网格线的数量. 而grid-template模板的意思, 上述规定有三行/row, 每行高100px; 三列/column, 每列宽150px, 四横线四纵线一共绘制成九格, 网格项按顺序排列. 横纵线起始为1.<br>值得注意的是, 图中虚线是查看dom就能看到的, 而且如果所设grid-template少于网格项的话, 如两行两列, 结果会遵循列数, 宽度不变, 高度只能靠内容撑起了.</p>\n</li>\n<li><p><font size=\"4\">网格单元格(Grid Cell)</font><br>相邻横网格线和相邻列网格线围成的区域就是网格单元格, 上诉指出的div.item-6就是网格单元格.</p>\n</li>\n</ul>\n<p><img src=\"//psilocine.github.io/2017/12/16/关于Grid布局的使用指南/grid-area.jpg\" alt=\"A Grid Area\"></p>\n<ul>\n<li><font size=\"4\">网格区域(Grid Area)</font><br>那不相邻的网格横纵线组成的区域, 就是网格区域, 如图4 5 6彩色区域, 即为行网格线2到3, 列网格线1到4所划区域.</li>\n</ul>\n<h4 id=\"属性\"><a href=\"#属性\" class=\"headerlink\" title=\"属性\"></a>属性</h4><ul>\n<li><font size=\"4\">grid-template</font><br>用来定义网格的列和行, 可以是像素值, 百分比, fr(等份网格容器中可用空间, eg: grid-template-rows: 1fr 1fr; 会二等分). 也可以auto留出自适应长度.<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-class\">.container</span>&#123;</span><br><span class=\"line\">    <span class=\"attribute\">grid-template-columns</span>: <span class=\"number\">40px</span> auto <span class=\"number\">50px</span>;</span><br><span class=\"line\">    <span class=\"attribute\">grid-template-rows</span>: <span class=\"number\">25%</span> auto <span class=\"number\">100px</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n</li>\n</ul>\n<p><img src=\"//psilocine.github.io/2017/12/16/关于Grid布局的使用指南/grid-template_auto.jpg\" alt=\"Grid Template: auto\"><br>同时支持缩写, grid-template: <rows> / <columns> 上面两行代码可写成 grid-template: 25% auto 100px / 40px auto 50px</columns></rows></p>\n<ul>\n<li><font size=\"4\">grid-template-areas</font><br>网格项通过 grid-area 属性来定义名字模板, 这时候就能在grid-template-areas里来引用名字模板.<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">/* 在第一个例子基础上 */</span><br><span class=\"line\">.container &#123;</span><br><span class=\"line\">  grid-template-areas: </span><br><span class=\"line\">    \"header header header\"</span><br><span class=\"line\">    \". main .\"</span><br><span class=\"line\">    \"footer footer footer\";</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">.item-1 &#123;</span><br><span class=\"line\">  grid-area: header;</span><br><span class=\"line\">  background: red;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">.item-2 &#123;</span><br><span class=\"line\">  grid-area: footer;</span><br><span class=\"line\">  background: green;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">.item-3 &#123;</span><br><span class=\"line\">  grid-area: main;</span><br><span class=\"line\">  background: orange;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n</li>\n</ul>\n<p><img src=\"//psilocine.github.io/2017/12/16/关于Grid布局的使用指南/grid-template-areas.jpg\" alt=\"Grid Template Areas\"><br>可以看出, “.”代表空的网格单元格, 三个grid-area布完局后, 多余的网络项也按顺序布局, 所以才有div.item-4, div.item-5填充在”.”里, 同时也能看出多余的网络项高度只能由内容撑起. grid-template-areas属性的出现, 结合grid-template-rows/columns能很方便实现aside/main等复杂布局.</p>\n<ul>\n<li><font size=\"4\">grid-gap</font><br>用来制定Grid Cell单元格的间距, grid-gap: (grid-row-gap:行与行之间间隙) (grid-column-gap:列与列间隙), 以上是缩写形式, 也可以单独定义.<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">/* 在第一个例子基础上 */</span><br><span class=\"line\">.container &#123;</span><br><span class=\"line\">  grid-row-gap: 20px;</span><br><span class=\"line\">  grid-column-gap: 10px;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n</li>\n</ul>\n<p><img src=\"//psilocine.github.io/2017/12/16/关于Grid布局的使用指南/grid-gap.jpg\" alt=\"Grid Gap\"><br>如上图可见Grid Cell被隔开了指定距离.</p>"},{"title":"写给自己的Markdown基本语法","date":"2020-05-28T01:22:03.000Z","_content":"\n##### 写在前面\n\n最近在用 Markdown 写文档，才发现自己没有系统地学习过 Markdown 语法，想用到某些语法还需要查阅，效率不高的同时还容易忘。故作此文，供自己巩固和学习\n\n### 简介\n\nMarkdown 是一种轻量级标记语言。特点是易读易写、专注内容、能被使用来编写电子书，目前很多社区都支持该语言作为编辑工具，利于无缝分发。如：Github、reddit\n\n<!-- more -->\n\n### 基本语法\n\n#### 标题\n\n###### 两种写法\n\n1、用 `#` 标记，`#` 对应一级标题、`######` 对应六级标题，一级标题字号最大，逐级递减\n\n```\n# I am a title\n\n## I am a subtitle\n\n###### 两种写法\n```\n\n2、用 `=` 或 `-` 在下一行标记一级标题或二级标题，符号的数量需要控制在两个以上\n\n```\nI am a title\n==\nI am a subtitle\n----\n```\n\n#### 段落换行\n\n两种  \n写法\n1、在需要换行的位置使用两个以上的 `空格` 并且回车\n\n```\n两种  (此处有两个空格)\n写法\n```\n\n2、使用空一行，值得注意的是，空多行也会被解析成一行\n\n```\n两种\n\n写法\n```\n\n#### 字体格式\n\n_两种写法_\n\n```\n*斜体文本*\n_斜体文本_\n\n**粗体文本**\n__粗体文本__\n\n***粗斜体文本***\n___粗斜体文本___\n```\n\n#### 删除线 分割线 下划线\n\n在~~特定文本~~两边分别填充两个 `~` 符号\n\n---\n\n在<u>特定文本</u>两边分别填充 `<u>` 标签\n\n---\n\n```\n在~~特定文本~~两边分别填充两个~符号（不允许有空格\n- - - （或者 * * *、***）\n在<u>特定文本</u>两边分别填充u标签\n***\n```\n\n#### 列表\n\n无序列表有三种写法（`*`、`+`、`-`）\n有序列表使用数字并加上 `.`，值得注意的是，有序列表的升序并不会受数字影响\n\n- 第一项\n- 第二项\n\n1. 第一项\n2. 第二项（显示 2. 并不受 55.影响\n\n- 嵌套列表\n  1. 第一项\n  2. 第二项\n\n```\n* 第一项\n* 第二项\n\n+ 第一项\n+ 第二项\n\n- 第一项\n- 第二项\n\n1. 第一项\n55. 第二项 （显示2. 并不受55.影响\n\n- 嵌套列表\n  1. 第一项\n  2. 第二项\n```\n\n#### 区块引用\n\n> 开头使用`>`符号\n>\n> 1. 第一项（区块中使用列表\n> 2. 第二项\n\n1. 列表中使用区块\n   > 区块\n2. 第二项\n\n```\n> 开头使用`>`符号\n> 1. 第一项\n> 2. 第二项\n\n1. 列表中使用区块\n    > 区块\n2. 第二项\n```\n\n#### 代码\n\n一行以内的代码片段直接使用反引号 \\`，如`code frag`\n多行的代码区块，两种写法\n\n    使用4个空格或者制表符（Tab）\n\n````\n你也可以使用```包裹一段代码，并指定一种语言，或不指定\n````\n\n#### 链接\n\n三种[写法](https://https://psilocine.github.io/)，按格式 `[链接名称](链接地址)` 或者 `<链接地址>`，还可以定义变量来设置[链接][link]\n[link]: https://https://psilocine.github.io/\n\n```\n三种[写法](https://https://psilocine.github.io/)\n\n[链接][link]\n[link]: https://https://psilocine.github.io/\n```\n\n#### 图片\n\n两种写法，按格式 `![alt 属性](图片地址)`，或者像链接地址一样通过定义变量图片链接  \n![图片失效的文本](error link)  \n![](https://avatars1.githubusercontent.com/u/25545052?s=400&u=03b9cfdb679e21c495d04b94ad99445c7336f887&v=4)\n\n```\n![图片失效的文本](error link)\n![](https://avatars1.githubusercontent.com/u/25545052?s=400&u=03b9cfdb679e21c495d04b94ad99445c7336f887&v=4)\n```\n\n#### 表格\n\n制作表格使用 `|` 来分隔不同的单元格，使用 `-` 来分隔表头和其他行。在分割表头位置可以设置表格的对齐方式：\n\n- `-:` 设置内容和标题栏居右对齐（默认值\n- `:-` 设置内容和标题栏居左对齐\n- `:-:` 设置内容和标题栏居中对齐\n\n| 左对齐 | 右对齐 | 居中对齐 |\n| :----- | -----: | :------: |\n| 单元格 | 单元格 |  单元格  |\n| 单元格 | 单元格 |  单元格  |\n\n```\n| 左对齐  | 右对齐 | 居中对齐 |\n| :-----| ----: | :----: |\n| 单元格 | 单元格 | 单元格 |\n| 单元格 | 单元格 | 单元格 |\n```\n","source":"_posts/写给自己的Markdown基本语法.md","raw":"---\ntitle: 写给自己的Markdown基本语法\ndate: 2020-05-28 09:22:03\ntags: 随笔\n---\n\n##### 写在前面\n\n最近在用 Markdown 写文档，才发现自己没有系统地学习过 Markdown 语法，想用到某些语法还需要查阅，效率不高的同时还容易忘。故作此文，供自己巩固和学习\n\n### 简介\n\nMarkdown 是一种轻量级标记语言。特点是易读易写、专注内容、能被使用来编写电子书，目前很多社区都支持该语言作为编辑工具，利于无缝分发。如：Github、reddit\n\n<!-- more -->\n\n### 基本语法\n\n#### 标题\n\n###### 两种写法\n\n1、用 `#` 标记，`#` 对应一级标题、`######` 对应六级标题，一级标题字号最大，逐级递减\n\n```\n# I am a title\n\n## I am a subtitle\n\n###### 两种写法\n```\n\n2、用 `=` 或 `-` 在下一行标记一级标题或二级标题，符号的数量需要控制在两个以上\n\n```\nI am a title\n==\nI am a subtitle\n----\n```\n\n#### 段落换行\n\n两种  \n写法\n1、在需要换行的位置使用两个以上的 `空格` 并且回车\n\n```\n两种  (此处有两个空格)\n写法\n```\n\n2、使用空一行，值得注意的是，空多行也会被解析成一行\n\n```\n两种\n\n写法\n```\n\n#### 字体格式\n\n_两种写法_\n\n```\n*斜体文本*\n_斜体文本_\n\n**粗体文本**\n__粗体文本__\n\n***粗斜体文本***\n___粗斜体文本___\n```\n\n#### 删除线 分割线 下划线\n\n在~~特定文本~~两边分别填充两个 `~` 符号\n\n---\n\n在<u>特定文本</u>两边分别填充 `<u>` 标签\n\n---\n\n```\n在~~特定文本~~两边分别填充两个~符号（不允许有空格\n- - - （或者 * * *、***）\n在<u>特定文本</u>两边分别填充u标签\n***\n```\n\n#### 列表\n\n无序列表有三种写法（`*`、`+`、`-`）\n有序列表使用数字并加上 `.`，值得注意的是，有序列表的升序并不会受数字影响\n\n- 第一项\n- 第二项\n\n1. 第一项\n2. 第二项（显示 2. 并不受 55.影响\n\n- 嵌套列表\n  1. 第一项\n  2. 第二项\n\n```\n* 第一项\n* 第二项\n\n+ 第一项\n+ 第二项\n\n- 第一项\n- 第二项\n\n1. 第一项\n55. 第二项 （显示2. 并不受55.影响\n\n- 嵌套列表\n  1. 第一项\n  2. 第二项\n```\n\n#### 区块引用\n\n> 开头使用`>`符号\n>\n> 1. 第一项（区块中使用列表\n> 2. 第二项\n\n1. 列表中使用区块\n   > 区块\n2. 第二项\n\n```\n> 开头使用`>`符号\n> 1. 第一项\n> 2. 第二项\n\n1. 列表中使用区块\n    > 区块\n2. 第二项\n```\n\n#### 代码\n\n一行以内的代码片段直接使用反引号 \\`，如`code frag`\n多行的代码区块，两种写法\n\n    使用4个空格或者制表符（Tab）\n\n````\n你也可以使用```包裹一段代码，并指定一种语言，或不指定\n````\n\n#### 链接\n\n三种[写法](https://https://psilocine.github.io/)，按格式 `[链接名称](链接地址)` 或者 `<链接地址>`，还可以定义变量来设置[链接][link]\n[link]: https://https://psilocine.github.io/\n\n```\n三种[写法](https://https://psilocine.github.io/)\n\n[链接][link]\n[link]: https://https://psilocine.github.io/\n```\n\n#### 图片\n\n两种写法，按格式 `![alt 属性](图片地址)`，或者像链接地址一样通过定义变量图片链接  \n![图片失效的文本](error link)  \n![](https://avatars1.githubusercontent.com/u/25545052?s=400&u=03b9cfdb679e21c495d04b94ad99445c7336f887&v=4)\n\n```\n![图片失效的文本](error link)\n![](https://avatars1.githubusercontent.com/u/25545052?s=400&u=03b9cfdb679e21c495d04b94ad99445c7336f887&v=4)\n```\n\n#### 表格\n\n制作表格使用 `|` 来分隔不同的单元格，使用 `-` 来分隔表头和其他行。在分割表头位置可以设置表格的对齐方式：\n\n- `-:` 设置内容和标题栏居右对齐（默认值\n- `:-` 设置内容和标题栏居左对齐\n- `:-:` 设置内容和标题栏居中对齐\n\n| 左对齐 | 右对齐 | 居中对齐 |\n| :----- | -----: | :------: |\n| 单元格 | 单元格 |  单元格  |\n| 单元格 | 单元格 |  单元格  |\n\n```\n| 左对齐  | 右对齐 | 居中对齐 |\n| :-----| ----: | :----: |\n| 单元格 | 单元格 | 单元格 |\n| 单元格 | 单元格 | 单元格 |\n```\n","slug":"写给自己的Markdown基本语法","published":1,"updated":"2021-07-02T03:20:30.661Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl5sb8gf5000oxq0rt7xpd2ig","content":"<h5 id=\"写在前面\"><a href=\"#写在前面\" class=\"headerlink\" title=\"写在前面\"></a>写在前面</h5><p>最近在用 Markdown 写文档，才发现自己没有系统地学习过 Markdown 语法，想用到某些语法还需要查阅，效率不高的同时还容易忘。故作此文，供自己巩固和学习</p>\n<h3 id=\"简介\"><a href=\"#简介\" class=\"headerlink\" title=\"简介\"></a>简介</h3><p>Markdown 是一种轻量级标记语言。特点是易读易写、专注内容、能被使用来编写电子书，目前很多社区都支持该语言作为编辑工具，利于无缝分发。如：Github、reddit</p>\n<a id=\"more\"></a>\n\n<h3 id=\"基本语法\"><a href=\"#基本语法\" class=\"headerlink\" title=\"基本语法\"></a>基本语法</h3><h4 id=\"标题\"><a href=\"#标题\" class=\"headerlink\" title=\"标题\"></a>标题</h4><h6 id=\"两种写法\"><a href=\"#两种写法\" class=\"headerlink\" title=\"两种写法\"></a>两种写法</h6><p>1、用 <code>#</code> 标记，<code>#</code> 对应一级标题、<code>######</code> 对应六级标题，一级标题字号最大，逐级递减</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"># I am a title</span><br><span class=\"line\"></span><br><span class=\"line\">## I am a subtitle</span><br><span class=\"line\"></span><br><span class=\"line\">###### 两种写法</span><br></pre></td></tr></table></figure>\n\n<p>2、用 <code>=</code> 或 <code>-</code> 在下一行标记一级标题或二级标题，符号的数量需要控制在两个以上</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">I am a title</span><br><span class=\"line\">==</span><br><span class=\"line\">I am a subtitle</span><br><span class=\"line\">----</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"段落换行\"><a href=\"#段落换行\" class=\"headerlink\" title=\"段落换行\"></a>段落换行</h4><p>两种<br>写法<br>1、在需要换行的位置使用两个以上的 <code>空格</code> 并且回车</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">两种  (此处有两个空格)</span><br><span class=\"line\">写法</span><br></pre></td></tr></table></figure>\n\n<p>2、使用空一行，值得注意的是，空多行也会被解析成一行</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">两种</span><br><span class=\"line\"></span><br><span class=\"line\">写法</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"字体格式\"><a href=\"#字体格式\" class=\"headerlink\" title=\"字体格式\"></a>字体格式</h4><p><em>两种写法</em></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">*斜体文本*</span><br><span class=\"line\">_斜体文本_</span><br><span class=\"line\"></span><br><span class=\"line\">**粗体文本**</span><br><span class=\"line\">__粗体文本__</span><br><span class=\"line\"></span><br><span class=\"line\">***粗斜体文本***</span><br><span class=\"line\">___粗斜体文本___</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"删除线-分割线-下划线\"><a href=\"#删除线-分割线-下划线\" class=\"headerlink\" title=\"删除线 分割线 下划线\"></a>删除线 分割线 下划线</h4><p>在<del>特定文本</del>两边分别填充两个 <code>~</code> 符号</p>\n<hr>\n<p>在<u>特定文本</u>两边分别填充 <code>&lt;u&gt;</code> 标签</p>\n<hr>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">在~~特定文本~~两边分别填充两个~符号（不允许有空格</span><br><span class=\"line\">- - - （或者 * * *、***）</span><br><span class=\"line\">在&lt;u&gt;特定文本&lt;/u&gt;两边分别填充u标签</span><br><span class=\"line\">***</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"列表\"><a href=\"#列表\" class=\"headerlink\" title=\"列表\"></a>列表</h4><p>无序列表有三种写法（<code>*</code>、<code>+</code>、<code>-</code>）<br>有序列表使用数字并加上 <code>.</code>，值得注意的是，有序列表的升序并不会受数字影响</p>\n<ul>\n<li>第一项</li>\n<li>第二项</li>\n</ul>\n<ol>\n<li>第一项</li>\n<li>第二项（显示 2. 并不受 55.影响</li>\n</ol>\n<ul>\n<li>嵌套列表<ol>\n<li>第一项</li>\n<li>第二项</li>\n</ol>\n</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">* 第一项</span><br><span class=\"line\">* 第二项</span><br><span class=\"line\"></span><br><span class=\"line\">+ 第一项</span><br><span class=\"line\">+ 第二项</span><br><span class=\"line\"></span><br><span class=\"line\">- 第一项</span><br><span class=\"line\">- 第二项</span><br><span class=\"line\"></span><br><span class=\"line\">1. 第一项</span><br><span class=\"line\">55. 第二项 （显示2. 并不受55.影响</span><br><span class=\"line\"></span><br><span class=\"line\">- 嵌套列表</span><br><span class=\"line\">  1. 第一项</span><br><span class=\"line\">  2. 第二项</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"区块引用\"><a href=\"#区块引用\" class=\"headerlink\" title=\"区块引用\"></a>区块引用</h4><blockquote>\n<p>开头使用<code>&gt;</code>符号</p>\n<ol>\n<li>第一项（区块中使用列表</li>\n<li>第二项</li>\n</ol>\n</blockquote>\n<ol>\n<li>列表中使用区块<blockquote>\n<p>区块</p>\n</blockquote>\n</li>\n<li>第二项</li>\n</ol>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&gt; 开头使用`&gt;`符号</span><br><span class=\"line\">&gt; 1. 第一项</span><br><span class=\"line\">&gt; 2. 第二项</span><br><span class=\"line\"></span><br><span class=\"line\">1. 列表中使用区块</span><br><span class=\"line\">    &gt; 区块</span><br><span class=\"line\">2. 第二项</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"代码\"><a href=\"#代码\" class=\"headerlink\" title=\"代码\"></a>代码</h4><p>一行以内的代码片段直接使用反引号 `，如<code>code frag</code><br>多行的代码区块，两种写法</p>\n<pre><code>使用4个空格或者制表符（Tab）</code></pre><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">你也可以使用```包裹一段代码，并指定一种语言，或不指定</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"链接\"><a href=\"#链接\" class=\"headerlink\" title=\"链接\"></a>链接</h4><p>三种<a href=\"https://https://psilocine.github.io/\" target=\"_blank\" rel=\"noopener\">写法</a>，按格式 <code>[链接名称](链接地址)</code> 或者 <code>&lt;链接地址&gt;</code>，还可以定义变量来设置[链接][link]<br>[link]: <a href=\"https://https://psilocine.github.io/\" target=\"_blank\" rel=\"noopener\">https://https://psilocine.github.io/</a></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">三种[写法](https://https://psilocine.github.io/)</span><br><span class=\"line\"></span><br><span class=\"line\">[链接][link]</span><br><span class=\"line\">[link]: https://https://psilocine.github.io/</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"图片\"><a href=\"#图片\" class=\"headerlink\" title=\"图片\"></a>图片</h4><p>两种写法，按格式 <code>![alt 属性](图片地址)</code>，或者像链接地址一样通过定义变量图片链接<br>![图片失效的文本](error link)<br><img src=\"https://avatars1.githubusercontent.com/u/25545052?s=400&u=03b9cfdb679e21c495d04b94ad99445c7336f887&v=4\" alt></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">![图片失效的文本](error link)</span><br><span class=\"line\">![](https://avatars1.githubusercontent.com/u/25545052?s=400&amp;u=03b9cfdb679e21c495d04b94ad99445c7336f887&amp;v=4)</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"表格\"><a href=\"#表格\" class=\"headerlink\" title=\"表格\"></a>表格</h4><p>制作表格使用 <code>|</code> 来分隔不同的单元格，使用 <code>-</code> 来分隔表头和其他行。在分割表头位置可以设置表格的对齐方式：</p>\n<ul>\n<li><code>-:</code> 设置内容和标题栏居右对齐（默认值</li>\n<li><code>:-</code> 设置内容和标题栏居左对齐</li>\n<li><code>:-:</code> 设置内容和标题栏居中对齐</li>\n</ul>\n<table>\n<thead>\n<tr>\n<th align=\"left\">左对齐</th>\n<th align=\"right\">右对齐</th>\n<th align=\"center\">居中对齐</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"left\">单元格</td>\n<td align=\"right\">单元格</td>\n<td align=\"center\">单元格</td>\n</tr>\n<tr>\n<td align=\"left\">单元格</td>\n<td align=\"right\">单元格</td>\n<td align=\"center\">单元格</td>\n</tr>\n</tbody></table>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">| 左对齐  | 右对齐 | 居中对齐 |</span><br><span class=\"line\">| :-----| ----: | :----: |</span><br><span class=\"line\">| 单元格 | 单元格 | 单元格 |</span><br><span class=\"line\">| 单元格 | 单元格 | 单元格 |</span><br></pre></td></tr></table></figure>\n\n","site":{"data":{}},"excerpt":"<h5 id=\"写在前面\"><a href=\"#写在前面\" class=\"headerlink\" title=\"写在前面\"></a>写在前面</h5><p>最近在用 Markdown 写文档，才发现自己没有系统地学习过 Markdown 语法，想用到某些语法还需要查阅，效率不高的同时还容易忘。故作此文，供自己巩固和学习</p>\n<h3 id=\"简介\"><a href=\"#简介\" class=\"headerlink\" title=\"简介\"></a>简介</h3><p>Markdown 是一种轻量级标记语言。特点是易读易写、专注内容、能被使用来编写电子书，目前很多社区都支持该语言作为编辑工具，利于无缝分发。如：Github、reddit</p>","more":"<h3 id=\"基本语法\"><a href=\"#基本语法\" class=\"headerlink\" title=\"基本语法\"></a>基本语法</h3><h4 id=\"标题\"><a href=\"#标题\" class=\"headerlink\" title=\"标题\"></a>标题</h4><h6 id=\"两种写法\"><a href=\"#两种写法\" class=\"headerlink\" title=\"两种写法\"></a>两种写法</h6><p>1、用 <code>#</code> 标记，<code>#</code> 对应一级标题、<code>######</code> 对应六级标题，一级标题字号最大，逐级递减</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"># I am a title</span><br><span class=\"line\"></span><br><span class=\"line\">## I am a subtitle</span><br><span class=\"line\"></span><br><span class=\"line\">###### 两种写法</span><br></pre></td></tr></table></figure>\n\n<p>2、用 <code>=</code> 或 <code>-</code> 在下一行标记一级标题或二级标题，符号的数量需要控制在两个以上</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">I am a title</span><br><span class=\"line\">==</span><br><span class=\"line\">I am a subtitle</span><br><span class=\"line\">----</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"段落换行\"><a href=\"#段落换行\" class=\"headerlink\" title=\"段落换行\"></a>段落换行</h4><p>两种<br>写法<br>1、在需要换行的位置使用两个以上的 <code>空格</code> 并且回车</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">两种  (此处有两个空格)</span><br><span class=\"line\">写法</span><br></pre></td></tr></table></figure>\n\n<p>2、使用空一行，值得注意的是，空多行也会被解析成一行</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">两种</span><br><span class=\"line\"></span><br><span class=\"line\">写法</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"字体格式\"><a href=\"#字体格式\" class=\"headerlink\" title=\"字体格式\"></a>字体格式</h4><p><em>两种写法</em></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">*斜体文本*</span><br><span class=\"line\">_斜体文本_</span><br><span class=\"line\"></span><br><span class=\"line\">**粗体文本**</span><br><span class=\"line\">__粗体文本__</span><br><span class=\"line\"></span><br><span class=\"line\">***粗斜体文本***</span><br><span class=\"line\">___粗斜体文本___</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"删除线-分割线-下划线\"><a href=\"#删除线-分割线-下划线\" class=\"headerlink\" title=\"删除线 分割线 下划线\"></a>删除线 分割线 下划线</h4><p>在<del>特定文本</del>两边分别填充两个 <code>~</code> 符号</p>\n<hr>\n<p>在<u>特定文本</u>两边分别填充 <code>&lt;u&gt;</code> 标签</p>\n<hr>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">在~~特定文本~~两边分别填充两个~符号（不允许有空格</span><br><span class=\"line\">- - - （或者 * * *、***）</span><br><span class=\"line\">在&lt;u&gt;特定文本&lt;/u&gt;两边分别填充u标签</span><br><span class=\"line\">***</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"列表\"><a href=\"#列表\" class=\"headerlink\" title=\"列表\"></a>列表</h4><p>无序列表有三种写法（<code>*</code>、<code>+</code>、<code>-</code>）<br>有序列表使用数字并加上 <code>.</code>，值得注意的是，有序列表的升序并不会受数字影响</p>\n<ul>\n<li>第一项</li>\n<li>第二项</li>\n</ul>\n<ol>\n<li>第一项</li>\n<li>第二项（显示 2. 并不受 55.影响</li>\n</ol>\n<ul>\n<li>嵌套列表<ol>\n<li>第一项</li>\n<li>第二项</li>\n</ol>\n</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">* 第一项</span><br><span class=\"line\">* 第二项</span><br><span class=\"line\"></span><br><span class=\"line\">+ 第一项</span><br><span class=\"line\">+ 第二项</span><br><span class=\"line\"></span><br><span class=\"line\">- 第一项</span><br><span class=\"line\">- 第二项</span><br><span class=\"line\"></span><br><span class=\"line\">1. 第一项</span><br><span class=\"line\">55. 第二项 （显示2. 并不受55.影响</span><br><span class=\"line\"></span><br><span class=\"line\">- 嵌套列表</span><br><span class=\"line\">  1. 第一项</span><br><span class=\"line\">  2. 第二项</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"区块引用\"><a href=\"#区块引用\" class=\"headerlink\" title=\"区块引用\"></a>区块引用</h4><blockquote>\n<p>开头使用<code>&gt;</code>符号</p>\n<ol>\n<li>第一项（区块中使用列表</li>\n<li>第二项</li>\n</ol>\n</blockquote>\n<ol>\n<li>列表中使用区块<blockquote>\n<p>区块</p>\n</blockquote>\n</li>\n<li>第二项</li>\n</ol>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&gt; 开头使用`&gt;`符号</span><br><span class=\"line\">&gt; 1. 第一项</span><br><span class=\"line\">&gt; 2. 第二项</span><br><span class=\"line\"></span><br><span class=\"line\">1. 列表中使用区块</span><br><span class=\"line\">    &gt; 区块</span><br><span class=\"line\">2. 第二项</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"代码\"><a href=\"#代码\" class=\"headerlink\" title=\"代码\"></a>代码</h4><p>一行以内的代码片段直接使用反引号 `，如<code>code frag</code><br>多行的代码区块，两种写法</p>\n<pre><code>使用4个空格或者制表符（Tab）</code></pre><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">你也可以使用```包裹一段代码，并指定一种语言，或不指定</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"链接\"><a href=\"#链接\" class=\"headerlink\" title=\"链接\"></a>链接</h4><p>三种<a href=\"https://https://psilocine.github.io/\" target=\"_blank\" rel=\"noopener\">写法</a>，按格式 <code>[链接名称](链接地址)</code> 或者 <code>&lt;链接地址&gt;</code>，还可以定义变量来设置[链接][link]<br>[link]: <a href=\"https://https://psilocine.github.io/\" target=\"_blank\" rel=\"noopener\">https://https://psilocine.github.io/</a></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">三种[写法](https://https://psilocine.github.io/)</span><br><span class=\"line\"></span><br><span class=\"line\">[链接][link]</span><br><span class=\"line\">[link]: https://https://psilocine.github.io/</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"图片\"><a href=\"#图片\" class=\"headerlink\" title=\"图片\"></a>图片</h4><p>两种写法，按格式 <code>![alt 属性](图片地址)</code>，或者像链接地址一样通过定义变量图片链接<br>![图片失效的文本](error link)<br><img src=\"https://avatars1.githubusercontent.com/u/25545052?s=400&u=03b9cfdb679e21c495d04b94ad99445c7336f887&v=4\" alt></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">![图片失效的文本](error link)</span><br><span class=\"line\">![](https://avatars1.githubusercontent.com/u/25545052?s=400&amp;u=03b9cfdb679e21c495d04b94ad99445c7336f887&amp;v=4)</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"表格\"><a href=\"#表格\" class=\"headerlink\" title=\"表格\"></a>表格</h4><p>制作表格使用 <code>|</code> 来分隔不同的单元格，使用 <code>-</code> 来分隔表头和其他行。在分割表头位置可以设置表格的对齐方式：</p>\n<ul>\n<li><code>-:</code> 设置内容和标题栏居右对齐（默认值</li>\n<li><code>:-</code> 设置内容和标题栏居左对齐</li>\n<li><code>:-:</code> 设置内容和标题栏居中对齐</li>\n</ul>\n<table>\n<thead>\n<tr>\n<th align=\"left\">左对齐</th>\n<th align=\"right\">右对齐</th>\n<th align=\"center\">居中对齐</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"left\">单元格</td>\n<td align=\"right\">单元格</td>\n<td align=\"center\">单元格</td>\n</tr>\n<tr>\n<td align=\"left\">单元格</td>\n<td align=\"right\">单元格</td>\n<td align=\"center\">单元格</td>\n</tr>\n</tbody></table>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">| 左对齐  | 右对齐 | 居中对齐 |</span><br><span class=\"line\">| :-----| ----: | :----: |</span><br><span class=\"line\">| 单元格 | 单元格 | 单元格 |</span><br><span class=\"line\">| 单元格 | 单元格 | 单元格 |</span><br></pre></td></tr></table></figure>"},{"title":"图片格式选择","date":"2022-04-19T15:03:08.000Z","_content":"\n目前前端领域的图片格式有以下几种，我们将依次浅析它们：\n\n- JPEG/JPG\n- PNG-8/PNG-24\n- SVG\n- Base64\n- WebP\n\n### JPEG/JPG\n\n最常用的图像文件格式\n\n**优势**\n\n- 支持极高的压缩率，可使文件传输、下载、预览速度大大加快\n- 利用可变的压缩比可以控制文件大小\n- 能够轻松地处理 1600 万种颜色，可以很好地再现全彩色的图像\n\n<!-- more -->\n\n**缺陷**\n\nJPG 的有损压缩在 轮播图 和 背景图 的展示上确实很难看出破绽，但当它处理矢量图形和 logo 等线条感较强、颜色对比强烈的图像时，人为压缩导致的 图片模糊 会相当明显。因此不适宜用该格式来显示 高清晰度 和 线条感较强 的图像\n\n除此之外， JPG 并不支持对有透明度要求的图像进行展示\n\n**业务场景**\n\nJPG 适用于呈现色彩丰富的图片，日常开发中，JPG 图片常作为大的 背景图、轮播图 或 预览图 出现\n\n### PNG-8/PNG-24\n\npng 是一种采用无损压缩算法的位图格式\n\n**优势**\n\n- 无损压缩\n- 完全支持 alpha 透明度\n- 可以重复保存且不降低图片质量\n\n**缺陷**\n\n体积大\n\n**业务场景**\n\n理论上说，当你追求最佳的显示效果，不在意存储大小或带宽，使用 PNG-24\n\n实际中，为了避免文件体积过大的问题，我们不用 PNG 处理较复杂的图像。\n\n需要处理透明度或线条感明显的图片时，采用 PNG，如网站 logo\n\n### SVG\n\n严格来说应该是一种开放标准的矢量图形语言\n\n**优势**\n\n- 可缩放，可支持无限放大\n- 可编程\n\n**缺陷**\n\n- 不是所有浏览器都支持，IE8- 需要插件\n- 复杂的图片会降低渲染速度\n\n**业务场景**\n\n用的比较多的是 icon，可以轻松通过 font-size 调整大小和通过 color 调整颜色\n\n### base64\n\n一种基于 64 个可打印字符来表示二进制数据的方法\n\n**优势**\n\n- 减少网络请求\n- 对于动态实时生成的图片无需将图片存储在服务器占用服务器资源\n\n**缺陷**\n\n- 只适用于小图\n- 若要频繁替换图片需要整个代码替换，可维护性低\n- 大小为原文件的 4/3，有机会就写一篇 base64 原理的文章，这里先挖个坑\n\n**业务场景**\n\n和雪碧图一样，作为小图标解决方案而存在\n\n但是 base64 编码后，图片大小会膨胀为原文件的 4/3。如果把大图编码成 base64，后者体积会明显增加，即便我们减少了 http 请求，也无法弥补庞大的体积带来的性能开销\n\n### WebP\n\n一种同时提供了有损压缩和无损压缩（可逆压缩）的图片文件格式\n\n**优势**\n\n- 支持有损压缩\n- 占用体积小\n- 可支持透明\n\n**缺陷**\n\n- 兼容性不好\n\n![figure](1.png)\n\n**业务场景**\n\n同 JPEG/JPG，因为目前兼容性不好，一般搭配 JPEG/JPG 一起使用\n\n## 总结\n\n![figure](2.png)\n","source":"_posts/图片格式选择.md","raw":"---\ntitle: 图片格式选择\ndate: 2022-04-19 23:03:08\ntags: 前端\n---\n\n目前前端领域的图片格式有以下几种，我们将依次浅析它们：\n\n- JPEG/JPG\n- PNG-8/PNG-24\n- SVG\n- Base64\n- WebP\n\n### JPEG/JPG\n\n最常用的图像文件格式\n\n**优势**\n\n- 支持极高的压缩率，可使文件传输、下载、预览速度大大加快\n- 利用可变的压缩比可以控制文件大小\n- 能够轻松地处理 1600 万种颜色，可以很好地再现全彩色的图像\n\n<!-- more -->\n\n**缺陷**\n\nJPG 的有损压缩在 轮播图 和 背景图 的展示上确实很难看出破绽，但当它处理矢量图形和 logo 等线条感较强、颜色对比强烈的图像时，人为压缩导致的 图片模糊 会相当明显。因此不适宜用该格式来显示 高清晰度 和 线条感较强 的图像\n\n除此之外， JPG 并不支持对有透明度要求的图像进行展示\n\n**业务场景**\n\nJPG 适用于呈现色彩丰富的图片，日常开发中，JPG 图片常作为大的 背景图、轮播图 或 预览图 出现\n\n### PNG-8/PNG-24\n\npng 是一种采用无损压缩算法的位图格式\n\n**优势**\n\n- 无损压缩\n- 完全支持 alpha 透明度\n- 可以重复保存且不降低图片质量\n\n**缺陷**\n\n体积大\n\n**业务场景**\n\n理论上说，当你追求最佳的显示效果，不在意存储大小或带宽，使用 PNG-24\n\n实际中，为了避免文件体积过大的问题，我们不用 PNG 处理较复杂的图像。\n\n需要处理透明度或线条感明显的图片时，采用 PNG，如网站 logo\n\n### SVG\n\n严格来说应该是一种开放标准的矢量图形语言\n\n**优势**\n\n- 可缩放，可支持无限放大\n- 可编程\n\n**缺陷**\n\n- 不是所有浏览器都支持，IE8- 需要插件\n- 复杂的图片会降低渲染速度\n\n**业务场景**\n\n用的比较多的是 icon，可以轻松通过 font-size 调整大小和通过 color 调整颜色\n\n### base64\n\n一种基于 64 个可打印字符来表示二进制数据的方法\n\n**优势**\n\n- 减少网络请求\n- 对于动态实时生成的图片无需将图片存储在服务器占用服务器资源\n\n**缺陷**\n\n- 只适用于小图\n- 若要频繁替换图片需要整个代码替换，可维护性低\n- 大小为原文件的 4/3，有机会就写一篇 base64 原理的文章，这里先挖个坑\n\n**业务场景**\n\n和雪碧图一样，作为小图标解决方案而存在\n\n但是 base64 编码后，图片大小会膨胀为原文件的 4/3。如果把大图编码成 base64，后者体积会明显增加，即便我们减少了 http 请求，也无法弥补庞大的体积带来的性能开销\n\n### WebP\n\n一种同时提供了有损压缩和无损压缩（可逆压缩）的图片文件格式\n\n**优势**\n\n- 支持有损压缩\n- 占用体积小\n- 可支持透明\n\n**缺陷**\n\n- 兼容性不好\n\n![figure](1.png)\n\n**业务场景**\n\n同 JPEG/JPG，因为目前兼容性不好，一般搭配 JPEG/JPG 一起使用\n\n## 总结\n\n![figure](2.png)\n","slug":"图片格式选择","published":1,"updated":"2022-07-19T15:07:45.474Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl5sb8gf6000qxq0rljs57mqn","content":"<p>目前前端领域的图片格式有以下几种，我们将依次浅析它们：</p>\n<ul>\n<li>JPEG/JPG</li>\n<li>PNG-8/PNG-24</li>\n<li>SVG</li>\n<li>Base64</li>\n<li>WebP</li>\n</ul>\n<h3 id=\"JPEG-JPG\"><a href=\"#JPEG-JPG\" class=\"headerlink\" title=\"JPEG/JPG\"></a>JPEG/JPG</h3><p>最常用的图像文件格式</p>\n<p><strong>优势</strong></p>\n<ul>\n<li>支持极高的压缩率，可使文件传输、下载、预览速度大大加快</li>\n<li>利用可变的压缩比可以控制文件大小</li>\n<li>能够轻松地处理 1600 万种颜色，可以很好地再现全彩色的图像</li>\n</ul>\n<a id=\"more\"></a>\n\n<p><strong>缺陷</strong></p>\n<p>JPG 的有损压缩在 轮播图 和 背景图 的展示上确实很难看出破绽，但当它处理矢量图形和 logo 等线条感较强、颜色对比强烈的图像时，人为压缩导致的 图片模糊 会相当明显。因此不适宜用该格式来显示 高清晰度 和 线条感较强 的图像</p>\n<p>除此之外， JPG 并不支持对有透明度要求的图像进行展示</p>\n<p><strong>业务场景</strong></p>\n<p>JPG 适用于呈现色彩丰富的图片，日常开发中，JPG 图片常作为大的 背景图、轮播图 或 预览图 出现</p>\n<h3 id=\"PNG-8-PNG-24\"><a href=\"#PNG-8-PNG-24\" class=\"headerlink\" title=\"PNG-8/PNG-24\"></a>PNG-8/PNG-24</h3><p>png 是一种采用无损压缩算法的位图格式</p>\n<p><strong>优势</strong></p>\n<ul>\n<li>无损压缩</li>\n<li>完全支持 alpha 透明度</li>\n<li>可以重复保存且不降低图片质量</li>\n</ul>\n<p><strong>缺陷</strong></p>\n<p>体积大</p>\n<p><strong>业务场景</strong></p>\n<p>理论上说，当你追求最佳的显示效果，不在意存储大小或带宽，使用 PNG-24</p>\n<p>实际中，为了避免文件体积过大的问题，我们不用 PNG 处理较复杂的图像。</p>\n<p>需要处理透明度或线条感明显的图片时，采用 PNG，如网站 logo</p>\n<h3 id=\"SVG\"><a href=\"#SVG\" class=\"headerlink\" title=\"SVG\"></a>SVG</h3><p>严格来说应该是一种开放标准的矢量图形语言</p>\n<p><strong>优势</strong></p>\n<ul>\n<li>可缩放，可支持无限放大</li>\n<li>可编程</li>\n</ul>\n<p><strong>缺陷</strong></p>\n<ul>\n<li>不是所有浏览器都支持，IE8- 需要插件</li>\n<li>复杂的图片会降低渲染速度</li>\n</ul>\n<p><strong>业务场景</strong></p>\n<p>用的比较多的是 icon，可以轻松通过 font-size 调整大小和通过 color 调整颜色</p>\n<h3 id=\"base64\"><a href=\"#base64\" class=\"headerlink\" title=\"base64\"></a>base64</h3><p>一种基于 64 个可打印字符来表示二进制数据的方法</p>\n<p><strong>优势</strong></p>\n<ul>\n<li>减少网络请求</li>\n<li>对于动态实时生成的图片无需将图片存储在服务器占用服务器资源</li>\n</ul>\n<p><strong>缺陷</strong></p>\n<ul>\n<li>只适用于小图</li>\n<li>若要频繁替换图片需要整个代码替换，可维护性低</li>\n<li>大小为原文件的 4/3，有机会就写一篇 base64 原理的文章，这里先挖个坑</li>\n</ul>\n<p><strong>业务场景</strong></p>\n<p>和雪碧图一样，作为小图标解决方案而存在</p>\n<p>但是 base64 编码后，图片大小会膨胀为原文件的 4/3。如果把大图编码成 base64，后者体积会明显增加，即便我们减少了 http 请求，也无法弥补庞大的体积带来的性能开销</p>\n<h3 id=\"WebP\"><a href=\"#WebP\" class=\"headerlink\" title=\"WebP\"></a>WebP</h3><p>一种同时提供了有损压缩和无损压缩（可逆压缩）的图片文件格式</p>\n<p><strong>优势</strong></p>\n<ul>\n<li>支持有损压缩</li>\n<li>占用体积小</li>\n<li>可支持透明</li>\n</ul>\n<p><strong>缺陷</strong></p>\n<ul>\n<li>兼容性不好</li>\n</ul>\n<p><img src=\"//psilocine.github.io/2022/04/19/图片格式选择/1.png\" alt=\"figure\"></p>\n<p><strong>业务场景</strong></p>\n<p>同 JPEG/JPG，因为目前兼容性不好，一般搭配 JPEG/JPG 一起使用</p>\n<h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><p><img src=\"//psilocine.github.io/2022/04/19/图片格式选择/2.png\" alt=\"figure\"></p>\n","site":{"data":{}},"excerpt":"<p>目前前端领域的图片格式有以下几种，我们将依次浅析它们：</p>\n<ul>\n<li>JPEG/JPG</li>\n<li>PNG-8/PNG-24</li>\n<li>SVG</li>\n<li>Base64</li>\n<li>WebP</li>\n</ul>\n<h3 id=\"JPEG-JPG\"><a href=\"#JPEG-JPG\" class=\"headerlink\" title=\"JPEG/JPG\"></a>JPEG/JPG</h3><p>最常用的图像文件格式</p>\n<p><strong>优势</strong></p>\n<ul>\n<li>支持极高的压缩率，可使文件传输、下载、预览速度大大加快</li>\n<li>利用可变的压缩比可以控制文件大小</li>\n<li>能够轻松地处理 1600 万种颜色，可以很好地再现全彩色的图像</li>\n</ul>","more":"<p><strong>缺陷</strong></p>\n<p>JPG 的有损压缩在 轮播图 和 背景图 的展示上确实很难看出破绽，但当它处理矢量图形和 logo 等线条感较强、颜色对比强烈的图像时，人为压缩导致的 图片模糊 会相当明显。因此不适宜用该格式来显示 高清晰度 和 线条感较强 的图像</p>\n<p>除此之外， JPG 并不支持对有透明度要求的图像进行展示</p>\n<p><strong>业务场景</strong></p>\n<p>JPG 适用于呈现色彩丰富的图片，日常开发中，JPG 图片常作为大的 背景图、轮播图 或 预览图 出现</p>\n<h3 id=\"PNG-8-PNG-24\"><a href=\"#PNG-8-PNG-24\" class=\"headerlink\" title=\"PNG-8/PNG-24\"></a>PNG-8/PNG-24</h3><p>png 是一种采用无损压缩算法的位图格式</p>\n<p><strong>优势</strong></p>\n<ul>\n<li>无损压缩</li>\n<li>完全支持 alpha 透明度</li>\n<li>可以重复保存且不降低图片质量</li>\n</ul>\n<p><strong>缺陷</strong></p>\n<p>体积大</p>\n<p><strong>业务场景</strong></p>\n<p>理论上说，当你追求最佳的显示效果，不在意存储大小或带宽，使用 PNG-24</p>\n<p>实际中，为了避免文件体积过大的问题，我们不用 PNG 处理较复杂的图像。</p>\n<p>需要处理透明度或线条感明显的图片时，采用 PNG，如网站 logo</p>\n<h3 id=\"SVG\"><a href=\"#SVG\" class=\"headerlink\" title=\"SVG\"></a>SVG</h3><p>严格来说应该是一种开放标准的矢量图形语言</p>\n<p><strong>优势</strong></p>\n<ul>\n<li>可缩放，可支持无限放大</li>\n<li>可编程</li>\n</ul>\n<p><strong>缺陷</strong></p>\n<ul>\n<li>不是所有浏览器都支持，IE8- 需要插件</li>\n<li>复杂的图片会降低渲染速度</li>\n</ul>\n<p><strong>业务场景</strong></p>\n<p>用的比较多的是 icon，可以轻松通过 font-size 调整大小和通过 color 调整颜色</p>\n<h3 id=\"base64\"><a href=\"#base64\" class=\"headerlink\" title=\"base64\"></a>base64</h3><p>一种基于 64 个可打印字符来表示二进制数据的方法</p>\n<p><strong>优势</strong></p>\n<ul>\n<li>减少网络请求</li>\n<li>对于动态实时生成的图片无需将图片存储在服务器占用服务器资源</li>\n</ul>\n<p><strong>缺陷</strong></p>\n<ul>\n<li>只适用于小图</li>\n<li>若要频繁替换图片需要整个代码替换，可维护性低</li>\n<li>大小为原文件的 4/3，有机会就写一篇 base64 原理的文章，这里先挖个坑</li>\n</ul>\n<p><strong>业务场景</strong></p>\n<p>和雪碧图一样，作为小图标解决方案而存在</p>\n<p>但是 base64 编码后，图片大小会膨胀为原文件的 4/3。如果把大图编码成 base64，后者体积会明显增加，即便我们减少了 http 请求，也无法弥补庞大的体积带来的性能开销</p>\n<h3 id=\"WebP\"><a href=\"#WebP\" class=\"headerlink\" title=\"WebP\"></a>WebP</h3><p>一种同时提供了有损压缩和无损压缩（可逆压缩）的图片文件格式</p>\n<p><strong>优势</strong></p>\n<ul>\n<li>支持有损压缩</li>\n<li>占用体积小</li>\n<li>可支持透明</li>\n</ul>\n<p><strong>缺陷</strong></p>\n<ul>\n<li>兼容性不好</li>\n</ul>\n<p><img src=\"//psilocine.github.io/2022/04/19/图片格式选择/1.png\" alt=\"figure\"></p>\n<p><strong>业务场景</strong></p>\n<p>同 JPEG/JPG，因为目前兼容性不好，一般搭配 JPEG/JPG 一起使用</p>\n<h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><p><img src=\"//psilocine.github.io/2022/04/19/图片格式选择/2.png\" alt=\"figure\"></p>"},{"title":"基于Inquirer实现命令行文件新增","date":"2021-04-29T05:58:11.000Z","_content":"\n##### 写在前面\n由于我们很多移动端项目是hybrid实现方案的特殊性，导致了多入口项目配置。\n当每次新业务需求来临的时候，需要：\n\n1. 手动配置入口文件、新增项目文件夹和文件\n2. 从老页面拷贝入口文件代码（统一的全局依赖、组件等）\n\n如果能够把这部分机械工作解放，那是十分好的，因此该脚本诞生。\n\n#### Inquirer概述\n\n<!-- more -->\n\n##### Inquirer是做什么的？\n![Inquirer](Inquirer_icon.png)\nInquirer.js试图为NodeJs做一个可嵌入式的美观的命令行界面，它是非常容易去处理以下几种事情的：\n\n* 提供错误回调\n* 询问操作者问题\n* 获取并解析用户输入\n* 检测用户回答是否合法\n* 管理多层级的提示\n\nInquirer采用问答的命令行形式呈现，问题对象具体配置项：\n\n![example](example_1.png)\n\n* type：（String）提示的类型。默认值：input-可能的值：input，number，confirm， list，rawlist，expand，checkbox，password，editor\n* name：（String）将答案存储在答案哈希中时使用的名称。如果名称包含句点，它将在答案哈希中定义路径。\n* message：（String | Function）要打印的问题。如果定义为函数，则第一个参数将是当前查询者会话答案。默认值为name（后面跟冒号）。\n* default：（String | Number | Boolean | Array | Function）如果未输入任何内容，则使用默认值，或者返回默认值的函数。如果定义为函数，则第一个参数将是当前查询者会话答案。\n* validate：（功能）接收用户输入并回答哈希。true如果该值有效，则应返回，否则返回错误消息（String）。如果false返回，则提供默认错误消息。\n* filter：（功能）接收用户输入并回答哈希。返回要在程序内部使用的过滤值。返回的值将添加到Answers哈希中。\n* transformer：（功能）接收用户输入，回答哈希和选项标志，并返回转换后的值以显示给用户。转换仅影响编辑时显示的内容。它不会修改答案哈希。\n* when：（Function，Boolean）接收当前用户的答案哈希，并应返回true或false取决于是否应询问此问题。该值也可以是一个简单的布尔值。\n* choices：（Array | Function）Choices数组或返回choices数组的函数。如果定义为函数，则第一个参数将是当前查询者会话答案。数组值可以是简单的numbers，strings或objects含有一个name（将在一览显示），一个value（在答案散列保存），和一个short（以后选择显示）属性。choices数组也可以包含一个Separator。\n\n> 值得注意的是，每个type类型需要的配置项是不一样的，如type为checkbox时，需要配置choices；type为number时则不需要\n\n#### 打开方式\n流程如下:\n1.npm run new\n2.依次输入7个问题：\n* 项目名\n* 是否P3项目\n* 页面入口\n* 页面标题\n* 是否需要数学公式\n* 是否需要页面loading\n* 是否需要页面通信lsbridge\n\n3.创建成功/创建失败\n\n##### 会遇到的情况\n* 创建失败：项目名重复\n\n![situation_1](situation_1.png)\n* 创建失败：文件名重复\n\n![situation_2](situation_2.png)\n* 创建成功\n\n![situation_3](situation_3.png)\n\n创建成功后，在对应目录写入对应文件和在配置文件（打包的入口entry）配置项目信息\n![result](result.png)\n\n![result_2](result_2.png)\n\n#### 代码实现\n首先依赖引入inquirer、chalk（命令行美化）、fs（文件读取写入）。\n逻辑我们分三部分：\n1. 判断项目名是否同名\n2. 判断项目是否为P3项目\n3. 走完后续问题对象的输入\n\n![code](code_1.png)\n\nisProjectExist方法是去遍历配置入口的所有项目名，一旦命中则退出脚本\n\n![code_2](code_2.png)\n\n判断项目是否为P3项目\n\n![code_3](code_3.png)\n\nsetEntry目的是为了获取到正确的文件路径，如果项目都新增在同一个文件夹中，则不需要这一步\n\n![code_4](code_4.png)\n\n走完后续问题对象的输入：\n写入文件将默认的模版字符串写入，把需要替换的字符串如图中的`__placeholder__`替换成命令行输入的项目名即可。\n","source":"_posts/基于Inquirer实现命令行文件新增.md","raw":"---\ntitle: 基于Inquirer实现命令行文件新增\ndate: 2021-04-29 13:58:11\ntags: [前端, JS]\n---\n\n##### 写在前面\n由于我们很多移动端项目是hybrid实现方案的特殊性，导致了多入口项目配置。\n当每次新业务需求来临的时候，需要：\n\n1. 手动配置入口文件、新增项目文件夹和文件\n2. 从老页面拷贝入口文件代码（统一的全局依赖、组件等）\n\n如果能够把这部分机械工作解放，那是十分好的，因此该脚本诞生。\n\n#### Inquirer概述\n\n<!-- more -->\n\n##### Inquirer是做什么的？\n![Inquirer](Inquirer_icon.png)\nInquirer.js试图为NodeJs做一个可嵌入式的美观的命令行界面，它是非常容易去处理以下几种事情的：\n\n* 提供错误回调\n* 询问操作者问题\n* 获取并解析用户输入\n* 检测用户回答是否合法\n* 管理多层级的提示\n\nInquirer采用问答的命令行形式呈现，问题对象具体配置项：\n\n![example](example_1.png)\n\n* type：（String）提示的类型。默认值：input-可能的值：input，number，confirm， list，rawlist，expand，checkbox，password，editor\n* name：（String）将答案存储在答案哈希中时使用的名称。如果名称包含句点，它将在答案哈希中定义路径。\n* message：（String | Function）要打印的问题。如果定义为函数，则第一个参数将是当前查询者会话答案。默认值为name（后面跟冒号）。\n* default：（String | Number | Boolean | Array | Function）如果未输入任何内容，则使用默认值，或者返回默认值的函数。如果定义为函数，则第一个参数将是当前查询者会话答案。\n* validate：（功能）接收用户输入并回答哈希。true如果该值有效，则应返回，否则返回错误消息（String）。如果false返回，则提供默认错误消息。\n* filter：（功能）接收用户输入并回答哈希。返回要在程序内部使用的过滤值。返回的值将添加到Answers哈希中。\n* transformer：（功能）接收用户输入，回答哈希和选项标志，并返回转换后的值以显示给用户。转换仅影响编辑时显示的内容。它不会修改答案哈希。\n* when：（Function，Boolean）接收当前用户的答案哈希，并应返回true或false取决于是否应询问此问题。该值也可以是一个简单的布尔值。\n* choices：（Array | Function）Choices数组或返回choices数组的函数。如果定义为函数，则第一个参数将是当前查询者会话答案。数组值可以是简单的numbers，strings或objects含有一个name（将在一览显示），一个value（在答案散列保存），和一个short（以后选择显示）属性。choices数组也可以包含一个Separator。\n\n> 值得注意的是，每个type类型需要的配置项是不一样的，如type为checkbox时，需要配置choices；type为number时则不需要\n\n#### 打开方式\n流程如下:\n1.npm run new\n2.依次输入7个问题：\n* 项目名\n* 是否P3项目\n* 页面入口\n* 页面标题\n* 是否需要数学公式\n* 是否需要页面loading\n* 是否需要页面通信lsbridge\n\n3.创建成功/创建失败\n\n##### 会遇到的情况\n* 创建失败：项目名重复\n\n![situation_1](situation_1.png)\n* 创建失败：文件名重复\n\n![situation_2](situation_2.png)\n* 创建成功\n\n![situation_3](situation_3.png)\n\n创建成功后，在对应目录写入对应文件和在配置文件（打包的入口entry）配置项目信息\n![result](result.png)\n\n![result_2](result_2.png)\n\n#### 代码实现\n首先依赖引入inquirer、chalk（命令行美化）、fs（文件读取写入）。\n逻辑我们分三部分：\n1. 判断项目名是否同名\n2. 判断项目是否为P3项目\n3. 走完后续问题对象的输入\n\n![code](code_1.png)\n\nisProjectExist方法是去遍历配置入口的所有项目名，一旦命中则退出脚本\n\n![code_2](code_2.png)\n\n判断项目是否为P3项目\n\n![code_3](code_3.png)\n\nsetEntry目的是为了获取到正确的文件路径，如果项目都新增在同一个文件夹中，则不需要这一步\n\n![code_4](code_4.png)\n\n走完后续问题对象的输入：\n写入文件将默认的模版字符串写入，把需要替换的字符串如图中的`__placeholder__`替换成命令行输入的项目名即可。\n","slug":"基于Inquirer实现命令行文件新增","published":1,"updated":"2021-07-02T06:23:21.443Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl5sb8gf7000sxq0rzm0013kc","content":"<h5 id=\"写在前面\"><a href=\"#写在前面\" class=\"headerlink\" title=\"写在前面\"></a>写在前面</h5><p>由于我们很多移动端项目是hybrid实现方案的特殊性，导致了多入口项目配置。<br>当每次新业务需求来临的时候，需要：</p>\n<ol>\n<li>手动配置入口文件、新增项目文件夹和文件</li>\n<li>从老页面拷贝入口文件代码（统一的全局依赖、组件等）</li>\n</ol>\n<p>如果能够把这部分机械工作解放，那是十分好的，因此该脚本诞生。</p>\n<h4 id=\"Inquirer概述\"><a href=\"#Inquirer概述\" class=\"headerlink\" title=\"Inquirer概述\"></a>Inquirer概述</h4><a id=\"more\"></a>\n\n<h5 id=\"Inquirer是做什么的？\"><a href=\"#Inquirer是做什么的？\" class=\"headerlink\" title=\"Inquirer是做什么的？\"></a>Inquirer是做什么的？</h5><p><img src=\"//psilocine.github.io/2021/04/29/基于Inquirer实现命令行文件新增/Inquirer_icon.png\" alt=\"Inquirer\"><br>Inquirer.js试图为NodeJs做一个可嵌入式的美观的命令行界面，它是非常容易去处理以下几种事情的：</p>\n<ul>\n<li>提供错误回调</li>\n<li>询问操作者问题</li>\n<li>获取并解析用户输入</li>\n<li>检测用户回答是否合法</li>\n<li>管理多层级的提示</li>\n</ul>\n<p>Inquirer采用问答的命令行形式呈现，问题对象具体配置项：</p>\n<p><img src=\"//psilocine.github.io/2021/04/29/基于Inquirer实现命令行文件新增/example_1.png\" alt=\"example\"></p>\n<ul>\n<li>type：（String）提示的类型。默认值：input-可能的值：input，number，confirm， list，rawlist，expand，checkbox，password，editor</li>\n<li>name：（String）将答案存储在答案哈希中时使用的名称。如果名称包含句点，它将在答案哈希中定义路径。</li>\n<li>message：（String | Function）要打印的问题。如果定义为函数，则第一个参数将是当前查询者会话答案。默认值为name（后面跟冒号）。</li>\n<li>default：（String | Number | Boolean | Array | Function）如果未输入任何内容，则使用默认值，或者返回默认值的函数。如果定义为函数，则第一个参数将是当前查询者会话答案。</li>\n<li>validate：（功能）接收用户输入并回答哈希。true如果该值有效，则应返回，否则返回错误消息（String）。如果false返回，则提供默认错误消息。</li>\n<li>filter：（功能）接收用户输入并回答哈希。返回要在程序内部使用的过滤值。返回的值将添加到Answers哈希中。</li>\n<li>transformer：（功能）接收用户输入，回答哈希和选项标志，并返回转换后的值以显示给用户。转换仅影响编辑时显示的内容。它不会修改答案哈希。</li>\n<li>when：（Function，Boolean）接收当前用户的答案哈希，并应返回true或false取决于是否应询问此问题。该值也可以是一个简单的布尔值。</li>\n<li>choices：（Array | Function）Choices数组或返回choices数组的函数。如果定义为函数，则第一个参数将是当前查询者会话答案。数组值可以是简单的numbers，strings或objects含有一个name（将在一览显示），一个value（在答案散列保存），和一个short（以后选择显示）属性。choices数组也可以包含一个Separator。</li>\n</ul>\n<blockquote>\n<p>值得注意的是，每个type类型需要的配置项是不一样的，如type为checkbox时，需要配置choices；type为number时则不需要</p>\n</blockquote>\n<h4 id=\"打开方式\"><a href=\"#打开方式\" class=\"headerlink\" title=\"打开方式\"></a>打开方式</h4><p>流程如下:<br>1.npm run new<br>2.依次输入7个问题：</p>\n<ul>\n<li>项目名</li>\n<li>是否P3项目</li>\n<li>页面入口</li>\n<li>页面标题</li>\n<li>是否需要数学公式</li>\n<li>是否需要页面loading</li>\n<li>是否需要页面通信lsbridge</li>\n</ul>\n<p>3.创建成功/创建失败</p>\n<h5 id=\"会遇到的情况\"><a href=\"#会遇到的情况\" class=\"headerlink\" title=\"会遇到的情况\"></a>会遇到的情况</h5><ul>\n<li>创建失败：项目名重复</li>\n</ul>\n<p><img src=\"//psilocine.github.io/2021/04/29/基于Inquirer实现命令行文件新增/situation_1.png\" alt=\"situation_1\"></p>\n<ul>\n<li>创建失败：文件名重复</li>\n</ul>\n<p><img src=\"//psilocine.github.io/2021/04/29/基于Inquirer实现命令行文件新增/situation_2.png\" alt=\"situation_2\"></p>\n<ul>\n<li>创建成功</li>\n</ul>\n<p><img src=\"//psilocine.github.io/2021/04/29/基于Inquirer实现命令行文件新增/situation_3.png\" alt=\"situation_3\"></p>\n<p>创建成功后，在对应目录写入对应文件和在配置文件（打包的入口entry）配置项目信息<br><img src=\"//psilocine.github.io/2021/04/29/基于Inquirer实现命令行文件新增/result.png\" alt=\"result\"></p>\n<p><img src=\"//psilocine.github.io/2021/04/29/基于Inquirer实现命令行文件新增/result_2.png\" alt=\"result_2\"></p>\n<h4 id=\"代码实现\"><a href=\"#代码实现\" class=\"headerlink\" title=\"代码实现\"></a>代码实现</h4><p>首先依赖引入inquirer、chalk（命令行美化）、fs（文件读取写入）。<br>逻辑我们分三部分：</p>\n<ol>\n<li>判断项目名是否同名</li>\n<li>判断项目是否为P3项目</li>\n<li>走完后续问题对象的输入</li>\n</ol>\n<p><img src=\"//psilocine.github.io/2021/04/29/基于Inquirer实现命令行文件新增/code_1.png\" alt=\"code\"></p>\n<p>isProjectExist方法是去遍历配置入口的所有项目名，一旦命中则退出脚本</p>\n<p><img src=\"//psilocine.github.io/2021/04/29/基于Inquirer实现命令行文件新增/code_2.png\" alt=\"code_2\"></p>\n<p>判断项目是否为P3项目</p>\n<p><img src=\"//psilocine.github.io/2021/04/29/基于Inquirer实现命令行文件新增/code_3.png\" alt=\"code_3\"></p>\n<p>setEntry目的是为了获取到正确的文件路径，如果项目都新增在同一个文件夹中，则不需要这一步</p>\n<p><img src=\"//psilocine.github.io/2021/04/29/基于Inquirer实现命令行文件新增/code_4.png\" alt=\"code_4\"></p>\n<p>走完后续问题对象的输入：<br>写入文件将默认的模版字符串写入，把需要替换的字符串如图中的<code>__placeholder__</code>替换成命令行输入的项目名即可。</p>\n","site":{"data":{}},"excerpt":"<h5 id=\"写在前面\"><a href=\"#写在前面\" class=\"headerlink\" title=\"写在前面\"></a>写在前面</h5><p>由于我们很多移动端项目是hybrid实现方案的特殊性，导致了多入口项目配置。<br>当每次新业务需求来临的时候，需要：</p>\n<ol>\n<li>手动配置入口文件、新增项目文件夹和文件</li>\n<li>从老页面拷贝入口文件代码（统一的全局依赖、组件等）</li>\n</ol>\n<p>如果能够把这部分机械工作解放，那是十分好的，因此该脚本诞生。</p>\n<h4 id=\"Inquirer概述\"><a href=\"#Inquirer概述\" class=\"headerlink\" title=\"Inquirer概述\"></a>Inquirer概述</h4>","more":"<h5 id=\"Inquirer是做什么的？\"><a href=\"#Inquirer是做什么的？\" class=\"headerlink\" title=\"Inquirer是做什么的？\"></a>Inquirer是做什么的？</h5><p><img src=\"//psilocine.github.io/2021/04/29/基于Inquirer实现命令行文件新增/Inquirer_icon.png\" alt=\"Inquirer\"><br>Inquirer.js试图为NodeJs做一个可嵌入式的美观的命令行界面，它是非常容易去处理以下几种事情的：</p>\n<ul>\n<li>提供错误回调</li>\n<li>询问操作者问题</li>\n<li>获取并解析用户输入</li>\n<li>检测用户回答是否合法</li>\n<li>管理多层级的提示</li>\n</ul>\n<p>Inquirer采用问答的命令行形式呈现，问题对象具体配置项：</p>\n<p><img src=\"//psilocine.github.io/2021/04/29/基于Inquirer实现命令行文件新增/example_1.png\" alt=\"example\"></p>\n<ul>\n<li>type：（String）提示的类型。默认值：input-可能的值：input，number，confirm， list，rawlist，expand，checkbox，password，editor</li>\n<li>name：（String）将答案存储在答案哈希中时使用的名称。如果名称包含句点，它将在答案哈希中定义路径。</li>\n<li>message：（String | Function）要打印的问题。如果定义为函数，则第一个参数将是当前查询者会话答案。默认值为name（后面跟冒号）。</li>\n<li>default：（String | Number | Boolean | Array | Function）如果未输入任何内容，则使用默认值，或者返回默认值的函数。如果定义为函数，则第一个参数将是当前查询者会话答案。</li>\n<li>validate：（功能）接收用户输入并回答哈希。true如果该值有效，则应返回，否则返回错误消息（String）。如果false返回，则提供默认错误消息。</li>\n<li>filter：（功能）接收用户输入并回答哈希。返回要在程序内部使用的过滤值。返回的值将添加到Answers哈希中。</li>\n<li>transformer：（功能）接收用户输入，回答哈希和选项标志，并返回转换后的值以显示给用户。转换仅影响编辑时显示的内容。它不会修改答案哈希。</li>\n<li>when：（Function，Boolean）接收当前用户的答案哈希，并应返回true或false取决于是否应询问此问题。该值也可以是一个简单的布尔值。</li>\n<li>choices：（Array | Function）Choices数组或返回choices数组的函数。如果定义为函数，则第一个参数将是当前查询者会话答案。数组值可以是简单的numbers，strings或objects含有一个name（将在一览显示），一个value（在答案散列保存），和一个short（以后选择显示）属性。choices数组也可以包含一个Separator。</li>\n</ul>\n<blockquote>\n<p>值得注意的是，每个type类型需要的配置项是不一样的，如type为checkbox时，需要配置choices；type为number时则不需要</p>\n</blockquote>\n<h4 id=\"打开方式\"><a href=\"#打开方式\" class=\"headerlink\" title=\"打开方式\"></a>打开方式</h4><p>流程如下:<br>1.npm run new<br>2.依次输入7个问题：</p>\n<ul>\n<li>项目名</li>\n<li>是否P3项目</li>\n<li>页面入口</li>\n<li>页面标题</li>\n<li>是否需要数学公式</li>\n<li>是否需要页面loading</li>\n<li>是否需要页面通信lsbridge</li>\n</ul>\n<p>3.创建成功/创建失败</p>\n<h5 id=\"会遇到的情况\"><a href=\"#会遇到的情况\" class=\"headerlink\" title=\"会遇到的情况\"></a>会遇到的情况</h5><ul>\n<li>创建失败：项目名重复</li>\n</ul>\n<p><img src=\"//psilocine.github.io/2021/04/29/基于Inquirer实现命令行文件新增/situation_1.png\" alt=\"situation_1\"></p>\n<ul>\n<li>创建失败：文件名重复</li>\n</ul>\n<p><img src=\"//psilocine.github.io/2021/04/29/基于Inquirer实现命令行文件新增/situation_2.png\" alt=\"situation_2\"></p>\n<ul>\n<li>创建成功</li>\n</ul>\n<p><img src=\"//psilocine.github.io/2021/04/29/基于Inquirer实现命令行文件新增/situation_3.png\" alt=\"situation_3\"></p>\n<p>创建成功后，在对应目录写入对应文件和在配置文件（打包的入口entry）配置项目信息<br><img src=\"//psilocine.github.io/2021/04/29/基于Inquirer实现命令行文件新增/result.png\" alt=\"result\"></p>\n<p><img src=\"//psilocine.github.io/2021/04/29/基于Inquirer实现命令行文件新增/result_2.png\" alt=\"result_2\"></p>\n<h4 id=\"代码实现\"><a href=\"#代码实现\" class=\"headerlink\" title=\"代码实现\"></a>代码实现</h4><p>首先依赖引入inquirer、chalk（命令行美化）、fs（文件读取写入）。<br>逻辑我们分三部分：</p>\n<ol>\n<li>判断项目名是否同名</li>\n<li>判断项目是否为P3项目</li>\n<li>走完后续问题对象的输入</li>\n</ol>\n<p><img src=\"//psilocine.github.io/2021/04/29/基于Inquirer实现命令行文件新增/code_1.png\" alt=\"code\"></p>\n<p>isProjectExist方法是去遍历配置入口的所有项目名，一旦命中则退出脚本</p>\n<p><img src=\"//psilocine.github.io/2021/04/29/基于Inquirer实现命令行文件新增/code_2.png\" alt=\"code_2\"></p>\n<p>判断项目是否为P3项目</p>\n<p><img src=\"//psilocine.github.io/2021/04/29/基于Inquirer实现命令行文件新增/code_3.png\" alt=\"code_3\"></p>\n<p>setEntry目的是为了获取到正确的文件路径，如果项目都新增在同一个文件夹中，则不需要这一步</p>\n<p><img src=\"//psilocine.github.io/2021/04/29/基于Inquirer实现命令行文件新增/code_4.png\" alt=\"code_4\"></p>\n<p>走完后续问题对象的输入：<br>写入文件将默认的模版字符串写入，把需要替换的字符串如图中的<code>__placeholder__</code>替换成命令行输入的项目名即可。</p>"},{"title":"微信小程序 && mpVue 部分踩坑实录","date":"2019-06-12T06:50:10.000Z","_content":"##### 写在前面\n下述只是笔者现阶段遇到的问题，时效性不强，后续mpVue更新可能有所出入。欢迎大家留言补充。\n\n### 生命周期相关\n- 使用mpvue时，其所有页面的created方法都会在小程序首次加载时执行。\n\n- 原生的生命周期onLoad、onReady方法比created、mounted方法执行的更早，使用前者会相对减少白屏时间。（但mpvue官方不推荐使用原生的生命周期\n- 我们熟悉的asyncComputed插件在小程序上有弊端：所有定义过asyncComputed方法的页面都会在小程序首页加载时执行方法，意味着http request更多。\n<!-- more -->\n### Template相关\n- 不支持在template标签里使用部分复杂的Js渲染表达式操作，只支持三元表达式。\n\n- 不支持使用methods定义的函数。\n- 不支持加“this”，如data定义了maysa变量，template中“{{this.maysa}}”是不可行的。\n- 不支持在使用组件时给其添加样式(style)或者新增class属性。\n```Vue\n<!--下述情况均无法成功渲染-->\n<Child class=\"maysa-class\" />\n<Child style=\"width: 100%\" />\n```\n### MpVue其余部分\n- 计算属性computed不能和wx.getStorageSync共用，因为wx.getStorageSync只会取第一次。（认为是没有双向绑定，所以不会实时更新\n\n- 引用文件不支持使用配置的alias。\n- 引用文件只支持单文件\n```Vue\nimport { maysa, maysaTech } from \"xxx\" // error\n```\n- v-for循环必须加key，多层v-for时index必须是不一样的名字，否则认为索引一样会报错。\n- 不支持注册全局组件。\n- 不支持ref属性。（其实是支持的，但是data和methods属性均为null，即无法调用任何属性和方法\n- 不支持vue-router。\n- 不支持v-html属性。\n- 不支持过滤器filter。\n- 不支持一个组件多个插槽。\n- 不支持transition标签。\n","source":"_posts/微信小程序-mpVue-部分踩坑实录.md","raw":"---\ntitle: 微信小程序 && mpVue 部分踩坑实录\ndate: 2019-06-12 14:50:10\ntags: [小程序, 前端]\n---\n##### 写在前面\n下述只是笔者现阶段遇到的问题，时效性不强，后续mpVue更新可能有所出入。欢迎大家留言补充。\n\n### 生命周期相关\n- 使用mpvue时，其所有页面的created方法都会在小程序首次加载时执行。\n\n- 原生的生命周期onLoad、onReady方法比created、mounted方法执行的更早，使用前者会相对减少白屏时间。（但mpvue官方不推荐使用原生的生命周期\n- 我们熟悉的asyncComputed插件在小程序上有弊端：所有定义过asyncComputed方法的页面都会在小程序首页加载时执行方法，意味着http request更多。\n<!-- more -->\n### Template相关\n- 不支持在template标签里使用部分复杂的Js渲染表达式操作，只支持三元表达式。\n\n- 不支持使用methods定义的函数。\n- 不支持加“this”，如data定义了maysa变量，template中“{{this.maysa}}”是不可行的。\n- 不支持在使用组件时给其添加样式(style)或者新增class属性。\n```Vue\n<!--下述情况均无法成功渲染-->\n<Child class=\"maysa-class\" />\n<Child style=\"width: 100%\" />\n```\n### MpVue其余部分\n- 计算属性computed不能和wx.getStorageSync共用，因为wx.getStorageSync只会取第一次。（认为是没有双向绑定，所以不会实时更新\n\n- 引用文件不支持使用配置的alias。\n- 引用文件只支持单文件\n```Vue\nimport { maysa, maysaTech } from \"xxx\" // error\n```\n- v-for循环必须加key，多层v-for时index必须是不一样的名字，否则认为索引一样会报错。\n- 不支持注册全局组件。\n- 不支持ref属性。（其实是支持的，但是data和methods属性均为null，即无法调用任何属性和方法\n- 不支持vue-router。\n- 不支持v-html属性。\n- 不支持过滤器filter。\n- 不支持一个组件多个插槽。\n- 不支持transition标签。\n","slug":"微信小程序-mpVue-部分踩坑实录","published":1,"updated":"2021-07-02T03:20:30.661Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl5sb8gf7000vxq0rfhpx7c4j","content":"<h5 id=\"写在前面\"><a href=\"#写在前面\" class=\"headerlink\" title=\"写在前面\"></a>写在前面</h5><p>下述只是笔者现阶段遇到的问题，时效性不强，后续mpVue更新可能有所出入。欢迎大家留言补充。</p>\n<h3 id=\"生命周期相关\"><a href=\"#生命周期相关\" class=\"headerlink\" title=\"生命周期相关\"></a>生命周期相关</h3><ul>\n<li><p>使用mpvue时，其所有页面的created方法都会在小程序首次加载时执行。</p>\n</li>\n<li><p>原生的生命周期onLoad、onReady方法比created、mounted方法执行的更早，使用前者会相对减少白屏时间。（但mpvue官方不推荐使用原生的生命周期</p>\n</li>\n<li><p>我们熟悉的asyncComputed插件在小程序上有弊端：所有定义过asyncComputed方法的页面都会在小程序首页加载时执行方法，意味着http request更多。</p>\n<a id=\"more\"></a>\n<h3 id=\"Template相关\"><a href=\"#Template相关\" class=\"headerlink\" title=\"Template相关\"></a>Template相关</h3></li>\n<li><p>不支持在template标签里使用部分复杂的Js渲染表达式操作，只支持三元表达式。</p>\n</li>\n<li><p>不支持使用methods定义的函数。</p>\n</li>\n<li><p>不支持加“this”，如data定义了maysa变量，template中“”是不可行的。</p>\n</li>\n<li><p>不支持在使用组件时给其添加样式(style)或者新增class属性。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;!--下述情况均无法成功渲染--&gt;</span><br><span class=\"line\">&lt;Child class=&quot;maysa-class&quot; /&gt;</span><br><span class=\"line\">&lt;Child style=&quot;width: 100%&quot; /&gt;</span><br></pre></td></tr></table></figure>\n\n</li>\n</ul>\n<h3 id=\"MpVue其余部分\"><a href=\"#MpVue其余部分\" class=\"headerlink\" title=\"MpVue其余部分\"></a>MpVue其余部分</h3><ul>\n<li><p>计算属性computed不能和wx.getStorageSync共用，因为wx.getStorageSync只会取第一次。（认为是没有双向绑定，所以不会实时更新</p>\n</li>\n<li><p>引用文件不支持使用配置的alias。</p>\n</li>\n<li><p>引用文件只支持单文件</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">import &#123; maysa, maysaTech &#125; from &quot;xxx&quot; // error</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>v-for循环必须加key，多层v-for时index必须是不一样的名字，否则认为索引一样会报错。</p>\n</li>\n<li><p>不支持注册全局组件。</p>\n</li>\n<li><p>不支持ref属性。（其实是支持的，但是data和methods属性均为null，即无法调用任何属性和方法</p>\n</li>\n<li><p>不支持vue-router。</p>\n</li>\n<li><p>不支持v-html属性。</p>\n</li>\n<li><p>不支持过滤器filter。</p>\n</li>\n<li><p>不支持一个组件多个插槽。</p>\n</li>\n<li><p>不支持transition标签。</p>\n</li>\n</ul>\n","site":{"data":{}},"excerpt":"<h5 id=\"写在前面\"><a href=\"#写在前面\" class=\"headerlink\" title=\"写在前面\"></a>写在前面</h5><p>下述只是笔者现阶段遇到的问题，时效性不强，后续mpVue更新可能有所出入。欢迎大家留言补充。</p>\n<h3 id=\"生命周期相关\"><a href=\"#生命周期相关\" class=\"headerlink\" title=\"生命周期相关\"></a>生命周期相关</h3><ul>\n<li><p>使用mpvue时，其所有页面的created方法都会在小程序首次加载时执行。</p>\n</li>\n<li><p>原生的生命周期onLoad、onReady方法比created、mounted方法执行的更早，使用前者会相对减少白屏时间。（但mpvue官方不推荐使用原生的生命周期</p>\n</li>\n<li><p>我们熟悉的asyncComputed插件在小程序上有弊端：所有定义过asyncComputed方法的页面都会在小程序首页加载时执行方法，意味着http request更多。</p></li></ul>","more":"<h3 id=\"Template相关\"><a href=\"#Template相关\" class=\"headerlink\" title=\"Template相关\"></a>Template相关</h3>\n<li><p>不支持在template标签里使用部分复杂的Js渲染表达式操作，只支持三元表达式。</p>\n</li>\n<li><p>不支持使用methods定义的函数。</p>\n</li>\n<li><p>不支持加“this”，如data定义了maysa变量，template中“”是不可行的。</p>\n</li>\n<li><p>不支持在使用组件时给其添加样式(style)或者新增class属性。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;!--下述情况均无法成功渲染--&gt;</span><br><span class=\"line\">&lt;Child class=&quot;maysa-class&quot; /&gt;</span><br><span class=\"line\">&lt;Child style=&quot;width: 100%&quot; /&gt;</span><br></pre></td></tr></table></figure>\n\n</li>\n\n<h3 id=\"MpVue其余部分\"><a href=\"#MpVue其余部分\" class=\"headerlink\" title=\"MpVue其余部分\"></a>MpVue其余部分</h3><ul>\n<li><p>计算属性computed不能和wx.getStorageSync共用，因为wx.getStorageSync只会取第一次。（认为是没有双向绑定，所以不会实时更新</p>\n</li>\n<li><p>引用文件不支持使用配置的alias。</p>\n</li>\n<li><p>引用文件只支持单文件</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">import &#123; maysa, maysaTech &#125; from &quot;xxx&quot; // error</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>v-for循环必须加key，多层v-for时index必须是不一样的名字，否则认为索引一样会报错。</p>\n</li>\n<li><p>不支持注册全局组件。</p>\n</li>\n<li><p>不支持ref属性。（其实是支持的，但是data和methods属性均为null，即无法调用任何属性和方法</p>\n</li>\n<li><p>不支持vue-router。</p>\n</li>\n<li><p>不支持v-html属性。</p>\n</li>\n<li><p>不支持过滤器filter。</p>\n</li>\n<li><p>不支持一个组件多个插槽。</p>\n</li>\n<li><p>不支持transition标签。</p>\n</li>\n</ul>"},{"title":"我搭建java后台遇到的一些难题","date":"2017-11-23T15:53:07.000Z","_content":"##### 写在前面\n在做一个前后端分离项目, 需要自己搭建后端, 此文章记录我艰辛的填坑之路\n\n* idea 16版本里terminal的git commit\ngit commit -m '不能用单引号', 报错. 用双引号即可\n\n* 安装gem. 国内gem被和谐掉, 需要代替原镜像源报错\nError fetching https://ruby.taobao.org/: 原因是taobao gems 源已经下架, 需要换成http://gems.ruby-china.org/\n\n* yum和apt-get\ncentos下是yum, ubuntu才是apt-get, 看到apt-get命令找不到不要怀疑自己, 可能只是系统不一样\n\n<!-- more -->\n\n* gem安装报错Error installing xxx:\n这是因为装了ruby没装ruby-devel, 再装个ruby-devel即可\n\n* gem安装指定版本\n和yum, npm 不一样, gem不是通过@来指定, 是gem install xxx -v 版本号\n\n* db.driverLocation在windows下的小问题\ndb.driverLocation: windows下路径 '\\'需要转义 如 E:\\\\xxx,或 E:/也行. 另外文件名后缀要补全, 笔者就是因为双击文件名复制导致'.jar'没有复制上, 疯狂报错(uri is not registered).\n\n* node-sass安装\n十分坑, 用registry淘宝源没用, 会提示转回node的git地址下载. 经查询才知道需要 SASS_BINARY_SITE=https://npm.taobao.org/mirrors/node-sass/ npm install node-sass@版本号\n\n* ftp远程连接500 oops\n1. 在安装了ftp的前提下, 需确认服务器的防火墙没有关掉20,21端口. 这里提一句, 安装ftp前要确定没有原本有无ftp, 不然你会start ftp一直失败, 原因是已经有一个ftp版本占据了21端口. 言归正传, 进入iptables看有没关掉端口, 改完需重启防火墙.\n2. 端口开启, 这时候要检查下ftp账号是不是有误.\n3. 账号无误, 去nginx配置文件看是不是路径有问题.\n\n* sql-where语句\n如果是多个条件语句的话, 不能用逗号分隔, 只能用 'and' , 不然会报语法错误.\n\n* java.lang.NoSuchMethodException: com.mmall.pojo.User.(init)\n很迷的错误, 网上都是说加个无参构造即可, 如下. 可是情况是已经有无参构造还报错, 最后是把无参里面的注释全部删掉, 即可?..\n```java\npublic class User{\n  ...\n  public User() {\n    super();\n  }\n  ...\n}\n```\n\n* 500错误 Unknown column 'xxx' in 'field list';\n两个原因会导致, 一可能是因为表没有这个xxx这个字段, 其二则为表字段顺序要和插入表的顺序一致.\n\n* Your local changes to the following files would be overwritten by merge:\ngit pull时发生错误, 原因是在本地有修改过文件, git不知道该不该覆盖.\n1. 如果打算覆盖, 可以git reset --hard 上个版本, 然后再 git pull\n2. 或者git stash后再git pull\n\n* Column 'id' cannot be null\n数据表的id不能自增, 由于不小心用navicat修改了id的类型, 导致错误. 确定不是后端出错后, 重新导入一张新表, 错误解决.\n\n\n* 前后端分离, 后端成功测试接口方法, 前端测试却400错误\n原因是因为前端传输过来的数值不能使用Integer来接收, 可以将相应的字段类型改成BigDecimal, 因为前端表单传输即使写的是数字传递时也会变成String字符串, eg: \"level\":5 => \"level\": \"5\". 导致后端存不了数值报错.\n\n* npm ERR! code ELIFECYCLE\nnpm run dist时候报错, 原因可能是因为node_modules里面有东西更新, 解决方法是把整个文件夹删掉, 清除缓存npm cache clean, 再安装一遍即可. 网上也有说法是权限不够.\n```html\n12 error Linux 2.6.32-642.6.2.el6.x86_64\n13 error argv \"/usr/local/node-v4.4.7-linux-x64/bin/node\" \"/usr/local/node-v4.4.7-linux-x64/bin/npm\" \"run\" \"dist\"\n14 error node v4.4.7\n15 error npm  v2.15.8\n16 error code ELIFECYCLE\n17 error admin-fe@1.0.0 dist: `WEBPACK_ENV=online webpack -p`\n17 error Exit status 2\n18 error Failed at the admin-fe@1.0.0 dist script 'WEBPACK_ENV=online webpack -p'.\n18 error This is most likely a problem with the admin-fe package,\n18 error not with npm itself.\n...\n```\n\n* 脚本的编写以及脚本快捷执行\n每次上线一次新的版本都要经过繁琐的行行代码执行, 解放双手的目的是必须的. 编写sh文件就是一种解放方式, 但是每次都需要进入对应的文件夹执行是不爽的事. \n可以进用户根目录的.bash_profile文件, 给对应的脚本赋值一个名字, 以后便可以在任何地方执行脚本\n```javascript\ncd ~\nvim .bash_profile\n// .bash_profile\nalias '名字'='脚本完整路径'\n```\n保存退出即可在命令行输入'名字'直接运行脚本\n\n* 测试url映射报错\nError parsing HTTP request header\n原因是http, 我测试时蠢了, 写成https.. 查阅了资料, 也有可能是tomcat版本不一致会导致 需注意. \n\n* 更新数据表时候报错\nDuplicate entry 'xxx'(id) for key 'PRIMARY'\n原因是使用insert into了又一次id, 使用update即可解决\n\n* 服务器npm run build/dist目的文件夹时候无法运行完, 中途被Killed\n还有安装package.json里的依赖的时候也会被Killed, webpack打包也会被Killed. 我猜想应该是服务器内存不够被迫中止. 解决方法是在根目录的opt文件夹下新建一个swap文件夹\n```linux\ncd /opt \nopt mkdir swap\ncd swap\n(sudo) dd if=/dev/zero of=swapfile bs=1M count=1024\nmkswap swapfile \nswapon swapfile \n```\n\n* Unexpected token < in JSON at position 0\n没解决, 网上有说是fileheader注释头应该去掉, 因为json本身不支持注释. 我去掉了注释还是不行, 解决掉下一个错误后, 该错误也神奇消失\n\n* java.io.filenotfoundexception: 路径 (permission denied)\n原因是 报错路径 的所属文件夹的权限不够, 更改一下当前的所属用户就可以了\n\n* MySQL check the manual that corresponds to your MySQL server version for the right syntax错误\n如果语法检查得很仔细, 感觉没错的话, 就要好好看看是否你的字段用到了关键字, 我用了desc(description描述)来充当描述字段, 结果报这个错误\n\n* MySQL check the manual that corresponds to your MySQL server version for the right syntax错误(二)\n可能是sql语句最后一句多加了个逗号\n\n* 低版本ie或360兼容模式报错\n'Promise未定义', 这样因为低版本ie不支持es6语法, 安装依赖babel-polyfill, 导入即可\n\n* vim 一个文件时 提示修改不成功\n会出现\"can't open file for writing\", 原因有两个  \n1.当前用户的权限不足, 解决方法是打开是加上sudo即可\n2.此文件可能正被其他程序或用户使用, 稍等片刻\n\n* 405 Method Not Allowed\n方法不被允许, 可能是接口方法指定post, 而你默认用get\n\n* 传值出现java lang错误\njava.lang.NullPointerException, 没有判断空的情况, 可能是参数名传错了, 比如userId, 前端发送id过来.\n\n* ftp转图片出现553 Could not create file\n可能是因为传输的目的文件权限不够.\n\n* 查询数据库时的问题\n1. 比如查询关键字+省市区, 当省市区为空时, 查询所有有关键字的列表出来, 在where查询里加上\n```JavaScript\n<if test=\"province!=null\">\n  and province = #{province}\n</if>\n```\n2. 虽然上面解决了只需要写一个方法的问题, 但是前端传值过来, 还是不能成功显示. 因为方法是get方法, 所传值会在url一起带回. 初步认为是 传回的省市区是空字符串不是null, 于是在前端加上( || null), 还是失败告终; 最后得知上述的if里面test可以多加条件语句, 加上 province != '' 即可!","source":"_posts/我搭建java后台遇到的一些难题.md","raw":"---\ntitle: 我搭建java后台遇到的一些难题\ndate: 2017-11-23 23:53:07\ntags: [JAVA,后端]\n---\n##### 写在前面\n在做一个前后端分离项目, 需要自己搭建后端, 此文章记录我艰辛的填坑之路\n\n* idea 16版本里terminal的git commit\ngit commit -m '不能用单引号', 报错. 用双引号即可\n\n* 安装gem. 国内gem被和谐掉, 需要代替原镜像源报错\nError fetching https://ruby.taobao.org/: 原因是taobao gems 源已经下架, 需要换成http://gems.ruby-china.org/\n\n* yum和apt-get\ncentos下是yum, ubuntu才是apt-get, 看到apt-get命令找不到不要怀疑自己, 可能只是系统不一样\n\n<!-- more -->\n\n* gem安装报错Error installing xxx:\n这是因为装了ruby没装ruby-devel, 再装个ruby-devel即可\n\n* gem安装指定版本\n和yum, npm 不一样, gem不是通过@来指定, 是gem install xxx -v 版本号\n\n* db.driverLocation在windows下的小问题\ndb.driverLocation: windows下路径 '\\'需要转义 如 E:\\\\xxx,或 E:/也行. 另外文件名后缀要补全, 笔者就是因为双击文件名复制导致'.jar'没有复制上, 疯狂报错(uri is not registered).\n\n* node-sass安装\n十分坑, 用registry淘宝源没用, 会提示转回node的git地址下载. 经查询才知道需要 SASS_BINARY_SITE=https://npm.taobao.org/mirrors/node-sass/ npm install node-sass@版本号\n\n* ftp远程连接500 oops\n1. 在安装了ftp的前提下, 需确认服务器的防火墙没有关掉20,21端口. 这里提一句, 安装ftp前要确定没有原本有无ftp, 不然你会start ftp一直失败, 原因是已经有一个ftp版本占据了21端口. 言归正传, 进入iptables看有没关掉端口, 改完需重启防火墙.\n2. 端口开启, 这时候要检查下ftp账号是不是有误.\n3. 账号无误, 去nginx配置文件看是不是路径有问题.\n\n* sql-where语句\n如果是多个条件语句的话, 不能用逗号分隔, 只能用 'and' , 不然会报语法错误.\n\n* java.lang.NoSuchMethodException: com.mmall.pojo.User.(init)\n很迷的错误, 网上都是说加个无参构造即可, 如下. 可是情况是已经有无参构造还报错, 最后是把无参里面的注释全部删掉, 即可?..\n```java\npublic class User{\n  ...\n  public User() {\n    super();\n  }\n  ...\n}\n```\n\n* 500错误 Unknown column 'xxx' in 'field list';\n两个原因会导致, 一可能是因为表没有这个xxx这个字段, 其二则为表字段顺序要和插入表的顺序一致.\n\n* Your local changes to the following files would be overwritten by merge:\ngit pull时发生错误, 原因是在本地有修改过文件, git不知道该不该覆盖.\n1. 如果打算覆盖, 可以git reset --hard 上个版本, 然后再 git pull\n2. 或者git stash后再git pull\n\n* Column 'id' cannot be null\n数据表的id不能自增, 由于不小心用navicat修改了id的类型, 导致错误. 确定不是后端出错后, 重新导入一张新表, 错误解决.\n\n\n* 前后端分离, 后端成功测试接口方法, 前端测试却400错误\n原因是因为前端传输过来的数值不能使用Integer来接收, 可以将相应的字段类型改成BigDecimal, 因为前端表单传输即使写的是数字传递时也会变成String字符串, eg: \"level\":5 => \"level\": \"5\". 导致后端存不了数值报错.\n\n* npm ERR! code ELIFECYCLE\nnpm run dist时候报错, 原因可能是因为node_modules里面有东西更新, 解决方法是把整个文件夹删掉, 清除缓存npm cache clean, 再安装一遍即可. 网上也有说法是权限不够.\n```html\n12 error Linux 2.6.32-642.6.2.el6.x86_64\n13 error argv \"/usr/local/node-v4.4.7-linux-x64/bin/node\" \"/usr/local/node-v4.4.7-linux-x64/bin/npm\" \"run\" \"dist\"\n14 error node v4.4.7\n15 error npm  v2.15.8\n16 error code ELIFECYCLE\n17 error admin-fe@1.0.0 dist: `WEBPACK_ENV=online webpack -p`\n17 error Exit status 2\n18 error Failed at the admin-fe@1.0.0 dist script 'WEBPACK_ENV=online webpack -p'.\n18 error This is most likely a problem with the admin-fe package,\n18 error not with npm itself.\n...\n```\n\n* 脚本的编写以及脚本快捷执行\n每次上线一次新的版本都要经过繁琐的行行代码执行, 解放双手的目的是必须的. 编写sh文件就是一种解放方式, 但是每次都需要进入对应的文件夹执行是不爽的事. \n可以进用户根目录的.bash_profile文件, 给对应的脚本赋值一个名字, 以后便可以在任何地方执行脚本\n```javascript\ncd ~\nvim .bash_profile\n// .bash_profile\nalias '名字'='脚本完整路径'\n```\n保存退出即可在命令行输入'名字'直接运行脚本\n\n* 测试url映射报错\nError parsing HTTP request header\n原因是http, 我测试时蠢了, 写成https.. 查阅了资料, 也有可能是tomcat版本不一致会导致 需注意. \n\n* 更新数据表时候报错\nDuplicate entry 'xxx'(id) for key 'PRIMARY'\n原因是使用insert into了又一次id, 使用update即可解决\n\n* 服务器npm run build/dist目的文件夹时候无法运行完, 中途被Killed\n还有安装package.json里的依赖的时候也会被Killed, webpack打包也会被Killed. 我猜想应该是服务器内存不够被迫中止. 解决方法是在根目录的opt文件夹下新建一个swap文件夹\n```linux\ncd /opt \nopt mkdir swap\ncd swap\n(sudo) dd if=/dev/zero of=swapfile bs=1M count=1024\nmkswap swapfile \nswapon swapfile \n```\n\n* Unexpected token < in JSON at position 0\n没解决, 网上有说是fileheader注释头应该去掉, 因为json本身不支持注释. 我去掉了注释还是不行, 解决掉下一个错误后, 该错误也神奇消失\n\n* java.io.filenotfoundexception: 路径 (permission denied)\n原因是 报错路径 的所属文件夹的权限不够, 更改一下当前的所属用户就可以了\n\n* MySQL check the manual that corresponds to your MySQL server version for the right syntax错误\n如果语法检查得很仔细, 感觉没错的话, 就要好好看看是否你的字段用到了关键字, 我用了desc(description描述)来充当描述字段, 结果报这个错误\n\n* MySQL check the manual that corresponds to your MySQL server version for the right syntax错误(二)\n可能是sql语句最后一句多加了个逗号\n\n* 低版本ie或360兼容模式报错\n'Promise未定义', 这样因为低版本ie不支持es6语法, 安装依赖babel-polyfill, 导入即可\n\n* vim 一个文件时 提示修改不成功\n会出现\"can't open file for writing\", 原因有两个  \n1.当前用户的权限不足, 解决方法是打开是加上sudo即可\n2.此文件可能正被其他程序或用户使用, 稍等片刻\n\n* 405 Method Not Allowed\n方法不被允许, 可能是接口方法指定post, 而你默认用get\n\n* 传值出现java lang错误\njava.lang.NullPointerException, 没有判断空的情况, 可能是参数名传错了, 比如userId, 前端发送id过来.\n\n* ftp转图片出现553 Could not create file\n可能是因为传输的目的文件权限不够.\n\n* 查询数据库时的问题\n1. 比如查询关键字+省市区, 当省市区为空时, 查询所有有关键字的列表出来, 在where查询里加上\n```JavaScript\n<if test=\"province!=null\">\n  and province = #{province}\n</if>\n```\n2. 虽然上面解决了只需要写一个方法的问题, 但是前端传值过来, 还是不能成功显示. 因为方法是get方法, 所传值会在url一起带回. 初步认为是 传回的省市区是空字符串不是null, 于是在前端加上( || null), 还是失败告终; 最后得知上述的if里面test可以多加条件语句, 加上 province != '' 即可!","slug":"我搭建java后台遇到的一些难题","published":1,"updated":"2021-07-02T03:20:30.661Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl5sb8gf8000xxq0rkp8fld5z","content":"<h5 id=\"写在前面\"><a href=\"#写在前面\" class=\"headerlink\" title=\"写在前面\"></a>写在前面</h5><p>在做一个前后端分离项目, 需要自己搭建后端, 此文章记录我艰辛的填坑之路</p>\n<ul>\n<li><p>idea 16版本里terminal的git commit<br>git commit -m ‘不能用单引号’, 报错. 用双引号即可</p>\n</li>\n<li><p>安装gem. 国内gem被和谐掉, 需要代替原镜像源报错<br>Error fetching <a href=\"https://ruby.taobao.org/\" target=\"_blank\" rel=\"noopener\">https://ruby.taobao.org/</a>: 原因是taobao gems 源已经下架, 需要换成<a href=\"http://gems.ruby-china.org/\" target=\"_blank\" rel=\"noopener\">http://gems.ruby-china.org/</a></p>\n</li>\n<li><p>yum和apt-get<br>centos下是yum, ubuntu才是apt-get, 看到apt-get命令找不到不要怀疑自己, 可能只是系统不一样</p>\n</li>\n</ul>\n<a id=\"more\"></a>\n\n<ul>\n<li><p>gem安装报错Error installing xxx:<br>这是因为装了ruby没装ruby-devel, 再装个ruby-devel即可</p>\n</li>\n<li><p>gem安装指定版本<br>和yum, npm 不一样, gem不是通过@来指定, 是gem install xxx -v 版本号</p>\n</li>\n<li><p>db.driverLocation在windows下的小问题<br>db.driverLocation: windows下路径 ‘&#39;需要转义 如 E:\\xxx,或 E:/也行. 另外文件名后缀要补全, 笔者就是因为双击文件名复制导致’.jar’没有复制上, 疯狂报错(uri is not registered).</p>\n</li>\n<li><p>node-sass安装<br>十分坑, 用registry淘宝源没用, 会提示转回node的git地址下载. 经查询才知道需要 SASS_BINARY_SITE=<a href=\"https://npm.taobao.org/mirrors/node-sass/\" target=\"_blank\" rel=\"noopener\">https://npm.taobao.org/mirrors/node-sass/</a> npm install node-sass@版本号</p>\n</li>\n<li><p>ftp远程连接500 oops</p>\n</li>\n</ul>\n<ol>\n<li>在安装了ftp的前提下, 需确认服务器的防火墙没有关掉20,21端口. 这里提一句, 安装ftp前要确定没有原本有无ftp, 不然你会start ftp一直失败, 原因是已经有一个ftp版本占据了21端口. 言归正传, 进入iptables看有没关掉端口, 改完需重启防火墙.</li>\n<li>端口开启, 这时候要检查下ftp账号是不是有误.</li>\n<li>账号无误, 去nginx配置文件看是不是路径有问题.</li>\n</ol>\n<ul>\n<li><p>sql-where语句<br>如果是多个条件语句的话, 不能用逗号分隔, 只能用 ‘and’ , 不然会报语法错误.</p>\n</li>\n<li><p>java.lang.NoSuchMethodException: com.mmall.pojo.User.(init)<br>很迷的错误, 网上都是说加个无参构造即可, 如下. 可是情况是已经有无参构造还报错, 最后是把无参里面的注释全部删掉, 即可?..</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">User</span></span>&#123;</span><br><span class=\"line\">  ...</span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">User</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">super</span>();</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  ...</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>500错误 Unknown column ‘xxx’ in ‘field list’;<br>两个原因会导致, 一可能是因为表没有这个xxx这个字段, 其二则为表字段顺序要和插入表的顺序一致.</p>\n</li>\n<li><p>Your local changes to the following files would be overwritten by merge:<br>git pull时发生错误, 原因是在本地有修改过文件, git不知道该不该覆盖.</p>\n</li>\n</ul>\n<ol>\n<li>如果打算覆盖, 可以git reset –hard 上个版本, 然后再 git pull</li>\n<li>或者git stash后再git pull</li>\n</ol>\n<ul>\n<li>Column ‘id’ cannot be null<br>数据表的id不能自增, 由于不小心用navicat修改了id的类型, 导致错误. 确定不是后端出错后, 重新导入一张新表, 错误解决.</li>\n</ul>\n<ul>\n<li><p>前后端分离, 后端成功测试接口方法, 前端测试却400错误<br>原因是因为前端传输过来的数值不能使用Integer来接收, 可以将相应的字段类型改成BigDecimal, 因为前端表单传输即使写的是数字传递时也会变成String字符串, eg: “level”:5 =&gt; “level”: “5”. 导致后端存不了数值报错.</p>\n</li>\n<li><p>npm ERR! code ELIFECYCLE<br>npm run dist时候报错, 原因可能是因为node_modules里面有东西更新, 解决方法是把整个文件夹删掉, 清除缓存npm cache clean, 再安装一遍即可. 网上也有说法是权限不够.</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">12 error Linux 2.6.32-642.6.2.el6.x86_64</span><br><span class=\"line\">13 error argv \"/usr/local/node-v4.4.7-linux-x64/bin/node\" \"/usr/local/node-v4.4.7-linux-x64/bin/npm\" \"run\" \"dist\"</span><br><span class=\"line\">14 error node v4.4.7</span><br><span class=\"line\">15 error npm  v2.15.8</span><br><span class=\"line\">16 error code ELIFECYCLE</span><br><span class=\"line\">17 error admin-fe@1.0.0 dist: `WEBPACK_ENV=online webpack -p`</span><br><span class=\"line\">17 error Exit status 2</span><br><span class=\"line\">18 error Failed at the admin-fe@1.0.0 dist script 'WEBPACK_ENV=online webpack -p'.</span><br><span class=\"line\">18 error This is most likely a problem with the admin-fe package,</span><br><span class=\"line\">18 error not with npm itself.</span><br><span class=\"line\">...</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>脚本的编写以及脚本快捷执行<br>每次上线一次新的版本都要经过繁琐的行行代码执行, 解放双手的目的是必须的. 编写sh文件就是一种解放方式, 但是每次都需要进入对应的文件夹执行是不爽的事.<br>可以进用户根目录的.bash_profile文件, 给对应的脚本赋值一个名字, 以后便可以在任何地方执行脚本</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">cd ~</span><br><span class=\"line\">vim .bash_profile</span><br><span class=\"line\"><span class=\"comment\">// .bash_profile</span></span><br><span class=\"line\">alias <span class=\"string\">'名字'</span>=<span class=\"string\">'脚本完整路径'</span></span><br></pre></td></tr></table></figure>\n\n</li>\n</ul>\n<p>保存退出即可在命令行输入’名字’直接运行脚本</p>\n<ul>\n<li><p>测试url映射报错<br>Error parsing HTTP request header<br>原因是http, 我测试时蠢了, 写成https.. 查阅了资料, 也有可能是tomcat版本不一致会导致 需注意. </p>\n</li>\n<li><p>更新数据表时候报错<br>Duplicate entry ‘xxx’(id) for key ‘PRIMARY’<br>原因是使用insert into了又一次id, 使用update即可解决</p>\n</li>\n<li><p>服务器npm run build/dist目的文件夹时候无法运行完, 中途被Killed<br>还有安装package.json里的依赖的时候也会被Killed, webpack打包也会被Killed. 我猜想应该是服务器内存不够被迫中止. 解决方法是在根目录的opt文件夹下新建一个swap文件夹</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">cd /opt </span><br><span class=\"line\">opt mkdir swap</span><br><span class=\"line\">cd swap</span><br><span class=\"line\">(sudo) dd if=/dev/zero of=swapfile bs=1M count=1024</span><br><span class=\"line\">mkswap swapfile </span><br><span class=\"line\">swapon swapfile</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>Unexpected token &lt; in JSON at position 0<br>没解决, 网上有说是fileheader注释头应该去掉, 因为json本身不支持注释. 我去掉了注释还是不行, 解决掉下一个错误后, 该错误也神奇消失</p>\n</li>\n<li><p>java.io.filenotfoundexception: 路径 (permission denied)<br>原因是 报错路径 的所属文件夹的权限不够, 更改一下当前的所属用户就可以了</p>\n</li>\n<li><p>MySQL check the manual that corresponds to your MySQL server version for the right syntax错误<br>如果语法检查得很仔细, 感觉没错的话, 就要好好看看是否你的字段用到了关键字, 我用了desc(description描述)来充当描述字段, 结果报这个错误</p>\n</li>\n<li><p>MySQL check the manual that corresponds to your MySQL server version for the right syntax错误(二)<br>可能是sql语句最后一句多加了个逗号</p>\n</li>\n<li><p>低版本ie或360兼容模式报错<br>‘Promise未定义’, 这样因为低版本ie不支持es6语法, 安装依赖babel-polyfill, 导入即可</p>\n</li>\n<li><p>vim 一个文件时 提示修改不成功<br>会出现”can’t open file for writing”, 原因有两个  </p>\n</li>\n</ul>\n<p>1.当前用户的权限不足, 解决方法是打开是加上sudo即可<br>2.此文件可能正被其他程序或用户使用, 稍等片刻</p>\n<ul>\n<li><p>405 Method Not Allowed<br>方法不被允许, 可能是接口方法指定post, 而你默认用get</p>\n</li>\n<li><p>传值出现java lang错误<br>java.lang.NullPointerException, 没有判断空的情况, 可能是参数名传错了, 比如userId, 前端发送id过来.</p>\n</li>\n<li><p>ftp转图片出现553 Could not create file<br>可能是因为传输的目的文件权限不够.</p>\n</li>\n<li><p>查询数据库时的问题</p>\n</li>\n</ul>\n<ol>\n<li><p>比如查询关键字+省市区, 当省市区为空时, 查询所有有关键字的列表出来, 在where查询里加上</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;<span class=\"keyword\">if</span> test=<span class=\"string\">\"province!=null\"</span>&gt;</span><br><span class=\"line\">  and province = #&#123;province&#125;</span><br><span class=\"line\">&lt;<span class=\"regexp\">/if&gt;</span></span><br></pre></td></tr></table></figure>\n</li>\n<li><p>虽然上面解决了只需要写一个方法的问题, 但是前端传值过来, 还是不能成功显示. 因为方法是get方法, 所传值会在url一起带回. 初步认为是 传回的省市区是空字符串不是null, 于是在前端加上( || null), 还是失败告终; 最后得知上述的if里面test可以多加条件语句, 加上 province != ‘’ 即可!</p>\n</li>\n</ol>\n","site":{"data":{}},"excerpt":"<h5 id=\"写在前面\"><a href=\"#写在前面\" class=\"headerlink\" title=\"写在前面\"></a>写在前面</h5><p>在做一个前后端分离项目, 需要自己搭建后端, 此文章记录我艰辛的填坑之路</p>\n<ul>\n<li><p>idea 16版本里terminal的git commit<br>git commit -m ‘不能用单引号’, 报错. 用双引号即可</p>\n</li>\n<li><p>安装gem. 国内gem被和谐掉, 需要代替原镜像源报错<br>Error fetching <a href=\"https://ruby.taobao.org/\" target=\"_blank\" rel=\"noopener\">https://ruby.taobao.org/</a>: 原因是taobao gems 源已经下架, 需要换成<a href=\"http://gems.ruby-china.org/\" target=\"_blank\" rel=\"noopener\">http://gems.ruby-china.org/</a></p>\n</li>\n<li><p>yum和apt-get<br>centos下是yum, ubuntu才是apt-get, 看到apt-get命令找不到不要怀疑自己, 可能只是系统不一样</p>\n</li>\n</ul>","more":"<ul>\n<li><p>gem安装报错Error installing xxx:<br>这是因为装了ruby没装ruby-devel, 再装个ruby-devel即可</p>\n</li>\n<li><p>gem安装指定版本<br>和yum, npm 不一样, gem不是通过@来指定, 是gem install xxx -v 版本号</p>\n</li>\n<li><p>db.driverLocation在windows下的小问题<br>db.driverLocation: windows下路径 ‘&#39;需要转义 如 E:\\xxx,或 E:/也行. 另外文件名后缀要补全, 笔者就是因为双击文件名复制导致’.jar’没有复制上, 疯狂报错(uri is not registered).</p>\n</li>\n<li><p>node-sass安装<br>十分坑, 用registry淘宝源没用, 会提示转回node的git地址下载. 经查询才知道需要 SASS_BINARY_SITE=<a href=\"https://npm.taobao.org/mirrors/node-sass/\" target=\"_blank\" rel=\"noopener\">https://npm.taobao.org/mirrors/node-sass/</a> npm install node-sass@版本号</p>\n</li>\n<li><p>ftp远程连接500 oops</p>\n</li>\n</ul>\n<ol>\n<li>在安装了ftp的前提下, 需确认服务器的防火墙没有关掉20,21端口. 这里提一句, 安装ftp前要确定没有原本有无ftp, 不然你会start ftp一直失败, 原因是已经有一个ftp版本占据了21端口. 言归正传, 进入iptables看有没关掉端口, 改完需重启防火墙.</li>\n<li>端口开启, 这时候要检查下ftp账号是不是有误.</li>\n<li>账号无误, 去nginx配置文件看是不是路径有问题.</li>\n</ol>\n<ul>\n<li><p>sql-where语句<br>如果是多个条件语句的话, 不能用逗号分隔, 只能用 ‘and’ , 不然会报语法错误.</p>\n</li>\n<li><p>java.lang.NoSuchMethodException: com.mmall.pojo.User.(init)<br>很迷的错误, 网上都是说加个无参构造即可, 如下. 可是情况是已经有无参构造还报错, 最后是把无参里面的注释全部删掉, 即可?..</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">User</span></span>&#123;</span><br><span class=\"line\">  ...</span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">User</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">super</span>();</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  ...</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>500错误 Unknown column ‘xxx’ in ‘field list’;<br>两个原因会导致, 一可能是因为表没有这个xxx这个字段, 其二则为表字段顺序要和插入表的顺序一致.</p>\n</li>\n<li><p>Your local changes to the following files would be overwritten by merge:<br>git pull时发生错误, 原因是在本地有修改过文件, git不知道该不该覆盖.</p>\n</li>\n</ul>\n<ol>\n<li>如果打算覆盖, 可以git reset –hard 上个版本, 然后再 git pull</li>\n<li>或者git stash后再git pull</li>\n</ol>\n<ul>\n<li>Column ‘id’ cannot be null<br>数据表的id不能自增, 由于不小心用navicat修改了id的类型, 导致错误. 确定不是后端出错后, 重新导入一张新表, 错误解决.</li>\n</ul>\n<ul>\n<li><p>前后端分离, 后端成功测试接口方法, 前端测试却400错误<br>原因是因为前端传输过来的数值不能使用Integer来接收, 可以将相应的字段类型改成BigDecimal, 因为前端表单传输即使写的是数字传递时也会变成String字符串, eg: “level”:5 =&gt; “level”: “5”. 导致后端存不了数值报错.</p>\n</li>\n<li><p>npm ERR! code ELIFECYCLE<br>npm run dist时候报错, 原因可能是因为node_modules里面有东西更新, 解决方法是把整个文件夹删掉, 清除缓存npm cache clean, 再安装一遍即可. 网上也有说法是权限不够.</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">12 error Linux 2.6.32-642.6.2.el6.x86_64</span><br><span class=\"line\">13 error argv \"/usr/local/node-v4.4.7-linux-x64/bin/node\" \"/usr/local/node-v4.4.7-linux-x64/bin/npm\" \"run\" \"dist\"</span><br><span class=\"line\">14 error node v4.4.7</span><br><span class=\"line\">15 error npm  v2.15.8</span><br><span class=\"line\">16 error code ELIFECYCLE</span><br><span class=\"line\">17 error admin-fe@1.0.0 dist: `WEBPACK_ENV=online webpack -p`</span><br><span class=\"line\">17 error Exit status 2</span><br><span class=\"line\">18 error Failed at the admin-fe@1.0.0 dist script 'WEBPACK_ENV=online webpack -p'.</span><br><span class=\"line\">18 error This is most likely a problem with the admin-fe package,</span><br><span class=\"line\">18 error not with npm itself.</span><br><span class=\"line\">...</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>脚本的编写以及脚本快捷执行<br>每次上线一次新的版本都要经过繁琐的行行代码执行, 解放双手的目的是必须的. 编写sh文件就是一种解放方式, 但是每次都需要进入对应的文件夹执行是不爽的事.<br>可以进用户根目录的.bash_profile文件, 给对应的脚本赋值一个名字, 以后便可以在任何地方执行脚本</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">cd ~</span><br><span class=\"line\">vim .bash_profile</span><br><span class=\"line\"><span class=\"comment\">// .bash_profile</span></span><br><span class=\"line\">alias <span class=\"string\">'名字'</span>=<span class=\"string\">'脚本完整路径'</span></span><br></pre></td></tr></table></figure>\n\n</li>\n</ul>\n<p>保存退出即可在命令行输入’名字’直接运行脚本</p>\n<ul>\n<li><p>测试url映射报错<br>Error parsing HTTP request header<br>原因是http, 我测试时蠢了, 写成https.. 查阅了资料, 也有可能是tomcat版本不一致会导致 需注意. </p>\n</li>\n<li><p>更新数据表时候报错<br>Duplicate entry ‘xxx’(id) for key ‘PRIMARY’<br>原因是使用insert into了又一次id, 使用update即可解决</p>\n</li>\n<li><p>服务器npm run build/dist目的文件夹时候无法运行完, 中途被Killed<br>还有安装package.json里的依赖的时候也会被Killed, webpack打包也会被Killed. 我猜想应该是服务器内存不够被迫中止. 解决方法是在根目录的opt文件夹下新建一个swap文件夹</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">cd /opt </span><br><span class=\"line\">opt mkdir swap</span><br><span class=\"line\">cd swap</span><br><span class=\"line\">(sudo) dd if=/dev/zero of=swapfile bs=1M count=1024</span><br><span class=\"line\">mkswap swapfile </span><br><span class=\"line\">swapon swapfile</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>Unexpected token &lt; in JSON at position 0<br>没解决, 网上有说是fileheader注释头应该去掉, 因为json本身不支持注释. 我去掉了注释还是不行, 解决掉下一个错误后, 该错误也神奇消失</p>\n</li>\n<li><p>java.io.filenotfoundexception: 路径 (permission denied)<br>原因是 报错路径 的所属文件夹的权限不够, 更改一下当前的所属用户就可以了</p>\n</li>\n<li><p>MySQL check the manual that corresponds to your MySQL server version for the right syntax错误<br>如果语法检查得很仔细, 感觉没错的话, 就要好好看看是否你的字段用到了关键字, 我用了desc(description描述)来充当描述字段, 结果报这个错误</p>\n</li>\n<li><p>MySQL check the manual that corresponds to your MySQL server version for the right syntax错误(二)<br>可能是sql语句最后一句多加了个逗号</p>\n</li>\n<li><p>低版本ie或360兼容模式报错<br>‘Promise未定义’, 这样因为低版本ie不支持es6语法, 安装依赖babel-polyfill, 导入即可</p>\n</li>\n<li><p>vim 一个文件时 提示修改不成功<br>会出现”can’t open file for writing”, 原因有两个  </p>\n</li>\n</ul>\n<p>1.当前用户的权限不足, 解决方法是打开是加上sudo即可<br>2.此文件可能正被其他程序或用户使用, 稍等片刻</p>\n<ul>\n<li><p>405 Method Not Allowed<br>方法不被允许, 可能是接口方法指定post, 而你默认用get</p>\n</li>\n<li><p>传值出现java lang错误<br>java.lang.NullPointerException, 没有判断空的情况, 可能是参数名传错了, 比如userId, 前端发送id过来.</p>\n</li>\n<li><p>ftp转图片出现553 Could not create file<br>可能是因为传输的目的文件权限不够.</p>\n</li>\n<li><p>查询数据库时的问题</p>\n</li>\n</ul>\n<ol>\n<li><p>比如查询关键字+省市区, 当省市区为空时, 查询所有有关键字的列表出来, 在where查询里加上</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;<span class=\"keyword\">if</span> test=<span class=\"string\">\"province!=null\"</span>&gt;</span><br><span class=\"line\">  and province = #&#123;province&#125;</span><br><span class=\"line\">&lt;<span class=\"regexp\">/if&gt;</span></span><br></pre></td></tr></table></figure>\n</li>\n<li><p>虽然上面解决了只需要写一个方法的问题, 但是前端传值过来, 还是不能成功显示. 因为方法是get方法, 所传值会在url一起带回. 初步认为是 传回的省市区是空字符串不是null, 于是在前端加上( || null), 还是失败告终; 最后得知上述的if里面test可以多加条件语句, 加上 province != ‘’ 即可!</p>\n</li>\n</ol>"},{"title":"我花三个月汉化了一个文档","date":"2020-08-24T09:41:10.000Z","_content":"\n##### 写在前面\n\n我汉化的是空间分析库 Turf.js。主要用来实现空间几何 GeoJSON 的距离面积计算、关系判断等等。该库是国外团队研发，目前没有中文版本。每次需要查阅时都比较困难，想到还有其他同学也受此困扰，我决定汉化该文档。一来汉化后大家可以受益，二来我也能在汉化的过程中学习 Turf 的所有方法，同时标注出我在学习过程中值得注意的点，避免大家踩坑\n\n#### 汉化文档地址\n\n- [汉化文档地址](https://psilocine.github.io/turfjs-docs-Zh-CN/)\n\nTurf 是模块化的地理空间分析工具库。涵盖空间几何图形的测量、关系判断、坐标变换和偏移、辅助方法等具体场景，功能强大，模块化按需引入。\n\n但是 Turf 暂时没有中文文档，且官方文档冗长，对英语水平不高的同学不太友好。\n\n本项目的初衷是帮助想使用或者正在使用经常查阅 Turf 的同学提供一个中文版本的文档，方便大家学习和快速定位，提高效率。\n\n对于想使用 Turf 的同学来说，学习 GeoJSON 的格式是必须的，还不熟悉的同学请自行学习。下述是部分参考链接：\n\n- [w3cschool 入门](https://www.w3cschool.cn/doc_rethinkdb_java/rethinkdb_java-api-java-geojson-index.html)\n\n- [在线绘制 GeoJSON](http://geojson.io/#map=2/20.0/0.0)\n\n#### 建议反馈\n\n- 在 [turfjs-docs-Zh-CN](https://github.com/Psilocine/turfjs-docs-Zh-CN) 仓库上提出 issue\n- 邮件发送至 `psilolau@foxmail.com`\n\n#### 官方文档\n\n- [Turf.js | Advanced geospatial analysis](http://turfjs.org/)\n\n#### todo\n\n文档框架是用 vuepress 搭建，官方文档每个方法右侧有地图 demo，目前 vuepress 暂时没有该类型插件。\n","source":"_posts/我花三个月汉化了一个文档.md","raw":"---\ntitle: 我花三个月汉化了一个文档\ndate: 2020-08-24 17:41:10\ntags: [前端, JS]\n---\n\n##### 写在前面\n\n我汉化的是空间分析库 Turf.js。主要用来实现空间几何 GeoJSON 的距离面积计算、关系判断等等。该库是国外团队研发，目前没有中文版本。每次需要查阅时都比较困难，想到还有其他同学也受此困扰，我决定汉化该文档。一来汉化后大家可以受益，二来我也能在汉化的过程中学习 Turf 的所有方法，同时标注出我在学习过程中值得注意的点，避免大家踩坑\n\n#### 汉化文档地址\n\n- [汉化文档地址](https://psilocine.github.io/turfjs-docs-Zh-CN/)\n\nTurf 是模块化的地理空间分析工具库。涵盖空间几何图形的测量、关系判断、坐标变换和偏移、辅助方法等具体场景，功能强大，模块化按需引入。\n\n但是 Turf 暂时没有中文文档，且官方文档冗长，对英语水平不高的同学不太友好。\n\n本项目的初衷是帮助想使用或者正在使用经常查阅 Turf 的同学提供一个中文版本的文档，方便大家学习和快速定位，提高效率。\n\n对于想使用 Turf 的同学来说，学习 GeoJSON 的格式是必须的，还不熟悉的同学请自行学习。下述是部分参考链接：\n\n- [w3cschool 入门](https://www.w3cschool.cn/doc_rethinkdb_java/rethinkdb_java-api-java-geojson-index.html)\n\n- [在线绘制 GeoJSON](http://geojson.io/#map=2/20.0/0.0)\n\n#### 建议反馈\n\n- 在 [turfjs-docs-Zh-CN](https://github.com/Psilocine/turfjs-docs-Zh-CN) 仓库上提出 issue\n- 邮件发送至 `psilolau@foxmail.com`\n\n#### 官方文档\n\n- [Turf.js | Advanced geospatial analysis](http://turfjs.org/)\n\n#### todo\n\n文档框架是用 vuepress 搭建，官方文档每个方法右侧有地图 demo，目前 vuepress 暂时没有该类型插件。\n","slug":"我花三个月汉化了一个文档","published":1,"updated":"2021-07-02T03:20:30.662Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl5sb8gf9000zxq0rhu8h0goy","content":"<h5 id=\"写在前面\"><a href=\"#写在前面\" class=\"headerlink\" title=\"写在前面\"></a>写在前面</h5><p>我汉化的是空间分析库 Turf.js。主要用来实现空间几何 GeoJSON 的距离面积计算、关系判断等等。该库是国外团队研发，目前没有中文版本。每次需要查阅时都比较困难，想到还有其他同学也受此困扰，我决定汉化该文档。一来汉化后大家可以受益，二来我也能在汉化的过程中学习 Turf 的所有方法，同时标注出我在学习过程中值得注意的点，避免大家踩坑</p>\n<h4 id=\"汉化文档地址\"><a href=\"#汉化文档地址\" class=\"headerlink\" title=\"汉化文档地址\"></a>汉化文档地址</h4><ul>\n<li><a href=\"https://psilocine.github.io/turfjs-docs-Zh-CN/\">汉化文档地址</a></li>\n</ul>\n<p>Turf 是模块化的地理空间分析工具库。涵盖空间几何图形的测量、关系判断、坐标变换和偏移、辅助方法等具体场景，功能强大，模块化按需引入。</p>\n<p>但是 Turf 暂时没有中文文档，且官方文档冗长，对英语水平不高的同学不太友好。</p>\n<p>本项目的初衷是帮助想使用或者正在使用经常查阅 Turf 的同学提供一个中文版本的文档，方便大家学习和快速定位，提高效率。</p>\n<p>对于想使用 Turf 的同学来说，学习 GeoJSON 的格式是必须的，还不熟悉的同学请自行学习。下述是部分参考链接：</p>\n<ul>\n<li><p><a href=\"https://www.w3cschool.cn/doc_rethinkdb_java/rethinkdb_java-api-java-geojson-index.html\" target=\"_blank\" rel=\"noopener\">w3cschool 入门</a></p>\n</li>\n<li><p><a href=\"http://geojson.io/#map=2/20.0/0.0\" target=\"_blank\" rel=\"noopener\">在线绘制 GeoJSON</a></p>\n</li>\n</ul>\n<h4 id=\"建议反馈\"><a href=\"#建议反馈\" class=\"headerlink\" title=\"建议反馈\"></a>建议反馈</h4><ul>\n<li>在 <a href=\"https://github.com/Psilocine/turfjs-docs-Zh-CN\" target=\"_blank\" rel=\"noopener\">turfjs-docs-Zh-CN</a> 仓库上提出 issue</li>\n<li>邮件发送至 <code>psilolau@foxmail.com</code></li>\n</ul>\n<h4 id=\"官方文档\"><a href=\"#官方文档\" class=\"headerlink\" title=\"官方文档\"></a>官方文档</h4><ul>\n<li><a href=\"http://turfjs.org/\" target=\"_blank\" rel=\"noopener\">Turf.js | Advanced geospatial analysis</a></li>\n</ul>\n<h4 id=\"todo\"><a href=\"#todo\" class=\"headerlink\" title=\"todo\"></a>todo</h4><p>文档框架是用 vuepress 搭建，官方文档每个方法右侧有地图 demo，目前 vuepress 暂时没有该类型插件。</p>\n","site":{"data":{}},"excerpt":"","more":"<h5 id=\"写在前面\"><a href=\"#写在前面\" class=\"headerlink\" title=\"写在前面\"></a>写在前面</h5><p>我汉化的是空间分析库 Turf.js。主要用来实现空间几何 GeoJSON 的距离面积计算、关系判断等等。该库是国外团队研发，目前没有中文版本。每次需要查阅时都比较困难，想到还有其他同学也受此困扰，我决定汉化该文档。一来汉化后大家可以受益，二来我也能在汉化的过程中学习 Turf 的所有方法，同时标注出我在学习过程中值得注意的点，避免大家踩坑</p>\n<h4 id=\"汉化文档地址\"><a href=\"#汉化文档地址\" class=\"headerlink\" title=\"汉化文档地址\"></a>汉化文档地址</h4><ul>\n<li><a href=\"https://psilocine.github.io/turfjs-docs-Zh-CN/\">汉化文档地址</a></li>\n</ul>\n<p>Turf 是模块化的地理空间分析工具库。涵盖空间几何图形的测量、关系判断、坐标变换和偏移、辅助方法等具体场景，功能强大，模块化按需引入。</p>\n<p>但是 Turf 暂时没有中文文档，且官方文档冗长，对英语水平不高的同学不太友好。</p>\n<p>本项目的初衷是帮助想使用或者正在使用经常查阅 Turf 的同学提供一个中文版本的文档，方便大家学习和快速定位，提高效率。</p>\n<p>对于想使用 Turf 的同学来说，学习 GeoJSON 的格式是必须的，还不熟悉的同学请自行学习。下述是部分参考链接：</p>\n<ul>\n<li><p><a href=\"https://www.w3cschool.cn/doc_rethinkdb_java/rethinkdb_java-api-java-geojson-index.html\" target=\"_blank\" rel=\"noopener\">w3cschool 入门</a></p>\n</li>\n<li><p><a href=\"http://geojson.io/#map=2/20.0/0.0\" target=\"_blank\" rel=\"noopener\">在线绘制 GeoJSON</a></p>\n</li>\n</ul>\n<h4 id=\"建议反馈\"><a href=\"#建议反馈\" class=\"headerlink\" title=\"建议反馈\"></a>建议反馈</h4><ul>\n<li>在 <a href=\"https://github.com/Psilocine/turfjs-docs-Zh-CN\" target=\"_blank\" rel=\"noopener\">turfjs-docs-Zh-CN</a> 仓库上提出 issue</li>\n<li>邮件发送至 <code>psilolau@foxmail.com</code></li>\n</ul>\n<h4 id=\"官方文档\"><a href=\"#官方文档\" class=\"headerlink\" title=\"官方文档\"></a>官方文档</h4><ul>\n<li><a href=\"http://turfjs.org/\" target=\"_blank\" rel=\"noopener\">Turf.js | Advanced geospatial analysis</a></li>\n</ul>\n<h4 id=\"todo\"><a href=\"#todo\" class=\"headerlink\" title=\"todo\"></a>todo</h4><p>文档框架是用 vuepress 搭建，官方文档每个方法右侧有地图 demo，目前 vuepress 暂时没有该类型插件。</p>\n"},{"title":"我认为的Vue官方文档重点(2)","date":"2018-03-03T15:46:09.000Z","_content":"##### 写在前面\n文章大体会根据Vue官方文档(教程2.X)提供的学习路线\n本文从 进入/离开 & 列表过渡 -> 状态过渡\n\n### 进入/离开 & 列表过渡\n1.想要vue的过渡transition标签有效, 必须和下列其一搭配\n```html\n1. v-if（条件渲染）\n2. v-show（条件展示）\n3. 动态组件\n4. 在组建的根节点上，并且被vue实例DOM方法触发，如appendTo方法把组件添加到某个根节点上\n```\n\n2.过渡的类名, 会有6个class切换\n```JavaScript\n// 这里的v 是过渡标签name里的值 如 <transition name='fade'> 则为 fade-enter\n1. v-enter: 进入过渡的开始状态\n2. v-enter-active: 过渡的状态, 在元素整个过渡过程中作用\n3. v-enter-to: 进入过渡的结束状态\n4. v-leave: 离开过渡的开始状态\n5. v-leave-active: 过渡的状态, 在元素整个过渡过程中作用\n6. v-leave-to: 离开过渡的结束状态\n```\n<!-- more -->\n![transition](2_transition.jpg)\n如上图所示, 因此v-enter-to和v-leave定义时可以一块写, 如果你想方便一点的话\n```css\n<transition name=\"fade\">\n  <p v-if=\"show\">hello</p>\n</transition>\n\n/* 进入和离开都是一样的过渡效果 */\n.fade-enter-active,\n.fade-leave-active {\n  transition: all .3s ease;\n}\n\n/* 进入和离开结束的位置 */\n.fade-enter,\n.fade-leave-to {\n  transform: translateX(10px);\n  opacity: 0;\n}\n```\n\n3.自定义类名, 可以用于配合第三方css动画库, 如Animate.css\n```JavaScript\nenter-class\nenter-active-class\nenter-to-class\nleave-class\nleave-active-class\nleave-to-class\n\n<transition name='fade' \n            enter-active-class='animated tada'\n            leave-active-class='animated bounceOutRight'>\n```\n\n\n4.transition的v-bind:duration属性, 是显性的过渡持续时间, 设置时间如果比transition-duration大, 则按照原本的时间来, 如果小, 那按照duration的时间来\n```html\n<transition name='fade' :duration='1000'>\n```\n5.JavaScript钩子, 可以单独使用. 值得注意的是在 enter 和 leave 中, 回调函数 done 是必须的; 推荐对于仅使用 JavaScript 过渡的元素添加 v-bind:css=\"false\", Vue 会跳过 CSS 的检测. 这也可以避免过渡过程中 CSS 的影响\n```html\n<transition\n  v-on:before-enter=\"beforeEnter\"\n  v-on:enter=\"enter\"\n  v-on:after-enter=\"afterEnter\"\n  v-on:enter-cancelled=\"enterCancelled\"\n\n  v-on:before-leave=\"beforeLeave\"\n  v-on:leave=\"leave\"\n  v-on:after-leave=\"afterLeave\"\n  v-on:leave-cancelled=\"leaveCancelled\"\n>\n  <!-- ... -->\n</transition>\n\nmethods: {\n  beforeEnter: function (el) {\n    // ...\n  },\n  // 此回调函数是可选项的设置\n  // 与 CSS 结合时使用\n  enter: function (el, done) {\n    // ...\n    done()\n  },\n  afterEnter: function (el) {\n    // ...\n  },\n  enterCancelled: function (el) {\n    // ...\n  },\n  beforeLeave: function (el) {\n    // ...\n  },\n  // 此回调函数是可选项的设置\n  // 与 CSS 结合时使用\n  leave: function (el, done) {\n    // ...\n    done()\n  },\n  afterLeave: function (el) {\n    // ...\n  },\n  // leaveCancelled 只用于 v-show 中\n  leaveCancelled: function (el) {\n    // ...\n  }\n}\n```\n\n6.列表过渡, 使用transition-group组件, 结合v-for\n```html\n1. 可以通过tag特性更换为其他元素\n2. 内部元素总是需要提供唯一的key属性值\n<transition-group name='fade' tag='p'>\n  <span v-for='item in items' :key='item'>{{item}}</span>\n</transition-group>\n\n假设items是[0, 1, 2, 3], 则最终渲染出4个p标签\n```\n\n### 状态过渡\n针对数据元素本身的动效. 数字和运算, 颜色的显示, SVG节点的位置, 元素的大小和其他的属性. 可以结合第三方库来实现切换元素的过渡状态\n\n### 混入\n混入 (mixins) 是一种分发 Vue 组件中可复用功能的非常灵活的方式\n1.当组件和混入对象含有同名选项(data里的属性, methods里的方法, components里的组件, directives里的自定义指令)时, 组件数据覆盖混入对象数据\n```JavaScript\nvar mixin = {\n  data () {\n    return {\n      message: 'hello',\n      foo: 'abc'\n    }\n  },\n  methods: {\n    hello () {\n      console.log('from mixin')\n    }\n  }\n}\n\nvar vm = new Vue({\n  mixins: [mixin],\n  data () {\n    return {\n      message: 'no hello',\n    }\n  },\n  created () {\n    console.log(this.$data) // { message: 'no hello', foo: 'abc' } mixin的message属性被组件属性覆盖\n  },\n  methods: {\n    hello () {\n      console.log('from vue')\n    }\n  }\n})\n\nvm.hello() // 'from vue' // mixin的method被覆盖\n```\n\n### 自定义指令\n1.当页面加载时, 让一个元素获得焦点\n```html\n<input v-focus type='text' />\n\n// 全局注册\nVue.directive('focus', {\n  inserted (el) {\n    el.focus()\n  }\n})\n\n// 局部注册\nnew Vue({\n  ...,\n  directives: {\n    focus: {\n      inserted (el) {\n        el.focus()\n      }\n    }\n  }\n})\n```\n\n### 渲染函数 & JSX\n","source":"_posts/我认为的Vue官方文档重点-2.md","raw":"---\ntitle: 我认为的Vue官方文档重点(2)\ndate: 2018-03-03 23:46:09\ntags: [VUE,前端]\n---\n##### 写在前面\n文章大体会根据Vue官方文档(教程2.X)提供的学习路线\n本文从 进入/离开 & 列表过渡 -> 状态过渡\n\n### 进入/离开 & 列表过渡\n1.想要vue的过渡transition标签有效, 必须和下列其一搭配\n```html\n1. v-if（条件渲染）\n2. v-show（条件展示）\n3. 动态组件\n4. 在组建的根节点上，并且被vue实例DOM方法触发，如appendTo方法把组件添加到某个根节点上\n```\n\n2.过渡的类名, 会有6个class切换\n```JavaScript\n// 这里的v 是过渡标签name里的值 如 <transition name='fade'> 则为 fade-enter\n1. v-enter: 进入过渡的开始状态\n2. v-enter-active: 过渡的状态, 在元素整个过渡过程中作用\n3. v-enter-to: 进入过渡的结束状态\n4. v-leave: 离开过渡的开始状态\n5. v-leave-active: 过渡的状态, 在元素整个过渡过程中作用\n6. v-leave-to: 离开过渡的结束状态\n```\n<!-- more -->\n![transition](2_transition.jpg)\n如上图所示, 因此v-enter-to和v-leave定义时可以一块写, 如果你想方便一点的话\n```css\n<transition name=\"fade\">\n  <p v-if=\"show\">hello</p>\n</transition>\n\n/* 进入和离开都是一样的过渡效果 */\n.fade-enter-active,\n.fade-leave-active {\n  transition: all .3s ease;\n}\n\n/* 进入和离开结束的位置 */\n.fade-enter,\n.fade-leave-to {\n  transform: translateX(10px);\n  opacity: 0;\n}\n```\n\n3.自定义类名, 可以用于配合第三方css动画库, 如Animate.css\n```JavaScript\nenter-class\nenter-active-class\nenter-to-class\nleave-class\nleave-active-class\nleave-to-class\n\n<transition name='fade' \n            enter-active-class='animated tada'\n            leave-active-class='animated bounceOutRight'>\n```\n\n\n4.transition的v-bind:duration属性, 是显性的过渡持续时间, 设置时间如果比transition-duration大, 则按照原本的时间来, 如果小, 那按照duration的时间来\n```html\n<transition name='fade' :duration='1000'>\n```\n5.JavaScript钩子, 可以单独使用. 值得注意的是在 enter 和 leave 中, 回调函数 done 是必须的; 推荐对于仅使用 JavaScript 过渡的元素添加 v-bind:css=\"false\", Vue 会跳过 CSS 的检测. 这也可以避免过渡过程中 CSS 的影响\n```html\n<transition\n  v-on:before-enter=\"beforeEnter\"\n  v-on:enter=\"enter\"\n  v-on:after-enter=\"afterEnter\"\n  v-on:enter-cancelled=\"enterCancelled\"\n\n  v-on:before-leave=\"beforeLeave\"\n  v-on:leave=\"leave\"\n  v-on:after-leave=\"afterLeave\"\n  v-on:leave-cancelled=\"leaveCancelled\"\n>\n  <!-- ... -->\n</transition>\n\nmethods: {\n  beforeEnter: function (el) {\n    // ...\n  },\n  // 此回调函数是可选项的设置\n  // 与 CSS 结合时使用\n  enter: function (el, done) {\n    // ...\n    done()\n  },\n  afterEnter: function (el) {\n    // ...\n  },\n  enterCancelled: function (el) {\n    // ...\n  },\n  beforeLeave: function (el) {\n    // ...\n  },\n  // 此回调函数是可选项的设置\n  // 与 CSS 结合时使用\n  leave: function (el, done) {\n    // ...\n    done()\n  },\n  afterLeave: function (el) {\n    // ...\n  },\n  // leaveCancelled 只用于 v-show 中\n  leaveCancelled: function (el) {\n    // ...\n  }\n}\n```\n\n6.列表过渡, 使用transition-group组件, 结合v-for\n```html\n1. 可以通过tag特性更换为其他元素\n2. 内部元素总是需要提供唯一的key属性值\n<transition-group name='fade' tag='p'>\n  <span v-for='item in items' :key='item'>{{item}}</span>\n</transition-group>\n\n假设items是[0, 1, 2, 3], 则最终渲染出4个p标签\n```\n\n### 状态过渡\n针对数据元素本身的动效. 数字和运算, 颜色的显示, SVG节点的位置, 元素的大小和其他的属性. 可以结合第三方库来实现切换元素的过渡状态\n\n### 混入\n混入 (mixins) 是一种分发 Vue 组件中可复用功能的非常灵活的方式\n1.当组件和混入对象含有同名选项(data里的属性, methods里的方法, components里的组件, directives里的自定义指令)时, 组件数据覆盖混入对象数据\n```JavaScript\nvar mixin = {\n  data () {\n    return {\n      message: 'hello',\n      foo: 'abc'\n    }\n  },\n  methods: {\n    hello () {\n      console.log('from mixin')\n    }\n  }\n}\n\nvar vm = new Vue({\n  mixins: [mixin],\n  data () {\n    return {\n      message: 'no hello',\n    }\n  },\n  created () {\n    console.log(this.$data) // { message: 'no hello', foo: 'abc' } mixin的message属性被组件属性覆盖\n  },\n  methods: {\n    hello () {\n      console.log('from vue')\n    }\n  }\n})\n\nvm.hello() // 'from vue' // mixin的method被覆盖\n```\n\n### 自定义指令\n1.当页面加载时, 让一个元素获得焦点\n```html\n<input v-focus type='text' />\n\n// 全局注册\nVue.directive('focus', {\n  inserted (el) {\n    el.focus()\n  }\n})\n\n// 局部注册\nnew Vue({\n  ...,\n  directives: {\n    focus: {\n      inserted (el) {\n        el.focus()\n      }\n    }\n  }\n})\n```\n\n### 渲染函数 & JSX\n","slug":"我认为的Vue官方文档重点-2","published":1,"updated":"2021-07-02T03:20:30.664Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl5sb8gf90011xq0rhgi0otnb","content":"<h5 id=\"写在前面\"><a href=\"#写在前面\" class=\"headerlink\" title=\"写在前面\"></a>写在前面</h5><p>文章大体会根据Vue官方文档(教程2.X)提供的学习路线<br>本文从 进入/离开 &amp; 列表过渡 -&gt; 状态过渡</p>\n<h3 id=\"进入-离开-amp-列表过渡\"><a href=\"#进入-离开-amp-列表过渡\" class=\"headerlink\" title=\"进入/离开 &amp; 列表过渡\"></a>进入/离开 &amp; 列表过渡</h3><p>1.想要vue的过渡transition标签有效, 必须和下列其一搭配</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">1. v-if（条件渲染）</span><br><span class=\"line\">2. v-show（条件展示）</span><br><span class=\"line\">3. 动态组件</span><br><span class=\"line\">4. 在组建的根节点上，并且被vue实例DOM方法触发，如appendTo方法把组件添加到某个根节点上</span><br></pre></td></tr></table></figure>\n\n<p>2.过渡的类名, 会有6个class切换</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 这里的v 是过渡标签name里的值 如 &lt;transition name='fade'&gt; 则为 fade-enter</span></span><br><span class=\"line\"><span class=\"number\">1.</span> v-enter: 进入过渡的开始状态</span><br><span class=\"line\"><span class=\"number\">2.</span> v-enter-active: 过渡的状态, 在元素整个过渡过程中作用</span><br><span class=\"line\"><span class=\"number\">3.</span> v-enter-to: 进入过渡的结束状态</span><br><span class=\"line\"><span class=\"number\">4.</span> v-leave: 离开过渡的开始状态</span><br><span class=\"line\"><span class=\"number\">5.</span> v-leave-active: 过渡的状态, 在元素整个过渡过程中作用</span><br><span class=\"line\"><span class=\"number\">6.</span> v-leave-to: 离开过渡的结束状态</span><br></pre></td></tr></table></figure>\n\n<a id=\"more\"></a>\n<p><img src=\"//psilocine.github.io/2018/03/03/我认为的Vue官方文档重点-2/2_transition.jpg\" alt=\"transition\"><br>如上图所示, 因此v-enter-to和v-leave定义时可以一块写, 如果你想方便一点的话</p>\n<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;transition name=\"fade\"&gt;</span><br><span class=\"line\">  &lt;p v-if=\"show\"&gt;hello&lt;/p&gt;</span><br><span class=\"line\">&lt;/transition&gt;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/* 进入和离开都是一样的过渡效果 */</span></span><br><span class=\"line\"><span class=\"selector-class\">.fade-enter-active</span>,</span><br><span class=\"line\"><span class=\"selector-class\">.fade-leave-active</span> &#123;</span><br><span class=\"line\">  <span class=\"attribute\">transition</span>: all .<span class=\"number\">3s</span> ease;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/* 进入和离开结束的位置 */</span></span><br><span class=\"line\"><span class=\"selector-class\">.fade-enter</span>,</span><br><span class=\"line\"><span class=\"selector-class\">.fade-leave-to</span> &#123;</span><br><span class=\"line\">  <span class=\"attribute\">transform</span>: <span class=\"built_in\">translateX</span>(<span class=\"number\">10px</span>);</span><br><span class=\"line\">  <span class=\"attribute\">opacity</span>: <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>3.自定义类名, 可以用于配合第三方css动画库, 如Animate.css</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">enter-<span class=\"class\"><span class=\"keyword\">class</span></span></span><br><span class=\"line\"><span class=\"class\"><span class=\"title\">enter</span>-<span class=\"title\">active</span>-<span class=\"title\">class</span></span></span><br><span class=\"line\"><span class=\"class\"><span class=\"title\">enter</span>-<span class=\"title\">to</span>-<span class=\"title\">class</span></span></span><br><span class=\"line\"><span class=\"class\"><span class=\"title\">leave</span>-<span class=\"title\">class</span></span></span><br><span class=\"line\"><span class=\"class\"><span class=\"title\">leave</span>-<span class=\"title\">active</span>-<span class=\"title\">class</span></span></span><br><span class=\"line\"><span class=\"class\"><span class=\"title\">leave</span>-<span class=\"title\">to</span>-<span class=\"title\">class</span></span></span><br><span class=\"line\"><span class=\"class\"></span></span><br><span class=\"line\"><span class=\"class\">&lt;<span class=\"title\">transition</span> <span class=\"title\">name</span></span>=<span class=\"string\">'fade'</span> </span><br><span class=\"line\">            enter-active-<span class=\"class\"><span class=\"keyword\">class</span></span>=<span class=\"string\">'animated tada'</span></span><br><span class=\"line\">            leave-active-<span class=\"class\"><span class=\"keyword\">class</span></span>=<span class=\"string\">'animated bounceOutRight'</span>&gt;</span><br></pre></td></tr></table></figure>\n\n<p>4.transition的v-bind:duration属性, 是显性的过渡持续时间, 设置时间如果比transition-duration大, 则按照原本的时间来, 如果小, 那按照duration的时间来</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">transition</span> <span class=\"attr\">name</span>=<span class=\"string\">'fade'</span> <span class=\"attr\">:duration</span>=<span class=\"string\">'1000'</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n<p>5.JavaScript钩子, 可以单独使用. 值得注意的是在 enter 和 leave 中, 回调函数 done 是必须的; 推荐对于仅使用 JavaScript 过渡的元素添加 v-bind:css=”false”, Vue 会跳过 CSS 的检测. 这也可以避免过渡过程中 CSS 的影响</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">transition</span></span></span><br><span class=\"line\"><span class=\"tag\">  <span class=\"attr\">v-on:before-enter</span>=<span class=\"string\">\"beforeEnter\"</span></span></span><br><span class=\"line\"><span class=\"tag\">  <span class=\"attr\">v-on:enter</span>=<span class=\"string\">\"enter\"</span></span></span><br><span class=\"line\"><span class=\"tag\">  <span class=\"attr\">v-on:after-enter</span>=<span class=\"string\">\"afterEnter\"</span></span></span><br><span class=\"line\"><span class=\"tag\">  <span class=\"attr\">v-on:enter-cancelled</span>=<span class=\"string\">\"enterCancelled\"</span></span></span><br><span class=\"line\"><span class=\"tag\"></span></span><br><span class=\"line\"><span class=\"tag\">  <span class=\"attr\">v-on:before-leave</span>=<span class=\"string\">\"beforeLeave\"</span></span></span><br><span class=\"line\"><span class=\"tag\">  <span class=\"attr\">v-on:leave</span>=<span class=\"string\">\"leave\"</span></span></span><br><span class=\"line\"><span class=\"tag\">  <span class=\"attr\">v-on:after-leave</span>=<span class=\"string\">\"afterLeave\"</span></span></span><br><span class=\"line\"><span class=\"tag\">  <span class=\"attr\">v-on:leave-cancelled</span>=<span class=\"string\">\"leaveCancelled\"</span></span></span><br><span class=\"line\"><span class=\"tag\">&gt;</span></span><br><span class=\"line\">  <span class=\"comment\">&lt;!-- ... --&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">transition</span>&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\">methods: &#123;</span><br><span class=\"line\">  beforeEnter: function (el) &#123;</span><br><span class=\"line\">    // ...</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  // 此回调函数是可选项的设置</span><br><span class=\"line\">  // 与 CSS 结合时使用</span><br><span class=\"line\">  enter: function (el, done) &#123;</span><br><span class=\"line\">    // ...</span><br><span class=\"line\">    done()</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  afterEnter: function (el) &#123;</span><br><span class=\"line\">    // ...</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  enterCancelled: function (el) &#123;</span><br><span class=\"line\">    // ...</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  beforeLeave: function (el) &#123;</span><br><span class=\"line\">    // ...</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  // 此回调函数是可选项的设置</span><br><span class=\"line\">  // 与 CSS 结合时使用</span><br><span class=\"line\">  leave: function (el, done) &#123;</span><br><span class=\"line\">    // ...</span><br><span class=\"line\">    done()</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  afterLeave: function (el) &#123;</span><br><span class=\"line\">    // ...</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  // leaveCancelled 只用于 v-show 中</span><br><span class=\"line\">  leaveCancelled: function (el) &#123;</span><br><span class=\"line\">    // ...</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>6.列表过渡, 使用transition-group组件, 结合v-for</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">1. 可以通过tag特性更换为其他元素</span><br><span class=\"line\">2. 内部元素总是需要提供唯一的key属性值</span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">transition-group</span> <span class=\"attr\">name</span>=<span class=\"string\">'fade'</span> <span class=\"attr\">tag</span>=<span class=\"string\">'p'</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">span</span> <span class=\"attr\">v-for</span>=<span class=\"string\">'item in items'</span> <span class=\"attr\">:key</span>=<span class=\"string\">'item'</span>&gt;</span>&#123;&#123;item&#125;&#125;<span class=\"tag\">&lt;/<span class=\"name\">span</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">transition-group</span>&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\">假设items是[0, 1, 2, 3], 则最终渲染出4个p标签</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"状态过渡\"><a href=\"#状态过渡\" class=\"headerlink\" title=\"状态过渡\"></a>状态过渡</h3><p>针对数据元素本身的动效. 数字和运算, 颜色的显示, SVG节点的位置, 元素的大小和其他的属性. 可以结合第三方库来实现切换元素的过渡状态</p>\n<h3 id=\"混入\"><a href=\"#混入\" class=\"headerlink\" title=\"混入\"></a>混入</h3><p>混入 (mixins) 是一种分发 Vue 组件中可复用功能的非常灵活的方式<br>1.当组件和混入对象含有同名选项(data里的属性, methods里的方法, components里的组件, directives里的自定义指令)时, 组件数据覆盖混入对象数据</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> mixin = &#123;</span><br><span class=\"line\">  data () &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> &#123;</span><br><span class=\"line\">      message: <span class=\"string\">'hello'</span>,</span><br><span class=\"line\">      foo: <span class=\"string\">'abc'</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  methods: &#123;</span><br><span class=\"line\">    hello () &#123;</span><br><span class=\"line\">      <span class=\"built_in\">console</span>.log(<span class=\"string\">'from mixin'</span>)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> vm = <span class=\"keyword\">new</span> Vue(&#123;</span><br><span class=\"line\">  mixins: [mixin],</span><br><span class=\"line\">  data () &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> &#123;</span><br><span class=\"line\">      message: <span class=\"string\">'no hello'</span>,</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  created () &#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"keyword\">this</span>.$data) <span class=\"comment\">// &#123; message: 'no hello', foo: 'abc' &#125; mixin的message属性被组件属性覆盖</span></span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  methods: &#123;</span><br><span class=\"line\">    hello () &#123;</span><br><span class=\"line\">      <span class=\"built_in\">console</span>.log(<span class=\"string\">'from vue'</span>)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\"></span><br><span class=\"line\">vm.hello() <span class=\"comment\">// 'from vue' // mixin的method被覆盖</span></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"自定义指令\"><a href=\"#自定义指令\" class=\"headerlink\" title=\"自定义指令\"></a>自定义指令</h3><p>1.当页面加载时, 让一个元素获得焦点</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">input</span> <span class=\"attr\">v-focus</span> <span class=\"attr\">type</span>=<span class=\"string\">'text'</span> /&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\">// 全局注册</span><br><span class=\"line\">Vue.directive('focus', &#123;</span><br><span class=\"line\">  inserted (el) &#123;</span><br><span class=\"line\">    el.focus()</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\"></span><br><span class=\"line\">// 局部注册</span><br><span class=\"line\">new Vue(&#123;</span><br><span class=\"line\">  ...,</span><br><span class=\"line\">  directives: &#123;</span><br><span class=\"line\">    focus: &#123;</span><br><span class=\"line\">      inserted (el) &#123;</span><br><span class=\"line\">        el.focus()</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"渲染函数-amp-JSX\"><a href=\"#渲染函数-amp-JSX\" class=\"headerlink\" title=\"渲染函数 &amp; JSX\"></a>渲染函数 &amp; JSX</h3>","site":{"data":{}},"excerpt":"<h5 id=\"写在前面\"><a href=\"#写在前面\" class=\"headerlink\" title=\"写在前面\"></a>写在前面</h5><p>文章大体会根据Vue官方文档(教程2.X)提供的学习路线<br>本文从 进入/离开 &amp; 列表过渡 -&gt; 状态过渡</p>\n<h3 id=\"进入-离开-amp-列表过渡\"><a href=\"#进入-离开-amp-列表过渡\" class=\"headerlink\" title=\"进入/离开 &amp; 列表过渡\"></a>进入/离开 &amp; 列表过渡</h3><p>1.想要vue的过渡transition标签有效, 必须和下列其一搭配</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">1. v-if（条件渲染）</span><br><span class=\"line\">2. v-show（条件展示）</span><br><span class=\"line\">3. 动态组件</span><br><span class=\"line\">4. 在组建的根节点上，并且被vue实例DOM方法触发，如appendTo方法把组件添加到某个根节点上</span><br></pre></td></tr></table></figure>\n\n<p>2.过渡的类名, 会有6个class切换</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 这里的v 是过渡标签name里的值 如 &lt;transition name='fade'&gt; 则为 fade-enter</span></span><br><span class=\"line\"><span class=\"number\">1.</span> v-enter: 进入过渡的开始状态</span><br><span class=\"line\"><span class=\"number\">2.</span> v-enter-active: 过渡的状态, 在元素整个过渡过程中作用</span><br><span class=\"line\"><span class=\"number\">3.</span> v-enter-to: 进入过渡的结束状态</span><br><span class=\"line\"><span class=\"number\">4.</span> v-leave: 离开过渡的开始状态</span><br><span class=\"line\"><span class=\"number\">5.</span> v-leave-active: 过渡的状态, 在元素整个过渡过程中作用</span><br><span class=\"line\"><span class=\"number\">6.</span> v-leave-to: 离开过渡的结束状态</span><br></pre></td></tr></table></figure>","more":"<p><img src=\"//psilocine.github.io/2018/03/03/我认为的Vue官方文档重点-2/2_transition.jpg\" alt=\"transition\"><br>如上图所示, 因此v-enter-to和v-leave定义时可以一块写, 如果你想方便一点的话</p>\n<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;transition name=\"fade\"&gt;</span><br><span class=\"line\">  &lt;p v-if=\"show\"&gt;hello&lt;/p&gt;</span><br><span class=\"line\">&lt;/transition&gt;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/* 进入和离开都是一样的过渡效果 */</span></span><br><span class=\"line\"><span class=\"selector-class\">.fade-enter-active</span>,</span><br><span class=\"line\"><span class=\"selector-class\">.fade-leave-active</span> &#123;</span><br><span class=\"line\">  <span class=\"attribute\">transition</span>: all .<span class=\"number\">3s</span> ease;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/* 进入和离开结束的位置 */</span></span><br><span class=\"line\"><span class=\"selector-class\">.fade-enter</span>,</span><br><span class=\"line\"><span class=\"selector-class\">.fade-leave-to</span> &#123;</span><br><span class=\"line\">  <span class=\"attribute\">transform</span>: <span class=\"built_in\">translateX</span>(<span class=\"number\">10px</span>);</span><br><span class=\"line\">  <span class=\"attribute\">opacity</span>: <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>3.自定义类名, 可以用于配合第三方css动画库, 如Animate.css</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">enter-<span class=\"class\"><span class=\"keyword\">class</span></span></span><br><span class=\"line\"><span class=\"class\"><span class=\"title\">enter</span>-<span class=\"title\">active</span>-<span class=\"title\">class</span></span></span><br><span class=\"line\"><span class=\"class\"><span class=\"title\">enter</span>-<span class=\"title\">to</span>-<span class=\"title\">class</span></span></span><br><span class=\"line\"><span class=\"class\"><span class=\"title\">leave</span>-<span class=\"title\">class</span></span></span><br><span class=\"line\"><span class=\"class\"><span class=\"title\">leave</span>-<span class=\"title\">active</span>-<span class=\"title\">class</span></span></span><br><span class=\"line\"><span class=\"class\"><span class=\"title\">leave</span>-<span class=\"title\">to</span>-<span class=\"title\">class</span></span></span><br><span class=\"line\"><span class=\"class\"></span></span><br><span class=\"line\"><span class=\"class\">&lt;<span class=\"title\">transition</span> <span class=\"title\">name</span></span>=<span class=\"string\">'fade'</span> </span><br><span class=\"line\">            enter-active-<span class=\"class\"><span class=\"keyword\">class</span></span>=<span class=\"string\">'animated tada'</span></span><br><span class=\"line\">            leave-active-<span class=\"class\"><span class=\"keyword\">class</span></span>=<span class=\"string\">'animated bounceOutRight'</span>&gt;</span><br></pre></td></tr></table></figure>\n\n<p>4.transition的v-bind:duration属性, 是显性的过渡持续时间, 设置时间如果比transition-duration大, 则按照原本的时间来, 如果小, 那按照duration的时间来</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">transition</span> <span class=\"attr\">name</span>=<span class=\"string\">'fade'</span> <span class=\"attr\">:duration</span>=<span class=\"string\">'1000'</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n<p>5.JavaScript钩子, 可以单独使用. 值得注意的是在 enter 和 leave 中, 回调函数 done 是必须的; 推荐对于仅使用 JavaScript 过渡的元素添加 v-bind:css=”false”, Vue 会跳过 CSS 的检测. 这也可以避免过渡过程中 CSS 的影响</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">transition</span></span></span><br><span class=\"line\"><span class=\"tag\">  <span class=\"attr\">v-on:before-enter</span>=<span class=\"string\">\"beforeEnter\"</span></span></span><br><span class=\"line\"><span class=\"tag\">  <span class=\"attr\">v-on:enter</span>=<span class=\"string\">\"enter\"</span></span></span><br><span class=\"line\"><span class=\"tag\">  <span class=\"attr\">v-on:after-enter</span>=<span class=\"string\">\"afterEnter\"</span></span></span><br><span class=\"line\"><span class=\"tag\">  <span class=\"attr\">v-on:enter-cancelled</span>=<span class=\"string\">\"enterCancelled\"</span></span></span><br><span class=\"line\"><span class=\"tag\"></span></span><br><span class=\"line\"><span class=\"tag\">  <span class=\"attr\">v-on:before-leave</span>=<span class=\"string\">\"beforeLeave\"</span></span></span><br><span class=\"line\"><span class=\"tag\">  <span class=\"attr\">v-on:leave</span>=<span class=\"string\">\"leave\"</span></span></span><br><span class=\"line\"><span class=\"tag\">  <span class=\"attr\">v-on:after-leave</span>=<span class=\"string\">\"afterLeave\"</span></span></span><br><span class=\"line\"><span class=\"tag\">  <span class=\"attr\">v-on:leave-cancelled</span>=<span class=\"string\">\"leaveCancelled\"</span></span></span><br><span class=\"line\"><span class=\"tag\">&gt;</span></span><br><span class=\"line\">  <span class=\"comment\">&lt;!-- ... --&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">transition</span>&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\">methods: &#123;</span><br><span class=\"line\">  beforeEnter: function (el) &#123;</span><br><span class=\"line\">    // ...</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  // 此回调函数是可选项的设置</span><br><span class=\"line\">  // 与 CSS 结合时使用</span><br><span class=\"line\">  enter: function (el, done) &#123;</span><br><span class=\"line\">    // ...</span><br><span class=\"line\">    done()</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  afterEnter: function (el) &#123;</span><br><span class=\"line\">    // ...</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  enterCancelled: function (el) &#123;</span><br><span class=\"line\">    // ...</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  beforeLeave: function (el) &#123;</span><br><span class=\"line\">    // ...</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  // 此回调函数是可选项的设置</span><br><span class=\"line\">  // 与 CSS 结合时使用</span><br><span class=\"line\">  leave: function (el, done) &#123;</span><br><span class=\"line\">    // ...</span><br><span class=\"line\">    done()</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  afterLeave: function (el) &#123;</span><br><span class=\"line\">    // ...</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  // leaveCancelled 只用于 v-show 中</span><br><span class=\"line\">  leaveCancelled: function (el) &#123;</span><br><span class=\"line\">    // ...</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>6.列表过渡, 使用transition-group组件, 结合v-for</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">1. 可以通过tag特性更换为其他元素</span><br><span class=\"line\">2. 内部元素总是需要提供唯一的key属性值</span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">transition-group</span> <span class=\"attr\">name</span>=<span class=\"string\">'fade'</span> <span class=\"attr\">tag</span>=<span class=\"string\">'p'</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">span</span> <span class=\"attr\">v-for</span>=<span class=\"string\">'item in items'</span> <span class=\"attr\">:key</span>=<span class=\"string\">'item'</span>&gt;</span>&#123;&#123;item&#125;&#125;<span class=\"tag\">&lt;/<span class=\"name\">span</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">transition-group</span>&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\">假设items是[0, 1, 2, 3], 则最终渲染出4个p标签</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"状态过渡\"><a href=\"#状态过渡\" class=\"headerlink\" title=\"状态过渡\"></a>状态过渡</h3><p>针对数据元素本身的动效. 数字和运算, 颜色的显示, SVG节点的位置, 元素的大小和其他的属性. 可以结合第三方库来实现切换元素的过渡状态</p>\n<h3 id=\"混入\"><a href=\"#混入\" class=\"headerlink\" title=\"混入\"></a>混入</h3><p>混入 (mixins) 是一种分发 Vue 组件中可复用功能的非常灵活的方式<br>1.当组件和混入对象含有同名选项(data里的属性, methods里的方法, components里的组件, directives里的自定义指令)时, 组件数据覆盖混入对象数据</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> mixin = &#123;</span><br><span class=\"line\">  data () &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> &#123;</span><br><span class=\"line\">      message: <span class=\"string\">'hello'</span>,</span><br><span class=\"line\">      foo: <span class=\"string\">'abc'</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  methods: &#123;</span><br><span class=\"line\">    hello () &#123;</span><br><span class=\"line\">      <span class=\"built_in\">console</span>.log(<span class=\"string\">'from mixin'</span>)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> vm = <span class=\"keyword\">new</span> Vue(&#123;</span><br><span class=\"line\">  mixins: [mixin],</span><br><span class=\"line\">  data () &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> &#123;</span><br><span class=\"line\">      message: <span class=\"string\">'no hello'</span>,</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  created () &#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"keyword\">this</span>.$data) <span class=\"comment\">// &#123; message: 'no hello', foo: 'abc' &#125; mixin的message属性被组件属性覆盖</span></span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  methods: &#123;</span><br><span class=\"line\">    hello () &#123;</span><br><span class=\"line\">      <span class=\"built_in\">console</span>.log(<span class=\"string\">'from vue'</span>)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\"></span><br><span class=\"line\">vm.hello() <span class=\"comment\">// 'from vue' // mixin的method被覆盖</span></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"自定义指令\"><a href=\"#自定义指令\" class=\"headerlink\" title=\"自定义指令\"></a>自定义指令</h3><p>1.当页面加载时, 让一个元素获得焦点</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">input</span> <span class=\"attr\">v-focus</span> <span class=\"attr\">type</span>=<span class=\"string\">'text'</span> /&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\">// 全局注册</span><br><span class=\"line\">Vue.directive('focus', &#123;</span><br><span class=\"line\">  inserted (el) &#123;</span><br><span class=\"line\">    el.focus()</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\"></span><br><span class=\"line\">// 局部注册</span><br><span class=\"line\">new Vue(&#123;</span><br><span class=\"line\">  ...,</span><br><span class=\"line\">  directives: &#123;</span><br><span class=\"line\">    focus: &#123;</span><br><span class=\"line\">      inserted (el) &#123;</span><br><span class=\"line\">        el.focus()</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"渲染函数-amp-JSX\"><a href=\"#渲染函数-amp-JSX\" class=\"headerlink\" title=\"渲染函数 &amp; JSX\"></a>渲染函数 &amp; JSX</h3>"},{"title":"搭建hexo的坑","date":"2017-05-13T10:51:17.000Z","_content":"##### 写在前面\n在搭建blog时的一些坑, 写下来方便大家查阅\n\n1.一切都弄好后要部署到github上时, 出现ERROR Deployer not found: git\n  需要在输hexo d指令前 先输入 npm install hexo-deployer-git --save, 安装成功后再部署.\n\n2.hexo d部署到一半发生错误, 出现fatal: could not read Username for ‘https://github.com‘: Invalid argument\n  我的解决方法是在根目录的_config.yml里deploy的repo设置成了http, 改回SSH即可.","source":"_posts/搭建hexo的坑.md","raw":"---\ntitle: 搭建hexo的坑\ndate: 2017-05-13 18:51:17\ntags: HEXO\n---\n##### 写在前面\n在搭建blog时的一些坑, 写下来方便大家查阅\n\n1.一切都弄好后要部署到github上时, 出现ERROR Deployer not found: git\n  需要在输hexo d指令前 先输入 npm install hexo-deployer-git --save, 安装成功后再部署.\n\n2.hexo d部署到一半发生错误, 出现fatal: could not read Username for ‘https://github.com‘: Invalid argument\n  我的解决方法是在根目录的_config.yml里deploy的repo设置成了http, 改回SSH即可.","slug":"搭建hexo的坑","published":1,"updated":"2021-07-02T03:20:30.664Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl5sb8gfa0013xq0rgwjnhq01","content":"<h5 id=\"写在前面\"><a href=\"#写在前面\" class=\"headerlink\" title=\"写在前面\"></a>写在前面</h5><p>在搭建blog时的一些坑, 写下来方便大家查阅</p>\n<p>1.一切都弄好后要部署到github上时, 出现ERROR Deployer not found: git<br>  需要在输hexo d指令前 先输入 npm install hexo-deployer-git –save, 安装成功后再部署.</p>\n<p>2.hexo d部署到一半发生错误, 出现fatal: could not read Username for ‘<a href=\"https://github.com‘\" target=\"_blank\" rel=\"noopener\">https://github.com‘</a>: Invalid argument<br>  我的解决方法是在根目录的_config.yml里deploy的repo设置成了http, 改回SSH即可.</p>\n","site":{"data":{}},"excerpt":"","more":"<h5 id=\"写在前面\"><a href=\"#写在前面\" class=\"headerlink\" title=\"写在前面\"></a>写在前面</h5><p>在搭建blog时的一些坑, 写下来方便大家查阅</p>\n<p>1.一切都弄好后要部署到github上时, 出现ERROR Deployer not found: git<br>  需要在输hexo d指令前 先输入 npm install hexo-deployer-git –save, 安装成功后再部署.</p>\n<p>2.hexo d部署到一半发生错误, 出现fatal: could not read Username for ‘<a href=\"https://github.com‘\" target=\"_blank\" rel=\"noopener\">https://github.com‘</a>: Invalid argument<br>  我的解决方法是在根目录的_config.yml里deploy的repo设置成了http, 改回SSH即可.</p>\n"},{"title":"浅析CSS实现Footer置底的几种方式","date":"2017-11-05T14:40:51.000Z","_content":"##### 写在前面\nFooter置底就是让footer部分始终能在浏览器窗口的最底部.\n1. 当页面内容超过vh时候, footer能够被推倒页面底部;\n2. 当页面内容不够vh时, footer能保持在浏览器窗口底部.\n\n### 将内容部分的底部外边距设为负数\n把内容content部分最小高度设为100%. 当content部分高度比浏览器高度小时, content负边距能让footer保持在浏览器窗口底部.\n注意负边距数值应和.push, .footer高度一致\n<!-- more -->\n```css\nhtml, body {\n  height: 100%;\n  margin: 0;\n}\n\n.content {\n  min-height: 100%;\n\n  /* 等于footer的高度 */\n  margin-bottom: -50px;\n}\n.footer, .push {\n  height: 50px;\n}\n```\n```html\n<body>\n  <div class='content'>\n    content\n    <div class='push'></div>\n  </div>\n  <div class='footer'></div>\n</body>\n```\n\n### 页脚顶部外边距设为负数\n和第一种方法大同小异, 需理解margin顶部底部负值的差异. \n注意如果content有背景或背景颜色, 用margin-bottom更佳, 因为用padding-bottom, footer会与背景重叠.\n```css\nhtml, body {\n  height: 100%;\n  margin: 0;\n}\n.wrapper {\n  min-height: 100%;\n}\n.content {\n  padding-bottom: 50px; /* margin-bottom ? */\n}\n.footer {\n  margin-top: -50px; /* 和padding-bottom数值一致 */\n}\n```\n```html\n<body>\n  <div class='wrapper'>\n    <div class='content'>\n      content\n    </div>\n  </div>\n  <div class='footer'></div>\n</body>\n```\n\n### calc()设置内容高度\n上述两种方式都需要额外的标签来实现, 使用css3的计算函数能够轻松实现\n缺点是只兼容高版本浏览器.\n```css\n.content {\n  min-height: calc(100vh - 50px); /* 注意(-)之间空格, 后者是footer高度 */\n}\n.footer {\n  height: 50px;\n}\n```\n```html\n<body>\n  <div class=\"content\">\n    content\n  </div>\n  <div class=\"footer\"></div>\n</body>\n```\n\n### flexbox弹性布局\n以上三种方法的footer高度都是已知的, 或者说是固定的, 不利于页面布局. 因为一旦内容、页脚超出固定高度就会破坏布局.\nflex同样不支持低版本ie.\n```css\nhtml {\n  height: 100%;\n}\nbody {\n  min-height: 100%;\n  display: flex;\n  flex-direction: column;\n}\n.content {\n  flex: 1;\n}\n```\n```html\n<body>\n  <div class='content'>\n    content\n  </div>\n  <div class='footer'></div>\n</body>\n```\n\n### Grid网格布局\n也是强大的布局, 但是目前兼容性最差, 只能在chrome和ff上使用.\n```css\nhtml {\n  height: 100%;\n}\nbody {\n  min-height: 100%;\n  display: grid;\n  grid-template-rows: 1fr auto;\n}\n.footer {\n  grid-row-start: 2;\n  grid-row-end: 3;\n}\n```\n```html\n<body>\n  <div class='content'>\n    content\n  </div>\n  <div class='footer'></div>\n</body>\n```","source":"_posts/浅析CSS实现Footer置底的几种方式.md","raw":"---\ntitle: 浅析CSS实现Footer置底的几种方式\ndate: 2017-11-05 22:40:51\ntags: [CSS,前端]\n---\n##### 写在前面\nFooter置底就是让footer部分始终能在浏览器窗口的最底部.\n1. 当页面内容超过vh时候, footer能够被推倒页面底部;\n2. 当页面内容不够vh时, footer能保持在浏览器窗口底部.\n\n### 将内容部分的底部外边距设为负数\n把内容content部分最小高度设为100%. 当content部分高度比浏览器高度小时, content负边距能让footer保持在浏览器窗口底部.\n注意负边距数值应和.push, .footer高度一致\n<!-- more -->\n```css\nhtml, body {\n  height: 100%;\n  margin: 0;\n}\n\n.content {\n  min-height: 100%;\n\n  /* 等于footer的高度 */\n  margin-bottom: -50px;\n}\n.footer, .push {\n  height: 50px;\n}\n```\n```html\n<body>\n  <div class='content'>\n    content\n    <div class='push'></div>\n  </div>\n  <div class='footer'></div>\n</body>\n```\n\n### 页脚顶部外边距设为负数\n和第一种方法大同小异, 需理解margin顶部底部负值的差异. \n注意如果content有背景或背景颜色, 用margin-bottom更佳, 因为用padding-bottom, footer会与背景重叠.\n```css\nhtml, body {\n  height: 100%;\n  margin: 0;\n}\n.wrapper {\n  min-height: 100%;\n}\n.content {\n  padding-bottom: 50px; /* margin-bottom ? */\n}\n.footer {\n  margin-top: -50px; /* 和padding-bottom数值一致 */\n}\n```\n```html\n<body>\n  <div class='wrapper'>\n    <div class='content'>\n      content\n    </div>\n  </div>\n  <div class='footer'></div>\n</body>\n```\n\n### calc()设置内容高度\n上述两种方式都需要额外的标签来实现, 使用css3的计算函数能够轻松实现\n缺点是只兼容高版本浏览器.\n```css\n.content {\n  min-height: calc(100vh - 50px); /* 注意(-)之间空格, 后者是footer高度 */\n}\n.footer {\n  height: 50px;\n}\n```\n```html\n<body>\n  <div class=\"content\">\n    content\n  </div>\n  <div class=\"footer\"></div>\n</body>\n```\n\n### flexbox弹性布局\n以上三种方法的footer高度都是已知的, 或者说是固定的, 不利于页面布局. 因为一旦内容、页脚超出固定高度就会破坏布局.\nflex同样不支持低版本ie.\n```css\nhtml {\n  height: 100%;\n}\nbody {\n  min-height: 100%;\n  display: flex;\n  flex-direction: column;\n}\n.content {\n  flex: 1;\n}\n```\n```html\n<body>\n  <div class='content'>\n    content\n  </div>\n  <div class='footer'></div>\n</body>\n```\n\n### Grid网格布局\n也是强大的布局, 但是目前兼容性最差, 只能在chrome和ff上使用.\n```css\nhtml {\n  height: 100%;\n}\nbody {\n  min-height: 100%;\n  display: grid;\n  grid-template-rows: 1fr auto;\n}\n.footer {\n  grid-row-start: 2;\n  grid-row-end: 3;\n}\n```\n```html\n<body>\n  <div class='content'>\n    content\n  </div>\n  <div class='footer'></div>\n</body>\n```","slug":"浅析CSS实现Footer置底的几种方式","published":1,"updated":"2021-07-02T03:20:30.664Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl5sb8gfb0016xq0riy2rg05y","content":"<h5 id=\"写在前面\"><a href=\"#写在前面\" class=\"headerlink\" title=\"写在前面\"></a>写在前面</h5><p>Footer置底就是让footer部分始终能在浏览器窗口的最底部.</p>\n<ol>\n<li>当页面内容超过vh时候, footer能够被推倒页面底部;</li>\n<li>当页面内容不够vh时, footer能保持在浏览器窗口底部.</li>\n</ol>\n<h3 id=\"将内容部分的底部外边距设为负数\"><a href=\"#将内容部分的底部外边距设为负数\" class=\"headerlink\" title=\"将内容部分的底部外边距设为负数\"></a>将内容部分的底部外边距设为负数</h3><p>把内容content部分最小高度设为100%. 当content部分高度比浏览器高度小时, content负边距能让footer保持在浏览器窗口底部.<br>注意负边距数值应和.push, .footer高度一致</p>\n<a id=\"more\"></a>\n<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-tag\">html</span>, <span class=\"selector-tag\">body</span> &#123;</span><br><span class=\"line\">  <span class=\"attribute\">height</span>: <span class=\"number\">100%</span>;</span><br><span class=\"line\">  <span class=\"attribute\">margin</span>: <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"selector-class\">.content</span> &#123;</span><br><span class=\"line\">  <span class=\"attribute\">min-height</span>: <span class=\"number\">100%</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">/* 等于footer的高度 */</span></span><br><span class=\"line\">  <span class=\"attribute\">margin-bottom</span>: -<span class=\"number\">50px</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"selector-class\">.footer</span>, <span class=\"selector-class\">.push</span> &#123;</span><br><span class=\"line\">  <span class=\"attribute\">height</span>: <span class=\"number\">50px</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">body</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">class</span>=<span class=\"string\">'content'</span>&gt;</span></span><br><span class=\"line\">    content</span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">class</span>=<span class=\"string\">'push'</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">class</span>=<span class=\"string\">'footer'</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">body</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"页脚顶部外边距设为负数\"><a href=\"#页脚顶部外边距设为负数\" class=\"headerlink\" title=\"页脚顶部外边距设为负数\"></a>页脚顶部外边距设为负数</h3><p>和第一种方法大同小异, 需理解margin顶部底部负值的差异.<br>注意如果content有背景或背景颜色, 用margin-bottom更佳, 因为用padding-bottom, footer会与背景重叠.</p>\n<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-tag\">html</span>, <span class=\"selector-tag\">body</span> &#123;</span><br><span class=\"line\">  <span class=\"attribute\">height</span>: <span class=\"number\">100%</span>;</span><br><span class=\"line\">  <span class=\"attribute\">margin</span>: <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"selector-class\">.wrapper</span> &#123;</span><br><span class=\"line\">  <span class=\"attribute\">min-height</span>: <span class=\"number\">100%</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"selector-class\">.content</span> &#123;</span><br><span class=\"line\">  <span class=\"attribute\">padding-bottom</span>: <span class=\"number\">50px</span>; <span class=\"comment\">/* margin-bottom ? */</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"selector-class\">.footer</span> &#123;</span><br><span class=\"line\">  <span class=\"attribute\">margin-top</span>: -<span class=\"number\">50px</span>; <span class=\"comment\">/* 和padding-bottom数值一致 */</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">body</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">class</span>=<span class=\"string\">'wrapper'</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">class</span>=<span class=\"string\">'content'</span>&gt;</span></span><br><span class=\"line\">      content</span><br><span class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">class</span>=<span class=\"string\">'footer'</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">body</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"calc-设置内容高度\"><a href=\"#calc-设置内容高度\" class=\"headerlink\" title=\"calc()设置内容高度\"></a>calc()设置内容高度</h3><p>上述两种方式都需要额外的标签来实现, 使用css3的计算函数能够轻松实现<br>缺点是只兼容高版本浏览器.</p>\n<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-class\">.content</span> &#123;</span><br><span class=\"line\">  <span class=\"attribute\">min-height</span>: <span class=\"built_in\">calc</span>(<span class=\"number\">100vh</span> - <span class=\"number\">50px</span>); <span class=\"comment\">/* 注意(-)之间空格, 后者是footer高度 */</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"selector-class\">.footer</span> &#123;</span><br><span class=\"line\">  <span class=\"attribute\">height</span>: <span class=\"number\">50px</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">body</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">class</span>=<span class=\"string\">\"content\"</span>&gt;</span></span><br><span class=\"line\">    content</span><br><span class=\"line\">  <span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">class</span>=<span class=\"string\">\"footer\"</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">body</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"flexbox弹性布局\"><a href=\"#flexbox弹性布局\" class=\"headerlink\" title=\"flexbox弹性布局\"></a>flexbox弹性布局</h3><p>以上三种方法的footer高度都是已知的, 或者说是固定的, 不利于页面布局. 因为一旦内容、页脚超出固定高度就会破坏布局.<br>flex同样不支持低版本ie.</p>\n<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-tag\">html</span> &#123;</span><br><span class=\"line\">  <span class=\"attribute\">height</span>: <span class=\"number\">100%</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"selector-tag\">body</span> &#123;</span><br><span class=\"line\">  <span class=\"attribute\">min-height</span>: <span class=\"number\">100%</span>;</span><br><span class=\"line\">  <span class=\"attribute\">display</span>: flex;</span><br><span class=\"line\">  <span class=\"attribute\">flex-direction</span>: column;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"selector-class\">.content</span> &#123;</span><br><span class=\"line\">  <span class=\"attribute\">flex</span>: <span class=\"number\">1</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">body</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">class</span>=<span class=\"string\">'content'</span>&gt;</span></span><br><span class=\"line\">    content</span><br><span class=\"line\">  <span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">class</span>=<span class=\"string\">'footer'</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">body</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"Grid网格布局\"><a href=\"#Grid网格布局\" class=\"headerlink\" title=\"Grid网格布局\"></a>Grid网格布局</h3><p>也是强大的布局, 但是目前兼容性最差, 只能在chrome和ff上使用.</p>\n<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-tag\">html</span> &#123;</span><br><span class=\"line\">  <span class=\"attribute\">height</span>: <span class=\"number\">100%</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"selector-tag\">body</span> &#123;</span><br><span class=\"line\">  <span class=\"attribute\">min-height</span>: <span class=\"number\">100%</span>;</span><br><span class=\"line\">  <span class=\"attribute\">display</span>: grid;</span><br><span class=\"line\">  <span class=\"attribute\">grid-template-rows</span>: <span class=\"number\">1</span>fr auto;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"selector-class\">.footer</span> &#123;</span><br><span class=\"line\">  <span class=\"attribute\">grid-row-start</span>: <span class=\"number\">2</span>;</span><br><span class=\"line\">  <span class=\"attribute\">grid-row-end</span>: <span class=\"number\">3</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">body</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">class</span>=<span class=\"string\">'content'</span>&gt;</span></span><br><span class=\"line\">    content</span><br><span class=\"line\">  <span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">class</span>=<span class=\"string\">'footer'</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">body</span>&gt;</span></span><br></pre></td></tr></table></figure>","site":{"data":{}},"excerpt":"<h5 id=\"写在前面\"><a href=\"#写在前面\" class=\"headerlink\" title=\"写在前面\"></a>写在前面</h5><p>Footer置底就是让footer部分始终能在浏览器窗口的最底部.</p>\n<ol>\n<li>当页面内容超过vh时候, footer能够被推倒页面底部;</li>\n<li>当页面内容不够vh时, footer能保持在浏览器窗口底部.</li>\n</ol>\n<h3 id=\"将内容部分的底部外边距设为负数\"><a href=\"#将内容部分的底部外边距设为负数\" class=\"headerlink\" title=\"将内容部分的底部外边距设为负数\"></a>将内容部分的底部外边距设为负数</h3><p>把内容content部分最小高度设为100%. 当content部分高度比浏览器高度小时, content负边距能让footer保持在浏览器窗口底部.<br>注意负边距数值应和.push, .footer高度一致</p>","more":"<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-tag\">html</span>, <span class=\"selector-tag\">body</span> &#123;</span><br><span class=\"line\">  <span class=\"attribute\">height</span>: <span class=\"number\">100%</span>;</span><br><span class=\"line\">  <span class=\"attribute\">margin</span>: <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"selector-class\">.content</span> &#123;</span><br><span class=\"line\">  <span class=\"attribute\">min-height</span>: <span class=\"number\">100%</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">/* 等于footer的高度 */</span></span><br><span class=\"line\">  <span class=\"attribute\">margin-bottom</span>: -<span class=\"number\">50px</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"selector-class\">.footer</span>, <span class=\"selector-class\">.push</span> &#123;</span><br><span class=\"line\">  <span class=\"attribute\">height</span>: <span class=\"number\">50px</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">body</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">class</span>=<span class=\"string\">'content'</span>&gt;</span></span><br><span class=\"line\">    content</span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">class</span>=<span class=\"string\">'push'</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">class</span>=<span class=\"string\">'footer'</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">body</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"页脚顶部外边距设为负数\"><a href=\"#页脚顶部外边距设为负数\" class=\"headerlink\" title=\"页脚顶部外边距设为负数\"></a>页脚顶部外边距设为负数</h3><p>和第一种方法大同小异, 需理解margin顶部底部负值的差异.<br>注意如果content有背景或背景颜色, 用margin-bottom更佳, 因为用padding-bottom, footer会与背景重叠.</p>\n<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-tag\">html</span>, <span class=\"selector-tag\">body</span> &#123;</span><br><span class=\"line\">  <span class=\"attribute\">height</span>: <span class=\"number\">100%</span>;</span><br><span class=\"line\">  <span class=\"attribute\">margin</span>: <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"selector-class\">.wrapper</span> &#123;</span><br><span class=\"line\">  <span class=\"attribute\">min-height</span>: <span class=\"number\">100%</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"selector-class\">.content</span> &#123;</span><br><span class=\"line\">  <span class=\"attribute\">padding-bottom</span>: <span class=\"number\">50px</span>; <span class=\"comment\">/* margin-bottom ? */</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"selector-class\">.footer</span> &#123;</span><br><span class=\"line\">  <span class=\"attribute\">margin-top</span>: -<span class=\"number\">50px</span>; <span class=\"comment\">/* 和padding-bottom数值一致 */</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">body</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">class</span>=<span class=\"string\">'wrapper'</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">class</span>=<span class=\"string\">'content'</span>&gt;</span></span><br><span class=\"line\">      content</span><br><span class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">class</span>=<span class=\"string\">'footer'</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">body</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"calc-设置内容高度\"><a href=\"#calc-设置内容高度\" class=\"headerlink\" title=\"calc()设置内容高度\"></a>calc()设置内容高度</h3><p>上述两种方式都需要额外的标签来实现, 使用css3的计算函数能够轻松实现<br>缺点是只兼容高版本浏览器.</p>\n<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-class\">.content</span> &#123;</span><br><span class=\"line\">  <span class=\"attribute\">min-height</span>: <span class=\"built_in\">calc</span>(<span class=\"number\">100vh</span> - <span class=\"number\">50px</span>); <span class=\"comment\">/* 注意(-)之间空格, 后者是footer高度 */</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"selector-class\">.footer</span> &#123;</span><br><span class=\"line\">  <span class=\"attribute\">height</span>: <span class=\"number\">50px</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">body</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">class</span>=<span class=\"string\">\"content\"</span>&gt;</span></span><br><span class=\"line\">    content</span><br><span class=\"line\">  <span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">class</span>=<span class=\"string\">\"footer\"</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">body</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"flexbox弹性布局\"><a href=\"#flexbox弹性布局\" class=\"headerlink\" title=\"flexbox弹性布局\"></a>flexbox弹性布局</h3><p>以上三种方法的footer高度都是已知的, 或者说是固定的, 不利于页面布局. 因为一旦内容、页脚超出固定高度就会破坏布局.<br>flex同样不支持低版本ie.</p>\n<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-tag\">html</span> &#123;</span><br><span class=\"line\">  <span class=\"attribute\">height</span>: <span class=\"number\">100%</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"selector-tag\">body</span> &#123;</span><br><span class=\"line\">  <span class=\"attribute\">min-height</span>: <span class=\"number\">100%</span>;</span><br><span class=\"line\">  <span class=\"attribute\">display</span>: flex;</span><br><span class=\"line\">  <span class=\"attribute\">flex-direction</span>: column;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"selector-class\">.content</span> &#123;</span><br><span class=\"line\">  <span class=\"attribute\">flex</span>: <span class=\"number\">1</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">body</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">class</span>=<span class=\"string\">'content'</span>&gt;</span></span><br><span class=\"line\">    content</span><br><span class=\"line\">  <span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">class</span>=<span class=\"string\">'footer'</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">body</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"Grid网格布局\"><a href=\"#Grid网格布局\" class=\"headerlink\" title=\"Grid网格布局\"></a>Grid网格布局</h3><p>也是强大的布局, 但是目前兼容性最差, 只能在chrome和ff上使用.</p>\n<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-tag\">html</span> &#123;</span><br><span class=\"line\">  <span class=\"attribute\">height</span>: <span class=\"number\">100%</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"selector-tag\">body</span> &#123;</span><br><span class=\"line\">  <span class=\"attribute\">min-height</span>: <span class=\"number\">100%</span>;</span><br><span class=\"line\">  <span class=\"attribute\">display</span>: grid;</span><br><span class=\"line\">  <span class=\"attribute\">grid-template-rows</span>: <span class=\"number\">1</span>fr auto;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"selector-class\">.footer</span> &#123;</span><br><span class=\"line\">  <span class=\"attribute\">grid-row-start</span>: <span class=\"number\">2</span>;</span><br><span class=\"line\">  <span class=\"attribute\">grid-row-end</span>: <span class=\"number\">3</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">body</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">class</span>=<span class=\"string\">'content'</span>&gt;</span></span><br><span class=\"line\">    content</span><br><span class=\"line\">  <span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">class</span>=<span class=\"string\">'footer'</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">body</span>&gt;</span></span><br></pre></td></tr></table></figure>"},{"title":"浅析Js的for循环方法","date":"2017-10-15T09:09:23.000Z","_content":"\n##### 写在前面\n\nJs 的 for 方法有几种了, 你有没有仔细思考过? 性能如何?\n除了原生的前测试循环 for(;;), 还有 es5(for-in),(forEach) 以及 es6 新方法(for-of)\n\n#### 普通 for 循环: for(;;)\n\n```javascript\nconst arr = [1, 2, 3];\nfor (let i = 0; i < arr.length; i++) {\n  console.log(arr[i]);\n}\n// 当length是个不变的定值时, 可以赋予变量来提高性能\nfor (let i = 0, len = arr.length; i < len; i++) {\n  console.log(arr[i]);\n}\n```\n\n其实 JavaScript 的 Array 的索引是 String 类型, 即 arr[i]的 i 并不是 number, 而是 string. arr[1]是系统把 1 转成 String 的'1'才能使用 arr[1].\n\n<!-- more -->\n\n#### for-in\n\n```javascript\nconst arr = [1, 2, 3];\nfor (let i in arr) {\n  console.log(arr[i]);\n}\n```\n\nfor-in 更适合来遍历对象, 而不是数组, 事实也确实如此, for-in 循环遍历是对象的属性, 如下\n\n```javascript\n// arr\nconst arr = [1, 2, 3];\narr.abc = 'abc';\nfor(let i in arr) {\n  console.log('arr[' + i + '] = ' + arr[i]);\n}\n// output\narr[0] = 1 // 此处的索引0是String类型\narr[1] = 2\narr[2] = 3\narr[abc] = \"abc\"\n\n// obj\nconst psilo = {\n  age = 18;\n  sex = 'male';\n}\nfor(let i in psilo) {\n  console.log('psilo[' + i + '] = ' + psilo[i]);\n}\n// output\npsilo[age] = 18\npsilo[sex] = \"male\"\n```\n\n需要注意的是, for-in 遍历的顺序是不确定的. 第二点就是只能遍历可枚举的属性(enumerable == true).\n没错还有第三点, 就是 for-in 不仅能遍历自身属性, 还是遍历原型链属性的方法\n\n```javascript\nArray.prototype.one = \"one\";\nconst arr = [1, 2, 3];\nfor (let i in arr) {\n  console.log(\"arr[\" + i + \"] = \" + arr[i]);\n}\n// output\narr[0] = 1;\narr[1] = 2;\narr[2] = 3;\narr[one] = \"one\";\n```\n\n因此如果是数组遍历就使用普通 for 循环. 除了稀疏数组.\n\n```javascript\nconst arr = [];\narr[0] = 1;\narr[1000] = 2;\narr[100000] = 3;\n// 这使用普通for循环显然是不合理的\nfor (let i in arr) {\n  console.log(arr[i]); // 1 2 3 不会出现undefined\n}\n```\n\n但是因为 for-in 会遍历属性和原型, 所以性能损耗也是巨大的, 速度比普通 for 循环慢几倍不止.\n\n### forEach\n\n```JavaScript\nconst arr = [1, 2, 3];\narr.forEach(i => console.log(i));\narr.forEach(i => console.log(i + 1)); // 返回2, 3, 4. 不改变原数组\n```\n\nforEach 的弊端就是不能 break 和 return, 循环中途不能操作. 性能方面也不如普通 for 循环\n\n### for-of\n\n```JavaScript\nconst arr = [1, 2, 3];\nfor(let i of arr) {\n  console.log(i);\n}\n// output\n1\n2\n3\n```\n\nes6 引进这个方法的目的十分明确, forEach 不能中断; for-in 遍历顺序随机且适合遍历对象\n\n1. for-of 能中断循环\n\n```javascript\nconst arr = [1, 2, 3];\nfor (let i of arr) {\n  if (i === 2) break;\n  console.log(i);\n}\n// output\n1;\n```\n\n2. for-of 不仅支持数组, 还支持类数组如 nodelist\n3. 支持 Map, Set 对象遍历\n\n```JavaScript\nlet set = new Set([1, 2, 3]);\nfor(let i of set) {\n  console.log(i)\n}\n// output\n1\n2\n3\n```\n\n4. 不支持普通对象的循环\n","source":"_posts/浅析Js的for循环方法.md","raw":"---\ntitle: 浅析Js的for循环方法\ndate: 2017-10-15 17:09:23\ntags: [前端, JS]\n---\n\n##### 写在前面\n\nJs 的 for 方法有几种了, 你有没有仔细思考过? 性能如何?\n除了原生的前测试循环 for(;;), 还有 es5(for-in),(forEach) 以及 es6 新方法(for-of)\n\n#### 普通 for 循环: for(;;)\n\n```javascript\nconst arr = [1, 2, 3];\nfor (let i = 0; i < arr.length; i++) {\n  console.log(arr[i]);\n}\n// 当length是个不变的定值时, 可以赋予变量来提高性能\nfor (let i = 0, len = arr.length; i < len; i++) {\n  console.log(arr[i]);\n}\n```\n\n其实 JavaScript 的 Array 的索引是 String 类型, 即 arr[i]的 i 并不是 number, 而是 string. arr[1]是系统把 1 转成 String 的'1'才能使用 arr[1].\n\n<!-- more -->\n\n#### for-in\n\n```javascript\nconst arr = [1, 2, 3];\nfor (let i in arr) {\n  console.log(arr[i]);\n}\n```\n\nfor-in 更适合来遍历对象, 而不是数组, 事实也确实如此, for-in 循环遍历是对象的属性, 如下\n\n```javascript\n// arr\nconst arr = [1, 2, 3];\narr.abc = 'abc';\nfor(let i in arr) {\n  console.log('arr[' + i + '] = ' + arr[i]);\n}\n// output\narr[0] = 1 // 此处的索引0是String类型\narr[1] = 2\narr[2] = 3\narr[abc] = \"abc\"\n\n// obj\nconst psilo = {\n  age = 18;\n  sex = 'male';\n}\nfor(let i in psilo) {\n  console.log('psilo[' + i + '] = ' + psilo[i]);\n}\n// output\npsilo[age] = 18\npsilo[sex] = \"male\"\n```\n\n需要注意的是, for-in 遍历的顺序是不确定的. 第二点就是只能遍历可枚举的属性(enumerable == true).\n没错还有第三点, 就是 for-in 不仅能遍历自身属性, 还是遍历原型链属性的方法\n\n```javascript\nArray.prototype.one = \"one\";\nconst arr = [1, 2, 3];\nfor (let i in arr) {\n  console.log(\"arr[\" + i + \"] = \" + arr[i]);\n}\n// output\narr[0] = 1;\narr[1] = 2;\narr[2] = 3;\narr[one] = \"one\";\n```\n\n因此如果是数组遍历就使用普通 for 循环. 除了稀疏数组.\n\n```javascript\nconst arr = [];\narr[0] = 1;\narr[1000] = 2;\narr[100000] = 3;\n// 这使用普通for循环显然是不合理的\nfor (let i in arr) {\n  console.log(arr[i]); // 1 2 3 不会出现undefined\n}\n```\n\n但是因为 for-in 会遍历属性和原型, 所以性能损耗也是巨大的, 速度比普通 for 循环慢几倍不止.\n\n### forEach\n\n```JavaScript\nconst arr = [1, 2, 3];\narr.forEach(i => console.log(i));\narr.forEach(i => console.log(i + 1)); // 返回2, 3, 4. 不改变原数组\n```\n\nforEach 的弊端就是不能 break 和 return, 循环中途不能操作. 性能方面也不如普通 for 循环\n\n### for-of\n\n```JavaScript\nconst arr = [1, 2, 3];\nfor(let i of arr) {\n  console.log(i);\n}\n// output\n1\n2\n3\n```\n\nes6 引进这个方法的目的十分明确, forEach 不能中断; for-in 遍历顺序随机且适合遍历对象\n\n1. for-of 能中断循环\n\n```javascript\nconst arr = [1, 2, 3];\nfor (let i of arr) {\n  if (i === 2) break;\n  console.log(i);\n}\n// output\n1;\n```\n\n2. for-of 不仅支持数组, 还支持类数组如 nodelist\n3. 支持 Map, Set 对象遍历\n\n```JavaScript\nlet set = new Set([1, 2, 3]);\nfor(let i of set) {\n  console.log(i)\n}\n// output\n1\n2\n3\n```\n\n4. 不支持普通对象的循环\n","slug":"浅析Js的for循环方法","published":1,"updated":"2021-07-02T03:20:30.665Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl5sb8gfc0018xq0rra113umn","content":"<h5 id=\"写在前面\"><a href=\"#写在前面\" class=\"headerlink\" title=\"写在前面\"></a>写在前面</h5><p>Js 的 for 方法有几种了, 你有没有仔细思考过? 性能如何?<br>除了原生的前测试循环 for(;;), 还有 es5(for-in),(forEach) 以及 es6 新方法(for-of)</p>\n<h4 id=\"普通-for-循环-for\"><a href=\"#普通-for-循环-for\" class=\"headerlink\" title=\"普通 for 循环: for(;;)\"></a>普通 for 循环: for(;;)</h4><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> arr = [<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>];</span><br><span class=\"line\"><span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> i = <span class=\"number\">0</span>; i &lt; arr.length; i++) &#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(arr[i]);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// 当length是个不变的定值时, 可以赋予变量来提高性能</span></span><br><span class=\"line\"><span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> i = <span class=\"number\">0</span>, len = arr.length; i &lt; len; i++) &#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(arr[i]);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>其实 JavaScript 的 Array 的索引是 String 类型, 即 arr[i]的 i 并不是 number, 而是 string. arr[1]是系统把 1 转成 String 的’1’才能使用 arr[1].</p>\n<a id=\"more\"></a>\n\n<h4 id=\"for-in\"><a href=\"#for-in\" class=\"headerlink\" title=\"for-in\"></a>for-in</h4><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> arr = [<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>];</span><br><span class=\"line\"><span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> i <span class=\"keyword\">in</span> arr) &#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(arr[i]);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>for-in 更适合来遍历对象, 而不是数组, 事实也确实如此, for-in 循环遍历是对象的属性, 如下</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// arr</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> arr = [<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>];</span><br><span class=\"line\">arr.abc = <span class=\"string\">'abc'</span>;</span><br><span class=\"line\"><span class=\"keyword\">for</span>(<span class=\"keyword\">let</span> i <span class=\"keyword\">in</span> arr) &#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"string\">'arr['</span> + i + <span class=\"string\">'] = '</span> + arr[i]);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// output</span></span><br><span class=\"line\">arr[<span class=\"number\">0</span>] = <span class=\"number\">1</span> <span class=\"comment\">// 此处的索引0是String类型</span></span><br><span class=\"line\">arr[<span class=\"number\">1</span>] = <span class=\"number\">2</span></span><br><span class=\"line\">arr[<span class=\"number\">2</span>] = <span class=\"number\">3</span></span><br><span class=\"line\">arr[abc] = <span class=\"string\">\"abc\"</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// obj</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> psilo = &#123;</span><br><span class=\"line\">  age = <span class=\"number\">18</span>;</span><br><span class=\"line\">  sex = <span class=\"string\">'male'</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">for</span>(<span class=\"keyword\">let</span> i <span class=\"keyword\">in</span> psilo) &#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"string\">'psilo['</span> + i + <span class=\"string\">'] = '</span> + psilo[i]);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// output</span></span><br><span class=\"line\">psilo[age] = <span class=\"number\">18</span></span><br><span class=\"line\">psilo[sex] = <span class=\"string\">\"male\"</span></span><br></pre></td></tr></table></figure>\n\n<p>需要注意的是, for-in 遍历的顺序是不确定的. 第二点就是只能遍历可枚举的属性(enumerable == true).<br>没错还有第三点, 就是 for-in 不仅能遍历自身属性, 还是遍历原型链属性的方法</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">Array</span>.prototype.one = <span class=\"string\">\"one\"</span>;</span><br><span class=\"line\"><span class=\"keyword\">const</span> arr = [<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>];</span><br><span class=\"line\"><span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> i <span class=\"keyword\">in</span> arr) &#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"string\">\"arr[\"</span> + i + <span class=\"string\">\"] = \"</span> + arr[i]);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// output</span></span><br><span class=\"line\">arr[<span class=\"number\">0</span>] = <span class=\"number\">1</span>;</span><br><span class=\"line\">arr[<span class=\"number\">1</span>] = <span class=\"number\">2</span>;</span><br><span class=\"line\">arr[<span class=\"number\">2</span>] = <span class=\"number\">3</span>;</span><br><span class=\"line\">arr[one] = <span class=\"string\">\"one\"</span>;</span><br></pre></td></tr></table></figure>\n\n<p>因此如果是数组遍历就使用普通 for 循环. 除了稀疏数组.</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> arr = [];</span><br><span class=\"line\">arr[<span class=\"number\">0</span>] = <span class=\"number\">1</span>;</span><br><span class=\"line\">arr[<span class=\"number\">1000</span>] = <span class=\"number\">2</span>;</span><br><span class=\"line\">arr[<span class=\"number\">100000</span>] = <span class=\"number\">3</span>;</span><br><span class=\"line\"><span class=\"comment\">// 这使用普通for循环显然是不合理的</span></span><br><span class=\"line\"><span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> i <span class=\"keyword\">in</span> arr) &#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(arr[i]); <span class=\"comment\">// 1 2 3 不会出现undefined</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>但是因为 for-in 会遍历属性和原型, 所以性能损耗也是巨大的, 速度比普通 for 循环慢几倍不止.</p>\n<h3 id=\"forEach\"><a href=\"#forEach\" class=\"headerlink\" title=\"forEach\"></a>forEach</h3><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> arr = [<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>];</span><br><span class=\"line\">arr.forEach(<span class=\"function\"><span class=\"params\">i</span> =&gt;</span> <span class=\"built_in\">console</span>.log(i));</span><br><span class=\"line\">arr.forEach(<span class=\"function\"><span class=\"params\">i</span> =&gt;</span> <span class=\"built_in\">console</span>.log(i + <span class=\"number\">1</span>)); <span class=\"comment\">// 返回2, 3, 4. 不改变原数组</span></span><br></pre></td></tr></table></figure>\n\n<p>forEach 的弊端就是不能 break 和 return, 循环中途不能操作. 性能方面也不如普通 for 循环</p>\n<h3 id=\"for-of\"><a href=\"#for-of\" class=\"headerlink\" title=\"for-of\"></a>for-of</h3><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> arr = [<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>];</span><br><span class=\"line\"><span class=\"keyword\">for</span>(<span class=\"keyword\">let</span> i <span class=\"keyword\">of</span> arr) &#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(i);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// output</span></span><br><span class=\"line\"><span class=\"number\">1</span></span><br><span class=\"line\"><span class=\"number\">2</span></span><br><span class=\"line\"><span class=\"number\">3</span></span><br></pre></td></tr></table></figure>\n\n<p>es6 引进这个方法的目的十分明确, forEach 不能中断; for-in 遍历顺序随机且适合遍历对象</p>\n<ol>\n<li>for-of 能中断循环</li>\n</ol>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> arr = [<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>];</span><br><span class=\"line\"><span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> i <span class=\"keyword\">of</span> arr) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (i === <span class=\"number\">2</span>) <span class=\"keyword\">break</span>;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(i);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// output</span></span><br><span class=\"line\"><span class=\"number\">1</span>;</span><br></pre></td></tr></table></figure>\n\n<ol start=\"2\">\n<li>for-of 不仅支持数组, 还支持类数组如 nodelist</li>\n<li>支持 Map, Set 对象遍历</li>\n</ol>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> <span class=\"keyword\">set</span> = new Set([1, 2, 3]);</span><br><span class=\"line\">for(let i of <span class=\"keyword\">set</span>) &#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(i)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// output</span></span><br><span class=\"line\"><span class=\"number\">1</span></span><br><span class=\"line\"><span class=\"number\">2</span></span><br><span class=\"line\"><span class=\"number\">3</span></span><br></pre></td></tr></table></figure>\n\n<ol start=\"4\">\n<li>不支持普通对象的循环</li>\n</ol>\n","site":{"data":{}},"excerpt":"<h5 id=\"写在前面\"><a href=\"#写在前面\" class=\"headerlink\" title=\"写在前面\"></a>写在前面</h5><p>Js 的 for 方法有几种了, 你有没有仔细思考过? 性能如何?<br>除了原生的前测试循环 for(;;), 还有 es5(for-in),(forEach) 以及 es6 新方法(for-of)</p>\n<h4 id=\"普通-for-循环-for\"><a href=\"#普通-for-循环-for\" class=\"headerlink\" title=\"普通 for 循环: for(;;)\"></a>普通 for 循环: for(;;)</h4><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> arr = [<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>];</span><br><span class=\"line\"><span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> i = <span class=\"number\">0</span>; i &lt; arr.length; i++) &#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(arr[i]);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// 当length是个不变的定值时, 可以赋予变量来提高性能</span></span><br><span class=\"line\"><span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> i = <span class=\"number\">0</span>, len = arr.length; i &lt; len; i++) &#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(arr[i]);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>其实 JavaScript 的 Array 的索引是 String 类型, 即 arr[i]的 i 并不是 number, 而是 string. arr[1]是系统把 1 转成 String 的’1’才能使用 arr[1].</p>","more":"<h4 id=\"for-in\"><a href=\"#for-in\" class=\"headerlink\" title=\"for-in\"></a>for-in</h4><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> arr = [<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>];</span><br><span class=\"line\"><span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> i <span class=\"keyword\">in</span> arr) &#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(arr[i]);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>for-in 更适合来遍历对象, 而不是数组, 事实也确实如此, for-in 循环遍历是对象的属性, 如下</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// arr</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> arr = [<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>];</span><br><span class=\"line\">arr.abc = <span class=\"string\">'abc'</span>;</span><br><span class=\"line\"><span class=\"keyword\">for</span>(<span class=\"keyword\">let</span> i <span class=\"keyword\">in</span> arr) &#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"string\">'arr['</span> + i + <span class=\"string\">'] = '</span> + arr[i]);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// output</span></span><br><span class=\"line\">arr[<span class=\"number\">0</span>] = <span class=\"number\">1</span> <span class=\"comment\">// 此处的索引0是String类型</span></span><br><span class=\"line\">arr[<span class=\"number\">1</span>] = <span class=\"number\">2</span></span><br><span class=\"line\">arr[<span class=\"number\">2</span>] = <span class=\"number\">3</span></span><br><span class=\"line\">arr[abc] = <span class=\"string\">\"abc\"</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// obj</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> psilo = &#123;</span><br><span class=\"line\">  age = <span class=\"number\">18</span>;</span><br><span class=\"line\">  sex = <span class=\"string\">'male'</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">for</span>(<span class=\"keyword\">let</span> i <span class=\"keyword\">in</span> psilo) &#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"string\">'psilo['</span> + i + <span class=\"string\">'] = '</span> + psilo[i]);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// output</span></span><br><span class=\"line\">psilo[age] = <span class=\"number\">18</span></span><br><span class=\"line\">psilo[sex] = <span class=\"string\">\"male\"</span></span><br></pre></td></tr></table></figure>\n\n<p>需要注意的是, for-in 遍历的顺序是不确定的. 第二点就是只能遍历可枚举的属性(enumerable == true).<br>没错还有第三点, 就是 for-in 不仅能遍历自身属性, 还是遍历原型链属性的方法</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">Array</span>.prototype.one = <span class=\"string\">\"one\"</span>;</span><br><span class=\"line\"><span class=\"keyword\">const</span> arr = [<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>];</span><br><span class=\"line\"><span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> i <span class=\"keyword\">in</span> arr) &#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"string\">\"arr[\"</span> + i + <span class=\"string\">\"] = \"</span> + arr[i]);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// output</span></span><br><span class=\"line\">arr[<span class=\"number\">0</span>] = <span class=\"number\">1</span>;</span><br><span class=\"line\">arr[<span class=\"number\">1</span>] = <span class=\"number\">2</span>;</span><br><span class=\"line\">arr[<span class=\"number\">2</span>] = <span class=\"number\">3</span>;</span><br><span class=\"line\">arr[one] = <span class=\"string\">\"one\"</span>;</span><br></pre></td></tr></table></figure>\n\n<p>因此如果是数组遍历就使用普通 for 循环. 除了稀疏数组.</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> arr = [];</span><br><span class=\"line\">arr[<span class=\"number\">0</span>] = <span class=\"number\">1</span>;</span><br><span class=\"line\">arr[<span class=\"number\">1000</span>] = <span class=\"number\">2</span>;</span><br><span class=\"line\">arr[<span class=\"number\">100000</span>] = <span class=\"number\">3</span>;</span><br><span class=\"line\"><span class=\"comment\">// 这使用普通for循环显然是不合理的</span></span><br><span class=\"line\"><span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> i <span class=\"keyword\">in</span> arr) &#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(arr[i]); <span class=\"comment\">// 1 2 3 不会出现undefined</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>但是因为 for-in 会遍历属性和原型, 所以性能损耗也是巨大的, 速度比普通 for 循环慢几倍不止.</p>\n<h3 id=\"forEach\"><a href=\"#forEach\" class=\"headerlink\" title=\"forEach\"></a>forEach</h3><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> arr = [<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>];</span><br><span class=\"line\">arr.forEach(<span class=\"function\"><span class=\"params\">i</span> =&gt;</span> <span class=\"built_in\">console</span>.log(i));</span><br><span class=\"line\">arr.forEach(<span class=\"function\"><span class=\"params\">i</span> =&gt;</span> <span class=\"built_in\">console</span>.log(i + <span class=\"number\">1</span>)); <span class=\"comment\">// 返回2, 3, 4. 不改变原数组</span></span><br></pre></td></tr></table></figure>\n\n<p>forEach 的弊端就是不能 break 和 return, 循环中途不能操作. 性能方面也不如普通 for 循环</p>\n<h3 id=\"for-of\"><a href=\"#for-of\" class=\"headerlink\" title=\"for-of\"></a>for-of</h3><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> arr = [<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>];</span><br><span class=\"line\"><span class=\"keyword\">for</span>(<span class=\"keyword\">let</span> i <span class=\"keyword\">of</span> arr) &#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(i);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// output</span></span><br><span class=\"line\"><span class=\"number\">1</span></span><br><span class=\"line\"><span class=\"number\">2</span></span><br><span class=\"line\"><span class=\"number\">3</span></span><br></pre></td></tr></table></figure>\n\n<p>es6 引进这个方法的目的十分明确, forEach 不能中断; for-in 遍历顺序随机且适合遍历对象</p>\n<ol>\n<li>for-of 能中断循环</li>\n</ol>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> arr = [<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>];</span><br><span class=\"line\"><span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> i <span class=\"keyword\">of</span> arr) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (i === <span class=\"number\">2</span>) <span class=\"keyword\">break</span>;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(i);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// output</span></span><br><span class=\"line\"><span class=\"number\">1</span>;</span><br></pre></td></tr></table></figure>\n\n<ol start=\"2\">\n<li>for-of 不仅支持数组, 还支持类数组如 nodelist</li>\n<li>支持 Map, Set 对象遍历</li>\n</ol>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> <span class=\"keyword\">set</span> = new Set([1, 2, 3]);</span><br><span class=\"line\">for(let i of <span class=\"keyword\">set</span>) &#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(i)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// output</span></span><br><span class=\"line\"><span class=\"number\">1</span></span><br><span class=\"line\"><span class=\"number\">2</span></span><br><span class=\"line\"><span class=\"number\">3</span></span><br></pre></td></tr></table></figure>\n\n<ol start=\"4\">\n<li>不支持普通对象的循环</li>\n</ol>"},{"title":"浅析Vuex","date":"2018-03-27T07:02:46.000Z","_content":"##### 写在前面\n在中大型项目中, 如果不在组件外部管理状态, 可能会过于繁琐且难以维护. 本篇文章记录笔者的学习笔记, 基于官方文档.\n\n#### 最简单的Vuex\n```vue\nconst store = new Vuex.Store({\n  state: {\n    count: 0\n  },\n  mutations: {\n    increment (state) {\n      state.count++\n    }\n  }\n})\n```\n\n#### vuex运行机制\n在 Vuex 中, 不能直接改变状态, 比如不能直接改变 store.state.count, 唯一的途径就是显示地提交 (commit) mutation\n```vue\nstore.commit('increment')\n\nconsole.log(store.state.count) // -> 1\n```\n<!-- more -->\n#### Vuex核心概念\n1.state (单一状态树), 这意味着, 每个应用将仅仅包含一个 store 实例\n2.getter, 当不止一个组件需要 store.state 中派生的一些状态时, 我们就需要用到getter, 因为去每一个组件里定义相同的方法是麻烦的. getter 和 computed 一样, 会将得到的数据缓存起来.\n```vue\n// Getter 接受 state 作为其第一个参数：\nconst store = new Vuex.Store({\n  state: {\n    todos: [\n      { id: 1, text: '...', done: true },\n      { id: 2, text: '...', done: false }\n    ]\n  },\n  getters: {\n    doneTodos: state => {\n      return state.todos.filter(todo => todo.done)\n    }\n  }\n})\n\n// 1.通过属性访问\nstore.getters.doneTodos // -> [{ id: 1, text: '...', done: true }]\n// 2.通过方法访问\ngetters: {\n  // ...\n  getTodoById: (state) => (id) => {\n    return state.todos.find(todo => todo.id === id)\n  }\n}\nstore.getters.getTodoById(2) // -> { id: 2, text: '...', done: false }\n```\n3.mutation, 不能直接调用, 需要 commit('mutation事件名'). 值得注意的是 Mutation 必须是同步函数\n```vue\nconst store = new Vuex.Store({\n  state: {\n    count: 1\n  },\n  mutations: {\n    increment (state) {\n      // 变更状态\n      state.count++\n    }\n  }\n})\n\n// mutation提供额外参数, 称为提交载荷(Payload). 更多情况下, 载荷应该是个对象\nmutations: {\n  increment (state, n) { // n 为基本类型\n    state.count += n\n  }\n}\n\nmutations: {\n  increment (state, payload) { // 作为对象传入\n    state.count += payload.amount\n  }\n}\n\n// 使用常量替代事件类型\n// mutation-types.js\nexport const SOME_MUTATION = 'SOME_MUTATION'\n\n// store.js\nimport Vuex from 'vuex'\nimport { SOME_MUTATION } from './mutation-types'\n\nconst store = new Vuex.Store({\n  state: { ... },\n  mutations: {\n    // 我们可以使用 ES2015 风格的计算属性命名功能来使用一个常量作为函数名\n    [SOME_MUTATION] (state) {\n      // mutate state\n    }\n  }\n})\n```\n4.action, 提交的是 mutation, 而不是直接变更状态. Action 可以包含任意异步操作.\n```vue\nconst store = new Vuex.Store({\n  state: {\n    count: 0\n  },\n  mutations: {\n    increment (state) {\n      state.count++\n    }\n  },\n  actions: {\n    increment (context) {\n      context.commit('increment')\n    }\n  }\n})\n\n// action通过store.dispatch触发\nstore.dispatch('increment')\n\n// 可以组合action, 处理更复杂的异步流程\n/ ... /\nactions: {\n  actionA ({ commit }) {\n    return new Promise((resolve, reject) => {\n      setTimeout(() => {\n        commit('someMutation')\n        resolve()\n      }, 1000)\n    })\n  },\n  actionB ({ dispatch, commit }) {\n    return dispatch('actionA').then(() => { // 先执行actionA\n      commit('someOtherMutation')\n    })\n  }\n}\n\n// 也可以\nstore.dispatch('actionA').then(() => {\n  commit('someOtherMutation')\n})\n\n// 也可以利用async, await\n// 假设 getData() 和 getOtherData() 返回的是 Promise\nactions: {\n  async actionA ({ commit }) {\n    commit('someMutation', await getData())\n  },\n  async actionB ({ dispatch, commit }) {\n    await dispatch('actionA') // 等待 actionA 完成\n    commit('someOtherMutation', await getOtherData())\n  }\n}\n```\n\n5.module, 当应用过大时, 单一的store可能会相当臃肿, Vuex允许我们将 store 分割成模块, 并且每个模块拥有自己的 state, mutation, action, getter 甚至是嵌套子模块\n```vue\nconst moduleA = {\n  state: { ... },\n  mutations: { ... },\n  actions: { ... },\n  getters: { ... }\n}\n\nconst moduleB = {\n  state: { ... },\n  mutations: { ... },\n  actions: { ... }\n}\n\nconst store = new Vuex.Store({\n  modules: {\n    a: moduleA,\n    b: moduleB\n  }\n})\n\nstore.state.a // -> moduleA 的状态\nstore.state.b // -> moduleB 的状态\n\n// 对于模块内部的mutation和getter, 第一个参数是模块的局部状态对象, 用context.state表示, 第三个参数是根节点状态, 用context.rootState表示; 根getter作为第四个参数传入, 用context.rootGetter\n// 模块foo下\ngetters: {\n  // 在这个模块的 getter 中，`getters` 被局部化了\n  // 你可以使用 getter 的第四个参数来调用 `rootGetters`\n  someGetter (state, getters, rootState, rootGetters) {\n    getters.someOtherGetter // -> 'foo/someOtherGetter'\n    rootGetters.someOtherGetter // -> 'someOtherGetter'\n  },\n  someOtherGetter: state => { ... }\n},\n\nactions: {\n  // 在这个模块中， dispatch 和 commit 也被局部化了\n  // 他们可以接受 `root` 属性以访问根 dispatch 或 commit\n  someAction ({ dispatch, commit, getters, rootGetters }) {\n    getters.someGetter // -> 'foo/someGetter'\n    rootGetters.someGetter // -> 'someGetter'\n\n    dispatch('someOtherAction') // -> 'foo/someOtherAction'\n    dispatch('someOtherAction', null, { root: true }) // -> 'someOtherAction'\n\n    commit('someMutation') // -> 'foo/someMutation'\n    commit('someMutation', null, { root: true }) // -> 'someMutation'\n  },\n  someOtherAction (ctx, payload) { ... }\n}\n```\n\n#### 辅助函数\n当一个组件需要获取多个状态时, 将这些状态声明为计算属性会有些重复和冗余, 我们可以使用辅助函数来帮助.\n1.mapState\n```vue\nimport { mapState } from 'vuex'\nimport { mapGetters } from 'vuex'\nimport { mapMutations } from 'vuex'\nimport { mapActions } from 'vuex'\n\nexport default {\n  computed: mapState([\n    // 映射 this.count 为 store.state.count\n    'count'\n  ])\n}\n\n// 将mapState与局部计算属性混合\ncomputed: {\n  / ... /,\n  ...mapState({\n    / ... /\n  })\n}\n```\n2.mapGetters\n```vue\nmapGetters({\n  // 映射 `this.doneCount` 为 `store.getters.doneTodosCount`\n  doneCount: 'doneTodosCount'\n})\n\n// 混合\ncomputed: {\n// 使用对象展开运算符将 getter 混入 computed 对象中\n  ...mapGetters([\n    'doneTodosCount',\n    'anotherGetter',\n    // ...\n  ])\n}\n```\n3.mapMutations\n```vue\nmethods: {\n  ...mapMutations([\n    'increment', // 将 `this.increment()` 映射为 `this.$store.commit('increment')`\n\n    // `mapMutations` 也支持载荷：\n    'incrementBy' // 将 `this.incrementBy(amount)` 映射为 `this.$store.commit('incrementBy', amount)`\n  ]),\n\n  ...mapMutations({\n    add: 'increment' // 将 `this.add()` 映射为 `this.$store.commit('increment')`\n  })\n}\n```\n4.mapActions\n```vue\nmethods: {\n  ...mapActions([\n    'increment', // 将 `this.increment()` 映射为 `this.$store.dispatch('increment')`\n\n    // `mapActions` 也支持载荷：\n    'incrementBy' // 将 `this.incrementBy(amount)` 映射为 `this.$store.dispatch('incrementBy', amount)`\n  ]),\n\n  ...mapActions({\n    add: 'increment' // 将 `this.add()` 映射为 `this.$store.dispatch('increment')`\n  })\n}\n```","source":"_posts/浅析Vuex.md","raw":"---\ntitle: 浅析Vuex\ndate: 2018-03-27 15:02:46\ntags: [VUE,前端]\n---\n##### 写在前面\n在中大型项目中, 如果不在组件外部管理状态, 可能会过于繁琐且难以维护. 本篇文章记录笔者的学习笔记, 基于官方文档.\n\n#### 最简单的Vuex\n```vue\nconst store = new Vuex.Store({\n  state: {\n    count: 0\n  },\n  mutations: {\n    increment (state) {\n      state.count++\n    }\n  }\n})\n```\n\n#### vuex运行机制\n在 Vuex 中, 不能直接改变状态, 比如不能直接改变 store.state.count, 唯一的途径就是显示地提交 (commit) mutation\n```vue\nstore.commit('increment')\n\nconsole.log(store.state.count) // -> 1\n```\n<!-- more -->\n#### Vuex核心概念\n1.state (单一状态树), 这意味着, 每个应用将仅仅包含一个 store 实例\n2.getter, 当不止一个组件需要 store.state 中派生的一些状态时, 我们就需要用到getter, 因为去每一个组件里定义相同的方法是麻烦的. getter 和 computed 一样, 会将得到的数据缓存起来.\n```vue\n// Getter 接受 state 作为其第一个参数：\nconst store = new Vuex.Store({\n  state: {\n    todos: [\n      { id: 1, text: '...', done: true },\n      { id: 2, text: '...', done: false }\n    ]\n  },\n  getters: {\n    doneTodos: state => {\n      return state.todos.filter(todo => todo.done)\n    }\n  }\n})\n\n// 1.通过属性访问\nstore.getters.doneTodos // -> [{ id: 1, text: '...', done: true }]\n// 2.通过方法访问\ngetters: {\n  // ...\n  getTodoById: (state) => (id) => {\n    return state.todos.find(todo => todo.id === id)\n  }\n}\nstore.getters.getTodoById(2) // -> { id: 2, text: '...', done: false }\n```\n3.mutation, 不能直接调用, 需要 commit('mutation事件名'). 值得注意的是 Mutation 必须是同步函数\n```vue\nconst store = new Vuex.Store({\n  state: {\n    count: 1\n  },\n  mutations: {\n    increment (state) {\n      // 变更状态\n      state.count++\n    }\n  }\n})\n\n// mutation提供额外参数, 称为提交载荷(Payload). 更多情况下, 载荷应该是个对象\nmutations: {\n  increment (state, n) { // n 为基本类型\n    state.count += n\n  }\n}\n\nmutations: {\n  increment (state, payload) { // 作为对象传入\n    state.count += payload.amount\n  }\n}\n\n// 使用常量替代事件类型\n// mutation-types.js\nexport const SOME_MUTATION = 'SOME_MUTATION'\n\n// store.js\nimport Vuex from 'vuex'\nimport { SOME_MUTATION } from './mutation-types'\n\nconst store = new Vuex.Store({\n  state: { ... },\n  mutations: {\n    // 我们可以使用 ES2015 风格的计算属性命名功能来使用一个常量作为函数名\n    [SOME_MUTATION] (state) {\n      // mutate state\n    }\n  }\n})\n```\n4.action, 提交的是 mutation, 而不是直接变更状态. Action 可以包含任意异步操作.\n```vue\nconst store = new Vuex.Store({\n  state: {\n    count: 0\n  },\n  mutations: {\n    increment (state) {\n      state.count++\n    }\n  },\n  actions: {\n    increment (context) {\n      context.commit('increment')\n    }\n  }\n})\n\n// action通过store.dispatch触发\nstore.dispatch('increment')\n\n// 可以组合action, 处理更复杂的异步流程\n/ ... /\nactions: {\n  actionA ({ commit }) {\n    return new Promise((resolve, reject) => {\n      setTimeout(() => {\n        commit('someMutation')\n        resolve()\n      }, 1000)\n    })\n  },\n  actionB ({ dispatch, commit }) {\n    return dispatch('actionA').then(() => { // 先执行actionA\n      commit('someOtherMutation')\n    })\n  }\n}\n\n// 也可以\nstore.dispatch('actionA').then(() => {\n  commit('someOtherMutation')\n})\n\n// 也可以利用async, await\n// 假设 getData() 和 getOtherData() 返回的是 Promise\nactions: {\n  async actionA ({ commit }) {\n    commit('someMutation', await getData())\n  },\n  async actionB ({ dispatch, commit }) {\n    await dispatch('actionA') // 等待 actionA 完成\n    commit('someOtherMutation', await getOtherData())\n  }\n}\n```\n\n5.module, 当应用过大时, 单一的store可能会相当臃肿, Vuex允许我们将 store 分割成模块, 并且每个模块拥有自己的 state, mutation, action, getter 甚至是嵌套子模块\n```vue\nconst moduleA = {\n  state: { ... },\n  mutations: { ... },\n  actions: { ... },\n  getters: { ... }\n}\n\nconst moduleB = {\n  state: { ... },\n  mutations: { ... },\n  actions: { ... }\n}\n\nconst store = new Vuex.Store({\n  modules: {\n    a: moduleA,\n    b: moduleB\n  }\n})\n\nstore.state.a // -> moduleA 的状态\nstore.state.b // -> moduleB 的状态\n\n// 对于模块内部的mutation和getter, 第一个参数是模块的局部状态对象, 用context.state表示, 第三个参数是根节点状态, 用context.rootState表示; 根getter作为第四个参数传入, 用context.rootGetter\n// 模块foo下\ngetters: {\n  // 在这个模块的 getter 中，`getters` 被局部化了\n  // 你可以使用 getter 的第四个参数来调用 `rootGetters`\n  someGetter (state, getters, rootState, rootGetters) {\n    getters.someOtherGetter // -> 'foo/someOtherGetter'\n    rootGetters.someOtherGetter // -> 'someOtherGetter'\n  },\n  someOtherGetter: state => { ... }\n},\n\nactions: {\n  // 在这个模块中， dispatch 和 commit 也被局部化了\n  // 他们可以接受 `root` 属性以访问根 dispatch 或 commit\n  someAction ({ dispatch, commit, getters, rootGetters }) {\n    getters.someGetter // -> 'foo/someGetter'\n    rootGetters.someGetter // -> 'someGetter'\n\n    dispatch('someOtherAction') // -> 'foo/someOtherAction'\n    dispatch('someOtherAction', null, { root: true }) // -> 'someOtherAction'\n\n    commit('someMutation') // -> 'foo/someMutation'\n    commit('someMutation', null, { root: true }) // -> 'someMutation'\n  },\n  someOtherAction (ctx, payload) { ... }\n}\n```\n\n#### 辅助函数\n当一个组件需要获取多个状态时, 将这些状态声明为计算属性会有些重复和冗余, 我们可以使用辅助函数来帮助.\n1.mapState\n```vue\nimport { mapState } from 'vuex'\nimport { mapGetters } from 'vuex'\nimport { mapMutations } from 'vuex'\nimport { mapActions } from 'vuex'\n\nexport default {\n  computed: mapState([\n    // 映射 this.count 为 store.state.count\n    'count'\n  ])\n}\n\n// 将mapState与局部计算属性混合\ncomputed: {\n  / ... /,\n  ...mapState({\n    / ... /\n  })\n}\n```\n2.mapGetters\n```vue\nmapGetters({\n  // 映射 `this.doneCount` 为 `store.getters.doneTodosCount`\n  doneCount: 'doneTodosCount'\n})\n\n// 混合\ncomputed: {\n// 使用对象展开运算符将 getter 混入 computed 对象中\n  ...mapGetters([\n    'doneTodosCount',\n    'anotherGetter',\n    // ...\n  ])\n}\n```\n3.mapMutations\n```vue\nmethods: {\n  ...mapMutations([\n    'increment', // 将 `this.increment()` 映射为 `this.$store.commit('increment')`\n\n    // `mapMutations` 也支持载荷：\n    'incrementBy' // 将 `this.incrementBy(amount)` 映射为 `this.$store.commit('incrementBy', amount)`\n  ]),\n\n  ...mapMutations({\n    add: 'increment' // 将 `this.add()` 映射为 `this.$store.commit('increment')`\n  })\n}\n```\n4.mapActions\n```vue\nmethods: {\n  ...mapActions([\n    'increment', // 将 `this.increment()` 映射为 `this.$store.dispatch('increment')`\n\n    // `mapActions` 也支持载荷：\n    'incrementBy' // 将 `this.incrementBy(amount)` 映射为 `this.$store.dispatch('incrementBy', amount)`\n  ]),\n\n  ...mapActions({\n    add: 'increment' // 将 `this.add()` 映射为 `this.$store.dispatch('increment')`\n  })\n}\n```","slug":"浅析Vuex","published":1,"updated":"2021-07-02T03:20:30.665Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl5sb8gfd001bxq0r0t9sza3s","content":"<h5 id=\"写在前面\"><a href=\"#写在前面\" class=\"headerlink\" title=\"写在前面\"></a>写在前面</h5><p>在中大型项目中, 如果不在组件外部管理状态, 可能会过于繁琐且难以维护. 本篇文章记录笔者的学习笔记, 基于官方文档.</p>\n<h4 id=\"最简单的Vuex\"><a href=\"#最简单的Vuex\" class=\"headerlink\" title=\"最简单的Vuex\"></a>最简单的Vuex</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">const store = new Vuex.Store(&#123;</span><br><span class=\"line\">  state: &#123;</span><br><span class=\"line\">    count: 0</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  mutations: &#123;</span><br><span class=\"line\">    increment (state) &#123;</span><br><span class=\"line\">      state.count++</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"vuex运行机制\"><a href=\"#vuex运行机制\" class=\"headerlink\" title=\"vuex运行机制\"></a>vuex运行机制</h4><p>在 Vuex 中, 不能直接改变状态, 比如不能直接改变 store.state.count, 唯一的途径就是显示地提交 (commit) mutation</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">store.commit(&apos;increment&apos;)</span><br><span class=\"line\"></span><br><span class=\"line\">console.log(store.state.count) // -&gt; 1</span><br></pre></td></tr></table></figure>\n\n<a id=\"more\"></a>\n<h4 id=\"Vuex核心概念\"><a href=\"#Vuex核心概念\" class=\"headerlink\" title=\"Vuex核心概念\"></a>Vuex核心概念</h4><p>1.state (单一状态树), 这意味着, 每个应用将仅仅包含一个 store 实例<br>2.getter, 当不止一个组件需要 store.state 中派生的一些状态时, 我们就需要用到getter, 因为去每一个组件里定义相同的方法是麻烦的. getter 和 computed 一样, 会将得到的数据缓存起来.</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// Getter 接受 state 作为其第一个参数：</span><br><span class=\"line\">const store = new Vuex.Store(&#123;</span><br><span class=\"line\">  state: &#123;</span><br><span class=\"line\">    todos: [</span><br><span class=\"line\">      &#123; id: 1, text: &apos;...&apos;, done: true &#125;,</span><br><span class=\"line\">      &#123; id: 2, text: &apos;...&apos;, done: false &#125;</span><br><span class=\"line\">    ]</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  getters: &#123;</span><br><span class=\"line\">    doneTodos: state =&gt; &#123;</span><br><span class=\"line\">      return state.todos.filter(todo =&gt; todo.done)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\"></span><br><span class=\"line\">// 1.通过属性访问</span><br><span class=\"line\">store.getters.doneTodos // -&gt; [&#123; id: 1, text: &apos;...&apos;, done: true &#125;]</span><br><span class=\"line\">// 2.通过方法访问</span><br><span class=\"line\">getters: &#123;</span><br><span class=\"line\">  // ...</span><br><span class=\"line\">  getTodoById: (state) =&gt; (id) =&gt; &#123;</span><br><span class=\"line\">    return state.todos.find(todo =&gt; todo.id === id)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">store.getters.getTodoById(2) // -&gt; &#123; id: 2, text: &apos;...&apos;, done: false &#125;</span><br></pre></td></tr></table></figure>\n\n<p>3.mutation, 不能直接调用, 需要 commit(‘mutation事件名’). 值得注意的是 Mutation 必须是同步函数</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">const store = new Vuex.Store(&#123;</span><br><span class=\"line\">  state: &#123;</span><br><span class=\"line\">    count: 1</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  mutations: &#123;</span><br><span class=\"line\">    increment (state) &#123;</span><br><span class=\"line\">      // 变更状态</span><br><span class=\"line\">      state.count++</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\"></span><br><span class=\"line\">// mutation提供额外参数, 称为提交载荷(Payload). 更多情况下, 载荷应该是个对象</span><br><span class=\"line\">mutations: &#123;</span><br><span class=\"line\">  increment (state, n) &#123; // n 为基本类型</span><br><span class=\"line\">    state.count += n</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">mutations: &#123;</span><br><span class=\"line\">  increment (state, payload) &#123; // 作为对象传入</span><br><span class=\"line\">    state.count += payload.amount</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">// 使用常量替代事件类型</span><br><span class=\"line\">// mutation-types.js</span><br><span class=\"line\">export const SOME_MUTATION = &apos;SOME_MUTATION&apos;</span><br><span class=\"line\"></span><br><span class=\"line\">// store.js</span><br><span class=\"line\">import Vuex from &apos;vuex&apos;</span><br><span class=\"line\">import &#123; SOME_MUTATION &#125; from &apos;./mutation-types&apos;</span><br><span class=\"line\"></span><br><span class=\"line\">const store = new Vuex.Store(&#123;</span><br><span class=\"line\">  state: &#123; ... &#125;,</span><br><span class=\"line\">  mutations: &#123;</span><br><span class=\"line\">    // 我们可以使用 ES2015 风格的计算属性命名功能来使用一个常量作为函数名</span><br><span class=\"line\">    [SOME_MUTATION] (state) &#123;</span><br><span class=\"line\">      // mutate state</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n\n<p>4.action, 提交的是 mutation, 而不是直接变更状态. Action 可以包含任意异步操作.</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">const store = new Vuex.Store(&#123;</span><br><span class=\"line\">  state: &#123;</span><br><span class=\"line\">    count: 0</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  mutations: &#123;</span><br><span class=\"line\">    increment (state) &#123;</span><br><span class=\"line\">      state.count++</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  actions: &#123;</span><br><span class=\"line\">    increment (context) &#123;</span><br><span class=\"line\">      context.commit(&apos;increment&apos;)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\"></span><br><span class=\"line\">// action通过store.dispatch触发</span><br><span class=\"line\">store.dispatch(&apos;increment&apos;)</span><br><span class=\"line\"></span><br><span class=\"line\">// 可以组合action, 处理更复杂的异步流程</span><br><span class=\"line\">/ ... /</span><br><span class=\"line\">actions: &#123;</span><br><span class=\"line\">  actionA (&#123; commit &#125;) &#123;</span><br><span class=\"line\">    return new Promise((resolve, reject) =&gt; &#123;</span><br><span class=\"line\">      setTimeout(() =&gt; &#123;</span><br><span class=\"line\">        commit(&apos;someMutation&apos;)</span><br><span class=\"line\">        resolve()</span><br><span class=\"line\">      &#125;, 1000)</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  actionB (&#123; dispatch, commit &#125;) &#123;</span><br><span class=\"line\">    return dispatch(&apos;actionA&apos;).then(() =&gt; &#123; // 先执行actionA</span><br><span class=\"line\">      commit(&apos;someOtherMutation&apos;)</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">// 也可以</span><br><span class=\"line\">store.dispatch(&apos;actionA&apos;).then(() =&gt; &#123;</span><br><span class=\"line\">  commit(&apos;someOtherMutation&apos;)</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\"></span><br><span class=\"line\">// 也可以利用async, await</span><br><span class=\"line\">// 假设 getData() 和 getOtherData() 返回的是 Promise</span><br><span class=\"line\">actions: &#123;</span><br><span class=\"line\">  async actionA (&#123; commit &#125;) &#123;</span><br><span class=\"line\">    commit(&apos;someMutation&apos;, await getData())</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  async actionB (&#123; dispatch, commit &#125;) &#123;</span><br><span class=\"line\">    await dispatch(&apos;actionA&apos;) // 等待 actionA 完成</span><br><span class=\"line\">    commit(&apos;someOtherMutation&apos;, await getOtherData())</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>5.module, 当应用过大时, 单一的store可能会相当臃肿, Vuex允许我们将 store 分割成模块, 并且每个模块拥有自己的 state, mutation, action, getter 甚至是嵌套子模块</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">const moduleA = &#123;</span><br><span class=\"line\">  state: &#123; ... &#125;,</span><br><span class=\"line\">  mutations: &#123; ... &#125;,</span><br><span class=\"line\">  actions: &#123; ... &#125;,</span><br><span class=\"line\">  getters: &#123; ... &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">const moduleB = &#123;</span><br><span class=\"line\">  state: &#123; ... &#125;,</span><br><span class=\"line\">  mutations: &#123; ... &#125;,</span><br><span class=\"line\">  actions: &#123; ... &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">const store = new Vuex.Store(&#123;</span><br><span class=\"line\">  modules: &#123;</span><br><span class=\"line\">    a: moduleA,</span><br><span class=\"line\">    b: moduleB</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\"></span><br><span class=\"line\">store.state.a // -&gt; moduleA 的状态</span><br><span class=\"line\">store.state.b // -&gt; moduleB 的状态</span><br><span class=\"line\"></span><br><span class=\"line\">// 对于模块内部的mutation和getter, 第一个参数是模块的局部状态对象, 用context.state表示, 第三个参数是根节点状态, 用context.rootState表示; 根getter作为第四个参数传入, 用context.rootGetter</span><br><span class=\"line\">// 模块foo下</span><br><span class=\"line\">getters: &#123;</span><br><span class=\"line\">  // 在这个模块的 getter 中，`getters` 被局部化了</span><br><span class=\"line\">  // 你可以使用 getter 的第四个参数来调用 `rootGetters`</span><br><span class=\"line\">  someGetter (state, getters, rootState, rootGetters) &#123;</span><br><span class=\"line\">    getters.someOtherGetter // -&gt; &apos;foo/someOtherGetter&apos;</span><br><span class=\"line\">    rootGetters.someOtherGetter // -&gt; &apos;someOtherGetter&apos;</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  someOtherGetter: state =&gt; &#123; ... &#125;</span><br><span class=\"line\">&#125;,</span><br><span class=\"line\"></span><br><span class=\"line\">actions: &#123;</span><br><span class=\"line\">  // 在这个模块中， dispatch 和 commit 也被局部化了</span><br><span class=\"line\">  // 他们可以接受 `root` 属性以访问根 dispatch 或 commit</span><br><span class=\"line\">  someAction (&#123; dispatch, commit, getters, rootGetters &#125;) &#123;</span><br><span class=\"line\">    getters.someGetter // -&gt; &apos;foo/someGetter&apos;</span><br><span class=\"line\">    rootGetters.someGetter // -&gt; &apos;someGetter&apos;</span><br><span class=\"line\"></span><br><span class=\"line\">    dispatch(&apos;someOtherAction&apos;) // -&gt; &apos;foo/someOtherAction&apos;</span><br><span class=\"line\">    dispatch(&apos;someOtherAction&apos;, null, &#123; root: true &#125;) // -&gt; &apos;someOtherAction&apos;</span><br><span class=\"line\"></span><br><span class=\"line\">    commit(&apos;someMutation&apos;) // -&gt; &apos;foo/someMutation&apos;</span><br><span class=\"line\">    commit(&apos;someMutation&apos;, null, &#123; root: true &#125;) // -&gt; &apos;someMutation&apos;</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  someOtherAction (ctx, payload) &#123; ... &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"辅助函数\"><a href=\"#辅助函数\" class=\"headerlink\" title=\"辅助函数\"></a>辅助函数</h4><p>当一个组件需要获取多个状态时, 将这些状态声明为计算属性会有些重复和冗余, 我们可以使用辅助函数来帮助.<br>1.mapState</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">import &#123; mapState &#125; from &apos;vuex&apos;</span><br><span class=\"line\">import &#123; mapGetters &#125; from &apos;vuex&apos;</span><br><span class=\"line\">import &#123; mapMutations &#125; from &apos;vuex&apos;</span><br><span class=\"line\">import &#123; mapActions &#125; from &apos;vuex&apos;</span><br><span class=\"line\"></span><br><span class=\"line\">export default &#123;</span><br><span class=\"line\">  computed: mapState([</span><br><span class=\"line\">    // 映射 this.count 为 store.state.count</span><br><span class=\"line\">    &apos;count&apos;</span><br><span class=\"line\">  ])</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">// 将mapState与局部计算属性混合</span><br><span class=\"line\">computed: &#123;</span><br><span class=\"line\">  / ... /,</span><br><span class=\"line\">  ...mapState(&#123;</span><br><span class=\"line\">    / ... /</span><br><span class=\"line\">  &#125;)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>2.mapGetters</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">mapGetters(&#123;</span><br><span class=\"line\">  // 映射 `this.doneCount` 为 `store.getters.doneTodosCount`</span><br><span class=\"line\">  doneCount: &apos;doneTodosCount&apos;</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\"></span><br><span class=\"line\">// 混合</span><br><span class=\"line\">computed: &#123;</span><br><span class=\"line\">// 使用对象展开运算符将 getter 混入 computed 对象中</span><br><span class=\"line\">  ...mapGetters([</span><br><span class=\"line\">    &apos;doneTodosCount&apos;,</span><br><span class=\"line\">    &apos;anotherGetter&apos;,</span><br><span class=\"line\">    // ...</span><br><span class=\"line\">  ])</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>3.mapMutations</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">methods: &#123;</span><br><span class=\"line\">  ...mapMutations([</span><br><span class=\"line\">    &apos;increment&apos;, // 将 `this.increment()` 映射为 `this.$store.commit(&apos;increment&apos;)`</span><br><span class=\"line\"></span><br><span class=\"line\">    // `mapMutations` 也支持载荷：</span><br><span class=\"line\">    &apos;incrementBy&apos; // 将 `this.incrementBy(amount)` 映射为 `this.$store.commit(&apos;incrementBy&apos;, amount)`</span><br><span class=\"line\">  ]),</span><br><span class=\"line\"></span><br><span class=\"line\">  ...mapMutations(&#123;</span><br><span class=\"line\">    add: &apos;increment&apos; // 将 `this.add()` 映射为 `this.$store.commit(&apos;increment&apos;)`</span><br><span class=\"line\">  &#125;)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>4.mapActions</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">methods: &#123;</span><br><span class=\"line\">  ...mapActions([</span><br><span class=\"line\">    &apos;increment&apos;, // 将 `this.increment()` 映射为 `this.$store.dispatch(&apos;increment&apos;)`</span><br><span class=\"line\"></span><br><span class=\"line\">    // `mapActions` 也支持载荷：</span><br><span class=\"line\">    &apos;incrementBy&apos; // 将 `this.incrementBy(amount)` 映射为 `this.$store.dispatch(&apos;incrementBy&apos;, amount)`</span><br><span class=\"line\">  ]),</span><br><span class=\"line\"></span><br><span class=\"line\">  ...mapActions(&#123;</span><br><span class=\"line\">    add: &apos;increment&apos; // 将 `this.add()` 映射为 `this.$store.dispatch(&apos;increment&apos;)`</span><br><span class=\"line\">  &#125;)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>","site":{"data":{}},"excerpt":"<h5 id=\"写在前面\"><a href=\"#写在前面\" class=\"headerlink\" title=\"写在前面\"></a>写在前面</h5><p>在中大型项目中, 如果不在组件外部管理状态, 可能会过于繁琐且难以维护. 本篇文章记录笔者的学习笔记, 基于官方文档.</p>\n<h4 id=\"最简单的Vuex\"><a href=\"#最简单的Vuex\" class=\"headerlink\" title=\"最简单的Vuex\"></a>最简单的Vuex</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">const store = new Vuex.Store(&#123;</span><br><span class=\"line\">  state: &#123;</span><br><span class=\"line\">    count: 0</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  mutations: &#123;</span><br><span class=\"line\">    increment (state) &#123;</span><br><span class=\"line\">      state.count++</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"vuex运行机制\"><a href=\"#vuex运行机制\" class=\"headerlink\" title=\"vuex运行机制\"></a>vuex运行机制</h4><p>在 Vuex 中, 不能直接改变状态, 比如不能直接改变 store.state.count, 唯一的途径就是显示地提交 (commit) mutation</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">store.commit(&apos;increment&apos;)</span><br><span class=\"line\"></span><br><span class=\"line\">console.log(store.state.count) // -&gt; 1</span><br></pre></td></tr></table></figure>","more":"<h4 id=\"Vuex核心概念\"><a href=\"#Vuex核心概念\" class=\"headerlink\" title=\"Vuex核心概念\"></a>Vuex核心概念</h4><p>1.state (单一状态树), 这意味着, 每个应用将仅仅包含一个 store 实例<br>2.getter, 当不止一个组件需要 store.state 中派生的一些状态时, 我们就需要用到getter, 因为去每一个组件里定义相同的方法是麻烦的. getter 和 computed 一样, 会将得到的数据缓存起来.</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// Getter 接受 state 作为其第一个参数：</span><br><span class=\"line\">const store = new Vuex.Store(&#123;</span><br><span class=\"line\">  state: &#123;</span><br><span class=\"line\">    todos: [</span><br><span class=\"line\">      &#123; id: 1, text: &apos;...&apos;, done: true &#125;,</span><br><span class=\"line\">      &#123; id: 2, text: &apos;...&apos;, done: false &#125;</span><br><span class=\"line\">    ]</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  getters: &#123;</span><br><span class=\"line\">    doneTodos: state =&gt; &#123;</span><br><span class=\"line\">      return state.todos.filter(todo =&gt; todo.done)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\"></span><br><span class=\"line\">// 1.通过属性访问</span><br><span class=\"line\">store.getters.doneTodos // -&gt; [&#123; id: 1, text: &apos;...&apos;, done: true &#125;]</span><br><span class=\"line\">// 2.通过方法访问</span><br><span class=\"line\">getters: &#123;</span><br><span class=\"line\">  // ...</span><br><span class=\"line\">  getTodoById: (state) =&gt; (id) =&gt; &#123;</span><br><span class=\"line\">    return state.todos.find(todo =&gt; todo.id === id)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">store.getters.getTodoById(2) // -&gt; &#123; id: 2, text: &apos;...&apos;, done: false &#125;</span><br></pre></td></tr></table></figure>\n\n<p>3.mutation, 不能直接调用, 需要 commit(‘mutation事件名’). 值得注意的是 Mutation 必须是同步函数</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">const store = new Vuex.Store(&#123;</span><br><span class=\"line\">  state: &#123;</span><br><span class=\"line\">    count: 1</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  mutations: &#123;</span><br><span class=\"line\">    increment (state) &#123;</span><br><span class=\"line\">      // 变更状态</span><br><span class=\"line\">      state.count++</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\"></span><br><span class=\"line\">// mutation提供额外参数, 称为提交载荷(Payload). 更多情况下, 载荷应该是个对象</span><br><span class=\"line\">mutations: &#123;</span><br><span class=\"line\">  increment (state, n) &#123; // n 为基本类型</span><br><span class=\"line\">    state.count += n</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">mutations: &#123;</span><br><span class=\"line\">  increment (state, payload) &#123; // 作为对象传入</span><br><span class=\"line\">    state.count += payload.amount</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">// 使用常量替代事件类型</span><br><span class=\"line\">// mutation-types.js</span><br><span class=\"line\">export const SOME_MUTATION = &apos;SOME_MUTATION&apos;</span><br><span class=\"line\"></span><br><span class=\"line\">// store.js</span><br><span class=\"line\">import Vuex from &apos;vuex&apos;</span><br><span class=\"line\">import &#123; SOME_MUTATION &#125; from &apos;./mutation-types&apos;</span><br><span class=\"line\"></span><br><span class=\"line\">const store = new Vuex.Store(&#123;</span><br><span class=\"line\">  state: &#123; ... &#125;,</span><br><span class=\"line\">  mutations: &#123;</span><br><span class=\"line\">    // 我们可以使用 ES2015 风格的计算属性命名功能来使用一个常量作为函数名</span><br><span class=\"line\">    [SOME_MUTATION] (state) &#123;</span><br><span class=\"line\">      // mutate state</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n\n<p>4.action, 提交的是 mutation, 而不是直接变更状态. Action 可以包含任意异步操作.</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">const store = new Vuex.Store(&#123;</span><br><span class=\"line\">  state: &#123;</span><br><span class=\"line\">    count: 0</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  mutations: &#123;</span><br><span class=\"line\">    increment (state) &#123;</span><br><span class=\"line\">      state.count++</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  actions: &#123;</span><br><span class=\"line\">    increment (context) &#123;</span><br><span class=\"line\">      context.commit(&apos;increment&apos;)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\"></span><br><span class=\"line\">// action通过store.dispatch触发</span><br><span class=\"line\">store.dispatch(&apos;increment&apos;)</span><br><span class=\"line\"></span><br><span class=\"line\">// 可以组合action, 处理更复杂的异步流程</span><br><span class=\"line\">/ ... /</span><br><span class=\"line\">actions: &#123;</span><br><span class=\"line\">  actionA (&#123; commit &#125;) &#123;</span><br><span class=\"line\">    return new Promise((resolve, reject) =&gt; &#123;</span><br><span class=\"line\">      setTimeout(() =&gt; &#123;</span><br><span class=\"line\">        commit(&apos;someMutation&apos;)</span><br><span class=\"line\">        resolve()</span><br><span class=\"line\">      &#125;, 1000)</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  actionB (&#123; dispatch, commit &#125;) &#123;</span><br><span class=\"line\">    return dispatch(&apos;actionA&apos;).then(() =&gt; &#123; // 先执行actionA</span><br><span class=\"line\">      commit(&apos;someOtherMutation&apos;)</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">// 也可以</span><br><span class=\"line\">store.dispatch(&apos;actionA&apos;).then(() =&gt; &#123;</span><br><span class=\"line\">  commit(&apos;someOtherMutation&apos;)</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\"></span><br><span class=\"line\">// 也可以利用async, await</span><br><span class=\"line\">// 假设 getData() 和 getOtherData() 返回的是 Promise</span><br><span class=\"line\">actions: &#123;</span><br><span class=\"line\">  async actionA (&#123; commit &#125;) &#123;</span><br><span class=\"line\">    commit(&apos;someMutation&apos;, await getData())</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  async actionB (&#123; dispatch, commit &#125;) &#123;</span><br><span class=\"line\">    await dispatch(&apos;actionA&apos;) // 等待 actionA 完成</span><br><span class=\"line\">    commit(&apos;someOtherMutation&apos;, await getOtherData())</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>5.module, 当应用过大时, 单一的store可能会相当臃肿, Vuex允许我们将 store 分割成模块, 并且每个模块拥有自己的 state, mutation, action, getter 甚至是嵌套子模块</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">const moduleA = &#123;</span><br><span class=\"line\">  state: &#123; ... &#125;,</span><br><span class=\"line\">  mutations: &#123; ... &#125;,</span><br><span class=\"line\">  actions: &#123; ... &#125;,</span><br><span class=\"line\">  getters: &#123; ... &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">const moduleB = &#123;</span><br><span class=\"line\">  state: &#123; ... &#125;,</span><br><span class=\"line\">  mutations: &#123; ... &#125;,</span><br><span class=\"line\">  actions: &#123; ... &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">const store = new Vuex.Store(&#123;</span><br><span class=\"line\">  modules: &#123;</span><br><span class=\"line\">    a: moduleA,</span><br><span class=\"line\">    b: moduleB</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\"></span><br><span class=\"line\">store.state.a // -&gt; moduleA 的状态</span><br><span class=\"line\">store.state.b // -&gt; moduleB 的状态</span><br><span class=\"line\"></span><br><span class=\"line\">// 对于模块内部的mutation和getter, 第一个参数是模块的局部状态对象, 用context.state表示, 第三个参数是根节点状态, 用context.rootState表示; 根getter作为第四个参数传入, 用context.rootGetter</span><br><span class=\"line\">// 模块foo下</span><br><span class=\"line\">getters: &#123;</span><br><span class=\"line\">  // 在这个模块的 getter 中，`getters` 被局部化了</span><br><span class=\"line\">  // 你可以使用 getter 的第四个参数来调用 `rootGetters`</span><br><span class=\"line\">  someGetter (state, getters, rootState, rootGetters) &#123;</span><br><span class=\"line\">    getters.someOtherGetter // -&gt; &apos;foo/someOtherGetter&apos;</span><br><span class=\"line\">    rootGetters.someOtherGetter // -&gt; &apos;someOtherGetter&apos;</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  someOtherGetter: state =&gt; &#123; ... &#125;</span><br><span class=\"line\">&#125;,</span><br><span class=\"line\"></span><br><span class=\"line\">actions: &#123;</span><br><span class=\"line\">  // 在这个模块中， dispatch 和 commit 也被局部化了</span><br><span class=\"line\">  // 他们可以接受 `root` 属性以访问根 dispatch 或 commit</span><br><span class=\"line\">  someAction (&#123; dispatch, commit, getters, rootGetters &#125;) &#123;</span><br><span class=\"line\">    getters.someGetter // -&gt; &apos;foo/someGetter&apos;</span><br><span class=\"line\">    rootGetters.someGetter // -&gt; &apos;someGetter&apos;</span><br><span class=\"line\"></span><br><span class=\"line\">    dispatch(&apos;someOtherAction&apos;) // -&gt; &apos;foo/someOtherAction&apos;</span><br><span class=\"line\">    dispatch(&apos;someOtherAction&apos;, null, &#123; root: true &#125;) // -&gt; &apos;someOtherAction&apos;</span><br><span class=\"line\"></span><br><span class=\"line\">    commit(&apos;someMutation&apos;) // -&gt; &apos;foo/someMutation&apos;</span><br><span class=\"line\">    commit(&apos;someMutation&apos;, null, &#123; root: true &#125;) // -&gt; &apos;someMutation&apos;</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  someOtherAction (ctx, payload) &#123; ... &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"辅助函数\"><a href=\"#辅助函数\" class=\"headerlink\" title=\"辅助函数\"></a>辅助函数</h4><p>当一个组件需要获取多个状态时, 将这些状态声明为计算属性会有些重复和冗余, 我们可以使用辅助函数来帮助.<br>1.mapState</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">import &#123; mapState &#125; from &apos;vuex&apos;</span><br><span class=\"line\">import &#123; mapGetters &#125; from &apos;vuex&apos;</span><br><span class=\"line\">import &#123; mapMutations &#125; from &apos;vuex&apos;</span><br><span class=\"line\">import &#123; mapActions &#125; from &apos;vuex&apos;</span><br><span class=\"line\"></span><br><span class=\"line\">export default &#123;</span><br><span class=\"line\">  computed: mapState([</span><br><span class=\"line\">    // 映射 this.count 为 store.state.count</span><br><span class=\"line\">    &apos;count&apos;</span><br><span class=\"line\">  ])</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">// 将mapState与局部计算属性混合</span><br><span class=\"line\">computed: &#123;</span><br><span class=\"line\">  / ... /,</span><br><span class=\"line\">  ...mapState(&#123;</span><br><span class=\"line\">    / ... /</span><br><span class=\"line\">  &#125;)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>2.mapGetters</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">mapGetters(&#123;</span><br><span class=\"line\">  // 映射 `this.doneCount` 为 `store.getters.doneTodosCount`</span><br><span class=\"line\">  doneCount: &apos;doneTodosCount&apos;</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\"></span><br><span class=\"line\">// 混合</span><br><span class=\"line\">computed: &#123;</span><br><span class=\"line\">// 使用对象展开运算符将 getter 混入 computed 对象中</span><br><span class=\"line\">  ...mapGetters([</span><br><span class=\"line\">    &apos;doneTodosCount&apos;,</span><br><span class=\"line\">    &apos;anotherGetter&apos;,</span><br><span class=\"line\">    // ...</span><br><span class=\"line\">  ])</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>3.mapMutations</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">methods: &#123;</span><br><span class=\"line\">  ...mapMutations([</span><br><span class=\"line\">    &apos;increment&apos;, // 将 `this.increment()` 映射为 `this.$store.commit(&apos;increment&apos;)`</span><br><span class=\"line\"></span><br><span class=\"line\">    // `mapMutations` 也支持载荷：</span><br><span class=\"line\">    &apos;incrementBy&apos; // 将 `this.incrementBy(amount)` 映射为 `this.$store.commit(&apos;incrementBy&apos;, amount)`</span><br><span class=\"line\">  ]),</span><br><span class=\"line\"></span><br><span class=\"line\">  ...mapMutations(&#123;</span><br><span class=\"line\">    add: &apos;increment&apos; // 将 `this.add()` 映射为 `this.$store.commit(&apos;increment&apos;)`</span><br><span class=\"line\">  &#125;)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>4.mapActions</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">methods: &#123;</span><br><span class=\"line\">  ...mapActions([</span><br><span class=\"line\">    &apos;increment&apos;, // 将 `this.increment()` 映射为 `this.$store.dispatch(&apos;increment&apos;)`</span><br><span class=\"line\"></span><br><span class=\"line\">    // `mapActions` 也支持载荷：</span><br><span class=\"line\">    &apos;incrementBy&apos; // 将 `this.incrementBy(amount)` 映射为 `this.$store.dispatch(&apos;incrementBy&apos;, amount)`</span><br><span class=\"line\">  ]),</span><br><span class=\"line\"></span><br><span class=\"line\">  ...mapActions(&#123;</span><br><span class=\"line\">    add: &apos;increment&apos; // 将 `this.add()` 映射为 `this.$store.dispatch(&apos;increment&apos;)`</span><br><span class=\"line\">  &#125;)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>"},{"title":"浅析axios","date":"2018-04-11T14:50:57.000Z","_content":"##### 写在前面\nvue官方已经确定不要维护vue-resource, 转而推荐axios. axios有何力量使得官方都推荐使用呢?\n\n#### 最简单的axios例子\n```JavaScript\n  axios('api'); // 默认get请求\n```\n<!-- more -->\n#### 几则例子\n```JavaScript\n// 1. api + params\naxios.get('/user?name=psilo').then(() => {\n  // 请求成功处理\n}).catch(() => {\n  // 请求失败处理\n});\n// 2. api\naxios.get('/user', {\n  params: {\n    name: 'psilo'\n  }\n}).then(() => {}).catch(() => {});\n\n// 请求方法\naxios.request(config)\naxios.get(url[, config])\naxios.delete(url[, config])\naxios.head(url[, config])\naxios.post(url[, data[, config]])\naxios.put(url[, data[, config]])\naxios.patch(url[, data[, config]])\n\n// 也可以把请求方法method, 请求地址url写在config里\naxios({\n  method: 'post', // 不写默认get方法\n  url: '/user/12345',\n  data: {\n    firstName: 'Psilo',\n    lastName: 'Lau'\n  }\n});\n```\n\n#### 并发请求\n```javascript\nfunction getUserAccount() {\n  return axios.get('/user/12345');\n}\n\nfunction getUserPermissions() {\n  return axios.get('/user/12345/permissions');\n}\n\naxios.all([getUserAccount(), getUserPermissions()]) // axios.all([iterable])\n  .then(axios.spread(function (acct, perms) { // axios.spread(callback)\n    // 两个请求现在都执行完成\n  }));\n```\n\n#### 一些请求配置\n```JavaScript\n  // `baseURL` 将自动加在 `url` 前面，除非 `url` 是一个绝对 URL。\n  // 它可以通过设置一个 `baseURL` 便于为 axios 实例的方法传递相对 URL\n  baseURL: 'https://some-domain.com/api/',\n\n  // `transformRequest` 允许在向服务器发送前，修改请求数据\n  // 只能用在 'PUT', 'POST' 和 'PATCH' 这几个请求方法\n  // 后面数组中的函数必须返回一个字符串，或 ArrayBuffer，或 Stream\n  transformRequest: [function (data) {\n    // 对 data 进行任意转换处理\n\n    return data;\n  }],\n\n  // `transformResponse` 在传递给 then/catch 前，允许修改响应数据\n  transformResponse: [function (data) {\n    // 对 data 进行任意转换处理\n\n    return data;\n  }],\n\n  // `timeout` 指定请求超时的毫秒数(0 表示无超时时间)\n  // 如果请求话费了超过 `timeout` 的时间，请求将被中断\n  timeout: 1000,\n```\n\n#### 响应结构\n```JavaScript\n{\n  // `data` 由服务器提供的响应\n  data: {},\n\n  // `status` 来自服务器响应的 HTTP 状态码\n  status: 200,\n\n  // `statusText` 来自服务器响应的 HTTP 状态信息\n  statusText: 'OK',\n\n  // `headers` 服务器响应的头\n  headers: {},\n\n  // `config` 是为请求提供的配置信息\n  config: {}\n}\n```\n\n#### 配置的优先顺序\n1. 在 lib/defaults.js 找到的库的默认值.\n2. 实例的 defaults 属性.\n3. 请求的 config 参数.\n```JavaScript\n// 使用由库提供的配置的默认值来创建实例\n// 此时超时配置的默认值是 `0`\nvar instance = axios.create();\n\n// 覆写库的超时默认值\n// 现在，在超时前，所有请求都会等待 2.5 秒\ninstance.defaults.timeout = 2500;\n\n// 为已知需要花费很长时间的请求覆写超时设置\ninstance.get('/longRequest', {\n  timeout: 5000\n});\n```\n\n#### 拦截器\n在请求或响应被 then 或 catch 处理前拦截它们.\n```JavaScript\n// 添加请求拦截器\naxios.interceptors.request.use(function (config) {\n    // 在发送请求之前做些什么\n    return config;\n  }, function (error) {\n    // 对请求错误做些什么\n    return Promise.reject(error);\n  });\n\n// 添加响应拦截器\naxios.interceptors.response.use(function (response) {\n    // 对响应数据做点什么\n    return response;\n  }, function (error) {\n    // 对响应错误做点什么\n    return Promise.reject(error);\n  });\n```","source":"_posts/浅析axios.md","raw":"---\ntitle: 浅析axios\ndate: 2018-04-11 22:50:57\ntags: [VUE,前端]\n---\n##### 写在前面\nvue官方已经确定不要维护vue-resource, 转而推荐axios. axios有何力量使得官方都推荐使用呢?\n\n#### 最简单的axios例子\n```JavaScript\n  axios('api'); // 默认get请求\n```\n<!-- more -->\n#### 几则例子\n```JavaScript\n// 1. api + params\naxios.get('/user?name=psilo').then(() => {\n  // 请求成功处理\n}).catch(() => {\n  // 请求失败处理\n});\n// 2. api\naxios.get('/user', {\n  params: {\n    name: 'psilo'\n  }\n}).then(() => {}).catch(() => {});\n\n// 请求方法\naxios.request(config)\naxios.get(url[, config])\naxios.delete(url[, config])\naxios.head(url[, config])\naxios.post(url[, data[, config]])\naxios.put(url[, data[, config]])\naxios.patch(url[, data[, config]])\n\n// 也可以把请求方法method, 请求地址url写在config里\naxios({\n  method: 'post', // 不写默认get方法\n  url: '/user/12345',\n  data: {\n    firstName: 'Psilo',\n    lastName: 'Lau'\n  }\n});\n```\n\n#### 并发请求\n```javascript\nfunction getUserAccount() {\n  return axios.get('/user/12345');\n}\n\nfunction getUserPermissions() {\n  return axios.get('/user/12345/permissions');\n}\n\naxios.all([getUserAccount(), getUserPermissions()]) // axios.all([iterable])\n  .then(axios.spread(function (acct, perms) { // axios.spread(callback)\n    // 两个请求现在都执行完成\n  }));\n```\n\n#### 一些请求配置\n```JavaScript\n  // `baseURL` 将自动加在 `url` 前面，除非 `url` 是一个绝对 URL。\n  // 它可以通过设置一个 `baseURL` 便于为 axios 实例的方法传递相对 URL\n  baseURL: 'https://some-domain.com/api/',\n\n  // `transformRequest` 允许在向服务器发送前，修改请求数据\n  // 只能用在 'PUT', 'POST' 和 'PATCH' 这几个请求方法\n  // 后面数组中的函数必须返回一个字符串，或 ArrayBuffer，或 Stream\n  transformRequest: [function (data) {\n    // 对 data 进行任意转换处理\n\n    return data;\n  }],\n\n  // `transformResponse` 在传递给 then/catch 前，允许修改响应数据\n  transformResponse: [function (data) {\n    // 对 data 进行任意转换处理\n\n    return data;\n  }],\n\n  // `timeout` 指定请求超时的毫秒数(0 表示无超时时间)\n  // 如果请求话费了超过 `timeout` 的时间，请求将被中断\n  timeout: 1000,\n```\n\n#### 响应结构\n```JavaScript\n{\n  // `data` 由服务器提供的响应\n  data: {},\n\n  // `status` 来自服务器响应的 HTTP 状态码\n  status: 200,\n\n  // `statusText` 来自服务器响应的 HTTP 状态信息\n  statusText: 'OK',\n\n  // `headers` 服务器响应的头\n  headers: {},\n\n  // `config` 是为请求提供的配置信息\n  config: {}\n}\n```\n\n#### 配置的优先顺序\n1. 在 lib/defaults.js 找到的库的默认值.\n2. 实例的 defaults 属性.\n3. 请求的 config 参数.\n```JavaScript\n// 使用由库提供的配置的默认值来创建实例\n// 此时超时配置的默认值是 `0`\nvar instance = axios.create();\n\n// 覆写库的超时默认值\n// 现在，在超时前，所有请求都会等待 2.5 秒\ninstance.defaults.timeout = 2500;\n\n// 为已知需要花费很长时间的请求覆写超时设置\ninstance.get('/longRequest', {\n  timeout: 5000\n});\n```\n\n#### 拦截器\n在请求或响应被 then 或 catch 处理前拦截它们.\n```JavaScript\n// 添加请求拦截器\naxios.interceptors.request.use(function (config) {\n    // 在发送请求之前做些什么\n    return config;\n  }, function (error) {\n    // 对请求错误做些什么\n    return Promise.reject(error);\n  });\n\n// 添加响应拦截器\naxios.interceptors.response.use(function (response) {\n    // 对响应数据做点什么\n    return response;\n  }, function (error) {\n    // 对响应错误做点什么\n    return Promise.reject(error);\n  });\n```","slug":"浅析axios","published":1,"updated":"2021-07-02T03:20:30.665Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl5sb8gfe001dxq0rghzxiv7k","content":"<h5 id=\"写在前面\"><a href=\"#写在前面\" class=\"headerlink\" title=\"写在前面\"></a>写在前面</h5><p>vue官方已经确定不要维护vue-resource, 转而推荐axios. axios有何力量使得官方都推荐使用呢?</p>\n<h4 id=\"最简单的axios例子\"><a href=\"#最简单的axios例子\" class=\"headerlink\" title=\"最简单的axios例子\"></a>最简单的axios例子</h4><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">axios(<span class=\"string\">'api'</span>); <span class=\"comment\">// 默认get请求</span></span><br></pre></td></tr></table></figure>\n\n<a id=\"more\"></a>\n<h4 id=\"几则例子\"><a href=\"#几则例子\" class=\"headerlink\" title=\"几则例子\"></a>几则例子</h4><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 1. api + params</span></span><br><span class=\"line\">axios.get(<span class=\"string\">'/user?name=psilo'</span>).then(<span class=\"function\"><span class=\"params\">()</span> =&gt;</span> &#123;</span><br><span class=\"line\">  <span class=\"comment\">// 请求成功处理</span></span><br><span class=\"line\">&#125;).catch(<span class=\"function\"><span class=\"params\">()</span> =&gt;</span> &#123;</span><br><span class=\"line\">  <span class=\"comment\">// 请求失败处理</span></span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"><span class=\"comment\">// 2. api</span></span><br><span class=\"line\">axios.get(<span class=\"string\">'/user'</span>, &#123;</span><br><span class=\"line\">  params: &#123;</span><br><span class=\"line\">    name: <span class=\"string\">'psilo'</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;).then(<span class=\"function\"><span class=\"params\">()</span> =&gt;</span> &#123;&#125;).catch(<span class=\"function\"><span class=\"params\">()</span> =&gt;</span> &#123;&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 请求方法</span></span><br><span class=\"line\">axios.request(config)</span><br><span class=\"line\">axios.get(url[, config])</span><br><span class=\"line\">axios.delete(url[, config])</span><br><span class=\"line\">axios.head(url[, config])</span><br><span class=\"line\">axios.post(url[, data[, config]])</span><br><span class=\"line\">axios.put(url[, data[, config]])</span><br><span class=\"line\">axios.patch(url[, data[, config]])</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 也可以把请求方法method, 请求地址url写在config里</span></span><br><span class=\"line\">axios(&#123;</span><br><span class=\"line\">  method: <span class=\"string\">'post'</span>, <span class=\"comment\">// 不写默认get方法</span></span><br><span class=\"line\">  url: <span class=\"string\">'/user/12345'</span>,</span><br><span class=\"line\">  data: &#123;</span><br><span class=\"line\">    firstName: <span class=\"string\">'Psilo'</span>,</span><br><span class=\"line\">    lastName: <span class=\"string\">'Lau'</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"并发请求\"><a href=\"#并发请求\" class=\"headerlink\" title=\"并发请求\"></a>并发请求</h4><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">getUserAccount</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> axios.get(<span class=\"string\">'/user/12345'</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">getUserPermissions</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> axios.get(<span class=\"string\">'/user/12345/permissions'</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">axios.all([getUserAccount(), getUserPermissions()]) <span class=\"comment\">// axios.all([iterable])</span></span><br><span class=\"line\">  .then(axios.spread(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">acct, perms</span>) </span>&#123; <span class=\"comment\">// axios.spread(callback)</span></span><br><span class=\"line\">    <span class=\"comment\">// 两个请求现在都执行完成</span></span><br><span class=\"line\">  &#125;));</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"一些请求配置\"><a href=\"#一些请求配置\" class=\"headerlink\" title=\"一些请求配置\"></a>一些请求配置</h4><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// `baseURL` 将自动加在 `url` 前面，除非 `url` 是一个绝对 URL。</span></span><br><span class=\"line\"><span class=\"comment\">// 它可以通过设置一个 `baseURL` 便于为 axios 实例的方法传递相对 URL</span></span><br><span class=\"line\">baseURL: <span class=\"string\">'https://some-domain.com/api/'</span>,</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// `transformRequest` 允许在向服务器发送前，修改请求数据</span></span><br><span class=\"line\"><span class=\"comment\">// 只能用在 'PUT', 'POST' 和 'PATCH' 这几个请求方法</span></span><br><span class=\"line\"><span class=\"comment\">// 后面数组中的函数必须返回一个字符串，或 ArrayBuffer，或 Stream</span></span><br><span class=\"line\">transformRequest: [<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">data</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">// 对 data 进行任意转换处理</span></span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">return</span> data;</span><br><span class=\"line\">&#125;],</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// `transformResponse` 在传递给 then/catch 前，允许修改响应数据</span></span><br><span class=\"line\">transformResponse: [<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">data</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">// 对 data 进行任意转换处理</span></span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">return</span> data;</span><br><span class=\"line\">&#125;],</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// `timeout` 指定请求超时的毫秒数(0 表示无超时时间)</span></span><br><span class=\"line\"><span class=\"comment\">// 如果请求话费了超过 `timeout` 的时间，请求将被中断</span></span><br><span class=\"line\">timeout: <span class=\"number\">1000</span>,</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"响应结构\"><a href=\"#响应结构\" class=\"headerlink\" title=\"响应结构\"></a>响应结构</h4><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;</span><br><span class=\"line\">  <span class=\"comment\">// `data` 由服务器提供的响应</span></span><br><span class=\"line\">  data: &#123;&#125;,</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// `status` 来自服务器响应的 HTTP 状态码</span></span><br><span class=\"line\">  status: <span class=\"number\">200</span>,</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// `statusText` 来自服务器响应的 HTTP 状态信息</span></span><br><span class=\"line\">  statusText: <span class=\"string\">'OK'</span>,</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// `headers` 服务器响应的头</span></span><br><span class=\"line\">  headers: &#123;&#125;,</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// `config` 是为请求提供的配置信息</span></span><br><span class=\"line\">  config: &#123;&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"配置的优先顺序\"><a href=\"#配置的优先顺序\" class=\"headerlink\" title=\"配置的优先顺序\"></a>配置的优先顺序</h4><ol>\n<li>在 lib/defaults.js 找到的库的默认值.</li>\n<li>实例的 defaults 属性.</li>\n<li>请求的 config 参数.<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 使用由库提供的配置的默认值来创建实例</span></span><br><span class=\"line\"><span class=\"comment\">// 此时超时配置的默认值是 `0`</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> instance = axios.create();</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 覆写库的超时默认值</span></span><br><span class=\"line\"><span class=\"comment\">// 现在，在超时前，所有请求都会等待 2.5 秒</span></span><br><span class=\"line\">instance.defaults.timeout = <span class=\"number\">2500</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 为已知需要花费很长时间的请求覆写超时设置</span></span><br><span class=\"line\">instance.get(<span class=\"string\">'/longRequest'</span>, &#123;</span><br><span class=\"line\">  timeout: <span class=\"number\">5000</span></span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n\n</li>\n</ol>\n<h4 id=\"拦截器\"><a href=\"#拦截器\" class=\"headerlink\" title=\"拦截器\"></a>拦截器</h4><p>在请求或响应被 then 或 catch 处理前拦截它们.</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 添加请求拦截器</span></span><br><span class=\"line\">axios.interceptors.request.use(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">config</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 在发送请求之前做些什么</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> config;</span><br><span class=\"line\">  &#125;, <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">error</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 对请求错误做些什么</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"built_in\">Promise</span>.reject(error);</span><br><span class=\"line\">  &#125;);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 添加响应拦截器</span></span><br><span class=\"line\">axios.interceptors.response.use(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">response</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 对响应数据做点什么</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> response;</span><br><span class=\"line\">  &#125;, <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">error</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 对响应错误做点什么</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"built_in\">Promise</span>.reject(error);</span><br><span class=\"line\">  &#125;);</span><br></pre></td></tr></table></figure>","site":{"data":{}},"excerpt":"<h5 id=\"写在前面\"><a href=\"#写在前面\" class=\"headerlink\" title=\"写在前面\"></a>写在前面</h5><p>vue官方已经确定不要维护vue-resource, 转而推荐axios. axios有何力量使得官方都推荐使用呢?</p>\n<h4 id=\"最简单的axios例子\"><a href=\"#最简单的axios例子\" class=\"headerlink\" title=\"最简单的axios例子\"></a>最简单的axios例子</h4><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">axios(<span class=\"string\">'api'</span>); <span class=\"comment\">// 默认get请求</span></span><br></pre></td></tr></table></figure>","more":"<h4 id=\"几则例子\"><a href=\"#几则例子\" class=\"headerlink\" title=\"几则例子\"></a>几则例子</h4><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 1. api + params</span></span><br><span class=\"line\">axios.get(<span class=\"string\">'/user?name=psilo'</span>).then(<span class=\"function\"><span class=\"params\">()</span> =&gt;</span> &#123;</span><br><span class=\"line\">  <span class=\"comment\">// 请求成功处理</span></span><br><span class=\"line\">&#125;).catch(<span class=\"function\"><span class=\"params\">()</span> =&gt;</span> &#123;</span><br><span class=\"line\">  <span class=\"comment\">// 请求失败处理</span></span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"><span class=\"comment\">// 2. api</span></span><br><span class=\"line\">axios.get(<span class=\"string\">'/user'</span>, &#123;</span><br><span class=\"line\">  params: &#123;</span><br><span class=\"line\">    name: <span class=\"string\">'psilo'</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;).then(<span class=\"function\"><span class=\"params\">()</span> =&gt;</span> &#123;&#125;).catch(<span class=\"function\"><span class=\"params\">()</span> =&gt;</span> &#123;&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 请求方法</span></span><br><span class=\"line\">axios.request(config)</span><br><span class=\"line\">axios.get(url[, config])</span><br><span class=\"line\">axios.delete(url[, config])</span><br><span class=\"line\">axios.head(url[, config])</span><br><span class=\"line\">axios.post(url[, data[, config]])</span><br><span class=\"line\">axios.put(url[, data[, config]])</span><br><span class=\"line\">axios.patch(url[, data[, config]])</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 也可以把请求方法method, 请求地址url写在config里</span></span><br><span class=\"line\">axios(&#123;</span><br><span class=\"line\">  method: <span class=\"string\">'post'</span>, <span class=\"comment\">// 不写默认get方法</span></span><br><span class=\"line\">  url: <span class=\"string\">'/user/12345'</span>,</span><br><span class=\"line\">  data: &#123;</span><br><span class=\"line\">    firstName: <span class=\"string\">'Psilo'</span>,</span><br><span class=\"line\">    lastName: <span class=\"string\">'Lau'</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"并发请求\"><a href=\"#并发请求\" class=\"headerlink\" title=\"并发请求\"></a>并发请求</h4><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">getUserAccount</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> axios.get(<span class=\"string\">'/user/12345'</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">getUserPermissions</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> axios.get(<span class=\"string\">'/user/12345/permissions'</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">axios.all([getUserAccount(), getUserPermissions()]) <span class=\"comment\">// axios.all([iterable])</span></span><br><span class=\"line\">  .then(axios.spread(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">acct, perms</span>) </span>&#123; <span class=\"comment\">// axios.spread(callback)</span></span><br><span class=\"line\">    <span class=\"comment\">// 两个请求现在都执行完成</span></span><br><span class=\"line\">  &#125;));</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"一些请求配置\"><a href=\"#一些请求配置\" class=\"headerlink\" title=\"一些请求配置\"></a>一些请求配置</h4><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// `baseURL` 将自动加在 `url` 前面，除非 `url` 是一个绝对 URL。</span></span><br><span class=\"line\"><span class=\"comment\">// 它可以通过设置一个 `baseURL` 便于为 axios 实例的方法传递相对 URL</span></span><br><span class=\"line\">baseURL: <span class=\"string\">'https://some-domain.com/api/'</span>,</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// `transformRequest` 允许在向服务器发送前，修改请求数据</span></span><br><span class=\"line\"><span class=\"comment\">// 只能用在 'PUT', 'POST' 和 'PATCH' 这几个请求方法</span></span><br><span class=\"line\"><span class=\"comment\">// 后面数组中的函数必须返回一个字符串，或 ArrayBuffer，或 Stream</span></span><br><span class=\"line\">transformRequest: [<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">data</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">// 对 data 进行任意转换处理</span></span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">return</span> data;</span><br><span class=\"line\">&#125;],</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// `transformResponse` 在传递给 then/catch 前，允许修改响应数据</span></span><br><span class=\"line\">transformResponse: [<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">data</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">// 对 data 进行任意转换处理</span></span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">return</span> data;</span><br><span class=\"line\">&#125;],</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// `timeout` 指定请求超时的毫秒数(0 表示无超时时间)</span></span><br><span class=\"line\"><span class=\"comment\">// 如果请求话费了超过 `timeout` 的时间，请求将被中断</span></span><br><span class=\"line\">timeout: <span class=\"number\">1000</span>,</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"响应结构\"><a href=\"#响应结构\" class=\"headerlink\" title=\"响应结构\"></a>响应结构</h4><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;</span><br><span class=\"line\">  <span class=\"comment\">// `data` 由服务器提供的响应</span></span><br><span class=\"line\">  data: &#123;&#125;,</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// `status` 来自服务器响应的 HTTP 状态码</span></span><br><span class=\"line\">  status: <span class=\"number\">200</span>,</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// `statusText` 来自服务器响应的 HTTP 状态信息</span></span><br><span class=\"line\">  statusText: <span class=\"string\">'OK'</span>,</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// `headers` 服务器响应的头</span></span><br><span class=\"line\">  headers: &#123;&#125;,</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// `config` 是为请求提供的配置信息</span></span><br><span class=\"line\">  config: &#123;&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"配置的优先顺序\"><a href=\"#配置的优先顺序\" class=\"headerlink\" title=\"配置的优先顺序\"></a>配置的优先顺序</h4><ol>\n<li>在 lib/defaults.js 找到的库的默认值.</li>\n<li>实例的 defaults 属性.</li>\n<li>请求的 config 参数.<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 使用由库提供的配置的默认值来创建实例</span></span><br><span class=\"line\"><span class=\"comment\">// 此时超时配置的默认值是 `0`</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> instance = axios.create();</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 覆写库的超时默认值</span></span><br><span class=\"line\"><span class=\"comment\">// 现在，在超时前，所有请求都会等待 2.5 秒</span></span><br><span class=\"line\">instance.defaults.timeout = <span class=\"number\">2500</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 为已知需要花费很长时间的请求覆写超时设置</span></span><br><span class=\"line\">instance.get(<span class=\"string\">'/longRequest'</span>, &#123;</span><br><span class=\"line\">  timeout: <span class=\"number\">5000</span></span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n\n</li>\n</ol>\n<h4 id=\"拦截器\"><a href=\"#拦截器\" class=\"headerlink\" title=\"拦截器\"></a>拦截器</h4><p>在请求或响应被 then 或 catch 处理前拦截它们.</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 添加请求拦截器</span></span><br><span class=\"line\">axios.interceptors.request.use(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">config</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 在发送请求之前做些什么</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> config;</span><br><span class=\"line\">  &#125;, <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">error</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 对请求错误做些什么</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"built_in\">Promise</span>.reject(error);</span><br><span class=\"line\">  &#125;);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 添加响应拦截器</span></span><br><span class=\"line\">axios.interceptors.response.use(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">response</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 对响应数据做点什么</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> response;</span><br><span class=\"line\">  &#125;, <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">error</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 对响应错误做点什么</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"built_in\">Promise</span>.reject(error);</span><br><span class=\"line\">  &#125;);</span><br></pre></td></tr></table></figure>"},{"title":"浅述CSS实现垂直居中水平居中的方法","date":"2017-07-25T04:14:08.000Z","_content":"##### 写在前面\n最近看面试题有看到类似实现方式\n\n#### 1. 第一种, 也是我最常用的.\n    {\n      position: absolute;\n      left: 0; top: 0; bottom: 0; right:0;\n      margin: auto;\n    }\n这里的margin: auto, 相当于margin-top: 0等四边; 此方法支持ie8-10, 也支持图片居中; 缺点就是要声明宽高;\n\n#### 2. 负外边距.\n<!--more-->\n    {\n      position: absolute;\n      width: 300px; height: 200px;\n      top: 50%; left: 50%;\n      margin-top: -100px;\n      margin-left: -150px;\n    }\n\n这里的margin负值, 还涉及到另一个问题, 就是top, left和 bottom right 的负值有不一样的效果.  \n假设a、b、c是三个inline-block的100px正方形div, 处于中间的b, 设margin-left: -50px的效果是将a的右半边覆盖, 相当于b、c往左平移了50px, 而margin-right: -50px的效果是让c向左平移50px, 将b的右半部分覆盖. 上下同理.  \n值得注意的是, 当居中的元素有padding时, 负外边距也要加上padding计算, 不然会偏右下.\n\n#### 3. transform变形  \n    {\n      position: absolute;\n      top: 50%; left: 50%;\n      transform: translate(-50%, -50%);\n    }\n兼容性的话, ie8以下不支持. 而且属性需加浏览器厂商前缀. 如-webkit-transform.\n这个方法是最近才学习的方法, 用到css3属性. 和上面方法不一样, 当居中的元素有padding时, 不会影响; 当有margin时, 此方法也会偏右下.\n\n#### 4. display: table方法\n    <div class='table'>\n      <div class='table-cell'>\n        <div class='center-block'>\n          \n    .table {\n      display: table;\n    }\n    \n    .table-cell {\n      display: table-cell;\n      vertical: middle;\n    }\n    \n    .center-block {\n      width: 50%;\n      margin: 0 auto;\n    }\n该方法的缺点就是需要比较多的标签和css, 好处是不用设宽高也能居中. display属性, ie8及以上都支持.\n\n#### 5. 行内块元素\n    <div class='box'>\n      <div class='center-block'>\n    .box {\n      text-align: center; //先水平居中\n    }\n    \n    .box:after, .center-block {\n      display: inline-block;\n      vertical-align: middle;\n    }\n\n    .box:after {\n      height: 100%;\n      content: '';\n    }\n    \n    .center-block {\n      width:\n      height:\n    }\n这个方法可能居中的位置并不是那么精确. 需要负外边距来调整. 而且需要一个容器. 此方法支持ie7.\n\n#### 6. calc计算居中\n    {\n      position: absolute;\n      width: 100px;\n      height: 100px;\n      top: calc(50% - 50px); //运算符前后都需要空格, 不然报错.\n      left: calc(50% - 50px);\n    }\ncalc 50%减去宽高的一半就行了, 简单明了. 缺点是不兼容低版本ie, 需要ie9+.\n\n#### 7. Flex布局\n    <div class='box'>\n      <div class='center-block'>\n    \n    .box {\n      display: flex;\n      align-items: center;  //垂直\n      justify-content: center;  //水平\n    }\n    .center-block {\n      width:\n      height:\n    }\n也是简单暴力的一种方法, 但是我们知道一条规则, 越简单兼容性就越差, 低版本ie肯定是不支持的, ie9都不支持. 而且属性需加浏览器厂商前缀.","source":"_posts/浅述CSS实现垂直居中水平居中的方法.md","raw":"---\ntitle: 浅述CSS实现垂直居中水平居中的方法\ndate: 2017-07-25 12:14:08\ntags: [CSS,前端]\n---\n##### 写在前面\n最近看面试题有看到类似实现方式\n\n#### 1. 第一种, 也是我最常用的.\n    {\n      position: absolute;\n      left: 0; top: 0; bottom: 0; right:0;\n      margin: auto;\n    }\n这里的margin: auto, 相当于margin-top: 0等四边; 此方法支持ie8-10, 也支持图片居中; 缺点就是要声明宽高;\n\n#### 2. 负外边距.\n<!--more-->\n    {\n      position: absolute;\n      width: 300px; height: 200px;\n      top: 50%; left: 50%;\n      margin-top: -100px;\n      margin-left: -150px;\n    }\n\n这里的margin负值, 还涉及到另一个问题, 就是top, left和 bottom right 的负值有不一样的效果.  \n假设a、b、c是三个inline-block的100px正方形div, 处于中间的b, 设margin-left: -50px的效果是将a的右半边覆盖, 相当于b、c往左平移了50px, 而margin-right: -50px的效果是让c向左平移50px, 将b的右半部分覆盖. 上下同理.  \n值得注意的是, 当居中的元素有padding时, 负外边距也要加上padding计算, 不然会偏右下.\n\n#### 3. transform变形  \n    {\n      position: absolute;\n      top: 50%; left: 50%;\n      transform: translate(-50%, -50%);\n    }\n兼容性的话, ie8以下不支持. 而且属性需加浏览器厂商前缀. 如-webkit-transform.\n这个方法是最近才学习的方法, 用到css3属性. 和上面方法不一样, 当居中的元素有padding时, 不会影响; 当有margin时, 此方法也会偏右下.\n\n#### 4. display: table方法\n    <div class='table'>\n      <div class='table-cell'>\n        <div class='center-block'>\n          \n    .table {\n      display: table;\n    }\n    \n    .table-cell {\n      display: table-cell;\n      vertical: middle;\n    }\n    \n    .center-block {\n      width: 50%;\n      margin: 0 auto;\n    }\n该方法的缺点就是需要比较多的标签和css, 好处是不用设宽高也能居中. display属性, ie8及以上都支持.\n\n#### 5. 行内块元素\n    <div class='box'>\n      <div class='center-block'>\n    .box {\n      text-align: center; //先水平居中\n    }\n    \n    .box:after, .center-block {\n      display: inline-block;\n      vertical-align: middle;\n    }\n\n    .box:after {\n      height: 100%;\n      content: '';\n    }\n    \n    .center-block {\n      width:\n      height:\n    }\n这个方法可能居中的位置并不是那么精确. 需要负外边距来调整. 而且需要一个容器. 此方法支持ie7.\n\n#### 6. calc计算居中\n    {\n      position: absolute;\n      width: 100px;\n      height: 100px;\n      top: calc(50% - 50px); //运算符前后都需要空格, 不然报错.\n      left: calc(50% - 50px);\n    }\ncalc 50%减去宽高的一半就行了, 简单明了. 缺点是不兼容低版本ie, 需要ie9+.\n\n#### 7. Flex布局\n    <div class='box'>\n      <div class='center-block'>\n    \n    .box {\n      display: flex;\n      align-items: center;  //垂直\n      justify-content: center;  //水平\n    }\n    .center-block {\n      width:\n      height:\n    }\n也是简单暴力的一种方法, 但是我们知道一条规则, 越简单兼容性就越差, 低版本ie肯定是不支持的, ie9都不支持. 而且属性需加浏览器厂商前缀.","slug":"浅述CSS实现垂直居中水平居中的方法","published":1,"updated":"2021-07-02T03:20:30.665Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl5sb8gff001gxq0r96402acc","content":"<h5 id=\"写在前面\"><a href=\"#写在前面\" class=\"headerlink\" title=\"写在前面\"></a>写在前面</h5><p>最近看面试题有看到类似实现方式</p>\n<h4 id=\"1-第一种-也是我最常用的\"><a href=\"#1-第一种-也是我最常用的\" class=\"headerlink\" title=\"1. 第一种, 也是我最常用的.\"></a>1. 第一种, 也是我最常用的.</h4><pre><code>{\n  position: absolute;\n  left: 0; top: 0; bottom: 0; right:0;\n  margin: auto;\n}</code></pre><p>这里的margin: auto, 相当于margin-top: 0等四边; 此方法支持ie8-10, 也支持图片居中; 缺点就是要声明宽高;</p>\n<h4 id=\"2-负外边距\"><a href=\"#2-负外边距\" class=\"headerlink\" title=\"2. 负外边距.\"></a>2. 负外边距.</h4><a id=\"more\"></a>\n<pre><code>{\n  position: absolute;\n  width: 300px; height: 200px;\n  top: 50%; left: 50%;\n  margin-top: -100px;\n  margin-left: -150px;\n}</code></pre><p>这里的margin负值, 还涉及到另一个问题, 就是top, left和 bottom right 的负值有不一样的效果.<br>假设a、b、c是三个inline-block的100px正方形div, 处于中间的b, 设margin-left: -50px的效果是将a的右半边覆盖, 相当于b、c往左平移了50px, 而margin-right: -50px的效果是让c向左平移50px, 将b的右半部分覆盖. 上下同理.<br>值得注意的是, 当居中的元素有padding时, 负外边距也要加上padding计算, 不然会偏右下.</p>\n<h4 id=\"3-transform变形\"><a href=\"#3-transform变形\" class=\"headerlink\" title=\"3. transform变形\"></a>3. transform变形</h4><pre><code>{\n  position: absolute;\n  top: 50%; left: 50%;\n  transform: translate(-50%, -50%);\n}</code></pre><p>兼容性的话, ie8以下不支持. 而且属性需加浏览器厂商前缀. 如-webkit-transform.<br>这个方法是最近才学习的方法, 用到css3属性. 和上面方法不一样, 当居中的元素有padding时, 不会影响; 当有margin时, 此方法也会偏右下.</p>\n<h4 id=\"4-display-table方法\"><a href=\"#4-display-table方法\" class=\"headerlink\" title=\"4. display: table方法\"></a>4. display: table方法</h4><pre><code>&lt;div class=&apos;table&apos;&gt;\n  &lt;div class=&apos;table-cell&apos;&gt;\n    &lt;div class=&apos;center-block&apos;&gt;\n\n.table {\n  display: table;\n}\n\n.table-cell {\n  display: table-cell;\n  vertical: middle;\n}\n\n.center-block {\n  width: 50%;\n  margin: 0 auto;\n}</code></pre><p>该方法的缺点就是需要比较多的标签和css, 好处是不用设宽高也能居中. display属性, ie8及以上都支持.</p>\n<h4 id=\"5-行内块元素\"><a href=\"#5-行内块元素\" class=\"headerlink\" title=\"5. 行内块元素\"></a>5. 行内块元素</h4><pre><code>&lt;div class=&apos;box&apos;&gt;\n  &lt;div class=&apos;center-block&apos;&gt;\n.box {\n  text-align: center; //先水平居中\n}\n\n.box:after, .center-block {\n  display: inline-block;\n  vertical-align: middle;\n}\n\n.box:after {\n  height: 100%;\n  content: &apos;&apos;;\n}\n\n.center-block {\n  width:\n  height:\n}</code></pre><p>这个方法可能居中的位置并不是那么精确. 需要负外边距来调整. 而且需要一个容器. 此方法支持ie7.</p>\n<h4 id=\"6-calc计算居中\"><a href=\"#6-calc计算居中\" class=\"headerlink\" title=\"6. calc计算居中\"></a>6. calc计算居中</h4><pre><code>{\n  position: absolute;\n  width: 100px;\n  height: 100px;\n  top: calc(50% - 50px); //运算符前后都需要空格, 不然报错.\n  left: calc(50% - 50px);\n}</code></pre><p>calc 50%减去宽高的一半就行了, 简单明了. 缺点是不兼容低版本ie, 需要ie9+.</p>\n<h4 id=\"7-Flex布局\"><a href=\"#7-Flex布局\" class=\"headerlink\" title=\"7. Flex布局\"></a>7. Flex布局</h4><pre><code>&lt;div class=&apos;box&apos;&gt;\n  &lt;div class=&apos;center-block&apos;&gt;\n\n.box {\n  display: flex;\n  align-items: center;  //垂直\n  justify-content: center;  //水平\n}\n.center-block {\n  width:\n  height:\n}</code></pre><p>也是简单暴力的一种方法, 但是我们知道一条规则, 越简单兼容性就越差, 低版本ie肯定是不支持的, ie9都不支持. 而且属性需加浏览器厂商前缀.</p>\n","site":{"data":{}},"excerpt":"<h5 id=\"写在前面\"><a href=\"#写在前面\" class=\"headerlink\" title=\"写在前面\"></a>写在前面</h5><p>最近看面试题有看到类似实现方式</p>\n<h4 id=\"1-第一种-也是我最常用的\"><a href=\"#1-第一种-也是我最常用的\" class=\"headerlink\" title=\"1. 第一种, 也是我最常用的.\"></a>1. 第一种, 也是我最常用的.</h4><pre><code>{\n  position: absolute;\n  left: 0; top: 0; bottom: 0; right:0;\n  margin: auto;\n}</code></pre><p>这里的margin: auto, 相当于margin-top: 0等四边; 此方法支持ie8-10, 也支持图片居中; 缺点就是要声明宽高;</p>\n<h4 id=\"2-负外边距\"><a href=\"#2-负外边距\" class=\"headerlink\" title=\"2. 负外边距.\"></a>2. 负外边距.</h4>","more":"<pre><code>{\n  position: absolute;\n  width: 300px; height: 200px;\n  top: 50%; left: 50%;\n  margin-top: -100px;\n  margin-left: -150px;\n}</code></pre><p>这里的margin负值, 还涉及到另一个问题, 就是top, left和 bottom right 的负值有不一样的效果.<br>假设a、b、c是三个inline-block的100px正方形div, 处于中间的b, 设margin-left: -50px的效果是将a的右半边覆盖, 相当于b、c往左平移了50px, 而margin-right: -50px的效果是让c向左平移50px, 将b的右半部分覆盖. 上下同理.<br>值得注意的是, 当居中的元素有padding时, 负外边距也要加上padding计算, 不然会偏右下.</p>\n<h4 id=\"3-transform变形\"><a href=\"#3-transform变形\" class=\"headerlink\" title=\"3. transform变形\"></a>3. transform变形</h4><pre><code>{\n  position: absolute;\n  top: 50%; left: 50%;\n  transform: translate(-50%, -50%);\n}</code></pre><p>兼容性的话, ie8以下不支持. 而且属性需加浏览器厂商前缀. 如-webkit-transform.<br>这个方法是最近才学习的方法, 用到css3属性. 和上面方法不一样, 当居中的元素有padding时, 不会影响; 当有margin时, 此方法也会偏右下.</p>\n<h4 id=\"4-display-table方法\"><a href=\"#4-display-table方法\" class=\"headerlink\" title=\"4. display: table方法\"></a>4. display: table方法</h4><pre><code>&lt;div class=&apos;table&apos;&gt;\n  &lt;div class=&apos;table-cell&apos;&gt;\n    &lt;div class=&apos;center-block&apos;&gt;\n\n.table {\n  display: table;\n}\n\n.table-cell {\n  display: table-cell;\n  vertical: middle;\n}\n\n.center-block {\n  width: 50%;\n  margin: 0 auto;\n}</code></pre><p>该方法的缺点就是需要比较多的标签和css, 好处是不用设宽高也能居中. display属性, ie8及以上都支持.</p>\n<h4 id=\"5-行内块元素\"><a href=\"#5-行内块元素\" class=\"headerlink\" title=\"5. 行内块元素\"></a>5. 行内块元素</h4><pre><code>&lt;div class=&apos;box&apos;&gt;\n  &lt;div class=&apos;center-block&apos;&gt;\n.box {\n  text-align: center; //先水平居中\n}\n\n.box:after, .center-block {\n  display: inline-block;\n  vertical-align: middle;\n}\n\n.box:after {\n  height: 100%;\n  content: &apos;&apos;;\n}\n\n.center-block {\n  width:\n  height:\n}</code></pre><p>这个方法可能居中的位置并不是那么精确. 需要负外边距来调整. 而且需要一个容器. 此方法支持ie7.</p>\n<h4 id=\"6-calc计算居中\"><a href=\"#6-calc计算居中\" class=\"headerlink\" title=\"6. calc计算居中\"></a>6. calc计算居中</h4><pre><code>{\n  position: absolute;\n  width: 100px;\n  height: 100px;\n  top: calc(50% - 50px); //运算符前后都需要空格, 不然报错.\n  left: calc(50% - 50px);\n}</code></pre><p>calc 50%减去宽高的一半就行了, 简单明了. 缺点是不兼容低版本ie, 需要ie9+.</p>\n<h4 id=\"7-Flex布局\"><a href=\"#7-Flex布局\" class=\"headerlink\" title=\"7. Flex布局\"></a>7. Flex布局</h4><pre><code>&lt;div class=&apos;box&apos;&gt;\n  &lt;div class=&apos;center-block&apos;&gt;\n\n.box {\n  display: flex;\n  align-items: center;  //垂直\n  justify-content: center;  //水平\n}\n.center-block {\n  width:\n  height:\n}</code></pre><p>也是简单暴力的一种方法, 但是我们知道一条规则, 越简单兼容性就越差, 低版本ie肯定是不支持的, ie9都不支持. 而且属性需加浏览器厂商前缀.</p>"},{"title":"深入浅出正则匹配","date":"2021-11-15T08:02:40.000Z","_content":"\n## 初衷\n原因是因为最近想研究模版引擎，需要正则的知识。回想过去，正则这个小老弟似乎一直没有得到我的重视，毕竟轮子这么多，遇到所需的正则一抓一大把。直到最近，我想匹配某些规则的时候痛苦不已。于是决定系统地过一遍正则。\n\n## 基本语法\n\n## 基本方法\n\n## 拓展\n","source":"_posts/深入浅出正则匹配.md","raw":"---\ntitle: 深入浅出正则匹配\ndate: 2021-11-15 16:02:40\ntags: [前端, JS]\n---\n\n## 初衷\n原因是因为最近想研究模版引擎，需要正则的知识。回想过去，正则这个小老弟似乎一直没有得到我的重视，毕竟轮子这么多，遇到所需的正则一抓一大把。直到最近，我想匹配某些规则的时候痛苦不已。于是决定系统地过一遍正则。\n\n## 基本语法\n\n## 基本方法\n\n## 拓展\n","slug":"深入浅出正则匹配","published":1,"updated":"2022-05-31T11:40:56.163Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl5sb8gff001ixq0rzbveqhl9","content":"<h2 id=\"初衷\"><a href=\"#初衷\" class=\"headerlink\" title=\"初衷\"></a>初衷</h2><p>原因是因为最近想研究模版引擎，需要正则的知识。回想过去，正则这个小老弟似乎一直没有得到我的重视，毕竟轮子这么多，遇到所需的正则一抓一大把。直到最近，我想匹配某些规则的时候痛苦不已。于是决定系统地过一遍正则。</p>\n<h2 id=\"基本语法\"><a href=\"#基本语法\" class=\"headerlink\" title=\"基本语法\"></a>基本语法</h2><h2 id=\"基本方法\"><a href=\"#基本方法\" class=\"headerlink\" title=\"基本方法\"></a>基本方法</h2><h2 id=\"拓展\"><a href=\"#拓展\" class=\"headerlink\" title=\"拓展\"></a>拓展</h2>","site":{"data":{}},"excerpt":"","more":"<h2 id=\"初衷\"><a href=\"#初衷\" class=\"headerlink\" title=\"初衷\"></a>初衷</h2><p>原因是因为最近想研究模版引擎，需要正则的知识。回想过去，正则这个小老弟似乎一直没有得到我的重视，毕竟轮子这么多，遇到所需的正则一抓一大把。直到最近，我想匹配某些规则的时候痛苦不已。于是决定系统地过一遍正则。</p>\n<h2 id=\"基本语法\"><a href=\"#基本语法\" class=\"headerlink\" title=\"基本语法\"></a>基本语法</h2><h2 id=\"基本方法\"><a href=\"#基本方法\" class=\"headerlink\" title=\"基本方法\"></a>基本方法</h2><h2 id=\"拓展\"><a href=\"#拓展\" class=\"headerlink\" title=\"拓展\"></a>拓展</h2>"},{"title":"简述CSS3的一些属性(1)","date":"2017-06-16T05:55:49.000Z","_content":"##### 写在前面\n这篇文章主要讲css3边框\n主要讲一下三个属性,分别是border-radius,border-image,box-shadow.它们都没有继承性.\n\n#### border-radius\n首先讨论兼容性问题, 除了ie8以下大部分都兼容, 相信这个属性大家也很常用.\n\n1. border-radius其实是缩写, 如果要定义单个角落的radius的话,应该这么写 border-xxx-xxx-radius, 记住先写上下再写左右.如要定义左上的话应该是这样, border-top-left-radius.\n2. 它的值有三种, px,em,百分比. 我们假设div的宽高是一致的如200px, 当所设的值是宽高一半时即100px, 就是最大值了, 此时div得border就是一个正圆.\n   百分比就是设50%的时候; em比较特殊,要考虑到当前字体大小, 如果默认字体大小是16px时, 那需要7em即7 * 16 = 112才能变成正圆. 当宽高不一致时, 取其中较小值来衡量.另外经过我的测试发现, 三种值的变化过程和变化结果都是不同的, 即使是正圆. 其中100px和50%也有细微的不同.\n\n<!--more-->\n3. border-radius还有另一种写法. eg:border-radius:5px 10px/15px 20px;  \n   顺序是从左上开始, 然后顺时针. 即左上的值是5px 15px 右上的值是10px 20px 右下的值是5px 15px, 左下10px 20px;  \n   另外要提的是,第一个值和第二个值影响两个方向的边框, 如左上的第一个值5px影响左上的上边框.  \n   这种写法可扩展, eg:border-radius:5px 10px 15px/20px 25px; 上5px 左右10px 下15px\n\n#### border-image\n兼容性问题与border-radius相同,它有五个属性,source,slice,width,outset,repeat\n\n1. border-image-source, 最容易理解, 边框图片地址, 用url()制定, 默认为none, 不设置会用border-style的值;\n2. border-image-slice, 只能用数字和%,px和em在这里会不显示; 还有不允许设负值, 将图片分为9块, 不设置fill的话中间为透明.\n3. border-image-width, 规定将图像分割为9个部分, 如果不写就由border的值制定.\n4. border-image-outset, 规定让边框背景延伸到盒子外, 不能用%.\n5. border-image-repeat, 默认stretch,即拉伸的意思, 还有另外两个值, repeat和round,二者显示效果差不多.\n\n#### box-shadow\n兼容性最差, ie11才兼容, 其他浏览器也要加前缀, -o-box-shadow, -webkit-box-shadow.\n\n1. 有六个值, x,y,blur,spread,color,inset.  \n   x,y设置阴影的位置, 可负值.\n   blur 可选, 让阴影模糊.  \n   spread 可选, 阴影延伸的尺寸.  \n   color 可选, 阴影的颜色.  \n   inset 可选, 将阴影设为内部阴影.\n2. 可以给每一边阴影不同的颜色, 效果相当于发散模糊的border, 用x,y来控制即可, 注意要用逗号隔开.  \n   eg:box-shadow: -10px 0 10px red,10px 0 10px yellow,0 -10px 10px blue,0 10px 10px green; 四边不同颜色的边框.\n3. 可以多层box-shadow嵌套, 但是上一层的spread不能大于下一层.  \n   eg:box-shadow: 0 0 10px 10px(spread) red, 0 0 10px 20px blue;\n\n\n\n","source":"_posts/简述CSS3的一些属性(1).md","raw":"---\ntitle: 简述CSS3的一些属性(1)\ndate: 2017-06-16 13:55:49\ntags: [CSS, 前端]\n---\n##### 写在前面\n这篇文章主要讲css3边框\n主要讲一下三个属性,分别是border-radius,border-image,box-shadow.它们都没有继承性.\n\n#### border-radius\n首先讨论兼容性问题, 除了ie8以下大部分都兼容, 相信这个属性大家也很常用.\n\n1. border-radius其实是缩写, 如果要定义单个角落的radius的话,应该这么写 border-xxx-xxx-radius, 记住先写上下再写左右.如要定义左上的话应该是这样, border-top-left-radius.\n2. 它的值有三种, px,em,百分比. 我们假设div的宽高是一致的如200px, 当所设的值是宽高一半时即100px, 就是最大值了, 此时div得border就是一个正圆.\n   百分比就是设50%的时候; em比较特殊,要考虑到当前字体大小, 如果默认字体大小是16px时, 那需要7em即7 * 16 = 112才能变成正圆. 当宽高不一致时, 取其中较小值来衡量.另外经过我的测试发现, 三种值的变化过程和变化结果都是不同的, 即使是正圆. 其中100px和50%也有细微的不同.\n\n<!--more-->\n3. border-radius还有另一种写法. eg:border-radius:5px 10px/15px 20px;  \n   顺序是从左上开始, 然后顺时针. 即左上的值是5px 15px 右上的值是10px 20px 右下的值是5px 15px, 左下10px 20px;  \n   另外要提的是,第一个值和第二个值影响两个方向的边框, 如左上的第一个值5px影响左上的上边框.  \n   这种写法可扩展, eg:border-radius:5px 10px 15px/20px 25px; 上5px 左右10px 下15px\n\n#### border-image\n兼容性问题与border-radius相同,它有五个属性,source,slice,width,outset,repeat\n\n1. border-image-source, 最容易理解, 边框图片地址, 用url()制定, 默认为none, 不设置会用border-style的值;\n2. border-image-slice, 只能用数字和%,px和em在这里会不显示; 还有不允许设负值, 将图片分为9块, 不设置fill的话中间为透明.\n3. border-image-width, 规定将图像分割为9个部分, 如果不写就由border的值制定.\n4. border-image-outset, 规定让边框背景延伸到盒子外, 不能用%.\n5. border-image-repeat, 默认stretch,即拉伸的意思, 还有另外两个值, repeat和round,二者显示效果差不多.\n\n#### box-shadow\n兼容性最差, ie11才兼容, 其他浏览器也要加前缀, -o-box-shadow, -webkit-box-shadow.\n\n1. 有六个值, x,y,blur,spread,color,inset.  \n   x,y设置阴影的位置, 可负值.\n   blur 可选, 让阴影模糊.  \n   spread 可选, 阴影延伸的尺寸.  \n   color 可选, 阴影的颜色.  \n   inset 可选, 将阴影设为内部阴影.\n2. 可以给每一边阴影不同的颜色, 效果相当于发散模糊的border, 用x,y来控制即可, 注意要用逗号隔开.  \n   eg:box-shadow: -10px 0 10px red,10px 0 10px yellow,0 -10px 10px blue,0 10px 10px green; 四边不同颜色的边框.\n3. 可以多层box-shadow嵌套, 但是上一层的spread不能大于下一层.  \n   eg:box-shadow: 0 0 10px 10px(spread) red, 0 0 10px 20px blue;\n\n\n\n","slug":"简述CSS3的一些属性(1)","published":1,"updated":"2021-07-02T03:20:30.666Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl5sb8gfg001lxq0rq8uupfb4","content":"<h5 id=\"写在前面\"><a href=\"#写在前面\" class=\"headerlink\" title=\"写在前面\"></a>写在前面</h5><p>这篇文章主要讲css3边框<br>主要讲一下三个属性,分别是border-radius,border-image,box-shadow.它们都没有继承性.</p>\n<h4 id=\"border-radius\"><a href=\"#border-radius\" class=\"headerlink\" title=\"border-radius\"></a>border-radius</h4><p>首先讨论兼容性问题, 除了ie8以下大部分都兼容, 相信这个属性大家也很常用.</p>\n<ol>\n<li>border-radius其实是缩写, 如果要定义单个角落的radius的话,应该这么写 border-xxx-xxx-radius, 记住先写上下再写左右.如要定义左上的话应该是这样, border-top-left-radius.</li>\n<li>它的值有三种, px,em,百分比. 我们假设div的宽高是一致的如200px, 当所设的值是宽高一半时即100px, 就是最大值了, 此时div得border就是一个正圆.<br>百分比就是设50%的时候; em比较特殊,要考虑到当前字体大小, 如果默认字体大小是16px时, 那需要7em即7 * 16 = 112才能变成正圆. 当宽高不一致时, 取其中较小值来衡量.另外经过我的测试发现, 三种值的变化过程和变化结果都是不同的, 即使是正圆. 其中100px和50%也有细微的不同.</li>\n</ol>\n<a id=\"more\"></a>\n<ol start=\"3\">\n<li>border-radius还有另一种写法. eg:border-radius:5px 10px/15px 20px;<br>顺序是从左上开始, 然后顺时针. 即左上的值是5px 15px 右上的值是10px 20px 右下的值是5px 15px, 左下10px 20px;<br>另外要提的是,第一个值和第二个值影响两个方向的边框, 如左上的第一个值5px影响左上的上边框.<br>这种写法可扩展, eg:border-radius:5px 10px 15px/20px 25px; 上5px 左右10px 下15px</li>\n</ol>\n<h4 id=\"border-image\"><a href=\"#border-image\" class=\"headerlink\" title=\"border-image\"></a>border-image</h4><p>兼容性问题与border-radius相同,它有五个属性,source,slice,width,outset,repeat</p>\n<ol>\n<li>border-image-source, 最容易理解, 边框图片地址, 用url()制定, 默认为none, 不设置会用border-style的值;</li>\n<li>border-image-slice, 只能用数字和%,px和em在这里会不显示; 还有不允许设负值, 将图片分为9块, 不设置fill的话中间为透明.</li>\n<li>border-image-width, 规定将图像分割为9个部分, 如果不写就由border的值制定.</li>\n<li>border-image-outset, 规定让边框背景延伸到盒子外, 不能用%.</li>\n<li>border-image-repeat, 默认stretch,即拉伸的意思, 还有另外两个值, repeat和round,二者显示效果差不多.</li>\n</ol>\n<h4 id=\"box-shadow\"><a href=\"#box-shadow\" class=\"headerlink\" title=\"box-shadow\"></a>box-shadow</h4><p>兼容性最差, ie11才兼容, 其他浏览器也要加前缀, -o-box-shadow, -webkit-box-shadow.</p>\n<ol>\n<li>有六个值, x,y,blur,spread,color,inset.<br>x,y设置阴影的位置, 可负值.<br>blur 可选, 让阴影模糊.<br>spread 可选, 阴影延伸的尺寸.<br>color 可选, 阴影的颜色.<br>inset 可选, 将阴影设为内部阴影.</li>\n<li>可以给每一边阴影不同的颜色, 效果相当于发散模糊的border, 用x,y来控制即可, 注意要用逗号隔开.<br>eg:box-shadow: -10px 0 10px red,10px 0 10px yellow,0 -10px 10px blue,0 10px 10px green; 四边不同颜色的边框.</li>\n<li>可以多层box-shadow嵌套, 但是上一层的spread不能大于下一层.<br>eg:box-shadow: 0 0 10px 10px(spread) red, 0 0 10px 20px blue;</li>\n</ol>\n","site":{"data":{}},"excerpt":"<h5 id=\"写在前面\"><a href=\"#写在前面\" class=\"headerlink\" title=\"写在前面\"></a>写在前面</h5><p>这篇文章主要讲css3边框<br>主要讲一下三个属性,分别是border-radius,border-image,box-shadow.它们都没有继承性.</p>\n<h4 id=\"border-radius\"><a href=\"#border-radius\" class=\"headerlink\" title=\"border-radius\"></a>border-radius</h4><p>首先讨论兼容性问题, 除了ie8以下大部分都兼容, 相信这个属性大家也很常用.</p>\n<ol>\n<li>border-radius其实是缩写, 如果要定义单个角落的radius的话,应该这么写 border-xxx-xxx-radius, 记住先写上下再写左右.如要定义左上的话应该是这样, border-top-left-radius.</li>\n<li>它的值有三种, px,em,百分比. 我们假设div的宽高是一致的如200px, 当所设的值是宽高一半时即100px, 就是最大值了, 此时div得border就是一个正圆.<br>百分比就是设50%的时候; em比较特殊,要考虑到当前字体大小, 如果默认字体大小是16px时, 那需要7em即7 * 16 = 112才能变成正圆. 当宽高不一致时, 取其中较小值来衡量.另外经过我的测试发现, 三种值的变化过程和变化结果都是不同的, 即使是正圆. 其中100px和50%也有细微的不同.</li>\n</ol>","more":"<ol start=\"3\">\n<li>border-radius还有另一种写法. eg:border-radius:5px 10px/15px 20px;<br>顺序是从左上开始, 然后顺时针. 即左上的值是5px 15px 右上的值是10px 20px 右下的值是5px 15px, 左下10px 20px;<br>另外要提的是,第一个值和第二个值影响两个方向的边框, 如左上的第一个值5px影响左上的上边框.<br>这种写法可扩展, eg:border-radius:5px 10px 15px/20px 25px; 上5px 左右10px 下15px</li>\n</ol>\n<h4 id=\"border-image\"><a href=\"#border-image\" class=\"headerlink\" title=\"border-image\"></a>border-image</h4><p>兼容性问题与border-radius相同,它有五个属性,source,slice,width,outset,repeat</p>\n<ol>\n<li>border-image-source, 最容易理解, 边框图片地址, 用url()制定, 默认为none, 不设置会用border-style的值;</li>\n<li>border-image-slice, 只能用数字和%,px和em在这里会不显示; 还有不允许设负值, 将图片分为9块, 不设置fill的话中间为透明.</li>\n<li>border-image-width, 规定将图像分割为9个部分, 如果不写就由border的值制定.</li>\n<li>border-image-outset, 规定让边框背景延伸到盒子外, 不能用%.</li>\n<li>border-image-repeat, 默认stretch,即拉伸的意思, 还有另外两个值, repeat和round,二者显示效果差不多.</li>\n</ol>\n<h4 id=\"box-shadow\"><a href=\"#box-shadow\" class=\"headerlink\" title=\"box-shadow\"></a>box-shadow</h4><p>兼容性最差, ie11才兼容, 其他浏览器也要加前缀, -o-box-shadow, -webkit-box-shadow.</p>\n<ol>\n<li>有六个值, x,y,blur,spread,color,inset.<br>x,y设置阴影的位置, 可负值.<br>blur 可选, 让阴影模糊.<br>spread 可选, 阴影延伸的尺寸.<br>color 可选, 阴影的颜色.<br>inset 可选, 将阴影设为内部阴影.</li>\n<li>可以给每一边阴影不同的颜色, 效果相当于发散模糊的border, 用x,y来控制即可, 注意要用逗号隔开.<br>eg:box-shadow: -10px 0 10px red,10px 0 10px yellow,0 -10px 10px blue,0 10px 10px green; 四边不同颜色的边框.</li>\n<li>可以多层box-shadow嵌套, 但是上一层的spread不能大于下一层.<br>eg:box-shadow: 0 0 10px 10px(spread) red, 0 0 10px 20px blue;</li>\n</ol>"},{"title":"简述CSS3的一些属性(2)","date":"2017-08-16T09:49:31.000Z","_content":"##### 写在前面\n这篇文章主要讲css3背景、文本效果\n六个属性,背景background-size, background-origin, background-clip, 它们都没有继承性.  \ntext-shadow, word-wrap, word-break, 都能被继承.\n\n#### background-size\nie9及以上都支持, 主流浏览器支持.\n\n* 四种负值方法, length/%/cover/contain\n   length: 设置宽高, px/em/rem都可以使用. 如果只给一个值, 第二个值也就是高会默认auto. 当然你也可以手动background-size:auto 100px; 让宽自动匹配.  \n   %: 值得注意的问题是这里的百分比并不是背景图像自身的宽高, 而是承载这个图像的容器的宽高. 100% 100%;就是覆盖整个容器.  \n   cover: 保持图像的比例拉伸, 完全覆盖容器. 要注意, 容器如果是宽高比例差很多的话, 只会显示极小一部分, 读者可自行想象.  \n   contain: 保持图像的比例大小拉伸, 当一侧到达容器的100%时, 就不在扩大.\n   \n<!--more-->\n#### background-origin, background-clip\nie9及以上都支持, 低版本浏览器需要加厂商前缀.\n之所以把这两个css3属性放在一起讲, 主要是因为这两个的显示效果几乎一致. origin是指定从哪里开始绘制背景, clip则控制背景的显示.\n\n1. 二者属性一致, border-box(clip默认值), padding-box(origin默认值), content-box.\n   border-box, 顾名思义, 所设背景从border开始显示, 但是如果容器没设border, 和padding-box的显示效果一样, 同理没有padding, content-box和padding-box显示效果一致.(origin,clip都是)\n2. 当二者属性同时写时, (background-clip:padding-box; background-origin:border-box;) 你会发现背景怎么从padding开始绘制, 不用质疑, 上述背景肯定是从border开始, 但是clip是控制背景的显示的, 所以只能有padding和content内容区域显示, 但是会少掉左上border宽度的一截  \n   读者测试时, 可以将边框dashed, 会清晰很多.\n3. clip制定背景可以覆盖到什么位置, 在哪片区域显示, origin指定背景从什么位置开始. 最后要注意clip的默认值是padding.\n\n#### text-shadow\n兼容性: ie10+, 属性和[简述CSS3的一些属性(1)](https://psilocine.github.io/2017/06/16/%E7%AE%80%E8%BF%B0CSS3%E7%9A%84%E4%B8%80%E4%BA%9B%E5%B1%9E%E6%80%A7%281%29/)中的box-shadow差不多.\n\n1. 属性: x, y, blur, color.  \n   x, y: 水平垂直阴影位置, 往右下移动, 可以负值.  \n   blur: 可选, 模糊程度.  \n   color: 可选, 默认黑色.\n2. 其实这个属性在css2中存在过一段时间, 最后被抛弃了, 不过在css3回来, 可见text-shadow还是很重要的. 主要能用它完成一些讨巧的阴影效果.\n3. 与box-shadow一样可以多层嵌套. 用逗号隔开, 确保下层偏移比上层偏移大就可以了.\n\n#### word-wrap, word-break\n主流浏览器都兼容二者(ie6也支持)\n\n1. word-wrap属性允许长单词或者url换行, 当有border的容器里面, 不设置word-wrap, 长单词会无视容器宽度而溢出, 这里是长单词本身比容器宽度大的情况.\n2. 通过word-wrap: break-word设置, word-wrap的默认值是normal, 让浏览器自行判断是否换行, 当它看到一个单词放不下了, 就会换行, 但是如果换行了还是比容器宽度大, 就是1.情况, 那就只能溢出了.\n3. 这时候可以设置word-break: break-all; 二者的区别就是word-break:break-all不将单词换行再拆分, 上述说了word-wrap会先将长单词换行后拆分, 这会导致上一行后面有一大段留白, word-break就能很好解决, 增加浏览时的体验. 如果讲得不透侧, 还是很有必要自行测试一下的.","source":"_posts/简述CSS3的一些属性(2).md","raw":"---\ntitle: 简述CSS3的一些属性(2)\ndate: 2017-08-16 17:49:31\ntags: [CSS, 前端]\n---\n##### 写在前面\n这篇文章主要讲css3背景、文本效果\n六个属性,背景background-size, background-origin, background-clip, 它们都没有继承性.  \ntext-shadow, word-wrap, word-break, 都能被继承.\n\n#### background-size\nie9及以上都支持, 主流浏览器支持.\n\n* 四种负值方法, length/%/cover/contain\n   length: 设置宽高, px/em/rem都可以使用. 如果只给一个值, 第二个值也就是高会默认auto. 当然你也可以手动background-size:auto 100px; 让宽自动匹配.  \n   %: 值得注意的问题是这里的百分比并不是背景图像自身的宽高, 而是承载这个图像的容器的宽高. 100% 100%;就是覆盖整个容器.  \n   cover: 保持图像的比例拉伸, 完全覆盖容器. 要注意, 容器如果是宽高比例差很多的话, 只会显示极小一部分, 读者可自行想象.  \n   contain: 保持图像的比例大小拉伸, 当一侧到达容器的100%时, 就不在扩大.\n   \n<!--more-->\n#### background-origin, background-clip\nie9及以上都支持, 低版本浏览器需要加厂商前缀.\n之所以把这两个css3属性放在一起讲, 主要是因为这两个的显示效果几乎一致. origin是指定从哪里开始绘制背景, clip则控制背景的显示.\n\n1. 二者属性一致, border-box(clip默认值), padding-box(origin默认值), content-box.\n   border-box, 顾名思义, 所设背景从border开始显示, 但是如果容器没设border, 和padding-box的显示效果一样, 同理没有padding, content-box和padding-box显示效果一致.(origin,clip都是)\n2. 当二者属性同时写时, (background-clip:padding-box; background-origin:border-box;) 你会发现背景怎么从padding开始绘制, 不用质疑, 上述背景肯定是从border开始, 但是clip是控制背景的显示的, 所以只能有padding和content内容区域显示, 但是会少掉左上border宽度的一截  \n   读者测试时, 可以将边框dashed, 会清晰很多.\n3. clip制定背景可以覆盖到什么位置, 在哪片区域显示, origin指定背景从什么位置开始. 最后要注意clip的默认值是padding.\n\n#### text-shadow\n兼容性: ie10+, 属性和[简述CSS3的一些属性(1)](https://psilocine.github.io/2017/06/16/%E7%AE%80%E8%BF%B0CSS3%E7%9A%84%E4%B8%80%E4%BA%9B%E5%B1%9E%E6%80%A7%281%29/)中的box-shadow差不多.\n\n1. 属性: x, y, blur, color.  \n   x, y: 水平垂直阴影位置, 往右下移动, 可以负值.  \n   blur: 可选, 模糊程度.  \n   color: 可选, 默认黑色.\n2. 其实这个属性在css2中存在过一段时间, 最后被抛弃了, 不过在css3回来, 可见text-shadow还是很重要的. 主要能用它完成一些讨巧的阴影效果.\n3. 与box-shadow一样可以多层嵌套. 用逗号隔开, 确保下层偏移比上层偏移大就可以了.\n\n#### word-wrap, word-break\n主流浏览器都兼容二者(ie6也支持)\n\n1. word-wrap属性允许长单词或者url换行, 当有border的容器里面, 不设置word-wrap, 长单词会无视容器宽度而溢出, 这里是长单词本身比容器宽度大的情况.\n2. 通过word-wrap: break-word设置, word-wrap的默认值是normal, 让浏览器自行判断是否换行, 当它看到一个单词放不下了, 就会换行, 但是如果换行了还是比容器宽度大, 就是1.情况, 那就只能溢出了.\n3. 这时候可以设置word-break: break-all; 二者的区别就是word-break:break-all不将单词换行再拆分, 上述说了word-wrap会先将长单词换行后拆分, 这会导致上一行后面有一大段留白, word-break就能很好解决, 增加浏览时的体验. 如果讲得不透侧, 还是很有必要自行测试一下的.","slug":"简述CSS3的一些属性(2)","published":1,"updated":"2021-07-02T03:20:30.666Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl5sb8gfh001nxq0rsz7wnx6q","content":"<h5 id=\"写在前面\"><a href=\"#写在前面\" class=\"headerlink\" title=\"写在前面\"></a>写在前面</h5><p>这篇文章主要讲css3背景、文本效果<br>六个属性,背景background-size, background-origin, background-clip, 它们都没有继承性.<br>text-shadow, word-wrap, word-break, 都能被继承.</p>\n<h4 id=\"background-size\"><a href=\"#background-size\" class=\"headerlink\" title=\"background-size\"></a>background-size</h4><p>ie9及以上都支持, 主流浏览器支持.</p>\n<ul>\n<li>四种负值方法, length/%/cover/contain<br> length: 设置宽高, px/em/rem都可以使用. 如果只给一个值, 第二个值也就是高会默认auto. 当然你也可以手动background-size:auto 100px; 让宽自动匹配.<br> %: 值得注意的问题是这里的百分比并不是背景图像自身的宽高, 而是承载这个图像的容器的宽高. 100% 100%;就是覆盖整个容器.<br> cover: 保持图像的比例拉伸, 完全覆盖容器. 要注意, 容器如果是宽高比例差很多的话, 只会显示极小一部分, 读者可自行想象.<br> contain: 保持图像的比例大小拉伸, 当一侧到达容器的100%时, 就不在扩大.</li>\n</ul>\n<a id=\"more\"></a>\n<h4 id=\"background-origin-background-clip\"><a href=\"#background-origin-background-clip\" class=\"headerlink\" title=\"background-origin, background-clip\"></a>background-origin, background-clip</h4><p>ie9及以上都支持, 低版本浏览器需要加厂商前缀.<br>之所以把这两个css3属性放在一起讲, 主要是因为这两个的显示效果几乎一致. origin是指定从哪里开始绘制背景, clip则控制背景的显示.</p>\n<ol>\n<li>二者属性一致, border-box(clip默认值), padding-box(origin默认值), content-box.<br>border-box, 顾名思义, 所设背景从border开始显示, 但是如果容器没设border, 和padding-box的显示效果一样, 同理没有padding, content-box和padding-box显示效果一致.(origin,clip都是)</li>\n<li>当二者属性同时写时, (background-clip:padding-box; background-origin:border-box;) 你会发现背景怎么从padding开始绘制, 不用质疑, 上述背景肯定是从border开始, 但是clip是控制背景的显示的, 所以只能有padding和content内容区域显示, 但是会少掉左上border宽度的一截<br>读者测试时, 可以将边框dashed, 会清晰很多.</li>\n<li>clip制定背景可以覆盖到什么位置, 在哪片区域显示, origin指定背景从什么位置开始. 最后要注意clip的默认值是padding.</li>\n</ol>\n<h4 id=\"text-shadow\"><a href=\"#text-shadow\" class=\"headerlink\" title=\"text-shadow\"></a>text-shadow</h4><p>兼容性: ie10+, 属性和<a href=\"https://psilocine.github.io/2017/06/16/%E7%AE%80%E8%BF%B0CSS3%E7%9A%84%E4%B8%80%E4%BA%9B%E5%B1%9E%E6%80%A7%281%29/\">简述CSS3的一些属性(1)</a>中的box-shadow差不多.</p>\n<ol>\n<li>属性: x, y, blur, color.<br>x, y: 水平垂直阴影位置, 往右下移动, 可以负值.<br>blur: 可选, 模糊程度.<br>color: 可选, 默认黑色.</li>\n<li>其实这个属性在css2中存在过一段时间, 最后被抛弃了, 不过在css3回来, 可见text-shadow还是很重要的. 主要能用它完成一些讨巧的阴影效果.</li>\n<li>与box-shadow一样可以多层嵌套. 用逗号隔开, 确保下层偏移比上层偏移大就可以了.</li>\n</ol>\n<h4 id=\"word-wrap-word-break\"><a href=\"#word-wrap-word-break\" class=\"headerlink\" title=\"word-wrap, word-break\"></a>word-wrap, word-break</h4><p>主流浏览器都兼容二者(ie6也支持)</p>\n<ol>\n<li>word-wrap属性允许长单词或者url换行, 当有border的容器里面, 不设置word-wrap, 长单词会无视容器宽度而溢出, 这里是长单词本身比容器宽度大的情况.</li>\n<li>通过word-wrap: break-word设置, word-wrap的默认值是normal, 让浏览器自行判断是否换行, 当它看到一个单词放不下了, 就会换行, 但是如果换行了还是比容器宽度大, 就是1.情况, 那就只能溢出了.</li>\n<li>这时候可以设置word-break: break-all; 二者的区别就是word-break:break-all不将单词换行再拆分, 上述说了word-wrap会先将长单词换行后拆分, 这会导致上一行后面有一大段留白, word-break就能很好解决, 增加浏览时的体验. 如果讲得不透侧, 还是很有必要自行测试一下的.</li>\n</ol>\n","site":{"data":{}},"excerpt":"<h5 id=\"写在前面\"><a href=\"#写在前面\" class=\"headerlink\" title=\"写在前面\"></a>写在前面</h5><p>这篇文章主要讲css3背景、文本效果<br>六个属性,背景background-size, background-origin, background-clip, 它们都没有继承性.<br>text-shadow, word-wrap, word-break, 都能被继承.</p>\n<h4 id=\"background-size\"><a href=\"#background-size\" class=\"headerlink\" title=\"background-size\"></a>background-size</h4><p>ie9及以上都支持, 主流浏览器支持.</p>\n<ul>\n<li>四种负值方法, length/%/cover/contain<br> length: 设置宽高, px/em/rem都可以使用. 如果只给一个值, 第二个值也就是高会默认auto. 当然你也可以手动background-size:auto 100px; 让宽自动匹配.<br> %: 值得注意的问题是这里的百分比并不是背景图像自身的宽高, 而是承载这个图像的容器的宽高. 100% 100%;就是覆盖整个容器.<br> cover: 保持图像的比例拉伸, 完全覆盖容器. 要注意, 容器如果是宽高比例差很多的话, 只会显示极小一部分, 读者可自行想象.<br> contain: 保持图像的比例大小拉伸, 当一侧到达容器的100%时, 就不在扩大.</li>\n</ul>","more":"<h4 id=\"background-origin-background-clip\"><a href=\"#background-origin-background-clip\" class=\"headerlink\" title=\"background-origin, background-clip\"></a>background-origin, background-clip</h4><p>ie9及以上都支持, 低版本浏览器需要加厂商前缀.<br>之所以把这两个css3属性放在一起讲, 主要是因为这两个的显示效果几乎一致. origin是指定从哪里开始绘制背景, clip则控制背景的显示.</p>\n<ol>\n<li>二者属性一致, border-box(clip默认值), padding-box(origin默认值), content-box.<br>border-box, 顾名思义, 所设背景从border开始显示, 但是如果容器没设border, 和padding-box的显示效果一样, 同理没有padding, content-box和padding-box显示效果一致.(origin,clip都是)</li>\n<li>当二者属性同时写时, (background-clip:padding-box; background-origin:border-box;) 你会发现背景怎么从padding开始绘制, 不用质疑, 上述背景肯定是从border开始, 但是clip是控制背景的显示的, 所以只能有padding和content内容区域显示, 但是会少掉左上border宽度的一截<br>读者测试时, 可以将边框dashed, 会清晰很多.</li>\n<li>clip制定背景可以覆盖到什么位置, 在哪片区域显示, origin指定背景从什么位置开始. 最后要注意clip的默认值是padding.</li>\n</ol>\n<h4 id=\"text-shadow\"><a href=\"#text-shadow\" class=\"headerlink\" title=\"text-shadow\"></a>text-shadow</h4><p>兼容性: ie10+, 属性和<a href=\"https://psilocine.github.io/2017/06/16/%E7%AE%80%E8%BF%B0CSS3%E7%9A%84%E4%B8%80%E4%BA%9B%E5%B1%9E%E6%80%A7%281%29/\">简述CSS3的一些属性(1)</a>中的box-shadow差不多.</p>\n<ol>\n<li>属性: x, y, blur, color.<br>x, y: 水平垂直阴影位置, 往右下移动, 可以负值.<br>blur: 可选, 模糊程度.<br>color: 可选, 默认黑色.</li>\n<li>其实这个属性在css2中存在过一段时间, 最后被抛弃了, 不过在css3回来, 可见text-shadow还是很重要的. 主要能用它完成一些讨巧的阴影效果.</li>\n<li>与box-shadow一样可以多层嵌套. 用逗号隔开, 确保下层偏移比上层偏移大就可以了.</li>\n</ol>\n<h4 id=\"word-wrap-word-break\"><a href=\"#word-wrap-word-break\" class=\"headerlink\" title=\"word-wrap, word-break\"></a>word-wrap, word-break</h4><p>主流浏览器都兼容二者(ie6也支持)</p>\n<ol>\n<li>word-wrap属性允许长单词或者url换行, 当有border的容器里面, 不设置word-wrap, 长单词会无视容器宽度而溢出, 这里是长单词本身比容器宽度大的情况.</li>\n<li>通过word-wrap: break-word设置, word-wrap的默认值是normal, 让浏览器自行判断是否换行, 当它看到一个单词放不下了, 就会换行, 但是如果换行了还是比容器宽度大, 就是1.情况, 那就只能溢出了.</li>\n<li>这时候可以设置word-break: break-all; 二者的区别就是word-break:break-all不将单词换行再拆分, 上述说了word-wrap会先将长单词换行后拆分, 这会导致上一行后面有一大段留白, word-break就能很好解决, 增加浏览时的体验. 如果讲得不透侧, 还是很有必要自行测试一下的.</li>\n</ol>"},{"title":"简述CSS3的一些属性(3)","date":"2017-08-18T05:26:12.000Z","_content":"##### 写在前面\n这篇文章主要讲css3字体、transform的2D转换\n首先是字体@font-face, 2D转换的translate(), rotate(), scale(), skew(), transform-origin, 还有大魔王matrix().\n2D转换的属性都没有继承性.\n\n#### @font-face\nie9及以上都支持, 但只支持.eot后缀字体. font-face的出现, 字体就没必要在用户用户端上提前安装好了.\n\n    @font-face {\n      font-family: fontName; // 一个变量名\n      src: url(\"fontTrueName.ttf\"), // 字体名\n      url(\"fontTrueName.eot\");\n    }\n    div {\n      font-family: fontName; // 引用字体的变量名即可\n    }\n<!--more-->\n注意, 如果要用字体的不同字体, 如粗细, 还需要再添加一个@font-face, 而且src的字体也要是新的粗字体, 还要加上font-weight: bold等, 而且变量名一定要一样.\n#### transform\nie10+, chrome,safari加-webkit-, ie9加-ms-(仅适用于2D转换), 厂商前缀都加载transform上. eg:-ms-transform: translate()\n\n* transform-origin\n1. 两个参数, 用法: transform-origin: x y; 初始值是50% 50%; 因此是需要变换的中心点, 下面都说基点.\n2. 可以规定变换的基点, 如0% 50%, 就是x轴0, y轴是变换物体高度的一半, 基点就是正左边缘点, 所有变换都会以正左为中心点旋转, 斜拉, 缩放(位移也是, 虽然看不出来).\n3. 参数除了百分数, 也可以用px像素, 也可以直接用left, right,(x轴) top, bottom,(y轴) center(x, y均可)来指定. 一般如果基点要求不是非常苛刻, 用left, right这些比较简单明了.\n\n* translate() 位移\n1. 两个参数, 用法 transform: translate(10px, 20px); 表示向右移10像素, 向下移动20像素.\n2. 如果只有一个参数, 那只在x轴移动即左右移动, 所以这个属性也能赋予负值.\n\n* rotate() 旋转\n1. 一个参数, 用法 transform: rotate(90deg); 表示顺时针旋转90度, 单位是deg(度 Degress的缩写), 可负值.\n2. 基点如果不是默认的话, 围绕所设基点位置旋转, 而且基点可值大于旋转物体的宽高值, 即设200% 200%, 会围绕变换物体以外的点旋转.\n\n* scale() 缩放\n1. 两个参数, 用法 transform: scale(2, 1); 表示宽度变为原来的两倍, 高度一倍不变.\n2. 只有一个参数时, 表示同时给定宽高的倍数. 可以负值, scale(-1, -1)相当于rotate(180deg)\n3. 如果基点不是默认, 如上述0% 50% 正左基点, 那么x轴上的缩放倍数, 如scale(2, 1)物体的左边位置不变, 往右扩展一倍. 读者可自行测试.\n\n* skew() 斜拉\n1. 两个参数, 用法 transform: skew(0deg, 0deg); skew(180deg, 180deg)和skew(0deg, 0deg)效果一样.\n2. 180deg一个循环, 当参数是90deg时候, 变换物体将被拉伸至消失, 想象一下高中时期的tan(90°), 因此两个参数有一个是90deg, 物体都会消失不见.\n3. 第一个参数表示左右偏移, 给定度数是正数时, 容器会往左上和右下横向拉扯. 负数相反. 第二个参数为正数时, 往左上和右下纵向拉扯. 负数相反.\n4. 如果基点不默认, 那基点位置将不变, 位置不动的情况下拉扯.\n\n* 大魔王matrix()\n1. 写在前面, 其实上述介绍的四种方法, 无论拉伸斜拉还是啥, 本质都是调用matrix()方法实现.\n2. matrix() 有6个参数, 别怕, 下面慢慢分析. 假设参数分别是a, b, c, d, e, f\n```\n      a c e   \n    [ b d f ]\n      0 0 1\n```\n将6参看成矩阵, 结合之前的transform-origin的两个参数x y来看\n```\n      a c e    x        ax + cy + e \n    [ b d f ][ y ] => [ bx + dy + f ] // 矩阵相乘 \n      0 0 1    1         0 + 0 + 1\n```\nax + cy + e代表水平坐标, bx + dy + f代表垂直坐标.\n3. 位移 eg matrix(1, 0, 0, 1, 30, 30) 基点默认时的坐标是(0, 0),即物体中心点. ax + cy + e => e = 30, bx + dy + f => f = 30, 相当于translate(30px, 30px). 上述可证明matrix后两位的参数分别表示, 水平偏移距离, 垂直偏移距离.\n2. 缩放 eg matrix(s, 0, 0, s, 0, 0) 基点默认, ax + cy + e => sx , bx + dy + f => sy, 相当于scale(sx, sy).\n3. 旋转 设旋转角度为α, eg matrix(cosα, sinα, -sinα, cosα, 0, 0)基点默认. ax + cy + e => xcosα - ysinα , bx + dy + f => xsinα + ycosα. 一般情况下, 用rotate(αdeg)就可以了, 方便简单.\n4. 拉伸 eg matrix(1, tan(αy), tan(αx), 1, 0, 0). ax + cy + e => x + ytan(αx) , bx + dy + f => xtan(αy) + y. 相当于skew(αx deg, αy deg). αx表示x轴倾斜的角度.\n","source":"_posts/简述CSS3的一些属性(3).md","raw":"---\ntitle: 简述CSS3的一些属性(3)\ndate: 2017-08-18 13:26:12\ntags: [CSS, 前端]\n---\n##### 写在前面\n这篇文章主要讲css3字体、transform的2D转换\n首先是字体@font-face, 2D转换的translate(), rotate(), scale(), skew(), transform-origin, 还有大魔王matrix().\n2D转换的属性都没有继承性.\n\n#### @font-face\nie9及以上都支持, 但只支持.eot后缀字体. font-face的出现, 字体就没必要在用户用户端上提前安装好了.\n\n    @font-face {\n      font-family: fontName; // 一个变量名\n      src: url(\"fontTrueName.ttf\"), // 字体名\n      url(\"fontTrueName.eot\");\n    }\n    div {\n      font-family: fontName; // 引用字体的变量名即可\n    }\n<!--more-->\n注意, 如果要用字体的不同字体, 如粗细, 还需要再添加一个@font-face, 而且src的字体也要是新的粗字体, 还要加上font-weight: bold等, 而且变量名一定要一样.\n#### transform\nie10+, chrome,safari加-webkit-, ie9加-ms-(仅适用于2D转换), 厂商前缀都加载transform上. eg:-ms-transform: translate()\n\n* transform-origin\n1. 两个参数, 用法: transform-origin: x y; 初始值是50% 50%; 因此是需要变换的中心点, 下面都说基点.\n2. 可以规定变换的基点, 如0% 50%, 就是x轴0, y轴是变换物体高度的一半, 基点就是正左边缘点, 所有变换都会以正左为中心点旋转, 斜拉, 缩放(位移也是, 虽然看不出来).\n3. 参数除了百分数, 也可以用px像素, 也可以直接用left, right,(x轴) top, bottom,(y轴) center(x, y均可)来指定. 一般如果基点要求不是非常苛刻, 用left, right这些比较简单明了.\n\n* translate() 位移\n1. 两个参数, 用法 transform: translate(10px, 20px); 表示向右移10像素, 向下移动20像素.\n2. 如果只有一个参数, 那只在x轴移动即左右移动, 所以这个属性也能赋予负值.\n\n* rotate() 旋转\n1. 一个参数, 用法 transform: rotate(90deg); 表示顺时针旋转90度, 单位是deg(度 Degress的缩写), 可负值.\n2. 基点如果不是默认的话, 围绕所设基点位置旋转, 而且基点可值大于旋转物体的宽高值, 即设200% 200%, 会围绕变换物体以外的点旋转.\n\n* scale() 缩放\n1. 两个参数, 用法 transform: scale(2, 1); 表示宽度变为原来的两倍, 高度一倍不变.\n2. 只有一个参数时, 表示同时给定宽高的倍数. 可以负值, scale(-1, -1)相当于rotate(180deg)\n3. 如果基点不是默认, 如上述0% 50% 正左基点, 那么x轴上的缩放倍数, 如scale(2, 1)物体的左边位置不变, 往右扩展一倍. 读者可自行测试.\n\n* skew() 斜拉\n1. 两个参数, 用法 transform: skew(0deg, 0deg); skew(180deg, 180deg)和skew(0deg, 0deg)效果一样.\n2. 180deg一个循环, 当参数是90deg时候, 变换物体将被拉伸至消失, 想象一下高中时期的tan(90°), 因此两个参数有一个是90deg, 物体都会消失不见.\n3. 第一个参数表示左右偏移, 给定度数是正数时, 容器会往左上和右下横向拉扯. 负数相反. 第二个参数为正数时, 往左上和右下纵向拉扯. 负数相反.\n4. 如果基点不默认, 那基点位置将不变, 位置不动的情况下拉扯.\n\n* 大魔王matrix()\n1. 写在前面, 其实上述介绍的四种方法, 无论拉伸斜拉还是啥, 本质都是调用matrix()方法实现.\n2. matrix() 有6个参数, 别怕, 下面慢慢分析. 假设参数分别是a, b, c, d, e, f\n```\n      a c e   \n    [ b d f ]\n      0 0 1\n```\n将6参看成矩阵, 结合之前的transform-origin的两个参数x y来看\n```\n      a c e    x        ax + cy + e \n    [ b d f ][ y ] => [ bx + dy + f ] // 矩阵相乘 \n      0 0 1    1         0 + 0 + 1\n```\nax + cy + e代表水平坐标, bx + dy + f代表垂直坐标.\n3. 位移 eg matrix(1, 0, 0, 1, 30, 30) 基点默认时的坐标是(0, 0),即物体中心点. ax + cy + e => e = 30, bx + dy + f => f = 30, 相当于translate(30px, 30px). 上述可证明matrix后两位的参数分别表示, 水平偏移距离, 垂直偏移距离.\n2. 缩放 eg matrix(s, 0, 0, s, 0, 0) 基点默认, ax + cy + e => sx , bx + dy + f => sy, 相当于scale(sx, sy).\n3. 旋转 设旋转角度为α, eg matrix(cosα, sinα, -sinα, cosα, 0, 0)基点默认. ax + cy + e => xcosα - ysinα , bx + dy + f => xsinα + ycosα. 一般情况下, 用rotate(αdeg)就可以了, 方便简单.\n4. 拉伸 eg matrix(1, tan(αy), tan(αx), 1, 0, 0). ax + cy + e => x + ytan(αx) , bx + dy + f => xtan(αy) + y. 相当于skew(αx deg, αy deg). αx表示x轴倾斜的角度.\n","slug":"简述CSS3的一些属性(3)","published":1,"updated":"2021-07-02T03:20:30.666Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl5sb8gfi001qxq0rpte47eqg","content":"<h5 id=\"写在前面\"><a href=\"#写在前面\" class=\"headerlink\" title=\"写在前面\"></a>写在前面</h5><p>这篇文章主要讲css3字体、transform的2D转换<br>首先是字体@font-face, 2D转换的translate(), rotate(), scale(), skew(), transform-origin, 还有大魔王matrix().<br>2D转换的属性都没有继承性.</p>\n<h4 id=\"font-face\"><a href=\"#font-face\" class=\"headerlink\" title=\"@font-face\"></a>@font-face</h4><p>ie9及以上都支持, 但只支持.eot后缀字体. font-face的出现, 字体就没必要在用户用户端上提前安装好了.</p>\n<pre><code>@font-face {\n  font-family: fontName; // 一个变量名\n  src: url(&quot;fontTrueName.ttf&quot;), // 字体名\n  url(&quot;fontTrueName.eot&quot;);\n}\ndiv {\n  font-family: fontName; // 引用字体的变量名即可\n}</code></pre><a id=\"more\"></a>\n<p>注意, 如果要用字体的不同字体, 如粗细, 还需要再添加一个@font-face, 而且src的字体也要是新的粗字体, 还要加上font-weight: bold等, 而且变量名一定要一样.</p>\n<h4 id=\"transform\"><a href=\"#transform\" class=\"headerlink\" title=\"transform\"></a>transform</h4><p>ie10+, chrome,safari加-webkit-, ie9加-ms-(仅适用于2D转换), 厂商前缀都加载transform上. eg:-ms-transform: translate()</p>\n<ul>\n<li>transform-origin</li>\n</ul>\n<ol>\n<li>两个参数, 用法: transform-origin: x y; 初始值是50% 50%; 因此是需要变换的中心点, 下面都说基点.</li>\n<li>可以规定变换的基点, 如0% 50%, 就是x轴0, y轴是变换物体高度的一半, 基点就是正左边缘点, 所有变换都会以正左为中心点旋转, 斜拉, 缩放(位移也是, 虽然看不出来).</li>\n<li>参数除了百分数, 也可以用px像素, 也可以直接用left, right,(x轴) top, bottom,(y轴) center(x, y均可)来指定. 一般如果基点要求不是非常苛刻, 用left, right这些比较简单明了.</li>\n</ol>\n<ul>\n<li>translate() 位移</li>\n</ul>\n<ol>\n<li>两个参数, 用法 transform: translate(10px, 20px); 表示向右移10像素, 向下移动20像素.</li>\n<li>如果只有一个参数, 那只在x轴移动即左右移动, 所以这个属性也能赋予负值.</li>\n</ol>\n<ul>\n<li>rotate() 旋转</li>\n</ul>\n<ol>\n<li>一个参数, 用法 transform: rotate(90deg); 表示顺时针旋转90度, 单位是deg(度 Degress的缩写), 可负值.</li>\n<li>基点如果不是默认的话, 围绕所设基点位置旋转, 而且基点可值大于旋转物体的宽高值, 即设200% 200%, 会围绕变换物体以外的点旋转.</li>\n</ol>\n<ul>\n<li>scale() 缩放</li>\n</ul>\n<ol>\n<li>两个参数, 用法 transform: scale(2, 1); 表示宽度变为原来的两倍, 高度一倍不变.</li>\n<li>只有一个参数时, 表示同时给定宽高的倍数. 可以负值, scale(-1, -1)相当于rotate(180deg)</li>\n<li>如果基点不是默认, 如上述0% 50% 正左基点, 那么x轴上的缩放倍数, 如scale(2, 1)物体的左边位置不变, 往右扩展一倍. 读者可自行测试.</li>\n</ol>\n<ul>\n<li>skew() 斜拉</li>\n</ul>\n<ol>\n<li>两个参数, 用法 transform: skew(0deg, 0deg); skew(180deg, 180deg)和skew(0deg, 0deg)效果一样.</li>\n<li>180deg一个循环, 当参数是90deg时候, 变换物体将被拉伸至消失, 想象一下高中时期的tan(90°), 因此两个参数有一个是90deg, 物体都会消失不见.</li>\n<li>第一个参数表示左右偏移, 给定度数是正数时, 容器会往左上和右下横向拉扯. 负数相反. 第二个参数为正数时, 往左上和右下纵向拉扯. 负数相反.</li>\n<li>如果基点不默认, 那基点位置将不变, 位置不动的情况下拉扯.</li>\n</ol>\n<ul>\n<li>大魔王matrix()</li>\n</ul>\n<ol>\n<li>写在前面, 其实上述介绍的四种方法, 无论拉伸斜拉还是啥, 本质都是调用matrix()方法实现.</li>\n<li>matrix() 有6个参数, 别怕, 下面慢慢分析. 假设参数分别是a, b, c, d, e, f<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">  a c e   </span><br><span class=\"line\">[ b d f ]</span><br><span class=\"line\">  0 0 1</span><br></pre></td></tr></table></figure>\n\n</li>\n</ol>\n<p>将6参看成矩阵, 结合之前的transform-origin的两个参数x y来看</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">  a c e    x        ax + cy + e </span><br><span class=\"line\">[ b d f ][ y ] =&gt; [ bx + dy + f ] // 矩阵相乘 </span><br><span class=\"line\">  0 0 1    1         0 + 0 + 1</span><br></pre></td></tr></table></figure>\n\n<p>ax + cy + e代表水平坐标, bx + dy + f代表垂直坐标.</p>\n<ol start=\"3\">\n<li>位移 eg matrix(1, 0, 0, 1, 30, 30) 基点默认时的坐标是(0, 0),即物体中心点. ax + cy + e =&gt; e = 30, bx + dy + f =&gt; f = 30, 相当于translate(30px, 30px). 上述可证明matrix后两位的参数分别表示, 水平偏移距离, 垂直偏移距离.</li>\n<li>缩放 eg matrix(s, 0, 0, s, 0, 0) 基点默认, ax + cy + e =&gt; sx , bx + dy + f =&gt; sy, 相当于scale(sx, sy).</li>\n<li>旋转 设旋转角度为α, eg matrix(cosα, sinα, -sinα, cosα, 0, 0)基点默认. ax + cy + e =&gt; xcosα - ysinα , bx + dy + f =&gt; xsinα + ycosα. 一般情况下, 用rotate(αdeg)就可以了, 方便简单.</li>\n<li>拉伸 eg matrix(1, tan(αy), tan(αx), 1, 0, 0). ax + cy + e =&gt; x + ytan(αx) , bx + dy + f =&gt; xtan(αy) + y. 相当于skew(αx deg, αy deg). αx表示x轴倾斜的角度.</li>\n</ol>\n","site":{"data":{}},"excerpt":"<h5 id=\"写在前面\"><a href=\"#写在前面\" class=\"headerlink\" title=\"写在前面\"></a>写在前面</h5><p>这篇文章主要讲css3字体、transform的2D转换<br>首先是字体@font-face, 2D转换的translate(), rotate(), scale(), skew(), transform-origin, 还有大魔王matrix().<br>2D转换的属性都没有继承性.</p>\n<h4 id=\"font-face\"><a href=\"#font-face\" class=\"headerlink\" title=\"@font-face\"></a>@font-face</h4><p>ie9及以上都支持, 但只支持.eot后缀字体. font-face的出现, 字体就没必要在用户用户端上提前安装好了.</p>\n<pre><code>@font-face {\n  font-family: fontName; // 一个变量名\n  src: url(&quot;fontTrueName.ttf&quot;), // 字体名\n  url(&quot;fontTrueName.eot&quot;);\n}\ndiv {\n  font-family: fontName; // 引用字体的变量名即可\n}</code></pre>","more":"<p>注意, 如果要用字体的不同字体, 如粗细, 还需要再添加一个@font-face, 而且src的字体也要是新的粗字体, 还要加上font-weight: bold等, 而且变量名一定要一样.</p>\n<h4 id=\"transform\"><a href=\"#transform\" class=\"headerlink\" title=\"transform\"></a>transform</h4><p>ie10+, chrome,safari加-webkit-, ie9加-ms-(仅适用于2D转换), 厂商前缀都加载transform上. eg:-ms-transform: translate()</p>\n<ul>\n<li>transform-origin</li>\n</ul>\n<ol>\n<li>两个参数, 用法: transform-origin: x y; 初始值是50% 50%; 因此是需要变换的中心点, 下面都说基点.</li>\n<li>可以规定变换的基点, 如0% 50%, 就是x轴0, y轴是变换物体高度的一半, 基点就是正左边缘点, 所有变换都会以正左为中心点旋转, 斜拉, 缩放(位移也是, 虽然看不出来).</li>\n<li>参数除了百分数, 也可以用px像素, 也可以直接用left, right,(x轴) top, bottom,(y轴) center(x, y均可)来指定. 一般如果基点要求不是非常苛刻, 用left, right这些比较简单明了.</li>\n</ol>\n<ul>\n<li>translate() 位移</li>\n</ul>\n<ol>\n<li>两个参数, 用法 transform: translate(10px, 20px); 表示向右移10像素, 向下移动20像素.</li>\n<li>如果只有一个参数, 那只在x轴移动即左右移动, 所以这个属性也能赋予负值.</li>\n</ol>\n<ul>\n<li>rotate() 旋转</li>\n</ul>\n<ol>\n<li>一个参数, 用法 transform: rotate(90deg); 表示顺时针旋转90度, 单位是deg(度 Degress的缩写), 可负值.</li>\n<li>基点如果不是默认的话, 围绕所设基点位置旋转, 而且基点可值大于旋转物体的宽高值, 即设200% 200%, 会围绕变换物体以外的点旋转.</li>\n</ol>\n<ul>\n<li>scale() 缩放</li>\n</ul>\n<ol>\n<li>两个参数, 用法 transform: scale(2, 1); 表示宽度变为原来的两倍, 高度一倍不变.</li>\n<li>只有一个参数时, 表示同时给定宽高的倍数. 可以负值, scale(-1, -1)相当于rotate(180deg)</li>\n<li>如果基点不是默认, 如上述0% 50% 正左基点, 那么x轴上的缩放倍数, 如scale(2, 1)物体的左边位置不变, 往右扩展一倍. 读者可自行测试.</li>\n</ol>\n<ul>\n<li>skew() 斜拉</li>\n</ul>\n<ol>\n<li>两个参数, 用法 transform: skew(0deg, 0deg); skew(180deg, 180deg)和skew(0deg, 0deg)效果一样.</li>\n<li>180deg一个循环, 当参数是90deg时候, 变换物体将被拉伸至消失, 想象一下高中时期的tan(90°), 因此两个参数有一个是90deg, 物体都会消失不见.</li>\n<li>第一个参数表示左右偏移, 给定度数是正数时, 容器会往左上和右下横向拉扯. 负数相反. 第二个参数为正数时, 往左上和右下纵向拉扯. 负数相反.</li>\n<li>如果基点不默认, 那基点位置将不变, 位置不动的情况下拉扯.</li>\n</ol>\n<ul>\n<li>大魔王matrix()</li>\n</ul>\n<ol>\n<li>写在前面, 其实上述介绍的四种方法, 无论拉伸斜拉还是啥, 本质都是调用matrix()方法实现.</li>\n<li>matrix() 有6个参数, 别怕, 下面慢慢分析. 假设参数分别是a, b, c, d, e, f<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">  a c e   </span><br><span class=\"line\">[ b d f ]</span><br><span class=\"line\">  0 0 1</span><br></pre></td></tr></table></figure>\n\n</li>\n</ol>\n<p>将6参看成矩阵, 结合之前的transform-origin的两个参数x y来看</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">  a c e    x        ax + cy + e </span><br><span class=\"line\">[ b d f ][ y ] =&gt; [ bx + dy + f ] // 矩阵相乘 </span><br><span class=\"line\">  0 0 1    1         0 + 0 + 1</span><br></pre></td></tr></table></figure>\n\n<p>ax + cy + e代表水平坐标, bx + dy + f代表垂直坐标.</p>\n<ol start=\"3\">\n<li>位移 eg matrix(1, 0, 0, 1, 30, 30) 基点默认时的坐标是(0, 0),即物体中心点. ax + cy + e =&gt; e = 30, bx + dy + f =&gt; f = 30, 相当于translate(30px, 30px). 上述可证明matrix后两位的参数分别表示, 水平偏移距离, 垂直偏移距离.</li>\n<li>缩放 eg matrix(s, 0, 0, s, 0, 0) 基点默认, ax + cy + e =&gt; sx , bx + dy + f =&gt; sy, 相当于scale(sx, sy).</li>\n<li>旋转 设旋转角度为α, eg matrix(cosα, sinα, -sinα, cosα, 0, 0)基点默认. ax + cy + e =&gt; xcosα - ysinα , bx + dy + f =&gt; xsinα + ycosα. 一般情况下, 用rotate(αdeg)就可以了, 方便简单.</li>\n<li>拉伸 eg matrix(1, tan(αy), tan(αx), 1, 0, 0). ax + cy + e =&gt; x + ytan(αx) , bx + dy + f =&gt; xtan(αy) + y. 相当于skew(αx deg, αy deg). αx表示x轴倾斜的角度.</li>\n</ol>"},{"title":"简述CSS3的一些属性(4)","date":"2017-08-20T05:40:18.000Z","_content":"##### 写在前面\n这篇文章主要讲transform的3D转换、css3过渡\n首先是rotate3d() rotate3d() rotate3d(), 视角perspective perspective-origin, transform-style, backface-visibility\n过渡的transition. 今天的属性都无继承性.\n\n#### rotate3d() translate3d() scale3d()\n兼容性ie10及以上支持3d, safari和chrome加上厂商前缀即可, opera只能支持2d.\nrotateZ()本质是rotate3d(x,y,z)的第三个参数. 斜拉skew没有z轴上的方法, 也没有skew3d()这个方法.\nx轴, y轴大家都很了解了, 这个z轴是在哪呢, 其实就是我们视角看向屏幕的方向, 即z轴是与屏幕垂直的, 越靠近我们z轴值越大.\n1. rotateZ(), 围绕z轴旋转. 和rotate()效果一模一样. rotateX()围绕x轴旋转, rotateY()围绕y轴, 可以看出3d效果.\n2. translateZ(), 结合后面的perspective一起才能起作用, 负值时往屏幕深处移动, 正值往屏幕正前方移动.\n3. scaleZ(), 当定义了一个3d变换物体, 这个方法用来制定z方向的拉伸缩小比例, 同样可以负值.\n\n<!--more-->\n#### perspective perspective-origin\nie10+, 其他要加-webkit- -moz- 火狐不用加前缀.\n1. perspective, 定义浏览器的视角高度,  如同unity3d中设置的camera一样.\n2. 用法: perspective: 100px; 当translateZ(101px);时候, 物体将会消失, 因为物体跑到视角后面去了. \n3. perspective-origin, 顾名思义, 就是3d元素的基点位置. 若值为(25% 75%), 就是在左下方, 假设translateZ是正值, 物体会往右上靠近我们.\n\n#### transform-style\nie11+, -moz-, -webkit-\n1. 默认值flat,表示子元素平面显示, transform-style: preserve-3d; 表示子元素3d显示.\n2. 一般想做一些较复杂的3d变换, 这个属性是必须设置的. 假设我们想做一个立体骰子, 没有设置这个属性的话, 6个面都会叠在一起.\n\n#### backface-visibility\nie10+, -moz-, -webkit-\n1. 顾名思义, 背部的显示与否. 默认值为visible. 可设置为hidden, 这样rotateX(180deg) rotateY(180deg)物体都不会显示.\n2. 实际上过了90deg后就已经算是背面了, 因此在91deg时候物体就消失不见了.\n\n#### matirx3d()\n1. 终极大魔王, 2d的时候6个参数, 3d参数为4*4=16个. 不过千万不要被它的参数所吓到, 其实本质是一样的, 如后4位(10, 20, 30, 1), 其实和2d一样, 是平移的值, 10为x 20为y 30为z轴上平移的值. \n2. matrix3d(1,0,0,0,0,1,0,0,0,0,1,0,0,0,0,1), transform-origin基点默认的情况下, 其实第一个1就是x轴的scale倍数, 第二个1就是y轴的, 第三个1就是z轴的.\n3. 呃, 剩下的skew和rotate有空再研究吧. orz\n\n#### transition 过渡\nie10+, Safari需要加前缀-webkit-. 这个属性实用程度远比上述都高. 有四个属性, 不过是这个属性同样可以缩写, 现在拆分变异理解.\n1. transition-property. 规定应用过渡的css属性名称, 其实嫌麻烦可以设为all.\n2. transition-duration. 定义过渡花费的时间, 小于1秒的小数可以省略前面的零, 如0.3秒写为.3s.\n3. transition-timing-function. 规定过渡效果的时间曲线, 默认值是ease, 效果是先慢后快再慢. 还有linear, 效果是速度保持一致过渡等, 其实时间设置补偿的前提下, 效果都差不多.\n4. transition-delay. 规定过渡效果何时开始, 默认为0, 其实就是延时作用, 一般不会修改这个属性.\n5. 上述可以缩写为, transition: width 1s linear 2s; 然后再给所设物体写上伪类hover设置变化的width即可.\n```javascript\n    div1 {\n      width: 100px;\n      height: 100px;\n      border: 1px solid #000;\n      transition: width 1s linear;\n      -webkit-transition: width 1s linear;\n    }\n    div1:hover {\n      width: 200px;\n    }\n```\n这样, 当我们鼠标hover到div1时候, 其宽度就会在1s内平缓变为200px;","source":"_posts/简述CSS3的一些属性-4.md","raw":"---\ntitle: 简述CSS3的一些属性(4)\ndate: 2017-08-20 13:40:18\ntags: [CSS, 前端]\n---\n##### 写在前面\n这篇文章主要讲transform的3D转换、css3过渡\n首先是rotate3d() rotate3d() rotate3d(), 视角perspective perspective-origin, transform-style, backface-visibility\n过渡的transition. 今天的属性都无继承性.\n\n#### rotate3d() translate3d() scale3d()\n兼容性ie10及以上支持3d, safari和chrome加上厂商前缀即可, opera只能支持2d.\nrotateZ()本质是rotate3d(x,y,z)的第三个参数. 斜拉skew没有z轴上的方法, 也没有skew3d()这个方法.\nx轴, y轴大家都很了解了, 这个z轴是在哪呢, 其实就是我们视角看向屏幕的方向, 即z轴是与屏幕垂直的, 越靠近我们z轴值越大.\n1. rotateZ(), 围绕z轴旋转. 和rotate()效果一模一样. rotateX()围绕x轴旋转, rotateY()围绕y轴, 可以看出3d效果.\n2. translateZ(), 结合后面的perspective一起才能起作用, 负值时往屏幕深处移动, 正值往屏幕正前方移动.\n3. scaleZ(), 当定义了一个3d变换物体, 这个方法用来制定z方向的拉伸缩小比例, 同样可以负值.\n\n<!--more-->\n#### perspective perspective-origin\nie10+, 其他要加-webkit- -moz- 火狐不用加前缀.\n1. perspective, 定义浏览器的视角高度,  如同unity3d中设置的camera一样.\n2. 用法: perspective: 100px; 当translateZ(101px);时候, 物体将会消失, 因为物体跑到视角后面去了. \n3. perspective-origin, 顾名思义, 就是3d元素的基点位置. 若值为(25% 75%), 就是在左下方, 假设translateZ是正值, 物体会往右上靠近我们.\n\n#### transform-style\nie11+, -moz-, -webkit-\n1. 默认值flat,表示子元素平面显示, transform-style: preserve-3d; 表示子元素3d显示.\n2. 一般想做一些较复杂的3d变换, 这个属性是必须设置的. 假设我们想做一个立体骰子, 没有设置这个属性的话, 6个面都会叠在一起.\n\n#### backface-visibility\nie10+, -moz-, -webkit-\n1. 顾名思义, 背部的显示与否. 默认值为visible. 可设置为hidden, 这样rotateX(180deg) rotateY(180deg)物体都不会显示.\n2. 实际上过了90deg后就已经算是背面了, 因此在91deg时候物体就消失不见了.\n\n#### matirx3d()\n1. 终极大魔王, 2d的时候6个参数, 3d参数为4*4=16个. 不过千万不要被它的参数所吓到, 其实本质是一样的, 如后4位(10, 20, 30, 1), 其实和2d一样, 是平移的值, 10为x 20为y 30为z轴上平移的值. \n2. matrix3d(1,0,0,0,0,1,0,0,0,0,1,0,0,0,0,1), transform-origin基点默认的情况下, 其实第一个1就是x轴的scale倍数, 第二个1就是y轴的, 第三个1就是z轴的.\n3. 呃, 剩下的skew和rotate有空再研究吧. orz\n\n#### transition 过渡\nie10+, Safari需要加前缀-webkit-. 这个属性实用程度远比上述都高. 有四个属性, 不过是这个属性同样可以缩写, 现在拆分变异理解.\n1. transition-property. 规定应用过渡的css属性名称, 其实嫌麻烦可以设为all.\n2. transition-duration. 定义过渡花费的时间, 小于1秒的小数可以省略前面的零, 如0.3秒写为.3s.\n3. transition-timing-function. 规定过渡效果的时间曲线, 默认值是ease, 效果是先慢后快再慢. 还有linear, 效果是速度保持一致过渡等, 其实时间设置补偿的前提下, 效果都差不多.\n4. transition-delay. 规定过渡效果何时开始, 默认为0, 其实就是延时作用, 一般不会修改这个属性.\n5. 上述可以缩写为, transition: width 1s linear 2s; 然后再给所设物体写上伪类hover设置变化的width即可.\n```javascript\n    div1 {\n      width: 100px;\n      height: 100px;\n      border: 1px solid #000;\n      transition: width 1s linear;\n      -webkit-transition: width 1s linear;\n    }\n    div1:hover {\n      width: 200px;\n    }\n```\n这样, 当我们鼠标hover到div1时候, 其宽度就会在1s内平缓变为200px;","slug":"简述CSS3的一些属性-4","published":1,"updated":"2021-07-02T03:20:30.666Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl5sb8gfi001sxq0ryjyv32yu","content":"<h5 id=\"写在前面\"><a href=\"#写在前面\" class=\"headerlink\" title=\"写在前面\"></a>写在前面</h5><p>这篇文章主要讲transform的3D转换、css3过渡<br>首先是rotate3d() rotate3d() rotate3d(), 视角perspective perspective-origin, transform-style, backface-visibility<br>过渡的transition. 今天的属性都无继承性.</p>\n<h4 id=\"rotate3d-translate3d-scale3d\"><a href=\"#rotate3d-translate3d-scale3d\" class=\"headerlink\" title=\"rotate3d() translate3d() scale3d()\"></a>rotate3d() translate3d() scale3d()</h4><p>兼容性ie10及以上支持3d, safari和chrome加上厂商前缀即可, opera只能支持2d.<br>rotateZ()本质是rotate3d(x,y,z)的第三个参数. 斜拉skew没有z轴上的方法, 也没有skew3d()这个方法.<br>x轴, y轴大家都很了解了, 这个z轴是在哪呢, 其实就是我们视角看向屏幕的方向, 即z轴是与屏幕垂直的, 越靠近我们z轴值越大.</p>\n<ol>\n<li>rotateZ(), 围绕z轴旋转. 和rotate()效果一模一样. rotateX()围绕x轴旋转, rotateY()围绕y轴, 可以看出3d效果.</li>\n<li>translateZ(), 结合后面的perspective一起才能起作用, 负值时往屏幕深处移动, 正值往屏幕正前方移动.</li>\n<li>scaleZ(), 当定义了一个3d变换物体, 这个方法用来制定z方向的拉伸缩小比例, 同样可以负值.</li>\n</ol>\n<a id=\"more\"></a>\n<h4 id=\"perspective-perspective-origin\"><a href=\"#perspective-perspective-origin\" class=\"headerlink\" title=\"perspective perspective-origin\"></a>perspective perspective-origin</h4><p>ie10+, 其他要加-webkit- -moz- 火狐不用加前缀.</p>\n<ol>\n<li>perspective, 定义浏览器的视角高度,  如同unity3d中设置的camera一样.</li>\n<li>用法: perspective: 100px; 当translateZ(101px);时候, 物体将会消失, 因为物体跑到视角后面去了. </li>\n<li>perspective-origin, 顾名思义, 就是3d元素的基点位置. 若值为(25% 75%), 就是在左下方, 假设translateZ是正值, 物体会往右上靠近我们.</li>\n</ol>\n<h4 id=\"transform-style\"><a href=\"#transform-style\" class=\"headerlink\" title=\"transform-style\"></a>transform-style</h4><p>ie11+, -moz-, -webkit-</p>\n<ol>\n<li>默认值flat,表示子元素平面显示, transform-style: preserve-3d; 表示子元素3d显示.</li>\n<li>一般想做一些较复杂的3d变换, 这个属性是必须设置的. 假设我们想做一个立体骰子, 没有设置这个属性的话, 6个面都会叠在一起.</li>\n</ol>\n<h4 id=\"backface-visibility\"><a href=\"#backface-visibility\" class=\"headerlink\" title=\"backface-visibility\"></a>backface-visibility</h4><p>ie10+, -moz-, -webkit-</p>\n<ol>\n<li>顾名思义, 背部的显示与否. 默认值为visible. 可设置为hidden, 这样rotateX(180deg) rotateY(180deg)物体都不会显示.</li>\n<li>实际上过了90deg后就已经算是背面了, 因此在91deg时候物体就消失不见了.</li>\n</ol>\n<h4 id=\"matirx3d\"><a href=\"#matirx3d\" class=\"headerlink\" title=\"matirx3d()\"></a>matirx3d()</h4><ol>\n<li>终极大魔王, 2d的时候6个参数, 3d参数为4*4=16个. 不过千万不要被它的参数所吓到, 其实本质是一样的, 如后4位(10, 20, 30, 1), 其实和2d一样, 是平移的值, 10为x 20为y 30为z轴上平移的值. </li>\n<li>matrix3d(1,0,0,0,0,1,0,0,0,0,1,0,0,0,0,1), transform-origin基点默认的情况下, 其实第一个1就是x轴的scale倍数, 第二个1就是y轴的, 第三个1就是z轴的.</li>\n<li>呃, 剩下的skew和rotate有空再研究吧. orz</li>\n</ol>\n<h4 id=\"transition-过渡\"><a href=\"#transition-过渡\" class=\"headerlink\" title=\"transition 过渡\"></a>transition 过渡</h4><p>ie10+, Safari需要加前缀-webkit-. 这个属性实用程度远比上述都高. 有四个属性, 不过是这个属性同样可以缩写, 现在拆分变异理解.</p>\n<ol>\n<li>transition-property. 规定应用过渡的css属性名称, 其实嫌麻烦可以设为all.</li>\n<li>transition-duration. 定义过渡花费的时间, 小于1秒的小数可以省略前面的零, 如0.3秒写为.3s.</li>\n<li>transition-timing-function. 规定过渡效果的时间曲线, 默认值是ease, 效果是先慢后快再慢. 还有linear, 效果是速度保持一致过渡等, 其实时间设置补偿的前提下, 效果都差不多.</li>\n<li>transition-delay. 规定过渡效果何时开始, 默认为0, 其实就是延时作用, 一般不会修改这个属性.</li>\n<li>上述可以缩写为, transition: width 1s linear 2s; 然后再给所设物体写上伪类hover设置变化的width即可.<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">div1 &#123;</span><br><span class=\"line\">  width: <span class=\"number\">100</span>px;</span><br><span class=\"line\">  height: <span class=\"number\">100</span>px;</span><br><span class=\"line\">  border: 1px solid #000;</span><br><span class=\"line\">  transition: width <span class=\"number\">1</span>s linear;</span><br><span class=\"line\">  -webkit-transition: width <span class=\"number\">1</span>s linear;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">div1:hover &#123;</span><br><span class=\"line\">  width: <span class=\"number\">200</span>px;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n</li>\n</ol>\n<p>这样, 当我们鼠标hover到div1时候, 其宽度就会在1s内平缓变为200px;</p>\n","site":{"data":{}},"excerpt":"<h5 id=\"写在前面\"><a href=\"#写在前面\" class=\"headerlink\" title=\"写在前面\"></a>写在前面</h5><p>这篇文章主要讲transform的3D转换、css3过渡<br>首先是rotate3d() rotate3d() rotate3d(), 视角perspective perspective-origin, transform-style, backface-visibility<br>过渡的transition. 今天的属性都无继承性.</p>\n<h4 id=\"rotate3d-translate3d-scale3d\"><a href=\"#rotate3d-translate3d-scale3d\" class=\"headerlink\" title=\"rotate3d() translate3d() scale3d()\"></a>rotate3d() translate3d() scale3d()</h4><p>兼容性ie10及以上支持3d, safari和chrome加上厂商前缀即可, opera只能支持2d.<br>rotateZ()本质是rotate3d(x,y,z)的第三个参数. 斜拉skew没有z轴上的方法, 也没有skew3d()这个方法.<br>x轴, y轴大家都很了解了, 这个z轴是在哪呢, 其实就是我们视角看向屏幕的方向, 即z轴是与屏幕垂直的, 越靠近我们z轴值越大.</p>\n<ol>\n<li>rotateZ(), 围绕z轴旋转. 和rotate()效果一模一样. rotateX()围绕x轴旋转, rotateY()围绕y轴, 可以看出3d效果.</li>\n<li>translateZ(), 结合后面的perspective一起才能起作用, 负值时往屏幕深处移动, 正值往屏幕正前方移动.</li>\n<li>scaleZ(), 当定义了一个3d变换物体, 这个方法用来制定z方向的拉伸缩小比例, 同样可以负值.</li>\n</ol>","more":"<h4 id=\"perspective-perspective-origin\"><a href=\"#perspective-perspective-origin\" class=\"headerlink\" title=\"perspective perspective-origin\"></a>perspective perspective-origin</h4><p>ie10+, 其他要加-webkit- -moz- 火狐不用加前缀.</p>\n<ol>\n<li>perspective, 定义浏览器的视角高度,  如同unity3d中设置的camera一样.</li>\n<li>用法: perspective: 100px; 当translateZ(101px);时候, 物体将会消失, 因为物体跑到视角后面去了. </li>\n<li>perspective-origin, 顾名思义, 就是3d元素的基点位置. 若值为(25% 75%), 就是在左下方, 假设translateZ是正值, 物体会往右上靠近我们.</li>\n</ol>\n<h4 id=\"transform-style\"><a href=\"#transform-style\" class=\"headerlink\" title=\"transform-style\"></a>transform-style</h4><p>ie11+, -moz-, -webkit-</p>\n<ol>\n<li>默认值flat,表示子元素平面显示, transform-style: preserve-3d; 表示子元素3d显示.</li>\n<li>一般想做一些较复杂的3d变换, 这个属性是必须设置的. 假设我们想做一个立体骰子, 没有设置这个属性的话, 6个面都会叠在一起.</li>\n</ol>\n<h4 id=\"backface-visibility\"><a href=\"#backface-visibility\" class=\"headerlink\" title=\"backface-visibility\"></a>backface-visibility</h4><p>ie10+, -moz-, -webkit-</p>\n<ol>\n<li>顾名思义, 背部的显示与否. 默认值为visible. 可设置为hidden, 这样rotateX(180deg) rotateY(180deg)物体都不会显示.</li>\n<li>实际上过了90deg后就已经算是背面了, 因此在91deg时候物体就消失不见了.</li>\n</ol>\n<h4 id=\"matirx3d\"><a href=\"#matirx3d\" class=\"headerlink\" title=\"matirx3d()\"></a>matirx3d()</h4><ol>\n<li>终极大魔王, 2d的时候6个参数, 3d参数为4*4=16个. 不过千万不要被它的参数所吓到, 其实本质是一样的, 如后4位(10, 20, 30, 1), 其实和2d一样, 是平移的值, 10为x 20为y 30为z轴上平移的值. </li>\n<li>matrix3d(1,0,0,0,0,1,0,0,0,0,1,0,0,0,0,1), transform-origin基点默认的情况下, 其实第一个1就是x轴的scale倍数, 第二个1就是y轴的, 第三个1就是z轴的.</li>\n<li>呃, 剩下的skew和rotate有空再研究吧. orz</li>\n</ol>\n<h4 id=\"transition-过渡\"><a href=\"#transition-过渡\" class=\"headerlink\" title=\"transition 过渡\"></a>transition 过渡</h4><p>ie10+, Safari需要加前缀-webkit-. 这个属性实用程度远比上述都高. 有四个属性, 不过是这个属性同样可以缩写, 现在拆分变异理解.</p>\n<ol>\n<li>transition-property. 规定应用过渡的css属性名称, 其实嫌麻烦可以设为all.</li>\n<li>transition-duration. 定义过渡花费的时间, 小于1秒的小数可以省略前面的零, 如0.3秒写为.3s.</li>\n<li>transition-timing-function. 规定过渡效果的时间曲线, 默认值是ease, 效果是先慢后快再慢. 还有linear, 效果是速度保持一致过渡等, 其实时间设置补偿的前提下, 效果都差不多.</li>\n<li>transition-delay. 规定过渡效果何时开始, 默认为0, 其实就是延时作用, 一般不会修改这个属性.</li>\n<li>上述可以缩写为, transition: width 1s linear 2s; 然后再给所设物体写上伪类hover设置变化的width即可.<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">div1 &#123;</span><br><span class=\"line\">  width: <span class=\"number\">100</span>px;</span><br><span class=\"line\">  height: <span class=\"number\">100</span>px;</span><br><span class=\"line\">  border: 1px solid #000;</span><br><span class=\"line\">  transition: width <span class=\"number\">1</span>s linear;</span><br><span class=\"line\">  -webkit-transition: width <span class=\"number\">1</span>s linear;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">div1:hover &#123;</span><br><span class=\"line\">  width: <span class=\"number\">200</span>px;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n</li>\n</ol>\n<p>这样, 当我们鼠标hover到div1时候, 其宽度就会在1s内平缓变为200px;</p>"},{"title":"简述CSS3的一些属性(5)","date":"2017-08-25T06:10:44.000Z","_content":"##### 写在前面\n这篇文章主要讲css3动画 column 用户界面\n动画的@keyframes animation,  column的colunm-count column-gap column-rule,  用户界面的resize box-sizing outline-offset. 都没有继承性.\n\n#### @keyframes 关键帧\n兼容ie10+, 其他浏览器需要加厂商前缀.\n1. 用法: @keyframes animationName { keyframes-selector { css-styles; } }\n   animationName: 必须. 指定关键帧的名称.\n   keyframes-selector: 必须, 规定动画持续时间的百分比, 步骤. 可以选0-100%, from(0%), to(100%)\n   css-styles: 必须, 一个或多个css样式.\n2. 必须与animation配合使用, 下面会给eg.\n\n#### animation\n<!--more-->\n兼容ie10+, 其他浏览器需要加厂商前缀.\n1. 属性有8个. animation-name: 要绑定到选择器的关键帧名称.\n   aimation-duration: 指定动画需要的时间, 与transition的duration用法一样, 默认值为0s.\n   animation-timing-function: 指定动画如何完成一个周期. 同上述, 默认值为ease;\n   animation-delay: 指定动画启动前的延迟. 同上述, 默认值为0;\n   animation-iteration-count: 定义动画执行的次数, 默认为1, 常用infinite(无限次).\n   animation-direction: 指定动画是否轮流方向播放. 默认值为normal.\n   animation-fill-mode: 指定动画不播放时, 或动画播放完成后的位置或样式. 默认值为none.\n   animation-play-state: 指定动画是否在运行或已暂停, 默认值为running.\n2. 与transition一样可以缩写成 animation: name duration timing-function delay teration-count direction fill-mode play-state. 一般比较常用name duration teration-count三个属性.\n```javascript\n// 只在chrome或safari测试\ndiv {\n  width: 100px; height: 100px;\n  background: red; position: relative;\n  animation: move 5s infinite;\n  -webkit-animation: move 5s infinite;\n}\n@keyframes {\n    0% { top: 0px; background: red; width: 100px; }\n  100% { top: 200px; background: yellow; width: 300px; }\n}\n@-webkit-keyframes {\n    0% { top: 0px; background: red; width: 100px; }\n  100% { top: 200px; background: yellow; width: 300px; }\n}\n```\n上述是div物体在5s内, 向下运动200px, 背景颜色由red逐渐变成yellow, 宽度也是逐渐变成300px. 速度都是平均, 想要不同的话可以改变timing-function. 值得注意的是, fill-mode和play-state, 当执行次数只有一次的时候, 设置fill-mode为forwards. 会停在动画结尾的位置, 即样式不会变为执行前的样式. 第二就是在动画过程中play-state的值如果变为pause, 物体会停在当前位置, 但是动画执行不会消失, 一旦play-state的值恢复running, 动画继续执行.\n\n那为何有了transition又要设计一个animation出来呢, 二者实现效果相似. 原因是animation和keyframes可以精准控制每一帧的动画效果, 能够更加精细地划分动画, 这是transition所欠缺的. 因此如果是一些较简单的动画效果笔者认为用transition足以.\n\n#### 多列column\ncolumn: 兼容ie10+, 除了Opera以外的浏览器都需要加厂商前缀.\n1. column-count. 规定元素赢干杯分隔的列数. 如要把一个p标签的文字分成3列: column-count: 3即可. 间隔宽度各大浏览器标准都不一致.\n2. column-gap: 规定列与列之间的间隔. column-gap: 40px; column-gap: 4em; 都是可以的, 百分比会失效.\n3. column-rule: 规定列与列之间的边框宽度颜色样式. column-rule: 3px solid #000; column-count: 2. 结果为两列间隔存在一宽度为3px的竖线黑色边框.\n\n#### 用户界面\n1. resize. ie不兼容, 低版本Firefox需要加-moz-. 指定的元素可以由用户调整宽高, 和textarea很相似. 默认为none. 可以设置为both, 用户即可调整宽高. horizont, 用户可调整物体宽度, vertical, 用户可调整高度.\n2. box-sizing. ie8+, 低版本chrome和Firefox需要加-webkit-, -moz-. 指定以某种方式定义某些元素, 以适应指定区域. 默认值为content-box. 效果为指定的样式宽高为多少, 内容区域(盒子模型里的content区)九尾多少, 即不包括padding. 可设置为border-box, 这样就包括padding.\n```JavaScript\n// 总宽度为 140px 包含两边padding\n.div1 {\n  width: 100px;\n  height: 100px;\n  padding: 20px;\n  box-sizing: content-box;\n}\n// 总宽度为 100px 内容区域为60px, width = content区 + padding\n.div2 {\n  width: 100px;\n  height: 100px;\n  padding: 20px;\n  box-sizing: border-box;\n}\n```\n\n* outline-offset. 只有ie不兼容. 设置border边缘外的偏移, 与outline共用. 可以理解为border外面又有一个border.\n```JavaScript\ndiv {\n  ...\n  border: 2px solid #000;\n  outline: 2px solid #F00;\n  outline-offset: 15px;\n}\n```\n在border外距离15px处存在一个红色的2px边框. outline不会影响布局空间, 因此不会影响元素的尺寸.\n\n#### 写在最后\n简述css3系列应该算是完结了, 实不相瞒, 当初是想了解box-sizing才看的css3, 结果发现了更多没有注意到的或者是根本没见过的属性, 让我受益良多. \n更多css3属性可以点击[css3汇总](http://www.css88.com/book/css/css3-quicksearch.htm)\n希望我能保持热情. 还是那句话, 喜欢的话就坚持吧.","source":"_posts/简述CSS3的一些属性-5.md","raw":"---\ntitle: 简述CSS3的一些属性(5)\ndate: 2017-08-25 14:10:44\ntags: [CSS, 前端]\n---\n##### 写在前面\n这篇文章主要讲css3动画 column 用户界面\n动画的@keyframes animation,  column的colunm-count column-gap column-rule,  用户界面的resize box-sizing outline-offset. 都没有继承性.\n\n#### @keyframes 关键帧\n兼容ie10+, 其他浏览器需要加厂商前缀.\n1. 用法: @keyframes animationName { keyframes-selector { css-styles; } }\n   animationName: 必须. 指定关键帧的名称.\n   keyframes-selector: 必须, 规定动画持续时间的百分比, 步骤. 可以选0-100%, from(0%), to(100%)\n   css-styles: 必须, 一个或多个css样式.\n2. 必须与animation配合使用, 下面会给eg.\n\n#### animation\n<!--more-->\n兼容ie10+, 其他浏览器需要加厂商前缀.\n1. 属性有8个. animation-name: 要绑定到选择器的关键帧名称.\n   aimation-duration: 指定动画需要的时间, 与transition的duration用法一样, 默认值为0s.\n   animation-timing-function: 指定动画如何完成一个周期. 同上述, 默认值为ease;\n   animation-delay: 指定动画启动前的延迟. 同上述, 默认值为0;\n   animation-iteration-count: 定义动画执行的次数, 默认为1, 常用infinite(无限次).\n   animation-direction: 指定动画是否轮流方向播放. 默认值为normal.\n   animation-fill-mode: 指定动画不播放时, 或动画播放完成后的位置或样式. 默认值为none.\n   animation-play-state: 指定动画是否在运行或已暂停, 默认值为running.\n2. 与transition一样可以缩写成 animation: name duration timing-function delay teration-count direction fill-mode play-state. 一般比较常用name duration teration-count三个属性.\n```javascript\n// 只在chrome或safari测试\ndiv {\n  width: 100px; height: 100px;\n  background: red; position: relative;\n  animation: move 5s infinite;\n  -webkit-animation: move 5s infinite;\n}\n@keyframes {\n    0% { top: 0px; background: red; width: 100px; }\n  100% { top: 200px; background: yellow; width: 300px; }\n}\n@-webkit-keyframes {\n    0% { top: 0px; background: red; width: 100px; }\n  100% { top: 200px; background: yellow; width: 300px; }\n}\n```\n上述是div物体在5s内, 向下运动200px, 背景颜色由red逐渐变成yellow, 宽度也是逐渐变成300px. 速度都是平均, 想要不同的话可以改变timing-function. 值得注意的是, fill-mode和play-state, 当执行次数只有一次的时候, 设置fill-mode为forwards. 会停在动画结尾的位置, 即样式不会变为执行前的样式. 第二就是在动画过程中play-state的值如果变为pause, 物体会停在当前位置, 但是动画执行不会消失, 一旦play-state的值恢复running, 动画继续执行.\n\n那为何有了transition又要设计一个animation出来呢, 二者实现效果相似. 原因是animation和keyframes可以精准控制每一帧的动画效果, 能够更加精细地划分动画, 这是transition所欠缺的. 因此如果是一些较简单的动画效果笔者认为用transition足以.\n\n#### 多列column\ncolumn: 兼容ie10+, 除了Opera以外的浏览器都需要加厂商前缀.\n1. column-count. 规定元素赢干杯分隔的列数. 如要把一个p标签的文字分成3列: column-count: 3即可. 间隔宽度各大浏览器标准都不一致.\n2. column-gap: 规定列与列之间的间隔. column-gap: 40px; column-gap: 4em; 都是可以的, 百分比会失效.\n3. column-rule: 规定列与列之间的边框宽度颜色样式. column-rule: 3px solid #000; column-count: 2. 结果为两列间隔存在一宽度为3px的竖线黑色边框.\n\n#### 用户界面\n1. resize. ie不兼容, 低版本Firefox需要加-moz-. 指定的元素可以由用户调整宽高, 和textarea很相似. 默认为none. 可以设置为both, 用户即可调整宽高. horizont, 用户可调整物体宽度, vertical, 用户可调整高度.\n2. box-sizing. ie8+, 低版本chrome和Firefox需要加-webkit-, -moz-. 指定以某种方式定义某些元素, 以适应指定区域. 默认值为content-box. 效果为指定的样式宽高为多少, 内容区域(盒子模型里的content区)九尾多少, 即不包括padding. 可设置为border-box, 这样就包括padding.\n```JavaScript\n// 总宽度为 140px 包含两边padding\n.div1 {\n  width: 100px;\n  height: 100px;\n  padding: 20px;\n  box-sizing: content-box;\n}\n// 总宽度为 100px 内容区域为60px, width = content区 + padding\n.div2 {\n  width: 100px;\n  height: 100px;\n  padding: 20px;\n  box-sizing: border-box;\n}\n```\n\n* outline-offset. 只有ie不兼容. 设置border边缘外的偏移, 与outline共用. 可以理解为border外面又有一个border.\n```JavaScript\ndiv {\n  ...\n  border: 2px solid #000;\n  outline: 2px solid #F00;\n  outline-offset: 15px;\n}\n```\n在border外距离15px处存在一个红色的2px边框. outline不会影响布局空间, 因此不会影响元素的尺寸.\n\n#### 写在最后\n简述css3系列应该算是完结了, 实不相瞒, 当初是想了解box-sizing才看的css3, 结果发现了更多没有注意到的或者是根本没见过的属性, 让我受益良多. \n更多css3属性可以点击[css3汇总](http://www.css88.com/book/css/css3-quicksearch.htm)\n希望我能保持热情. 还是那句话, 喜欢的话就坚持吧.","slug":"简述CSS3的一些属性-5","published":1,"updated":"2021-07-02T03:20:30.667Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl5sb8gfj001vxq0rv7ro2ev9","content":"<h5 id=\"写在前面\"><a href=\"#写在前面\" class=\"headerlink\" title=\"写在前面\"></a>写在前面</h5><p>这篇文章主要讲css3动画 column 用户界面<br>动画的@keyframes animation,  column的colunm-count column-gap column-rule,  用户界面的resize box-sizing outline-offset. 都没有继承性.</p>\n<h4 id=\"keyframes-关键帧\"><a href=\"#keyframes-关键帧\" class=\"headerlink\" title=\"@keyframes 关键帧\"></a>@keyframes 关键帧</h4><p>兼容ie10+, 其他浏览器需要加厂商前缀.</p>\n<ol>\n<li>用法: @keyframes animationName { keyframes-selector { css-styles; } }<br>animationName: 必须. 指定关键帧的名称.<br>keyframes-selector: 必须, 规定动画持续时间的百分比, 步骤. 可以选0-100%, from(0%), to(100%)<br>css-styles: 必须, 一个或多个css样式.</li>\n<li>必须与animation配合使用, 下面会给eg.</li>\n</ol>\n<h4 id=\"animation\"><a href=\"#animation\" class=\"headerlink\" title=\"animation\"></a>animation</h4><a id=\"more\"></a>\n<p>兼容ie10+, 其他浏览器需要加厂商前缀.</p>\n<ol>\n<li>属性有8个. animation-name: 要绑定到选择器的关键帧名称.<br>aimation-duration: 指定动画需要的时间, 与transition的duration用法一样, 默认值为0s.<br>animation-timing-function: 指定动画如何完成一个周期. 同上述, 默认值为ease;<br>animation-delay: 指定动画启动前的延迟. 同上述, 默认值为0;<br>animation-iteration-count: 定义动画执行的次数, 默认为1, 常用infinite(无限次).<br>animation-direction: 指定动画是否轮流方向播放. 默认值为normal.<br>animation-fill-mode: 指定动画不播放时, 或动画播放完成后的位置或样式. 默认值为none.<br>animation-play-state: 指定动画是否在运行或已暂停, 默认值为running.</li>\n<li>与transition一样可以缩写成 animation: name duration timing-function delay teration-count direction fill-mode play-state. 一般比较常用name duration teration-count三个属性.<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 只在chrome或safari测试</span></span><br><span class=\"line\">div &#123;</span><br><span class=\"line\">  width: <span class=\"number\">100</span>px; height: <span class=\"number\">100</span>px;</span><br><span class=\"line\">  background: red; position: relative;</span><br><span class=\"line\">  animation: move <span class=\"number\">5</span>s infinite;</span><br><span class=\"line\">  -webkit-animation: move <span class=\"number\">5</span>s infinite;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">@keyframes &#123;</span><br><span class=\"line\">    <span class=\"number\">0</span>% &#123; <span class=\"attr\">top</span>: <span class=\"number\">0</span>px; background: red; width: <span class=\"number\">100</span>px; &#125;</span><br><span class=\"line\">  <span class=\"number\">100</span>% &#123; <span class=\"attr\">top</span>: <span class=\"number\">200</span>px; background: yellow; width: <span class=\"number\">300</span>px; &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">@-webkit-keyframes &#123;</span><br><span class=\"line\">    <span class=\"number\">0</span>% &#123; <span class=\"attr\">top</span>: <span class=\"number\">0</span>px; background: red; width: <span class=\"number\">100</span>px; &#125;</span><br><span class=\"line\">  <span class=\"number\">100</span>% &#123; <span class=\"attr\">top</span>: <span class=\"number\">200</span>px; background: yellow; width: <span class=\"number\">300</span>px; &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n</li>\n</ol>\n<p>上述是div物体在5s内, 向下运动200px, 背景颜色由red逐渐变成yellow, 宽度也是逐渐变成300px. 速度都是平均, 想要不同的话可以改变timing-function. 值得注意的是, fill-mode和play-state, 当执行次数只有一次的时候, 设置fill-mode为forwards. 会停在动画结尾的位置, 即样式不会变为执行前的样式. 第二就是在动画过程中play-state的值如果变为pause, 物体会停在当前位置, 但是动画执行不会消失, 一旦play-state的值恢复running, 动画继续执行.</p>\n<p>那为何有了transition又要设计一个animation出来呢, 二者实现效果相似. 原因是animation和keyframes可以精准控制每一帧的动画效果, 能够更加精细地划分动画, 这是transition所欠缺的. 因此如果是一些较简单的动画效果笔者认为用transition足以.</p>\n<h4 id=\"多列column\"><a href=\"#多列column\" class=\"headerlink\" title=\"多列column\"></a>多列column</h4><p>column: 兼容ie10+, 除了Opera以外的浏览器都需要加厂商前缀.</p>\n<ol>\n<li>column-count. 规定元素赢干杯分隔的列数. 如要把一个p标签的文字分成3列: column-count: 3即可. 间隔宽度各大浏览器标准都不一致.</li>\n<li>column-gap: 规定列与列之间的间隔. column-gap: 40px; column-gap: 4em; 都是可以的, 百分比会失效.</li>\n<li>column-rule: 规定列与列之间的边框宽度颜色样式. column-rule: 3px solid #000; column-count: 2. 结果为两列间隔存在一宽度为3px的竖线黑色边框.</li>\n</ol>\n<h4 id=\"用户界面\"><a href=\"#用户界面\" class=\"headerlink\" title=\"用户界面\"></a>用户界面</h4><ol>\n<li>resize. ie不兼容, 低版本Firefox需要加-moz-. 指定的元素可以由用户调整宽高, 和textarea很相似. 默认为none. 可以设置为both, 用户即可调整宽高. horizont, 用户可调整物体宽度, vertical, 用户可调整高度.</li>\n<li>box-sizing. ie8+, 低版本chrome和Firefox需要加-webkit-, -moz-. 指定以某种方式定义某些元素, 以适应指定区域. 默认值为content-box. 效果为指定的样式宽高为多少, 内容区域(盒子模型里的content区)九尾多少, 即不包括padding. 可设置为border-box, 这样就包括padding.<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 总宽度为 140px 包含两边padding</span></span><br><span class=\"line\">.div1 &#123;</span><br><span class=\"line\">  width: <span class=\"number\">100</span>px;</span><br><span class=\"line\">  height: <span class=\"number\">100</span>px;</span><br><span class=\"line\">  padding: <span class=\"number\">20</span>px;</span><br><span class=\"line\">  box-sizing: content-box;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// 总宽度为 100px 内容区域为60px, width = content区 + padding</span></span><br><span class=\"line\">.div2 &#123;</span><br><span class=\"line\">  width: <span class=\"number\">100</span>px;</span><br><span class=\"line\">  height: <span class=\"number\">100</span>px;</span><br><span class=\"line\">  padding: <span class=\"number\">20</span>px;</span><br><span class=\"line\">  box-sizing: border-box;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n</ol>\n<ul>\n<li>outline-offset. 只有ie不兼容. 设置border边缘外的偏移, 与outline共用. 可以理解为border外面又有一个border.<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">div &#123;</span><br><span class=\"line\">  ...</span><br><span class=\"line\">  border: 2px solid #000;</span><br><span class=\"line\">  outline: 2px solid #F00;</span><br><span class=\"line\">  outline-offset: <span class=\"number\">15</span>px;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n</li>\n</ul>\n<p>在border外距离15px处存在一个红色的2px边框. outline不会影响布局空间, 因此不会影响元素的尺寸.</p>\n<h4 id=\"写在最后\"><a href=\"#写在最后\" class=\"headerlink\" title=\"写在最后\"></a>写在最后</h4><p>简述css3系列应该算是完结了, 实不相瞒, 当初是想了解box-sizing才看的css3, 结果发现了更多没有注意到的或者是根本没见过的属性, 让我受益良多.<br>更多css3属性可以点击<a href=\"http://www.css88.com/book/css/css3-quicksearch.htm\" target=\"_blank\" rel=\"noopener\">css3汇总</a><br>希望我能保持热情. 还是那句话, 喜欢的话就坚持吧.</p>\n","site":{"data":{}},"excerpt":"<h5 id=\"写在前面\"><a href=\"#写在前面\" class=\"headerlink\" title=\"写在前面\"></a>写在前面</h5><p>这篇文章主要讲css3动画 column 用户界面<br>动画的@keyframes animation,  column的colunm-count column-gap column-rule,  用户界面的resize box-sizing outline-offset. 都没有继承性.</p>\n<h4 id=\"keyframes-关键帧\"><a href=\"#keyframes-关键帧\" class=\"headerlink\" title=\"@keyframes 关键帧\"></a>@keyframes 关键帧</h4><p>兼容ie10+, 其他浏览器需要加厂商前缀.</p>\n<ol>\n<li>用法: @keyframes animationName { keyframes-selector { css-styles; } }<br>animationName: 必须. 指定关键帧的名称.<br>keyframes-selector: 必须, 规定动画持续时间的百分比, 步骤. 可以选0-100%, from(0%), to(100%)<br>css-styles: 必须, 一个或多个css样式.</li>\n<li>必须与animation配合使用, 下面会给eg.</li>\n</ol>\n<h4 id=\"animation\"><a href=\"#animation\" class=\"headerlink\" title=\"animation\"></a>animation</h4>","more":"<p>兼容ie10+, 其他浏览器需要加厂商前缀.</p>\n<ol>\n<li>属性有8个. animation-name: 要绑定到选择器的关键帧名称.<br>aimation-duration: 指定动画需要的时间, 与transition的duration用法一样, 默认值为0s.<br>animation-timing-function: 指定动画如何完成一个周期. 同上述, 默认值为ease;<br>animation-delay: 指定动画启动前的延迟. 同上述, 默认值为0;<br>animation-iteration-count: 定义动画执行的次数, 默认为1, 常用infinite(无限次).<br>animation-direction: 指定动画是否轮流方向播放. 默认值为normal.<br>animation-fill-mode: 指定动画不播放时, 或动画播放完成后的位置或样式. 默认值为none.<br>animation-play-state: 指定动画是否在运行或已暂停, 默认值为running.</li>\n<li>与transition一样可以缩写成 animation: name duration timing-function delay teration-count direction fill-mode play-state. 一般比较常用name duration teration-count三个属性.<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 只在chrome或safari测试</span></span><br><span class=\"line\">div &#123;</span><br><span class=\"line\">  width: <span class=\"number\">100</span>px; height: <span class=\"number\">100</span>px;</span><br><span class=\"line\">  background: red; position: relative;</span><br><span class=\"line\">  animation: move <span class=\"number\">5</span>s infinite;</span><br><span class=\"line\">  -webkit-animation: move <span class=\"number\">5</span>s infinite;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">@keyframes &#123;</span><br><span class=\"line\">    <span class=\"number\">0</span>% &#123; <span class=\"attr\">top</span>: <span class=\"number\">0</span>px; background: red; width: <span class=\"number\">100</span>px; &#125;</span><br><span class=\"line\">  <span class=\"number\">100</span>% &#123; <span class=\"attr\">top</span>: <span class=\"number\">200</span>px; background: yellow; width: <span class=\"number\">300</span>px; &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">@-webkit-keyframes &#123;</span><br><span class=\"line\">    <span class=\"number\">0</span>% &#123; <span class=\"attr\">top</span>: <span class=\"number\">0</span>px; background: red; width: <span class=\"number\">100</span>px; &#125;</span><br><span class=\"line\">  <span class=\"number\">100</span>% &#123; <span class=\"attr\">top</span>: <span class=\"number\">200</span>px; background: yellow; width: <span class=\"number\">300</span>px; &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n</li>\n</ol>\n<p>上述是div物体在5s内, 向下运动200px, 背景颜色由red逐渐变成yellow, 宽度也是逐渐变成300px. 速度都是平均, 想要不同的话可以改变timing-function. 值得注意的是, fill-mode和play-state, 当执行次数只有一次的时候, 设置fill-mode为forwards. 会停在动画结尾的位置, 即样式不会变为执行前的样式. 第二就是在动画过程中play-state的值如果变为pause, 物体会停在当前位置, 但是动画执行不会消失, 一旦play-state的值恢复running, 动画继续执行.</p>\n<p>那为何有了transition又要设计一个animation出来呢, 二者实现效果相似. 原因是animation和keyframes可以精准控制每一帧的动画效果, 能够更加精细地划分动画, 这是transition所欠缺的. 因此如果是一些较简单的动画效果笔者认为用transition足以.</p>\n<h4 id=\"多列column\"><a href=\"#多列column\" class=\"headerlink\" title=\"多列column\"></a>多列column</h4><p>column: 兼容ie10+, 除了Opera以外的浏览器都需要加厂商前缀.</p>\n<ol>\n<li>column-count. 规定元素赢干杯分隔的列数. 如要把一个p标签的文字分成3列: column-count: 3即可. 间隔宽度各大浏览器标准都不一致.</li>\n<li>column-gap: 规定列与列之间的间隔. column-gap: 40px; column-gap: 4em; 都是可以的, 百分比会失效.</li>\n<li>column-rule: 规定列与列之间的边框宽度颜色样式. column-rule: 3px solid #000; column-count: 2. 结果为两列间隔存在一宽度为3px的竖线黑色边框.</li>\n</ol>\n<h4 id=\"用户界面\"><a href=\"#用户界面\" class=\"headerlink\" title=\"用户界面\"></a>用户界面</h4><ol>\n<li>resize. ie不兼容, 低版本Firefox需要加-moz-. 指定的元素可以由用户调整宽高, 和textarea很相似. 默认为none. 可以设置为both, 用户即可调整宽高. horizont, 用户可调整物体宽度, vertical, 用户可调整高度.</li>\n<li>box-sizing. ie8+, 低版本chrome和Firefox需要加-webkit-, -moz-. 指定以某种方式定义某些元素, 以适应指定区域. 默认值为content-box. 效果为指定的样式宽高为多少, 内容区域(盒子模型里的content区)九尾多少, 即不包括padding. 可设置为border-box, 这样就包括padding.<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 总宽度为 140px 包含两边padding</span></span><br><span class=\"line\">.div1 &#123;</span><br><span class=\"line\">  width: <span class=\"number\">100</span>px;</span><br><span class=\"line\">  height: <span class=\"number\">100</span>px;</span><br><span class=\"line\">  padding: <span class=\"number\">20</span>px;</span><br><span class=\"line\">  box-sizing: content-box;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// 总宽度为 100px 内容区域为60px, width = content区 + padding</span></span><br><span class=\"line\">.div2 &#123;</span><br><span class=\"line\">  width: <span class=\"number\">100</span>px;</span><br><span class=\"line\">  height: <span class=\"number\">100</span>px;</span><br><span class=\"line\">  padding: <span class=\"number\">20</span>px;</span><br><span class=\"line\">  box-sizing: border-box;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n</ol>\n<ul>\n<li>outline-offset. 只有ie不兼容. 设置border边缘外的偏移, 与outline共用. 可以理解为border外面又有一个border.<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">div &#123;</span><br><span class=\"line\">  ...</span><br><span class=\"line\">  border: 2px solid #000;</span><br><span class=\"line\">  outline: 2px solid #F00;</span><br><span class=\"line\">  outline-offset: <span class=\"number\">15</span>px;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n</li>\n</ul>\n<p>在border外距离15px处存在一个红色的2px边框. outline不会影响布局空间, 因此不会影响元素的尺寸.</p>\n<h4 id=\"写在最后\"><a href=\"#写在最后\" class=\"headerlink\" title=\"写在最后\"></a>写在最后</h4><p>简述css3系列应该算是完结了, 实不相瞒, 当初是想了解box-sizing才看的css3, 结果发现了更多没有注意到的或者是根本没见过的属性, 让我受益良多.<br>更多css3属性可以点击<a href=\"http://www.css88.com/book/css/css3-quicksearch.htm\" target=\"_blank\" rel=\"noopener\">css3汇总</a><br>希望我能保持热情. 还是那句话, 喜欢的话就坚持吧.</p>"},{"title":"算法核心框架整理(2)","date":"2022-06-01T02:17:07.000Z","_content":"\n##### 写在前面\n\n[前文](/2022/03/16/算法核心框架整理-1/)对十大算法做了简单概述，本文将继续讨论算法，但是会把重心转移到 leetcode 常见算法上\n\n主要有：\n\n- 动态规划\n- 深度优先搜索 dfs\n- 回溯\n- 广度优先搜索 bfs\n- 二分查找\n\n<!-- more -->","source":"_posts/算法核心框架整理-2.md","raw":"---\ntitle: 算法核心框架整理(2)\ndate: 2022-06-01 10:17:07\ntags: 算法\n---\n\n##### 写在前面\n\n[前文](/2022/03/16/算法核心框架整理-1/)对十大算法做了简单概述，本文将继续讨论算法，但是会把重心转移到 leetcode 常见算法上\n\n主要有：\n\n- 动态规划\n- 深度优先搜索 dfs\n- 回溯\n- 广度优先搜索 bfs\n- 二分查找\n\n<!-- more -->","slug":"算法核心框架整理-2","published":1,"updated":"2022-06-01T08:30:35.211Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl5sb8gg1002sxq0raqlax616","content":"<h5 id=\"写在前面\"><a href=\"#写在前面\" class=\"headerlink\" title=\"写在前面\"></a>写在前面</h5><p><a href=\"/2022/03/16/算法核心框架整理-1/\">前文</a>对十大算法做了简单概述，本文将继续讨论算法，但是会把重心转移到 leetcode 常见算法上</p>\n<p>主要有：</p>\n<ul>\n<li>动态规划</li>\n<li>深度优先搜索 dfs</li>\n<li>回溯</li>\n<li>广度优先搜索 bfs</li>\n<li>二分查找</li>\n</ul>\n<a id=\"more\"></a>","site":{"data":{}},"excerpt":"<h5 id=\"写在前面\"><a href=\"#写在前面\" class=\"headerlink\" title=\"写在前面\"></a>写在前面</h5><p><a href=\"/2022/03/16/算法核心框架整理-1/\">前文</a>对十大算法做了简单概述，本文将继续讨论算法，但是会把重心转移到 leetcode 常见算法上</p>\n<p>主要有：</p>\n<ul>\n<li>动态规划</li>\n<li>深度优先搜索 dfs</li>\n<li>回溯</li>\n<li>广度优先搜索 bfs</li>\n<li>二分查找</li>\n</ul>","more":""},{"title":"2019年面试总结","date":"2019-08-27T01:59:09.000Z","_content":"##### 写在前面\n绝不推荐脱产寻找工作机会, 特别是非一线城市(具有时效性). 笔者始终觉得, 面试是快速提升个人实力的有效方式, 但是面试的状态真的是又累又焦虑, 也是笔者第一次经历社招, 深深觉得社招对工作年限的严格性, 有个工作3年的同事也在找工作(笔者工作1年), 但是他的面试机会比我多一倍不止, 能力虽有差距, 但是他分享的面经发现笔者能答上大部分, 着实难受. 本文记下近期面试的印象深刻的题\n\n#### JavaScript基础\n##### 设计模式: 了解单例和工厂吗 应用场景是什么\n1. 单例模式(Singleton)的特点是只有一个实例对象, 且该类能自行创建这个实例的一种模式, 单例类对外提供一个访问该单例的全局访问点\n```JavaScript\nvar createWindow = function() {\n    var div;\n    return function () {\n        if (!div) {\n            div = document.createElement('div');\n            div.innerHTML = 'a toast';\n            div.style.display = 'none';\n            // ...\n            document.body.appendChild(div);\n        }\n        return div;\n    }\n}\ndocument.getElementById('id').onclick = function () {\n    var win = createWindow();\n    win.style.display = 'block';\n}\n// 点击创建并展示弹窗, 关闭时移除弹窗dom, 频繁dom操作影响性能, 单例只实例化一次\n```\n应用场景: 某类只要求生成一个对象的时候; 对象需要被共享的时候; 某类频繁实例化和频繁被销毁的时候;\n<!-- more -->\n2. 工厂方法模式是一类产品的生产模式, 我们把被创建的对象称为\"产品\", 把创建产品的对象成为\"工厂\", 特点是用户只需要知道具体工厂的名称就可以得到所要的产品, 无需知道产品的具体创建过程;\n工厂方法模式由抽象工厂、具体工厂、抽象产品和具体产品等4个要素构成\n```html\n抽象工厂（Abstract Factory）：提供了创建产品的接口，它包含多个创建产品的方法 newProduct()，可以创建多个不同等级的产品。\n具体工厂（Concrete Factory）：主要是实现抽象工厂中的多个抽象方法，完成具体产品的创建。\n抽象产品（Product）：定义了产品的规范，描述了产品的主要特性和功能，抽象工厂模式有多个抽象产品。\n具体产品（Concrete Product）：实现了抽象产品角色所定义的接口，由具体工厂来创建，它同具体工厂之间是多对一的关系。\n```\n应用场景: 只知道创建产品的工厂名, 不知道具体的产品名; 创建对象的任务由多个子工厂的某一个完成, 而抽象工厂只提供创建产品的接口; 客户不关心创建产品的细节, 只关心产品的品牌;\n\n3. 抽象工厂模式可生产多维度的产品, 特点除了工厂方法模式的特点还有当增加一个新的产品族时不需要修改原代码, 满足开闭原则\n在工厂方法模式的具体工厂实现多个产品的生成方法\n应用场景: 需要创建的对象是一系列相关联或相依赖的产品族时, 如电器工厂的电视机洗衣机; 系统提供产品的类库, 且所有产品的接口相同, 客户端不依赖产品实例的创建细节和内部结构\n\n##### es5和es6是如何继承的\n```JavaScript\n// es5\n// 原型链实现继承: 利用原型让一个引用类型继承另一个引用类型的属性和方法\n// 缺点是引用类型的值会被所以实例共享; 创造子类的实例不能向超类构造函数中传递参数\nfunction Super() {\n    this.property = true;\n}\nSuper.prototype.getSuperValue = function () {\n    return this.property;\n}\nfunction Sub() {\n    this.subproperty = false;\n}\nSub.prototype = new Super();\nSub.prototype.getSubValue = function () {\n    return this.subproperty;\n}\nvar sub = new Sub();\nsub.getSuperValue; // true\n// 借用构造函数: 在子类构造函数的内部调用超类的构造函数, 通过apply或call来修改作用域, 能够传递参数\n// 缺点是方法都在构造函数中定义, 函数无法复用; 在超类定义的方法, 子类不可见\nfunction Super () {\n    this.property = true;\n}\nfunction Sub() {\n    Super.call(this)\n}\nvar sub1 = new Sub();\nvar sub2 = new Sub();\nsub1.property = false;\nsub1.property; // false\nsub2.property; // true\n// 组合继承: 讲原型链和借用构造函数组合, 原型链实现了原型属性和方法的继承, 借用构造函数实现了实例属性的继承, 函数复用, 又保证属性不会被实例共享\n// 缺点是调用两次超类构造函数, 一次在创建子类原型的时候, 一次是子类构造函数的内部\nfunction Super (name) {\n    this.property = true;\n    this.name = name;\n}\nSuper.prototype.sayName = function () {\n    console.log('name: ', this.name);\n}\nfunction Sub (name, age) {\n    Super.call(this, name); // 参数不固定可以用apply\n    this.age = age;\n}\n\nSub.prototype = new Super();\nSub.prototype.constructor = Sub;\nSub.prototype.sayAge = function () {\n    console.log('age: ', this.age);\n}\n\nvar sub = new Sub('PsiloLau', 18);\nsub.sayName(); // name: PsiloLau\nsub.sayAge(); // age: 18\n// 寄生组合式继承: 通过借用构造函数来继承属性, 是最理想的继承方式\nfunction object(o) {\n    function F() {}\n    F.prototype = o;\n    return new F();\n}\nfunction inheritPrototype(Sub, Super) {\n    var prototype = object(Super.prototype);\n    prototype.constructor = Sub;\n    Sub.prototype = prototype\n}\nfunction Super (name) {\n    this.name = name;\n    this.colors = ['red', 'green'];\n}\nSuper.prototype.sayName = function () {\n    console.log(this.name);\n}\nfunction Sub (name, age) {\n    Super.call(this, name);\n    this.age = age;\n}\ninheritPrototype(Sub, Super);\n\nSub.prototype.sayAge = function () {\n    console.log(this.age);\n}\n// es6 class与extends实现继承, 本质是es5修改原型链实现继承的语法糖\nclass Animal {\n    constructor (props) {\n        this.name = props.name || 'Animal'\n    }\n    eat () {\n        console.log(this.name + ' can eat');\n    }\n    sleep () {\n        console.log(this.name + ' can sleep');\n    }\n}\n\nclass Bird extends Animal {\n    constructor (props, ownClass) {\n        super(props); // 相对于获得父类的this指向\n        this.type = props.type || 'Egg animal';\n        this.class = ownClass\n    }\n    fly () {\n        console.log(this.name + ' can fly');\n    }\n    eat () {\n        console.log(this.name + ' can eat worms') // 父类方法重写\n    }\n}\n\nvar swollow = new Bird({\n    name: '小燕子',\n    type: 'Egg animal'\n}, 'Bird class')\nswollow.fly(); // 小燕子 can fly\nswollow.sleep(); // 小燕子 can sleep\nswollow.eat(); // 小燕子 can eat worms\n```\n\n##### 原生JavaScript设计组件\ntodo\n\n##### jsonp工作原理, 为什么不是真正的ajax\n原理: 利用script标签没有跨域限制的特性来达到与第三方通讯的目的, 需要通讯时创建script标签指向第三方api地址, 并提供一个回调函数来接受数据(函数名可约定, 也可通过参数传递), 客户端通过调用回调函数来进行交互.\n为什么不是真正的ajax: ajax的核心的通过xmlHttpRequest获取内容, jsonp的核心是动态添加; jsonp只支持get请求; ajax不一定要用json格式来传递数据\n\n##### requestAnimationFrame原理\n正常显示器刷新频率是60Hz, 即我们看到的显示图像每秒60次的频率刷新. setTimeout通过设置一个间隔时间来不断改变图像位置从而达到动画效果, 但是setTimeout的执行步调和屏幕的刷新步调不一致会导致丢帧现象, requestAnimationFrame的优势就是由系统来决定回调函数的执行步调, 60Hz的显示器就是1000 / 60 = 16.7ms被执行一次, 75Hz的显示器就是13.3ms\n```JavaScript\nvar progress = 0;\n\nfunction render () {\n    progress += 1;\n\n    if (progress < 100) {\n        // 条件递归渲染\n        window.requestAnimationFrame(render);\n    }\n}\n\nwindow.requestAnimationFrame(render);\n// cpu节能: setTimeout实现的动画即使页面被最小化或者切换其他标签的时候, 当前页面仍会执行动画任务, requestAnimationFrame只有在激活状态才会执行\n// 函数节流: 一个刷新间隔内执行多次函数没有意义\n// 缺点: 在低版本安卓下并不友好, github有提供的polyfill, 优先使用高级特效requestAnimationFrame, 后优雅降级\n```\n\n##### ['1','2','3'].map(parseInt)的输出, 为什么\n```html\n输出: [1, NaN, NaN]\n原因: parseInt()函数可传两个参数, parseInt(string, radix)\nstring: 必需, 要解析的字符串.\nradix: 可选, 表示要解析的数字的基数, 基于2~36之间, 不填默认为10进制, 小于2或大于36都会返回NaN. \nmap()可传三个参数, map(item, index, arr)\nitem: 必需, 当前元素的值\nindex: 可选, 当前元素的索引值\narr: 可选, 当前元素属于的数组对象\n['1', '2', '3'].map(parseInt) => parseInt('1', 0) (arr是第三个参数, 但是parseInt只接收两个, 所以无效) parseInt('2', 1) parseInt('3', 2) 所以是1, NaN, NaN\n```\n\n#### 浏览器\n##### 预检请求options作用\n在CORS中, 可以使用options方法发起一个预检请求, 以检测实际请求是否可以被服务器所接受. 在某些情况下会发起一次options请求, 当options请求成功返回后, 真正的ajax请求才会发起\n```html\n某些情况:\n1. 跨域请求\n2. 自定义请求头\n3. 请求头中的content-type是application/x-www-form-urlencoded、multipart/form-data、text/plain以外的格式(默认情况下axios会将JavaScript对象序列化为JSON来发送, 即content-type赋值成application/json)\n满足 12 或 13 就会发送options请求\n```\n\n##### 对缓存的理解\n浏览器每次发起请求, 都会先在浏览器缓存中查找该请求的结果以及缓存标识, 每次拿到返回的请求结果都会将该结果和缓存标识(Last-Modified Etag)存入浏览器缓存中\n1. 浏览器没有缓存, 向服务器发起请求, 会在请求头上加上Expires和Cache-Control, 返回200ok和响应结果以及缓存标识, 存入缓存\nExpires是http/1的产物, 受限于本地时间, 如果修改了本地时间, 可能会造成缓存失效; Cache-Control是http/1.1的规则, 设置max-age=300时代表这个请求正确返回时间的5分钟内再次加载资源会命中缓存. Cache-Control优先级高于Expires\n2. 浏览器在缓存中查找, Cache-Control没有过期, 直接从disk或memory读取资源, 即强缓存\n3. 浏览器在缓存中查找, 如果过期了, 向服务器发起请求, 携带标识If-Modified-Since和If-None-Match, 其中之一没有命中意味着资源有更新, 协商缓存失败, 返回200 重新返回资源和缓存标识, 存入浏览器缓存中; 都命中意味资源无更新, 协商缓存成功返回304, 继续使用缓存.\n服务器校验优先考虑Etag, 精度上Etag优于Last-Modified, 性能上Etag要差于后者\n\n#### Vue\n##### Vue原理详细阐述\n主要有Observer、Watcher、Compile、Dep等模块, Vue初始化时调用reactive, 就是Observer用Object.defineProperty重写getter setter来监听属性变化, 在getter里添加订阅者(订阅器Dep里的dep数组, 当dep.target存在时, 如果id不重复就往订阅器添加订阅者, dep.target赋值会在Watcher里做, 赋值后再调用一次属性触发getter, 然后把dep.target置null), 在setter里notify所有的dep, notify会调用所有的dep的update方法, 并触发Compile的回调, 更新视图.\n\n##### mpVue原理详细阐述\n典型的逻辑视图层框架, 逻辑层和视图层之间的工作方式是: 数据变更驱动视图更新, 视图交互触发事件, 事件响应函数修改数据再次触发视图更新\n在mpVue中, 小程序负责视图层, 所有业务逻辑在vue.js中, vue数据变更后同步到小程序:\n1. Vue实例与小程序page实例建立关联\n2. mnp与Vue生命周期建立映射关系, 能在mnp生命周期中触发Vue的生命周期\n3. mnp事件建立代理机制, 在事件代理函数中触发与之对应的Vue事件响应\n\n#### 前端\n##### 前端组件化 模块化 工程化的理解\n组件化和模块化可以放在一起讲, 首先是颗粒度不同, 拿vue来讲, 组件化应该是包含(template+script+style)的功能完备单元. 模块化更像是js模块, 如Observer、watcher.\n其次用测试的角度来看, 组件化像黑盒, 不需要知道内部逻辑, 关注io和功能性; 模块化更像白盒, 内容可见, 注重设计.\n工程化可以按以下点来讲:\n1 代码规范: 保证团队有统一的代码风格, 如eslint\n2 分支管理: 每个迭代的分支命名或开发的模块分支命名\n3 模块管理: 模块/组件命名规范 路径规范\n4 自动化测试: 单元测试 集成测试 端到端测试\n5 commit规范: husky校验, 包括push\n6 构建: 多种构建方式, 本地构建, jenkins构建\n7 部署: 多种部署方式, 本地部署, jenkins部署","source":"_posts/2019年面试总结.md","raw":"---\ntitle: 2019年面试总结\ndate: 2019-08-27 09:59:09\ntags: [前端, 随笔, 面试]\n---\n##### 写在前面\n绝不推荐脱产寻找工作机会, 特别是非一线城市(具有时效性). 笔者始终觉得, 面试是快速提升个人实力的有效方式, 但是面试的状态真的是又累又焦虑, 也是笔者第一次经历社招, 深深觉得社招对工作年限的严格性, 有个工作3年的同事也在找工作(笔者工作1年), 但是他的面试机会比我多一倍不止, 能力虽有差距, 但是他分享的面经发现笔者能答上大部分, 着实难受. 本文记下近期面试的印象深刻的题\n\n#### JavaScript基础\n##### 设计模式: 了解单例和工厂吗 应用场景是什么\n1. 单例模式(Singleton)的特点是只有一个实例对象, 且该类能自行创建这个实例的一种模式, 单例类对外提供一个访问该单例的全局访问点\n```JavaScript\nvar createWindow = function() {\n    var div;\n    return function () {\n        if (!div) {\n            div = document.createElement('div');\n            div.innerHTML = 'a toast';\n            div.style.display = 'none';\n            // ...\n            document.body.appendChild(div);\n        }\n        return div;\n    }\n}\ndocument.getElementById('id').onclick = function () {\n    var win = createWindow();\n    win.style.display = 'block';\n}\n// 点击创建并展示弹窗, 关闭时移除弹窗dom, 频繁dom操作影响性能, 单例只实例化一次\n```\n应用场景: 某类只要求生成一个对象的时候; 对象需要被共享的时候; 某类频繁实例化和频繁被销毁的时候;\n<!-- more -->\n2. 工厂方法模式是一类产品的生产模式, 我们把被创建的对象称为\"产品\", 把创建产品的对象成为\"工厂\", 特点是用户只需要知道具体工厂的名称就可以得到所要的产品, 无需知道产品的具体创建过程;\n工厂方法模式由抽象工厂、具体工厂、抽象产品和具体产品等4个要素构成\n```html\n抽象工厂（Abstract Factory）：提供了创建产品的接口，它包含多个创建产品的方法 newProduct()，可以创建多个不同等级的产品。\n具体工厂（Concrete Factory）：主要是实现抽象工厂中的多个抽象方法，完成具体产品的创建。\n抽象产品（Product）：定义了产品的规范，描述了产品的主要特性和功能，抽象工厂模式有多个抽象产品。\n具体产品（Concrete Product）：实现了抽象产品角色所定义的接口，由具体工厂来创建，它同具体工厂之间是多对一的关系。\n```\n应用场景: 只知道创建产品的工厂名, 不知道具体的产品名; 创建对象的任务由多个子工厂的某一个完成, 而抽象工厂只提供创建产品的接口; 客户不关心创建产品的细节, 只关心产品的品牌;\n\n3. 抽象工厂模式可生产多维度的产品, 特点除了工厂方法模式的特点还有当增加一个新的产品族时不需要修改原代码, 满足开闭原则\n在工厂方法模式的具体工厂实现多个产品的生成方法\n应用场景: 需要创建的对象是一系列相关联或相依赖的产品族时, 如电器工厂的电视机洗衣机; 系统提供产品的类库, 且所有产品的接口相同, 客户端不依赖产品实例的创建细节和内部结构\n\n##### es5和es6是如何继承的\n```JavaScript\n// es5\n// 原型链实现继承: 利用原型让一个引用类型继承另一个引用类型的属性和方法\n// 缺点是引用类型的值会被所以实例共享; 创造子类的实例不能向超类构造函数中传递参数\nfunction Super() {\n    this.property = true;\n}\nSuper.prototype.getSuperValue = function () {\n    return this.property;\n}\nfunction Sub() {\n    this.subproperty = false;\n}\nSub.prototype = new Super();\nSub.prototype.getSubValue = function () {\n    return this.subproperty;\n}\nvar sub = new Sub();\nsub.getSuperValue; // true\n// 借用构造函数: 在子类构造函数的内部调用超类的构造函数, 通过apply或call来修改作用域, 能够传递参数\n// 缺点是方法都在构造函数中定义, 函数无法复用; 在超类定义的方法, 子类不可见\nfunction Super () {\n    this.property = true;\n}\nfunction Sub() {\n    Super.call(this)\n}\nvar sub1 = new Sub();\nvar sub2 = new Sub();\nsub1.property = false;\nsub1.property; // false\nsub2.property; // true\n// 组合继承: 讲原型链和借用构造函数组合, 原型链实现了原型属性和方法的继承, 借用构造函数实现了实例属性的继承, 函数复用, 又保证属性不会被实例共享\n// 缺点是调用两次超类构造函数, 一次在创建子类原型的时候, 一次是子类构造函数的内部\nfunction Super (name) {\n    this.property = true;\n    this.name = name;\n}\nSuper.prototype.sayName = function () {\n    console.log('name: ', this.name);\n}\nfunction Sub (name, age) {\n    Super.call(this, name); // 参数不固定可以用apply\n    this.age = age;\n}\n\nSub.prototype = new Super();\nSub.prototype.constructor = Sub;\nSub.prototype.sayAge = function () {\n    console.log('age: ', this.age);\n}\n\nvar sub = new Sub('PsiloLau', 18);\nsub.sayName(); // name: PsiloLau\nsub.sayAge(); // age: 18\n// 寄生组合式继承: 通过借用构造函数来继承属性, 是最理想的继承方式\nfunction object(o) {\n    function F() {}\n    F.prototype = o;\n    return new F();\n}\nfunction inheritPrototype(Sub, Super) {\n    var prototype = object(Super.prototype);\n    prototype.constructor = Sub;\n    Sub.prototype = prototype\n}\nfunction Super (name) {\n    this.name = name;\n    this.colors = ['red', 'green'];\n}\nSuper.prototype.sayName = function () {\n    console.log(this.name);\n}\nfunction Sub (name, age) {\n    Super.call(this, name);\n    this.age = age;\n}\ninheritPrototype(Sub, Super);\n\nSub.prototype.sayAge = function () {\n    console.log(this.age);\n}\n// es6 class与extends实现继承, 本质是es5修改原型链实现继承的语法糖\nclass Animal {\n    constructor (props) {\n        this.name = props.name || 'Animal'\n    }\n    eat () {\n        console.log(this.name + ' can eat');\n    }\n    sleep () {\n        console.log(this.name + ' can sleep');\n    }\n}\n\nclass Bird extends Animal {\n    constructor (props, ownClass) {\n        super(props); // 相对于获得父类的this指向\n        this.type = props.type || 'Egg animal';\n        this.class = ownClass\n    }\n    fly () {\n        console.log(this.name + ' can fly');\n    }\n    eat () {\n        console.log(this.name + ' can eat worms') // 父类方法重写\n    }\n}\n\nvar swollow = new Bird({\n    name: '小燕子',\n    type: 'Egg animal'\n}, 'Bird class')\nswollow.fly(); // 小燕子 can fly\nswollow.sleep(); // 小燕子 can sleep\nswollow.eat(); // 小燕子 can eat worms\n```\n\n##### 原生JavaScript设计组件\ntodo\n\n##### jsonp工作原理, 为什么不是真正的ajax\n原理: 利用script标签没有跨域限制的特性来达到与第三方通讯的目的, 需要通讯时创建script标签指向第三方api地址, 并提供一个回调函数来接受数据(函数名可约定, 也可通过参数传递), 客户端通过调用回调函数来进行交互.\n为什么不是真正的ajax: ajax的核心的通过xmlHttpRequest获取内容, jsonp的核心是动态添加; jsonp只支持get请求; ajax不一定要用json格式来传递数据\n\n##### requestAnimationFrame原理\n正常显示器刷新频率是60Hz, 即我们看到的显示图像每秒60次的频率刷新. setTimeout通过设置一个间隔时间来不断改变图像位置从而达到动画效果, 但是setTimeout的执行步调和屏幕的刷新步调不一致会导致丢帧现象, requestAnimationFrame的优势就是由系统来决定回调函数的执行步调, 60Hz的显示器就是1000 / 60 = 16.7ms被执行一次, 75Hz的显示器就是13.3ms\n```JavaScript\nvar progress = 0;\n\nfunction render () {\n    progress += 1;\n\n    if (progress < 100) {\n        // 条件递归渲染\n        window.requestAnimationFrame(render);\n    }\n}\n\nwindow.requestAnimationFrame(render);\n// cpu节能: setTimeout实现的动画即使页面被最小化或者切换其他标签的时候, 当前页面仍会执行动画任务, requestAnimationFrame只有在激活状态才会执行\n// 函数节流: 一个刷新间隔内执行多次函数没有意义\n// 缺点: 在低版本安卓下并不友好, github有提供的polyfill, 优先使用高级特效requestAnimationFrame, 后优雅降级\n```\n\n##### ['1','2','3'].map(parseInt)的输出, 为什么\n```html\n输出: [1, NaN, NaN]\n原因: parseInt()函数可传两个参数, parseInt(string, radix)\nstring: 必需, 要解析的字符串.\nradix: 可选, 表示要解析的数字的基数, 基于2~36之间, 不填默认为10进制, 小于2或大于36都会返回NaN. \nmap()可传三个参数, map(item, index, arr)\nitem: 必需, 当前元素的值\nindex: 可选, 当前元素的索引值\narr: 可选, 当前元素属于的数组对象\n['1', '2', '3'].map(parseInt) => parseInt('1', 0) (arr是第三个参数, 但是parseInt只接收两个, 所以无效) parseInt('2', 1) parseInt('3', 2) 所以是1, NaN, NaN\n```\n\n#### 浏览器\n##### 预检请求options作用\n在CORS中, 可以使用options方法发起一个预检请求, 以检测实际请求是否可以被服务器所接受. 在某些情况下会发起一次options请求, 当options请求成功返回后, 真正的ajax请求才会发起\n```html\n某些情况:\n1. 跨域请求\n2. 自定义请求头\n3. 请求头中的content-type是application/x-www-form-urlencoded、multipart/form-data、text/plain以外的格式(默认情况下axios会将JavaScript对象序列化为JSON来发送, 即content-type赋值成application/json)\n满足 12 或 13 就会发送options请求\n```\n\n##### 对缓存的理解\n浏览器每次发起请求, 都会先在浏览器缓存中查找该请求的结果以及缓存标识, 每次拿到返回的请求结果都会将该结果和缓存标识(Last-Modified Etag)存入浏览器缓存中\n1. 浏览器没有缓存, 向服务器发起请求, 会在请求头上加上Expires和Cache-Control, 返回200ok和响应结果以及缓存标识, 存入缓存\nExpires是http/1的产物, 受限于本地时间, 如果修改了本地时间, 可能会造成缓存失效; Cache-Control是http/1.1的规则, 设置max-age=300时代表这个请求正确返回时间的5分钟内再次加载资源会命中缓存. Cache-Control优先级高于Expires\n2. 浏览器在缓存中查找, Cache-Control没有过期, 直接从disk或memory读取资源, 即强缓存\n3. 浏览器在缓存中查找, 如果过期了, 向服务器发起请求, 携带标识If-Modified-Since和If-None-Match, 其中之一没有命中意味着资源有更新, 协商缓存失败, 返回200 重新返回资源和缓存标识, 存入浏览器缓存中; 都命中意味资源无更新, 协商缓存成功返回304, 继续使用缓存.\n服务器校验优先考虑Etag, 精度上Etag优于Last-Modified, 性能上Etag要差于后者\n\n#### Vue\n##### Vue原理详细阐述\n主要有Observer、Watcher、Compile、Dep等模块, Vue初始化时调用reactive, 就是Observer用Object.defineProperty重写getter setter来监听属性变化, 在getter里添加订阅者(订阅器Dep里的dep数组, 当dep.target存在时, 如果id不重复就往订阅器添加订阅者, dep.target赋值会在Watcher里做, 赋值后再调用一次属性触发getter, 然后把dep.target置null), 在setter里notify所有的dep, notify会调用所有的dep的update方法, 并触发Compile的回调, 更新视图.\n\n##### mpVue原理详细阐述\n典型的逻辑视图层框架, 逻辑层和视图层之间的工作方式是: 数据变更驱动视图更新, 视图交互触发事件, 事件响应函数修改数据再次触发视图更新\n在mpVue中, 小程序负责视图层, 所有业务逻辑在vue.js中, vue数据变更后同步到小程序:\n1. Vue实例与小程序page实例建立关联\n2. mnp与Vue生命周期建立映射关系, 能在mnp生命周期中触发Vue的生命周期\n3. mnp事件建立代理机制, 在事件代理函数中触发与之对应的Vue事件响应\n\n#### 前端\n##### 前端组件化 模块化 工程化的理解\n组件化和模块化可以放在一起讲, 首先是颗粒度不同, 拿vue来讲, 组件化应该是包含(template+script+style)的功能完备单元. 模块化更像是js模块, 如Observer、watcher.\n其次用测试的角度来看, 组件化像黑盒, 不需要知道内部逻辑, 关注io和功能性; 模块化更像白盒, 内容可见, 注重设计.\n工程化可以按以下点来讲:\n1 代码规范: 保证团队有统一的代码风格, 如eslint\n2 分支管理: 每个迭代的分支命名或开发的模块分支命名\n3 模块管理: 模块/组件命名规范 路径规范\n4 自动化测试: 单元测试 集成测试 端到端测试\n5 commit规范: husky校验, 包括push\n6 构建: 多种构建方式, 本地构建, jenkins构建\n7 部署: 多种部署方式, 本地部署, jenkins部署","slug":"2019年面试总结","published":1,"updated":"2021-07-02T03:20:30.649Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl5sb8gg3002txq0rdy25p1y3","content":"<h5 id=\"写在前面\"><a href=\"#写在前面\" class=\"headerlink\" title=\"写在前面\"></a>写在前面</h5><p>绝不推荐脱产寻找工作机会, 特别是非一线城市(具有时效性). 笔者始终觉得, 面试是快速提升个人实力的有效方式, 但是面试的状态真的是又累又焦虑, 也是笔者第一次经历社招, 深深觉得社招对工作年限的严格性, 有个工作3年的同事也在找工作(笔者工作1年), 但是他的面试机会比我多一倍不止, 能力虽有差距, 但是他分享的面经发现笔者能答上大部分, 着实难受. 本文记下近期面试的印象深刻的题</p>\n<h4 id=\"JavaScript基础\"><a href=\"#JavaScript基础\" class=\"headerlink\" title=\"JavaScript基础\"></a>JavaScript基础</h4><h5 id=\"设计模式-了解单例和工厂吗-应用场景是什么\"><a href=\"#设计模式-了解单例和工厂吗-应用场景是什么\" class=\"headerlink\" title=\"设计模式: 了解单例和工厂吗 应用场景是什么\"></a>设计模式: 了解单例和工厂吗 应用场景是什么</h5><ol>\n<li>单例模式(Singleton)的特点是只有一个实例对象, 且该类能自行创建这个实例的一种模式, 单例类对外提供一个访问该单例的全局访问点<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> createWindow = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> div;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (!div) &#123;</span><br><span class=\"line\">            div = <span class=\"built_in\">document</span>.createElement(<span class=\"string\">'div'</span>);</span><br><span class=\"line\">            div.innerHTML = <span class=\"string\">'a toast'</span>;</span><br><span class=\"line\">            div.style.display = <span class=\"string\">'none'</span>;</span><br><span class=\"line\">            <span class=\"comment\">// ...</span></span><br><span class=\"line\">            <span class=\"built_in\">document</span>.body.appendChild(div);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> div;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"built_in\">document</span>.getElementById(<span class=\"string\">'id'</span>).onclick = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> win = createWindow();</span><br><span class=\"line\">    win.style.display = <span class=\"string\">'block'</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// 点击创建并展示弹窗, 关闭时移除弹窗dom, 频繁dom操作影响性能, 单例只实例化一次</span></span><br></pre></td></tr></table></figure>\n\n</li>\n</ol>\n<p>应用场景: 某类只要求生成一个对象的时候; 对象需要被共享的时候; 某类频繁实例化和频繁被销毁的时候;</p>\n<a id=\"more\"></a>\n<ol start=\"2\">\n<li>工厂方法模式是一类产品的生产模式, 我们把被创建的对象称为”产品”, 把创建产品的对象成为”工厂”, 特点是用户只需要知道具体工厂的名称就可以得到所要的产品, 无需知道产品的具体创建过程;<br>工厂方法模式由抽象工厂、具体工厂、抽象产品和具体产品等4个要素构成<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">抽象工厂（Abstract Factory）：提供了创建产品的接口，它包含多个创建产品的方法 newProduct()，可以创建多个不同等级的产品。</span><br><span class=\"line\">具体工厂（Concrete Factory）：主要是实现抽象工厂中的多个抽象方法，完成具体产品的创建。</span><br><span class=\"line\">抽象产品（Product）：定义了产品的规范，描述了产品的主要特性和功能，抽象工厂模式有多个抽象产品。</span><br><span class=\"line\">具体产品（Concrete Product）：实现了抽象产品角色所定义的接口，由具体工厂来创建，它同具体工厂之间是多对一的关系。</span><br></pre></td></tr></table></figure>\n\n</li>\n</ol>\n<p>应用场景: 只知道创建产品的工厂名, 不知道具体的产品名; 创建对象的任务由多个子工厂的某一个完成, 而抽象工厂只提供创建产品的接口; 客户不关心创建产品的细节, 只关心产品的品牌;</p>\n<ol start=\"3\">\n<li>抽象工厂模式可生产多维度的产品, 特点除了工厂方法模式的特点还有当增加一个新的产品族时不需要修改原代码, 满足开闭原则<br>在工厂方法模式的具体工厂实现多个产品的生成方法<br>应用场景: 需要创建的对象是一系列相关联或相依赖的产品族时, 如电器工厂的电视机洗衣机; 系统提供产品的类库, 且所有产品的接口相同, 客户端不依赖产品实例的创建细节和内部结构</li>\n</ol>\n<h5 id=\"es5和es6是如何继承的\"><a href=\"#es5和es6是如何继承的\" class=\"headerlink\" title=\"es5和es6是如何继承的\"></a>es5和es6是如何继承的</h5><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br><span class=\"line\">104</span><br><span class=\"line\">105</span><br><span class=\"line\">106</span><br><span class=\"line\">107</span><br><span class=\"line\">108</span><br><span class=\"line\">109</span><br><span class=\"line\">110</span><br><span class=\"line\">111</span><br><span class=\"line\">112</span><br><span class=\"line\">113</span><br><span class=\"line\">114</span><br><span class=\"line\">115</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// es5</span></span><br><span class=\"line\"><span class=\"comment\">// 原型链实现继承: 利用原型让一个引用类型继承另一个引用类型的属性和方法</span></span><br><span class=\"line\"><span class=\"comment\">// 缺点是引用类型的值会被所以实例共享; 创造子类的实例不能向超类构造函数中传递参数</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">Super</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.property = <span class=\"literal\">true</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">Super.prototype.getSuperValue = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>.property;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">Sub</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.subproperty = <span class=\"literal\">false</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">Sub.prototype = <span class=\"keyword\">new</span> Super();</span><br><span class=\"line\">Sub.prototype.getSubValue = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>.subproperty;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">var</span> sub = <span class=\"keyword\">new</span> Sub();</span><br><span class=\"line\">sub.getSuperValue; <span class=\"comment\">// true</span></span><br><span class=\"line\"><span class=\"comment\">// 借用构造函数: 在子类构造函数的内部调用超类的构造函数, 通过apply或call来修改作用域, 能够传递参数</span></span><br><span class=\"line\"><span class=\"comment\">// 缺点是方法都在构造函数中定义, 函数无法复用; 在超类定义的方法, 子类不可见</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">Super</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.property = <span class=\"literal\">true</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">Sub</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    Super.call(<span class=\"keyword\">this</span>)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">var</span> sub1 = <span class=\"keyword\">new</span> Sub();</span><br><span class=\"line\"><span class=\"keyword\">var</span> sub2 = <span class=\"keyword\">new</span> Sub();</span><br><span class=\"line\">sub1.property = <span class=\"literal\">false</span>;</span><br><span class=\"line\">sub1.property; <span class=\"comment\">// false</span></span><br><span class=\"line\">sub2.property; <span class=\"comment\">// true</span></span><br><span class=\"line\"><span class=\"comment\">// 组合继承: 讲原型链和借用构造函数组合, 原型链实现了原型属性和方法的继承, 借用构造函数实现了实例属性的继承, 函数复用, 又保证属性不会被实例共享</span></span><br><span class=\"line\"><span class=\"comment\">// 缺点是调用两次超类构造函数, 一次在创建子类原型的时候, 一次是子类构造函数的内部</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">Super</span> (<span class=\"params\">name</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.property = <span class=\"literal\">true</span>;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.name = name;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">Super.prototype.sayName = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">'name: '</span>, <span class=\"keyword\">this</span>.name);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">Sub</span> (<span class=\"params\">name, age</span>) </span>&#123;</span><br><span class=\"line\">    Super.call(<span class=\"keyword\">this</span>, name); <span class=\"comment\">// 参数不固定可以用apply</span></span><br><span class=\"line\">    <span class=\"keyword\">this</span>.age = age;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">Sub.prototype = <span class=\"keyword\">new</span> Super();</span><br><span class=\"line\">Sub.prototype.constructor = Sub;</span><br><span class=\"line\">Sub.prototype.sayAge = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">'age: '</span>, <span class=\"keyword\">this</span>.age);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> sub = <span class=\"keyword\">new</span> Sub(<span class=\"string\">'PsiloLau'</span>, <span class=\"number\">18</span>);</span><br><span class=\"line\">sub.sayName(); <span class=\"comment\">// name: PsiloLau</span></span><br><span class=\"line\">sub.sayAge(); <span class=\"comment\">// age: 18</span></span><br><span class=\"line\"><span class=\"comment\">// 寄生组合式继承: 通过借用构造函数来继承属性, 是最理想的继承方式</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">object</span>(<span class=\"params\">o</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">F</span>(<span class=\"params\"></span>) </span>&#123;&#125;</span><br><span class=\"line\">    F.prototype = o;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> F();</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">inheritPrototype</span>(<span class=\"params\">Sub, Super</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> prototype = object(Super.prototype);</span><br><span class=\"line\">    prototype.constructor = Sub;</span><br><span class=\"line\">    Sub.prototype = prototype</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">Super</span> (<span class=\"params\">name</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.name = name;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.colors = [<span class=\"string\">'red'</span>, <span class=\"string\">'green'</span>];</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">Super.prototype.sayName = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"keyword\">this</span>.name);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">Sub</span> (<span class=\"params\">name, age</span>) </span>&#123;</span><br><span class=\"line\">    Super.call(<span class=\"keyword\">this</span>, name);</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.age = age;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">inheritPrototype(Sub, Super);</span><br><span class=\"line\"></span><br><span class=\"line\">Sub.prototype.sayAge = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"keyword\">this</span>.age);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// es6 class与extends实现继承, 本质是es5修改原型链实现继承的语法糖</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Animal</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">constructor</span> (props) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.name = props.name || <span class=\"string\">'Animal'</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    eat () &#123;</span><br><span class=\"line\">        <span class=\"built_in\">console</span>.log(<span class=\"keyword\">this</span>.name + <span class=\"string\">' can eat'</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    sleep () &#123;</span><br><span class=\"line\">        <span class=\"built_in\">console</span>.log(<span class=\"keyword\">this</span>.name + <span class=\"string\">' can sleep'</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Bird</span> <span class=\"keyword\">extends</span> <span class=\"title\">Animal</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">constructor</span> (props, ownClass) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">super</span>(props); <span class=\"comment\">// 相对于获得父类的this指向</span></span><br><span class=\"line\">        <span class=\"keyword\">this</span>.type = props.type || <span class=\"string\">'Egg animal'</span>;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.class = ownClass</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    fly () &#123;</span><br><span class=\"line\">        <span class=\"built_in\">console</span>.log(<span class=\"keyword\">this</span>.name + <span class=\"string\">' can fly'</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    eat () &#123;</span><br><span class=\"line\">        <span class=\"built_in\">console</span>.log(<span class=\"keyword\">this</span>.name + <span class=\"string\">' can eat worms'</span>) <span class=\"comment\">// 父类方法重写</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> swollow = <span class=\"keyword\">new</span> Bird(&#123;</span><br><span class=\"line\">    name: <span class=\"string\">'小燕子'</span>,</span><br><span class=\"line\">    type: <span class=\"string\">'Egg animal'</span></span><br><span class=\"line\">&#125;, <span class=\"string\">'Bird class'</span>)</span><br><span class=\"line\">swollow.fly(); <span class=\"comment\">// 小燕子 can fly</span></span><br><span class=\"line\">swollow.sleep(); <span class=\"comment\">// 小燕子 can sleep</span></span><br><span class=\"line\">swollow.eat(); <span class=\"comment\">// 小燕子 can eat worms</span></span><br></pre></td></tr></table></figure>\n\n<h5 id=\"原生JavaScript设计组件\"><a href=\"#原生JavaScript设计组件\" class=\"headerlink\" title=\"原生JavaScript设计组件\"></a>原生JavaScript设计组件</h5><p>todo</p>\n<h5 id=\"jsonp工作原理-为什么不是真正的ajax\"><a href=\"#jsonp工作原理-为什么不是真正的ajax\" class=\"headerlink\" title=\"jsonp工作原理, 为什么不是真正的ajax\"></a>jsonp工作原理, 为什么不是真正的ajax</h5><p>原理: 利用script标签没有跨域限制的特性来达到与第三方通讯的目的, 需要通讯时创建script标签指向第三方api地址, 并提供一个回调函数来接受数据(函数名可约定, 也可通过参数传递), 客户端通过调用回调函数来进行交互.<br>为什么不是真正的ajax: ajax的核心的通过xmlHttpRequest获取内容, jsonp的核心是动态添加; jsonp只支持get请求; ajax不一定要用json格式来传递数据</p>\n<h5 id=\"requestAnimationFrame原理\"><a href=\"#requestAnimationFrame原理\" class=\"headerlink\" title=\"requestAnimationFrame原理\"></a>requestAnimationFrame原理</h5><p>正常显示器刷新频率是60Hz, 即我们看到的显示图像每秒60次的频率刷新. setTimeout通过设置一个间隔时间来不断改变图像位置从而达到动画效果, 但是setTimeout的执行步调和屏幕的刷新步调不一致会导致丢帧现象, requestAnimationFrame的优势就是由系统来决定回调函数的执行步调, 60Hz的显示器就是1000 / 60 = 16.7ms被执行一次, 75Hz的显示器就是13.3ms</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> progress = <span class=\"number\">0</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">render</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    progress += <span class=\"number\">1</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (progress &lt; <span class=\"number\">100</span>) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 条件递归渲染</span></span><br><span class=\"line\">        <span class=\"built_in\">window</span>.requestAnimationFrame(render);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">window</span>.requestAnimationFrame(render);</span><br><span class=\"line\"><span class=\"comment\">// cpu节能: setTimeout实现的动画即使页面被最小化或者切换其他标签的时候, 当前页面仍会执行动画任务, requestAnimationFrame只有在激活状态才会执行</span></span><br><span class=\"line\"><span class=\"comment\">// 函数节流: 一个刷新间隔内执行多次函数没有意义</span></span><br><span class=\"line\"><span class=\"comment\">// 缺点: 在低版本安卓下并不友好, github有提供的polyfill, 优先使用高级特效requestAnimationFrame, 后优雅降级</span></span><br></pre></td></tr></table></figure>\n\n<h5 id=\"‘1’-’2’-’3’-map-parseInt-的输出-为什么\"><a href=\"#‘1’-’2’-’3’-map-parseInt-的输出-为什么\" class=\"headerlink\" title=\"[‘1’,’2’,’3’].map(parseInt)的输出, 为什么\"></a>[‘1’,’2’,’3’].map(parseInt)的输出, 为什么</h5><figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">输出: [1, NaN, NaN]</span><br><span class=\"line\">原因: parseInt()函数可传两个参数, parseInt(string, radix)</span><br><span class=\"line\">string: 必需, 要解析的字符串.</span><br><span class=\"line\">radix: 可选, 表示要解析的数字的基数, 基于2~36之间, 不填默认为10进制, 小于2或大于36都会返回NaN. </span><br><span class=\"line\">map()可传三个参数, map(item, index, arr)</span><br><span class=\"line\">item: 必需, 当前元素的值</span><br><span class=\"line\">index: 可选, 当前元素的索引值</span><br><span class=\"line\">arr: 可选, 当前元素属于的数组对象</span><br><span class=\"line\">['1', '2', '3'].map(parseInt) =&gt; parseInt('1', 0) (arr是第三个参数, 但是parseInt只接收两个, 所以无效) parseInt('2', 1) parseInt('3', 2) 所以是1, NaN, NaN</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"浏览器\"><a href=\"#浏览器\" class=\"headerlink\" title=\"浏览器\"></a>浏览器</h4><h5 id=\"预检请求options作用\"><a href=\"#预检请求options作用\" class=\"headerlink\" title=\"预检请求options作用\"></a>预检请求options作用</h5><p>在CORS中, 可以使用options方法发起一个预检请求, 以检测实际请求是否可以被服务器所接受. 在某些情况下会发起一次options请求, 当options请求成功返回后, 真正的ajax请求才会发起</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">某些情况:</span><br><span class=\"line\">1. 跨域请求</span><br><span class=\"line\">2. 自定义请求头</span><br><span class=\"line\">3. 请求头中的content-type是application/x-www-form-urlencoded、multipart/form-data、text/plain以外的格式(默认情况下axios会将JavaScript对象序列化为JSON来发送, 即content-type赋值成application/json)</span><br><span class=\"line\">满足 12 或 13 就会发送options请求</span><br></pre></td></tr></table></figure>\n\n<h5 id=\"对缓存的理解\"><a href=\"#对缓存的理解\" class=\"headerlink\" title=\"对缓存的理解\"></a>对缓存的理解</h5><p>浏览器每次发起请求, 都会先在浏览器缓存中查找该请求的结果以及缓存标识, 每次拿到返回的请求结果都会将该结果和缓存标识(Last-Modified Etag)存入浏览器缓存中</p>\n<ol>\n<li>浏览器没有缓存, 向服务器发起请求, 会在请求头上加上Expires和Cache-Control, 返回200ok和响应结果以及缓存标识, 存入缓存<br>Expires是http/1的产物, 受限于本地时间, 如果修改了本地时间, 可能会造成缓存失效; Cache-Control是http/1.1的规则, 设置max-age=300时代表这个请求正确返回时间的5分钟内再次加载资源会命中缓存. Cache-Control优先级高于Expires</li>\n<li>浏览器在缓存中查找, Cache-Control没有过期, 直接从disk或memory读取资源, 即强缓存</li>\n<li>浏览器在缓存中查找, 如果过期了, 向服务器发起请求, 携带标识If-Modified-Since和If-None-Match, 其中之一没有命中意味着资源有更新, 协商缓存失败, 返回200 重新返回资源和缓存标识, 存入浏览器缓存中; 都命中意味资源无更新, 协商缓存成功返回304, 继续使用缓存.<br>服务器校验优先考虑Etag, 精度上Etag优于Last-Modified, 性能上Etag要差于后者</li>\n</ol>\n<h4 id=\"Vue\"><a href=\"#Vue\" class=\"headerlink\" title=\"Vue\"></a>Vue</h4><h5 id=\"Vue原理详细阐述\"><a href=\"#Vue原理详细阐述\" class=\"headerlink\" title=\"Vue原理详细阐述\"></a>Vue原理详细阐述</h5><p>主要有Observer、Watcher、Compile、Dep等模块, Vue初始化时调用reactive, 就是Observer用Object.defineProperty重写getter setter来监听属性变化, 在getter里添加订阅者(订阅器Dep里的dep数组, 当dep.target存在时, 如果id不重复就往订阅器添加订阅者, dep.target赋值会在Watcher里做, 赋值后再调用一次属性触发getter, 然后把dep.target置null), 在setter里notify所有的dep, notify会调用所有的dep的update方法, 并触发Compile的回调, 更新视图.</p>\n<h5 id=\"mpVue原理详细阐述\"><a href=\"#mpVue原理详细阐述\" class=\"headerlink\" title=\"mpVue原理详细阐述\"></a>mpVue原理详细阐述</h5><p>典型的逻辑视图层框架, 逻辑层和视图层之间的工作方式是: 数据变更驱动视图更新, 视图交互触发事件, 事件响应函数修改数据再次触发视图更新<br>在mpVue中, 小程序负责视图层, 所有业务逻辑在vue.js中, vue数据变更后同步到小程序:</p>\n<ol>\n<li>Vue实例与小程序page实例建立关联</li>\n<li>mnp与Vue生命周期建立映射关系, 能在mnp生命周期中触发Vue的生命周期</li>\n<li>mnp事件建立代理机制, 在事件代理函数中触发与之对应的Vue事件响应</li>\n</ol>\n<h4 id=\"前端\"><a href=\"#前端\" class=\"headerlink\" title=\"前端\"></a>前端</h4><h5 id=\"前端组件化-模块化-工程化的理解\"><a href=\"#前端组件化-模块化-工程化的理解\" class=\"headerlink\" title=\"前端组件化 模块化 工程化的理解\"></a>前端组件化 模块化 工程化的理解</h5><p>组件化和模块化可以放在一起讲, 首先是颗粒度不同, 拿vue来讲, 组件化应该是包含(template+script+style)的功能完备单元. 模块化更像是js模块, 如Observer、watcher.<br>其次用测试的角度来看, 组件化像黑盒, 不需要知道内部逻辑, 关注io和功能性; 模块化更像白盒, 内容可见, 注重设计.<br>工程化可以按以下点来讲:<br>1 代码规范: 保证团队有统一的代码风格, 如eslint<br>2 分支管理: 每个迭代的分支命名或开发的模块分支命名<br>3 模块管理: 模块/组件命名规范 路径规范<br>4 自动化测试: 单元测试 集成测试 端到端测试<br>5 commit规范: husky校验, 包括push<br>6 构建: 多种构建方式, 本地构建, jenkins构建<br>7 部署: 多种部署方式, 本地部署, jenkins部署</p>\n","site":{"data":{}},"excerpt":"<h5 id=\"写在前面\"><a href=\"#写在前面\" class=\"headerlink\" title=\"写在前面\"></a>写在前面</h5><p>绝不推荐脱产寻找工作机会, 特别是非一线城市(具有时效性). 笔者始终觉得, 面试是快速提升个人实力的有效方式, 但是面试的状态真的是又累又焦虑, 也是笔者第一次经历社招, 深深觉得社招对工作年限的严格性, 有个工作3年的同事也在找工作(笔者工作1年), 但是他的面试机会比我多一倍不止, 能力虽有差距, 但是他分享的面经发现笔者能答上大部分, 着实难受. 本文记下近期面试的印象深刻的题</p>\n<h4 id=\"JavaScript基础\"><a href=\"#JavaScript基础\" class=\"headerlink\" title=\"JavaScript基础\"></a>JavaScript基础</h4><h5 id=\"设计模式-了解单例和工厂吗-应用场景是什么\"><a href=\"#设计模式-了解单例和工厂吗-应用场景是什么\" class=\"headerlink\" title=\"设计模式: 了解单例和工厂吗 应用场景是什么\"></a>设计模式: 了解单例和工厂吗 应用场景是什么</h5><ol>\n<li>单例模式(Singleton)的特点是只有一个实例对象, 且该类能自行创建这个实例的一种模式, 单例类对外提供一个访问该单例的全局访问点<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> createWindow = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> div;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (!div) &#123;</span><br><span class=\"line\">            div = <span class=\"built_in\">document</span>.createElement(<span class=\"string\">'div'</span>);</span><br><span class=\"line\">            div.innerHTML = <span class=\"string\">'a toast'</span>;</span><br><span class=\"line\">            div.style.display = <span class=\"string\">'none'</span>;</span><br><span class=\"line\">            <span class=\"comment\">// ...</span></span><br><span class=\"line\">            <span class=\"built_in\">document</span>.body.appendChild(div);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> div;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"built_in\">document</span>.getElementById(<span class=\"string\">'id'</span>).onclick = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> win = createWindow();</span><br><span class=\"line\">    win.style.display = <span class=\"string\">'block'</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// 点击创建并展示弹窗, 关闭时移除弹窗dom, 频繁dom操作影响性能, 单例只实例化一次</span></span><br></pre></td></tr></table></figure>\n\n</li>\n</ol>\n<p>应用场景: 某类只要求生成一个对象的时候; 对象需要被共享的时候; 某类频繁实例化和频繁被销毁的时候;</p>","more":"<ol start=\"2\">\n<li>工厂方法模式是一类产品的生产模式, 我们把被创建的对象称为”产品”, 把创建产品的对象成为”工厂”, 特点是用户只需要知道具体工厂的名称就可以得到所要的产品, 无需知道产品的具体创建过程;<br>工厂方法模式由抽象工厂、具体工厂、抽象产品和具体产品等4个要素构成<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">抽象工厂（Abstract Factory）：提供了创建产品的接口，它包含多个创建产品的方法 newProduct()，可以创建多个不同等级的产品。</span><br><span class=\"line\">具体工厂（Concrete Factory）：主要是实现抽象工厂中的多个抽象方法，完成具体产品的创建。</span><br><span class=\"line\">抽象产品（Product）：定义了产品的规范，描述了产品的主要特性和功能，抽象工厂模式有多个抽象产品。</span><br><span class=\"line\">具体产品（Concrete Product）：实现了抽象产品角色所定义的接口，由具体工厂来创建，它同具体工厂之间是多对一的关系。</span><br></pre></td></tr></table></figure>\n\n</li>\n</ol>\n<p>应用场景: 只知道创建产品的工厂名, 不知道具体的产品名; 创建对象的任务由多个子工厂的某一个完成, 而抽象工厂只提供创建产品的接口; 客户不关心创建产品的细节, 只关心产品的品牌;</p>\n<ol start=\"3\">\n<li>抽象工厂模式可生产多维度的产品, 特点除了工厂方法模式的特点还有当增加一个新的产品族时不需要修改原代码, 满足开闭原则<br>在工厂方法模式的具体工厂实现多个产品的生成方法<br>应用场景: 需要创建的对象是一系列相关联或相依赖的产品族时, 如电器工厂的电视机洗衣机; 系统提供产品的类库, 且所有产品的接口相同, 客户端不依赖产品实例的创建细节和内部结构</li>\n</ol>\n<h5 id=\"es5和es6是如何继承的\"><a href=\"#es5和es6是如何继承的\" class=\"headerlink\" title=\"es5和es6是如何继承的\"></a>es5和es6是如何继承的</h5><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br><span class=\"line\">104</span><br><span class=\"line\">105</span><br><span class=\"line\">106</span><br><span class=\"line\">107</span><br><span class=\"line\">108</span><br><span class=\"line\">109</span><br><span class=\"line\">110</span><br><span class=\"line\">111</span><br><span class=\"line\">112</span><br><span class=\"line\">113</span><br><span class=\"line\">114</span><br><span class=\"line\">115</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// es5</span></span><br><span class=\"line\"><span class=\"comment\">// 原型链实现继承: 利用原型让一个引用类型继承另一个引用类型的属性和方法</span></span><br><span class=\"line\"><span class=\"comment\">// 缺点是引用类型的值会被所以实例共享; 创造子类的实例不能向超类构造函数中传递参数</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">Super</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.property = <span class=\"literal\">true</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">Super.prototype.getSuperValue = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>.property;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">Sub</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.subproperty = <span class=\"literal\">false</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">Sub.prototype = <span class=\"keyword\">new</span> Super();</span><br><span class=\"line\">Sub.prototype.getSubValue = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>.subproperty;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">var</span> sub = <span class=\"keyword\">new</span> Sub();</span><br><span class=\"line\">sub.getSuperValue; <span class=\"comment\">// true</span></span><br><span class=\"line\"><span class=\"comment\">// 借用构造函数: 在子类构造函数的内部调用超类的构造函数, 通过apply或call来修改作用域, 能够传递参数</span></span><br><span class=\"line\"><span class=\"comment\">// 缺点是方法都在构造函数中定义, 函数无法复用; 在超类定义的方法, 子类不可见</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">Super</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.property = <span class=\"literal\">true</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">Sub</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    Super.call(<span class=\"keyword\">this</span>)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">var</span> sub1 = <span class=\"keyword\">new</span> Sub();</span><br><span class=\"line\"><span class=\"keyword\">var</span> sub2 = <span class=\"keyword\">new</span> Sub();</span><br><span class=\"line\">sub1.property = <span class=\"literal\">false</span>;</span><br><span class=\"line\">sub1.property; <span class=\"comment\">// false</span></span><br><span class=\"line\">sub2.property; <span class=\"comment\">// true</span></span><br><span class=\"line\"><span class=\"comment\">// 组合继承: 讲原型链和借用构造函数组合, 原型链实现了原型属性和方法的继承, 借用构造函数实现了实例属性的继承, 函数复用, 又保证属性不会被实例共享</span></span><br><span class=\"line\"><span class=\"comment\">// 缺点是调用两次超类构造函数, 一次在创建子类原型的时候, 一次是子类构造函数的内部</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">Super</span> (<span class=\"params\">name</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.property = <span class=\"literal\">true</span>;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.name = name;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">Super.prototype.sayName = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">'name: '</span>, <span class=\"keyword\">this</span>.name);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">Sub</span> (<span class=\"params\">name, age</span>) </span>&#123;</span><br><span class=\"line\">    Super.call(<span class=\"keyword\">this</span>, name); <span class=\"comment\">// 参数不固定可以用apply</span></span><br><span class=\"line\">    <span class=\"keyword\">this</span>.age = age;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">Sub.prototype = <span class=\"keyword\">new</span> Super();</span><br><span class=\"line\">Sub.prototype.constructor = Sub;</span><br><span class=\"line\">Sub.prototype.sayAge = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">'age: '</span>, <span class=\"keyword\">this</span>.age);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> sub = <span class=\"keyword\">new</span> Sub(<span class=\"string\">'PsiloLau'</span>, <span class=\"number\">18</span>);</span><br><span class=\"line\">sub.sayName(); <span class=\"comment\">// name: PsiloLau</span></span><br><span class=\"line\">sub.sayAge(); <span class=\"comment\">// age: 18</span></span><br><span class=\"line\"><span class=\"comment\">// 寄生组合式继承: 通过借用构造函数来继承属性, 是最理想的继承方式</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">object</span>(<span class=\"params\">o</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">F</span>(<span class=\"params\"></span>) </span>&#123;&#125;</span><br><span class=\"line\">    F.prototype = o;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> F();</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">inheritPrototype</span>(<span class=\"params\">Sub, Super</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> prototype = object(Super.prototype);</span><br><span class=\"line\">    prototype.constructor = Sub;</span><br><span class=\"line\">    Sub.prototype = prototype</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">Super</span> (<span class=\"params\">name</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.name = name;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.colors = [<span class=\"string\">'red'</span>, <span class=\"string\">'green'</span>];</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">Super.prototype.sayName = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"keyword\">this</span>.name);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">Sub</span> (<span class=\"params\">name, age</span>) </span>&#123;</span><br><span class=\"line\">    Super.call(<span class=\"keyword\">this</span>, name);</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.age = age;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">inheritPrototype(Sub, Super);</span><br><span class=\"line\"></span><br><span class=\"line\">Sub.prototype.sayAge = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"keyword\">this</span>.age);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// es6 class与extends实现继承, 本质是es5修改原型链实现继承的语法糖</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Animal</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">constructor</span> (props) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.name = props.name || <span class=\"string\">'Animal'</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    eat () &#123;</span><br><span class=\"line\">        <span class=\"built_in\">console</span>.log(<span class=\"keyword\">this</span>.name + <span class=\"string\">' can eat'</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    sleep () &#123;</span><br><span class=\"line\">        <span class=\"built_in\">console</span>.log(<span class=\"keyword\">this</span>.name + <span class=\"string\">' can sleep'</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Bird</span> <span class=\"keyword\">extends</span> <span class=\"title\">Animal</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">constructor</span> (props, ownClass) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">super</span>(props); <span class=\"comment\">// 相对于获得父类的this指向</span></span><br><span class=\"line\">        <span class=\"keyword\">this</span>.type = props.type || <span class=\"string\">'Egg animal'</span>;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.class = ownClass</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    fly () &#123;</span><br><span class=\"line\">        <span class=\"built_in\">console</span>.log(<span class=\"keyword\">this</span>.name + <span class=\"string\">' can fly'</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    eat () &#123;</span><br><span class=\"line\">        <span class=\"built_in\">console</span>.log(<span class=\"keyword\">this</span>.name + <span class=\"string\">' can eat worms'</span>) <span class=\"comment\">// 父类方法重写</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> swollow = <span class=\"keyword\">new</span> Bird(&#123;</span><br><span class=\"line\">    name: <span class=\"string\">'小燕子'</span>,</span><br><span class=\"line\">    type: <span class=\"string\">'Egg animal'</span></span><br><span class=\"line\">&#125;, <span class=\"string\">'Bird class'</span>)</span><br><span class=\"line\">swollow.fly(); <span class=\"comment\">// 小燕子 can fly</span></span><br><span class=\"line\">swollow.sleep(); <span class=\"comment\">// 小燕子 can sleep</span></span><br><span class=\"line\">swollow.eat(); <span class=\"comment\">// 小燕子 can eat worms</span></span><br></pre></td></tr></table></figure>\n\n<h5 id=\"原生JavaScript设计组件\"><a href=\"#原生JavaScript设计组件\" class=\"headerlink\" title=\"原生JavaScript设计组件\"></a>原生JavaScript设计组件</h5><p>todo</p>\n<h5 id=\"jsonp工作原理-为什么不是真正的ajax\"><a href=\"#jsonp工作原理-为什么不是真正的ajax\" class=\"headerlink\" title=\"jsonp工作原理, 为什么不是真正的ajax\"></a>jsonp工作原理, 为什么不是真正的ajax</h5><p>原理: 利用script标签没有跨域限制的特性来达到与第三方通讯的目的, 需要通讯时创建script标签指向第三方api地址, 并提供一个回调函数来接受数据(函数名可约定, 也可通过参数传递), 客户端通过调用回调函数来进行交互.<br>为什么不是真正的ajax: ajax的核心的通过xmlHttpRequest获取内容, jsonp的核心是动态添加; jsonp只支持get请求; ajax不一定要用json格式来传递数据</p>\n<h5 id=\"requestAnimationFrame原理\"><a href=\"#requestAnimationFrame原理\" class=\"headerlink\" title=\"requestAnimationFrame原理\"></a>requestAnimationFrame原理</h5><p>正常显示器刷新频率是60Hz, 即我们看到的显示图像每秒60次的频率刷新. setTimeout通过设置一个间隔时间来不断改变图像位置从而达到动画效果, 但是setTimeout的执行步调和屏幕的刷新步调不一致会导致丢帧现象, requestAnimationFrame的优势就是由系统来决定回调函数的执行步调, 60Hz的显示器就是1000 / 60 = 16.7ms被执行一次, 75Hz的显示器就是13.3ms</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> progress = <span class=\"number\">0</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">render</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    progress += <span class=\"number\">1</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (progress &lt; <span class=\"number\">100</span>) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 条件递归渲染</span></span><br><span class=\"line\">        <span class=\"built_in\">window</span>.requestAnimationFrame(render);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">window</span>.requestAnimationFrame(render);</span><br><span class=\"line\"><span class=\"comment\">// cpu节能: setTimeout实现的动画即使页面被最小化或者切换其他标签的时候, 当前页面仍会执行动画任务, requestAnimationFrame只有在激活状态才会执行</span></span><br><span class=\"line\"><span class=\"comment\">// 函数节流: 一个刷新间隔内执行多次函数没有意义</span></span><br><span class=\"line\"><span class=\"comment\">// 缺点: 在低版本安卓下并不友好, github有提供的polyfill, 优先使用高级特效requestAnimationFrame, 后优雅降级</span></span><br></pre></td></tr></table></figure>\n\n<h5 id=\"‘1’-’2’-’3’-map-parseInt-的输出-为什么\"><a href=\"#‘1’-’2’-’3’-map-parseInt-的输出-为什么\" class=\"headerlink\" title=\"[‘1’,’2’,’3’].map(parseInt)的输出, 为什么\"></a>[‘1’,’2’,’3’].map(parseInt)的输出, 为什么</h5><figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">输出: [1, NaN, NaN]</span><br><span class=\"line\">原因: parseInt()函数可传两个参数, parseInt(string, radix)</span><br><span class=\"line\">string: 必需, 要解析的字符串.</span><br><span class=\"line\">radix: 可选, 表示要解析的数字的基数, 基于2~36之间, 不填默认为10进制, 小于2或大于36都会返回NaN. </span><br><span class=\"line\">map()可传三个参数, map(item, index, arr)</span><br><span class=\"line\">item: 必需, 当前元素的值</span><br><span class=\"line\">index: 可选, 当前元素的索引值</span><br><span class=\"line\">arr: 可选, 当前元素属于的数组对象</span><br><span class=\"line\">['1', '2', '3'].map(parseInt) =&gt; parseInt('1', 0) (arr是第三个参数, 但是parseInt只接收两个, 所以无效) parseInt('2', 1) parseInt('3', 2) 所以是1, NaN, NaN</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"浏览器\"><a href=\"#浏览器\" class=\"headerlink\" title=\"浏览器\"></a>浏览器</h4><h5 id=\"预检请求options作用\"><a href=\"#预检请求options作用\" class=\"headerlink\" title=\"预检请求options作用\"></a>预检请求options作用</h5><p>在CORS中, 可以使用options方法发起一个预检请求, 以检测实际请求是否可以被服务器所接受. 在某些情况下会发起一次options请求, 当options请求成功返回后, 真正的ajax请求才会发起</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">某些情况:</span><br><span class=\"line\">1. 跨域请求</span><br><span class=\"line\">2. 自定义请求头</span><br><span class=\"line\">3. 请求头中的content-type是application/x-www-form-urlencoded、multipart/form-data、text/plain以外的格式(默认情况下axios会将JavaScript对象序列化为JSON来发送, 即content-type赋值成application/json)</span><br><span class=\"line\">满足 12 或 13 就会发送options请求</span><br></pre></td></tr></table></figure>\n\n<h5 id=\"对缓存的理解\"><a href=\"#对缓存的理解\" class=\"headerlink\" title=\"对缓存的理解\"></a>对缓存的理解</h5><p>浏览器每次发起请求, 都会先在浏览器缓存中查找该请求的结果以及缓存标识, 每次拿到返回的请求结果都会将该结果和缓存标识(Last-Modified Etag)存入浏览器缓存中</p>\n<ol>\n<li>浏览器没有缓存, 向服务器发起请求, 会在请求头上加上Expires和Cache-Control, 返回200ok和响应结果以及缓存标识, 存入缓存<br>Expires是http/1的产物, 受限于本地时间, 如果修改了本地时间, 可能会造成缓存失效; Cache-Control是http/1.1的规则, 设置max-age=300时代表这个请求正确返回时间的5分钟内再次加载资源会命中缓存. Cache-Control优先级高于Expires</li>\n<li>浏览器在缓存中查找, Cache-Control没有过期, 直接从disk或memory读取资源, 即强缓存</li>\n<li>浏览器在缓存中查找, 如果过期了, 向服务器发起请求, 携带标识If-Modified-Since和If-None-Match, 其中之一没有命中意味着资源有更新, 协商缓存失败, 返回200 重新返回资源和缓存标识, 存入浏览器缓存中; 都命中意味资源无更新, 协商缓存成功返回304, 继续使用缓存.<br>服务器校验优先考虑Etag, 精度上Etag优于Last-Modified, 性能上Etag要差于后者</li>\n</ol>\n<h4 id=\"Vue\"><a href=\"#Vue\" class=\"headerlink\" title=\"Vue\"></a>Vue</h4><h5 id=\"Vue原理详细阐述\"><a href=\"#Vue原理详细阐述\" class=\"headerlink\" title=\"Vue原理详细阐述\"></a>Vue原理详细阐述</h5><p>主要有Observer、Watcher、Compile、Dep等模块, Vue初始化时调用reactive, 就是Observer用Object.defineProperty重写getter setter来监听属性变化, 在getter里添加订阅者(订阅器Dep里的dep数组, 当dep.target存在时, 如果id不重复就往订阅器添加订阅者, dep.target赋值会在Watcher里做, 赋值后再调用一次属性触发getter, 然后把dep.target置null), 在setter里notify所有的dep, notify会调用所有的dep的update方法, 并触发Compile的回调, 更新视图.</p>\n<h5 id=\"mpVue原理详细阐述\"><a href=\"#mpVue原理详细阐述\" class=\"headerlink\" title=\"mpVue原理详细阐述\"></a>mpVue原理详细阐述</h5><p>典型的逻辑视图层框架, 逻辑层和视图层之间的工作方式是: 数据变更驱动视图更新, 视图交互触发事件, 事件响应函数修改数据再次触发视图更新<br>在mpVue中, 小程序负责视图层, 所有业务逻辑在vue.js中, vue数据变更后同步到小程序:</p>\n<ol>\n<li>Vue实例与小程序page实例建立关联</li>\n<li>mnp与Vue生命周期建立映射关系, 能在mnp生命周期中触发Vue的生命周期</li>\n<li>mnp事件建立代理机制, 在事件代理函数中触发与之对应的Vue事件响应</li>\n</ol>\n<h4 id=\"前端\"><a href=\"#前端\" class=\"headerlink\" title=\"前端\"></a>前端</h4><h5 id=\"前端组件化-模块化-工程化的理解\"><a href=\"#前端组件化-模块化-工程化的理解\" class=\"headerlink\" title=\"前端组件化 模块化 工程化的理解\"></a>前端组件化 模块化 工程化的理解</h5><p>组件化和模块化可以放在一起讲, 首先是颗粒度不同, 拿vue来讲, 组件化应该是包含(template+script+style)的功能完备单元. 模块化更像是js模块, 如Observer、watcher.<br>其次用测试的角度来看, 组件化像黑盒, 不需要知道内部逻辑, 关注io和功能性; 模块化更像白盒, 内容可见, 注重设计.<br>工程化可以按以下点来讲:<br>1 代码规范: 保证团队有统一的代码风格, 如eslint<br>2 分支管理: 每个迭代的分支命名或开发的模块分支命名<br>3 模块管理: 模块/组件命名规范 路径规范<br>4 自动化测试: 单元测试 集成测试 端到端测试<br>5 commit规范: husky校验, 包括push<br>6 构建: 多种构建方式, 本地构建, jenkins构建<br>7 部署: 多种部署方式, 本地部署, jenkins部署</p>"},{"title":"GC 垃圾回收","date":"2022-07-18T12:04:18.000Z","_content":"\n### GC 是什么\n\nGarbage Collection，程序工作过程中会产生很多垃圾，这些垃圾是程序不用的内存或者是之前用过了，以后不会再用的空间，而 GC 负责回收。不是所有的语言都有 GC，Java、JavaScript、Python 自带 GC；再比如 C、C++ 没有 GC，需要手动管理内存，相对麻烦\n\n### 垃圾产生&为何回收\n\n我们知道写代码时创建一个基本类型、对象、函数……都是需要占用内存的\n\n```jsx\nlet test = {\n  name: \"psilo\",\n};\n\ntest = [1, 2, 3, 4, 5];\n```\n\n我们知道 JavaScript 的引用数据类型是保存在堆内存中，然后在栈内存中保存一个对堆内存中实际对象的引用。上图所示，{ name: 'psilo' } 对象没有了引用关系，如果不清理（回收），内存会越来越大。\n\n<!-- more -->\n\n![figure](1.png)\n\n### 垃圾回收策略\n\n在 JavaScript 中，垃圾回收的机制是定期找出不再用到的内存（变量），然后释放其内存。\n\n常见策略：\n\n1. 标记清除\n2. 引用计数\n\n### 标记清除（Mark-Sweep）\n\n在 JavaScript 是最常用的，分别 标记 和 清除 两个阶段，标记阶段为所有活动对象做上标记，清除阶段则把没有标记的对象销毁。\n\n引擎在执行 GC 时，需要从出发点去遍历内存中所有的对象打标记，而这个出发点有很多，我们称之为一组 根 对象，而所谓的根对象，其实在浏览器环境中包括又不止于全局 Window 对象、文档 DOM 树 等。整个算法过程大致如下：\n\n- 垃圾收集器在运行时会给内存中的所有变量都加上一个标记，假设内存中所有对象都是垃圾，全标记为 0\n- 然后从各个根对象开始遍历，把不是垃圾的节点改成 1\n- 清理所有标记为 0 的垃圾，销毁并回收它们所占用的内存空间\n- 把所有内存中对象标记修改为 0，等待下一轮垃圾回收\n\n**优点：**\n\n实现比较简单，只需要一个二进制（0 和 1）位就可以标记\n\n**缺点：**\n\n清除后剩余对象的内存位置是不变的，导致空闲内存空间是不连续的，出现了 内存碎片，这就牵扯除了内存分配问题\n\n![figure](2.png)\n\n假设我们新建对象分配内存时需要大小为 size，由于空闲内存是间断的、不连续的，则需要对空间内存列表进行一次单向遍历找出大于等于 size 的块才能为其分配\n\n![figure](3.png)\n\n那如何找到合适的块呢？有三种分配策略：\n\n- First-fit，找到大于等于 size 的块立即返回\n- Best-fit，遍历整个空闲列表，返回大于等于 size 的最小分块\n- Worst-fit，遍历整个空闲列表，找到最大的分块，然后切成两部分，一部分 size 大小，并将该部分返回\n\n看起来 Worst-fit 的空间利用率最合理，但实际上切分之后会造成更多的小块（回收后），形成内存碎片。对于 First-fit 和 Best-fit 来说，考虑分配的速度和效率 First-fit 才是更名明智的选择。\n\n综上所述，标记清除算法有两个缺点：\n\n- **内存碎片化，**空闲内存块是不连续的，容易出现很多空闲内存块\n- **分配速度慢，**即便是 First-fit，其操作仍是一个 O(n) 的操作\n\n归根结底，标记清除的缺点在于内存碎片化，**标记整理（Mark-Compact）**就可以有效地解决：在标记结束后，标记整理会将活着的对象向内存的一端移动，最后清理掉边界的内存\n\n![figure](4.png)\n\n### 引用计数（Reference Counting）\n\n因为它问题很多，目前很少使用这种算法了。策略是跟踪记录每个变量值被使用的次数\n\n- 当声明一个变量并且将一个引用类型赋值给该变量的时候这个值的引用次数就为 1\n- 如果同一个值又被赋给另一个变量，那么引用数加 1\n- 如果该变量的值被其他的值覆盖了，则引用次数减 1\n- 当这个值引用次数变为 0 的时候，说明没有变量在使用，这个值没法被访问了，回收\n\n```jsx\nlet a = new Object() \t// 此对象的引用计数为 1（a引用）\nlet b = a \t\t// 此对象的引用计数是 2（a,b引用）\na = null  \t\t// 此对象的引用计数为 1（b引用）\nb = null \t \t// 此对象的引用计数为 0（无引用）\n...\t\t\t// GC 回收此对象\n```\n\n虽然看起来简单，但是有一个很严重的问题：循环引用，即：\n\n```jsx\nfunction test() {\n  let A = new Object();\n  let B = new Object();\n\n  A.b = B;\n  B.a = A;\n}\n```\n\n按照上文的引用计数策略，对象 A 和 B 的引用数量都为 2，但是在 test 函数执行完是需要被清理的\n\n**优点**\n\n在引用值为 0 的时候可以立即被回收，而标记清除需要每隔一段时间进行，而且需要 JS 脚本暂停去执行 GC\n\n**缺点**\n\n需要一个很大内存的计数器，因为我们不知道被引用数量的上限；循环引用问题无法解决\n\n### V8 对 GC 的优化\n\nV8 是基于标记清除算法，但是也做了一些优化\n\n**分代式垃圾回收**\n\n标记清除在每次回收时都要检查内存中所有对象，分代进行 GC 效率会更好，且一些大、老、存活时间厂的对象来说不需要频繁进行清理。\n\nV8 将堆内存分为新生代和老生代两区域，采用不同的 GC 策略管理\n\n新生代的对象为存活时间较短的对象，简单来说就是新产生的对象，通常只支持 1 ～ 8M 的容量，而老生代的对象为存活事件较长或常驻内存的对象。\n\n![figure](5.png)\n\n**新生代垃圾回收**\n\n通过一个 Scavenge 算法进行垃圾回收，将堆内存一分为二，一个是处于使用状态的空间我们暂且称为 使用区，一个是处于闲置状态的空间称之为 空闲区\n\n![figure](6.png)\n\n新加入的对象都会存放到使用区，当使用区快被写满时，就需要执行一次垃圾清理操作\n\n开始回收时，新生代垃圾回收器会对使用区中的活动对象做标记，标记完成后将使用区的活动对象复制进空闲区并进行排序，随后进入垃圾清理阶段，即将非活动对象占用的空间清理掉。最后进行角色互换，把原来的使用区变成空闲区，把原来的空闲区变成使用区\n\n当一个对象经过多次复制后依赖存活，它将会被认为是生命周期较长的对象，随后会被移动到老生代中，采用老生代的垃圾回收策略进行管理\n\n当复制一个对象到空闲区时，空闲区空间占用超过 25%，那么这个对象会被直接移动到老生代空间中，因为两个区域互换的时候，如果占比较大，会影响后续内存分配。\n\n**老生代垃圾回收**\n\n标记清除 + 标记整理\n\n**为什么需要分代式**\n\n分代式机制把一些新、小、存活时间短的对象作为新生代，采用一小块内存频率较高的快速清理，而一些大、老、存活时间较长的对象作为老生代，使其很少接受检查，新老生代的回收机制及频率是不同的，可以说此机制的出现很大程序提高了垃圾回收机制的效率\n\n**并行回收（Parallel）**\n\n在介绍并行之前，要了解 全停顿（Stop-The-World）概念，我们都知道 JavaScript 是一门单线程的语言，它是运行在主线程上的，那在进行垃圾回收时就会阻塞 JavaScript 脚本的执行，需等待垃圾回收完毕后再恢复脚本执行，称为全停顿\n\n比如一次 GC 需要 60ms，那我们的应用逻辑就得暂停 60ms，所谓并行，指的是垃圾回收器在主线程上执行的过程中，开启多个辅助线程，同时执行同样的回收工作\n\n![figure](7.png)\n\n简单来说，使用并行回收，加入本来主线程一个人干活，它需要 3s，现在叫上 2 个辅助线程一起干活，加上多人协同（同步开销）的时间（0.5s），本来需要 3s 的活现在 1.5s 就可以干完\n\n新生代对象空间就采用并行策略，在执行垃圾回收的过程中，会启动多个线程来负责新生代中的垃圾清理操作，这些线程同时将对象空间中的数据移动到空闲区域，这个过程中由于数据地址会发生改变，所以还需要同步更新引用这些对象的指针，即并行回收\n\n**增量标记与惰性清理**\n\n并行策略虽然可以增加垃圾回收的效率，对于新生代垃圾回收器能够有很好的优化，但是其实它还是一种全停顿式的垃圾回收方式，对于老生代来说，它的内部存放的都是一些比较大的对象，对于这些大的对象 GC 时哪怕我们使用并行策略依然会消耗大量时间\n\n所以为了减少全停顿的时间，在 2011 年，V8 对老生代的标记进行老优化，从全停顿标记切换到增量标记\n\n**什么是增量标记**\n\n增量就是将一次 GC 标记的过程，分成了很多小步，每执行完一小步就让应用逻辑执行一会，这样交替多次后完成一轮 GC\n\n![figure](8.png)\n\n将一次完整的 GC 标记分次执行，那么在每一小次 GC 标记执行完后如何暂停下来去执行任务程序，而后又怎么恢复呢？假如我们在一次完整的 GC 标记分块暂停后，执行任务程序时内存中标记好的对象引用关系被修改老又怎么办呢？V8 针对这两个问题对应的解决方案分别是 三色标记法 和 写屏障\n\n**三色标记法**\n\n我们知道老生代是采用标记清理算法，而上文的标记清理中我们说过，也就是在没有采用增量算法前，单纯使用黑色和白色来标记数据就可以来，在执行一次完整的 GC 标记前，垃圾回收器会将所有的数据置为白色，然后垃圾回收器在从一组根对象触发，将所有能访问到的数据标记为黑色，遍历结束后，标记为白色的对象就是待清理对象\n\n如果采用这种非黑即白的标记策略，那么在垃圾回收器执行来一段增量回收后，暂停启用主线程去执行应用程序中的一段 JavaScript 代码，随后当垃圾回收器再次被启动，这时候内存中黑白色都有，我们无法得知下一步走到哪里了\n\n三色标记法使用每个对象的两个标记位和一个标记工作表来实现标记，两个标记位编码三种颜色：白、灰、黑\n\n- 白色指的是未被标记的对象\n- 灰色指的是自身被标记，成员变量（该对象的引用对象）未被标记\n- 黑色指自身和成员皆被标记\n\n![figure](9.png)\n\n直到没有可标记灰色的对象时，那么剩下的白色对象就是无法到达的，等待回收（如上图 C、E）\n\n**写屏障（增量中修改引用）**\n\n一次完整的 GC 标记分块暂停后，执行任务程序时内存中标记好的对象引用关系被修改了\n\n![figure](10.png)\n\n修改后，没有灰色对象，新修改的白色对象 D 将在次轮 GC 的清理阶段被回收。为了解决这个问题， V8 增量回收使用 写屏障（Write-barrier）机制，一旦又黑色对象引用白色对象，该机制会强制将引用的白色对象改为灰色，保证下一次增量 GC 标记阶段可以正确标记，这个机制也称做 强三色不变性\n\n**惰性清理**\n\n增量标记其实只是对活动对象和非活动对象进行标记，对于真正的清理释放内存 V8 采用的是惰性清理（Lazy Sweeping）\n\n增量标记完成后，惰性清理就开始了。当增量标记完成后，假如当前的可用内存足以让我们快速的执行代码，其实我们是没必要立即清理内存的，可将清理过程稍微延迟一下，让 JavaScript 脚本代码先执行，也无需一次性清理完所有非活动对象的内存，可用按需逐一进行清理直到所有的非活动对象内存都清理完毕，后面再接着执行增量标记\n\n**增量标记与惰性清理的优缺**\n\n增量标记与惰性清理的出现，使得主线程的停顿时间大大减少了，让用户与浏览器交互的过程变得更加流畅。但是由于每个小的增量标记之间执行了 JavaScript 代码，堆中的对象指针可能发生变化，需要使用写屏障计数来记录引用关系的变化，所以增量标记缺点也很明显：\n\n首先是并没有减少主线程的总暂停时间，甚至会略微增加，其次由于写屏障机制的成本，增量标记可能会降低应用程序的吞吐量\n\n### 并发回收（Concurrent）\n\n并行回收依然会阻塞主线程，增量标记也会增加总暂停时间、降低应用程序吞吐量两个缺点。并发回收能在主线程执行 JavaScript 过程中，辅助线程能够在后台完成执行垃圾回收的操作，辅助线程在执行垃圾回收的时候，主线程也可以自由执行而不会被挂起\n\n![figure](11.png)\n\n辅助线程在执行垃圾回收的时候，主线程也可以自由执行而不会被挂起，这是并发的优点也是并发实现的难点，因为它需要考虑主线程在执行 JavaScript 时，堆中对象引用关系随时都有可能发生变化，这时辅助线程之前做的一些标记活着正在进行的标记就会有所改变，所以它需要额外实现一些读写锁机制来控制\n\n**V8 中 GC 优化**\n\n我们说过新生代垃圾回收器，使用并行回收可以很好的增加垃圾回收的效率，那老生代垃圾回收器是用哪种策略呢？上面说来并行回收、增量标记与惰性清理、并发回收这几种回收方式来提高效率、优化体验，其实老生代垃圾回收器都是融合使用的。\n\n老生代主要使用并发标记，主线程在开始执行 JavaScript 时，辅助线程也同时执行标记操作\n\n标记完成后，再执行并行清理操作\n\n同时，清理的任务会采用增量的方式分批在各个 JavaScript 任务间执行\n","source":"_posts/GC-垃圾回收.md","raw":"---\ntitle: GC 垃圾回收\ndate: 2022-07-18 20:04:18\ntags: JS\n---\n\n### GC 是什么\n\nGarbage Collection，程序工作过程中会产生很多垃圾，这些垃圾是程序不用的内存或者是之前用过了，以后不会再用的空间，而 GC 负责回收。不是所有的语言都有 GC，Java、JavaScript、Python 自带 GC；再比如 C、C++ 没有 GC，需要手动管理内存，相对麻烦\n\n### 垃圾产生&为何回收\n\n我们知道写代码时创建一个基本类型、对象、函数……都是需要占用内存的\n\n```jsx\nlet test = {\n  name: \"psilo\",\n};\n\ntest = [1, 2, 3, 4, 5];\n```\n\n我们知道 JavaScript 的引用数据类型是保存在堆内存中，然后在栈内存中保存一个对堆内存中实际对象的引用。上图所示，{ name: 'psilo' } 对象没有了引用关系，如果不清理（回收），内存会越来越大。\n\n<!-- more -->\n\n![figure](1.png)\n\n### 垃圾回收策略\n\n在 JavaScript 中，垃圾回收的机制是定期找出不再用到的内存（变量），然后释放其内存。\n\n常见策略：\n\n1. 标记清除\n2. 引用计数\n\n### 标记清除（Mark-Sweep）\n\n在 JavaScript 是最常用的，分别 标记 和 清除 两个阶段，标记阶段为所有活动对象做上标记，清除阶段则把没有标记的对象销毁。\n\n引擎在执行 GC 时，需要从出发点去遍历内存中所有的对象打标记，而这个出发点有很多，我们称之为一组 根 对象，而所谓的根对象，其实在浏览器环境中包括又不止于全局 Window 对象、文档 DOM 树 等。整个算法过程大致如下：\n\n- 垃圾收集器在运行时会给内存中的所有变量都加上一个标记，假设内存中所有对象都是垃圾，全标记为 0\n- 然后从各个根对象开始遍历，把不是垃圾的节点改成 1\n- 清理所有标记为 0 的垃圾，销毁并回收它们所占用的内存空间\n- 把所有内存中对象标记修改为 0，等待下一轮垃圾回收\n\n**优点：**\n\n实现比较简单，只需要一个二进制（0 和 1）位就可以标记\n\n**缺点：**\n\n清除后剩余对象的内存位置是不变的，导致空闲内存空间是不连续的，出现了 内存碎片，这就牵扯除了内存分配问题\n\n![figure](2.png)\n\n假设我们新建对象分配内存时需要大小为 size，由于空闲内存是间断的、不连续的，则需要对空间内存列表进行一次单向遍历找出大于等于 size 的块才能为其分配\n\n![figure](3.png)\n\n那如何找到合适的块呢？有三种分配策略：\n\n- First-fit，找到大于等于 size 的块立即返回\n- Best-fit，遍历整个空闲列表，返回大于等于 size 的最小分块\n- Worst-fit，遍历整个空闲列表，找到最大的分块，然后切成两部分，一部分 size 大小，并将该部分返回\n\n看起来 Worst-fit 的空间利用率最合理，但实际上切分之后会造成更多的小块（回收后），形成内存碎片。对于 First-fit 和 Best-fit 来说，考虑分配的速度和效率 First-fit 才是更名明智的选择。\n\n综上所述，标记清除算法有两个缺点：\n\n- **内存碎片化，**空闲内存块是不连续的，容易出现很多空闲内存块\n- **分配速度慢，**即便是 First-fit，其操作仍是一个 O(n) 的操作\n\n归根结底，标记清除的缺点在于内存碎片化，**标记整理（Mark-Compact）**就可以有效地解决：在标记结束后，标记整理会将活着的对象向内存的一端移动，最后清理掉边界的内存\n\n![figure](4.png)\n\n### 引用计数（Reference Counting）\n\n因为它问题很多，目前很少使用这种算法了。策略是跟踪记录每个变量值被使用的次数\n\n- 当声明一个变量并且将一个引用类型赋值给该变量的时候这个值的引用次数就为 1\n- 如果同一个值又被赋给另一个变量，那么引用数加 1\n- 如果该变量的值被其他的值覆盖了，则引用次数减 1\n- 当这个值引用次数变为 0 的时候，说明没有变量在使用，这个值没法被访问了，回收\n\n```jsx\nlet a = new Object() \t// 此对象的引用计数为 1（a引用）\nlet b = a \t\t// 此对象的引用计数是 2（a,b引用）\na = null  \t\t// 此对象的引用计数为 1（b引用）\nb = null \t \t// 此对象的引用计数为 0（无引用）\n...\t\t\t// GC 回收此对象\n```\n\n虽然看起来简单，但是有一个很严重的问题：循环引用，即：\n\n```jsx\nfunction test() {\n  let A = new Object();\n  let B = new Object();\n\n  A.b = B;\n  B.a = A;\n}\n```\n\n按照上文的引用计数策略，对象 A 和 B 的引用数量都为 2，但是在 test 函数执行完是需要被清理的\n\n**优点**\n\n在引用值为 0 的时候可以立即被回收，而标记清除需要每隔一段时间进行，而且需要 JS 脚本暂停去执行 GC\n\n**缺点**\n\n需要一个很大内存的计数器，因为我们不知道被引用数量的上限；循环引用问题无法解决\n\n### V8 对 GC 的优化\n\nV8 是基于标记清除算法，但是也做了一些优化\n\n**分代式垃圾回收**\n\n标记清除在每次回收时都要检查内存中所有对象，分代进行 GC 效率会更好，且一些大、老、存活时间厂的对象来说不需要频繁进行清理。\n\nV8 将堆内存分为新生代和老生代两区域，采用不同的 GC 策略管理\n\n新生代的对象为存活时间较短的对象，简单来说就是新产生的对象，通常只支持 1 ～ 8M 的容量，而老生代的对象为存活事件较长或常驻内存的对象。\n\n![figure](5.png)\n\n**新生代垃圾回收**\n\n通过一个 Scavenge 算法进行垃圾回收，将堆内存一分为二，一个是处于使用状态的空间我们暂且称为 使用区，一个是处于闲置状态的空间称之为 空闲区\n\n![figure](6.png)\n\n新加入的对象都会存放到使用区，当使用区快被写满时，就需要执行一次垃圾清理操作\n\n开始回收时，新生代垃圾回收器会对使用区中的活动对象做标记，标记完成后将使用区的活动对象复制进空闲区并进行排序，随后进入垃圾清理阶段，即将非活动对象占用的空间清理掉。最后进行角色互换，把原来的使用区变成空闲区，把原来的空闲区变成使用区\n\n当一个对象经过多次复制后依赖存活，它将会被认为是生命周期较长的对象，随后会被移动到老生代中，采用老生代的垃圾回收策略进行管理\n\n当复制一个对象到空闲区时，空闲区空间占用超过 25%，那么这个对象会被直接移动到老生代空间中，因为两个区域互换的时候，如果占比较大，会影响后续内存分配。\n\n**老生代垃圾回收**\n\n标记清除 + 标记整理\n\n**为什么需要分代式**\n\n分代式机制把一些新、小、存活时间短的对象作为新生代，采用一小块内存频率较高的快速清理，而一些大、老、存活时间较长的对象作为老生代，使其很少接受检查，新老生代的回收机制及频率是不同的，可以说此机制的出现很大程序提高了垃圾回收机制的效率\n\n**并行回收（Parallel）**\n\n在介绍并行之前，要了解 全停顿（Stop-The-World）概念，我们都知道 JavaScript 是一门单线程的语言，它是运行在主线程上的，那在进行垃圾回收时就会阻塞 JavaScript 脚本的执行，需等待垃圾回收完毕后再恢复脚本执行，称为全停顿\n\n比如一次 GC 需要 60ms，那我们的应用逻辑就得暂停 60ms，所谓并行，指的是垃圾回收器在主线程上执行的过程中，开启多个辅助线程，同时执行同样的回收工作\n\n![figure](7.png)\n\n简单来说，使用并行回收，加入本来主线程一个人干活，它需要 3s，现在叫上 2 个辅助线程一起干活，加上多人协同（同步开销）的时间（0.5s），本来需要 3s 的活现在 1.5s 就可以干完\n\n新生代对象空间就采用并行策略，在执行垃圾回收的过程中，会启动多个线程来负责新生代中的垃圾清理操作，这些线程同时将对象空间中的数据移动到空闲区域，这个过程中由于数据地址会发生改变，所以还需要同步更新引用这些对象的指针，即并行回收\n\n**增量标记与惰性清理**\n\n并行策略虽然可以增加垃圾回收的效率，对于新生代垃圾回收器能够有很好的优化，但是其实它还是一种全停顿式的垃圾回收方式，对于老生代来说，它的内部存放的都是一些比较大的对象，对于这些大的对象 GC 时哪怕我们使用并行策略依然会消耗大量时间\n\n所以为了减少全停顿的时间，在 2011 年，V8 对老生代的标记进行老优化，从全停顿标记切换到增量标记\n\n**什么是增量标记**\n\n增量就是将一次 GC 标记的过程，分成了很多小步，每执行完一小步就让应用逻辑执行一会，这样交替多次后完成一轮 GC\n\n![figure](8.png)\n\n将一次完整的 GC 标记分次执行，那么在每一小次 GC 标记执行完后如何暂停下来去执行任务程序，而后又怎么恢复呢？假如我们在一次完整的 GC 标记分块暂停后，执行任务程序时内存中标记好的对象引用关系被修改老又怎么办呢？V8 针对这两个问题对应的解决方案分别是 三色标记法 和 写屏障\n\n**三色标记法**\n\n我们知道老生代是采用标记清理算法，而上文的标记清理中我们说过，也就是在没有采用增量算法前，单纯使用黑色和白色来标记数据就可以来，在执行一次完整的 GC 标记前，垃圾回收器会将所有的数据置为白色，然后垃圾回收器在从一组根对象触发，将所有能访问到的数据标记为黑色，遍历结束后，标记为白色的对象就是待清理对象\n\n如果采用这种非黑即白的标记策略，那么在垃圾回收器执行来一段增量回收后，暂停启用主线程去执行应用程序中的一段 JavaScript 代码，随后当垃圾回收器再次被启动，这时候内存中黑白色都有，我们无法得知下一步走到哪里了\n\n三色标记法使用每个对象的两个标记位和一个标记工作表来实现标记，两个标记位编码三种颜色：白、灰、黑\n\n- 白色指的是未被标记的对象\n- 灰色指的是自身被标记，成员变量（该对象的引用对象）未被标记\n- 黑色指自身和成员皆被标记\n\n![figure](9.png)\n\n直到没有可标记灰色的对象时，那么剩下的白色对象就是无法到达的，等待回收（如上图 C、E）\n\n**写屏障（增量中修改引用）**\n\n一次完整的 GC 标记分块暂停后，执行任务程序时内存中标记好的对象引用关系被修改了\n\n![figure](10.png)\n\n修改后，没有灰色对象，新修改的白色对象 D 将在次轮 GC 的清理阶段被回收。为了解决这个问题， V8 增量回收使用 写屏障（Write-barrier）机制，一旦又黑色对象引用白色对象，该机制会强制将引用的白色对象改为灰色，保证下一次增量 GC 标记阶段可以正确标记，这个机制也称做 强三色不变性\n\n**惰性清理**\n\n增量标记其实只是对活动对象和非活动对象进行标记，对于真正的清理释放内存 V8 采用的是惰性清理（Lazy Sweeping）\n\n增量标记完成后，惰性清理就开始了。当增量标记完成后，假如当前的可用内存足以让我们快速的执行代码，其实我们是没必要立即清理内存的，可将清理过程稍微延迟一下，让 JavaScript 脚本代码先执行，也无需一次性清理完所有非活动对象的内存，可用按需逐一进行清理直到所有的非活动对象内存都清理完毕，后面再接着执行增量标记\n\n**增量标记与惰性清理的优缺**\n\n增量标记与惰性清理的出现，使得主线程的停顿时间大大减少了，让用户与浏览器交互的过程变得更加流畅。但是由于每个小的增量标记之间执行了 JavaScript 代码，堆中的对象指针可能发生变化，需要使用写屏障计数来记录引用关系的变化，所以增量标记缺点也很明显：\n\n首先是并没有减少主线程的总暂停时间，甚至会略微增加，其次由于写屏障机制的成本，增量标记可能会降低应用程序的吞吐量\n\n### 并发回收（Concurrent）\n\n并行回收依然会阻塞主线程，增量标记也会增加总暂停时间、降低应用程序吞吐量两个缺点。并发回收能在主线程执行 JavaScript 过程中，辅助线程能够在后台完成执行垃圾回收的操作，辅助线程在执行垃圾回收的时候，主线程也可以自由执行而不会被挂起\n\n![figure](11.png)\n\n辅助线程在执行垃圾回收的时候，主线程也可以自由执行而不会被挂起，这是并发的优点也是并发实现的难点，因为它需要考虑主线程在执行 JavaScript 时，堆中对象引用关系随时都有可能发生变化，这时辅助线程之前做的一些标记活着正在进行的标记就会有所改变，所以它需要额外实现一些读写锁机制来控制\n\n**V8 中 GC 优化**\n\n我们说过新生代垃圾回收器，使用并行回收可以很好的增加垃圾回收的效率，那老生代垃圾回收器是用哪种策略呢？上面说来并行回收、增量标记与惰性清理、并发回收这几种回收方式来提高效率、优化体验，其实老生代垃圾回收器都是融合使用的。\n\n老生代主要使用并发标记，主线程在开始执行 JavaScript 时，辅助线程也同时执行标记操作\n\n标记完成后，再执行并行清理操作\n\n同时，清理的任务会采用增量的方式分批在各个 JavaScript 任务间执行\n","slug":"GC-垃圾回收","published":1,"updated":"2022-07-18T12:13:28.178Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl5sb8gg4002vxq0r185a81dv","content":"<h3 id=\"GC-是什么\"><a href=\"#GC-是什么\" class=\"headerlink\" title=\"GC 是什么\"></a>GC 是什么</h3><p>Garbage Collection，程序工作过程中会产生很多垃圾，这些垃圾是程序不用的内存或者是之前用过了，以后不会再用的空间，而 GC 负责回收。不是所有的语言都有 GC，Java、JavaScript、Python 自带 GC；再比如 C、C++ 没有 GC，需要手动管理内存，相对麻烦</p>\n<h3 id=\"垃圾产生-amp-为何回收\"><a href=\"#垃圾产生-amp-为何回收\" class=\"headerlink\" title=\"垃圾产生&amp;为何回收\"></a>垃圾产生&amp;为何回收</h3><p>我们知道写代码时创建一个基本类型、对象、函数……都是需要占用内存的</p>\n<figure class=\"highlight jsx\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> test = &#123;</span><br><span class=\"line\">  name: <span class=\"string\">\"psilo\"</span>,</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">test = [<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>, <span class=\"number\">4</span>, <span class=\"number\">5</span>];</span><br></pre></td></tr></table></figure>\n\n<p>我们知道 JavaScript 的引用数据类型是保存在堆内存中，然后在栈内存中保存一个对堆内存中实际对象的引用。上图所示，{ name: ‘psilo’ } 对象没有了引用关系，如果不清理（回收），内存会越来越大。</p>\n<a id=\"more\"></a>\n\n<p><img src=\"//psilocine.github.io/2022/07/18/GC-垃圾回收/1.png\" alt=\"figure\"></p>\n<h3 id=\"垃圾回收策略\"><a href=\"#垃圾回收策略\" class=\"headerlink\" title=\"垃圾回收策略\"></a>垃圾回收策略</h3><p>在 JavaScript 中，垃圾回收的机制是定期找出不再用到的内存（变量），然后释放其内存。</p>\n<p>常见策略：</p>\n<ol>\n<li>标记清除</li>\n<li>引用计数</li>\n</ol>\n<h3 id=\"标记清除（Mark-Sweep）\"><a href=\"#标记清除（Mark-Sweep）\" class=\"headerlink\" title=\"标记清除（Mark-Sweep）\"></a>标记清除（Mark-Sweep）</h3><p>在 JavaScript 是最常用的，分别 标记 和 清除 两个阶段，标记阶段为所有活动对象做上标记，清除阶段则把没有标记的对象销毁。</p>\n<p>引擎在执行 GC 时，需要从出发点去遍历内存中所有的对象打标记，而这个出发点有很多，我们称之为一组 根 对象，而所谓的根对象，其实在浏览器环境中包括又不止于全局 Window 对象、文档 DOM 树 等。整个算法过程大致如下：</p>\n<ul>\n<li>垃圾收集器在运行时会给内存中的所有变量都加上一个标记，假设内存中所有对象都是垃圾，全标记为 0</li>\n<li>然后从各个根对象开始遍历，把不是垃圾的节点改成 1</li>\n<li>清理所有标记为 0 的垃圾，销毁并回收它们所占用的内存空间</li>\n<li>把所有内存中对象标记修改为 0，等待下一轮垃圾回收</li>\n</ul>\n<p><strong>优点：</strong></p>\n<p>实现比较简单，只需要一个二进制（0 和 1）位就可以标记</p>\n<p><strong>缺点：</strong></p>\n<p>清除后剩余对象的内存位置是不变的，导致空闲内存空间是不连续的，出现了 内存碎片，这就牵扯除了内存分配问题</p>\n<p><img src=\"//psilocine.github.io/2022/07/18/GC-垃圾回收/2.png\" alt=\"figure\"></p>\n<p>假设我们新建对象分配内存时需要大小为 size，由于空闲内存是间断的、不连续的，则需要对空间内存列表进行一次单向遍历找出大于等于 size 的块才能为其分配</p>\n<p><img src=\"//psilocine.github.io/2022/07/18/GC-垃圾回收/3.png\" alt=\"figure\"></p>\n<p>那如何找到合适的块呢？有三种分配策略：</p>\n<ul>\n<li>First-fit，找到大于等于 size 的块立即返回</li>\n<li>Best-fit，遍历整个空闲列表，返回大于等于 size 的最小分块</li>\n<li>Worst-fit，遍历整个空闲列表，找到最大的分块，然后切成两部分，一部分 size 大小，并将该部分返回</li>\n</ul>\n<p>看起来 Worst-fit 的空间利用率最合理，但实际上切分之后会造成更多的小块（回收后），形成内存碎片。对于 First-fit 和 Best-fit 来说，考虑分配的速度和效率 First-fit 才是更名明智的选择。</p>\n<p>综上所述，标记清除算法有两个缺点：</p>\n<ul>\n<li><strong>内存碎片化，</strong>空闲内存块是不连续的，容易出现很多空闲内存块</li>\n<li><strong>分配速度慢，</strong>即便是 First-fit，其操作仍是一个 O(n) 的操作</li>\n</ul>\n<p>归根结底，标记清除的缺点在于内存碎片化，<strong>标记整理（Mark-Compact）</strong>就可以有效地解决：在标记结束后，标记整理会将活着的对象向内存的一端移动，最后清理掉边界的内存</p>\n<p><img src=\"//psilocine.github.io/2022/07/18/GC-垃圾回收/4.png\" alt=\"figure\"></p>\n<h3 id=\"引用计数（Reference-Counting）\"><a href=\"#引用计数（Reference-Counting）\" class=\"headerlink\" title=\"引用计数（Reference Counting）\"></a>引用计数（Reference Counting）</h3><p>因为它问题很多，目前很少使用这种算法了。策略是跟踪记录每个变量值被使用的次数</p>\n<ul>\n<li>当声明一个变量并且将一个引用类型赋值给该变量的时候这个值的引用次数就为 1</li>\n<li>如果同一个值又被赋给另一个变量，那么引用数加 1</li>\n<li>如果该变量的值被其他的值覆盖了，则引用次数减 1</li>\n<li>当这个值引用次数变为 0 的时候，说明没有变量在使用，这个值没法被访问了，回收</li>\n</ul>\n<figure class=\"highlight jsx\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> a = <span class=\"keyword\">new</span> <span class=\"built_in\">Object</span>() \t<span class=\"comment\">// 此对象的引用计数为 1（a引用）</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> b = a \t\t<span class=\"comment\">// 此对象的引用计数是 2（a,b引用）</span></span><br><span class=\"line\">a = <span class=\"literal\">null</span>  \t\t<span class=\"comment\">// 此对象的引用计数为 1（b引用）</span></span><br><span class=\"line\">b = <span class=\"literal\">null</span> \t \t<span class=\"comment\">// 此对象的引用计数为 0（无引用）</span></span><br><span class=\"line\">...\t\t\t<span class=\"comment\">// GC 回收此对象</span></span><br></pre></td></tr></table></figure>\n\n<p>虽然看起来简单，但是有一个很严重的问题：循环引用，即：</p>\n<figure class=\"highlight jsx\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">test</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> A = <span class=\"keyword\">new</span> <span class=\"built_in\">Object</span>();</span><br><span class=\"line\">  <span class=\"keyword\">let</span> B = <span class=\"keyword\">new</span> <span class=\"built_in\">Object</span>();</span><br><span class=\"line\"></span><br><span class=\"line\">  A.b = B;</span><br><span class=\"line\">  B.a = A;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>按照上文的引用计数策略，对象 A 和 B 的引用数量都为 2，但是在 test 函数执行完是需要被清理的</p>\n<p><strong>优点</strong></p>\n<p>在引用值为 0 的时候可以立即被回收，而标记清除需要每隔一段时间进行，而且需要 JS 脚本暂停去执行 GC</p>\n<p><strong>缺点</strong></p>\n<p>需要一个很大内存的计数器，因为我们不知道被引用数量的上限；循环引用问题无法解决</p>\n<h3 id=\"V8-对-GC-的优化\"><a href=\"#V8-对-GC-的优化\" class=\"headerlink\" title=\"V8 对 GC 的优化\"></a>V8 对 GC 的优化</h3><p>V8 是基于标记清除算法，但是也做了一些优化</p>\n<p><strong>分代式垃圾回收</strong></p>\n<p>标记清除在每次回收时都要检查内存中所有对象，分代进行 GC 效率会更好，且一些大、老、存活时间厂的对象来说不需要频繁进行清理。</p>\n<p>V8 将堆内存分为新生代和老生代两区域，采用不同的 GC 策略管理</p>\n<p>新生代的对象为存活时间较短的对象，简单来说就是新产生的对象，通常只支持 1 ～ 8M 的容量，而老生代的对象为存活事件较长或常驻内存的对象。</p>\n<p><img src=\"//psilocine.github.io/2022/07/18/GC-垃圾回收/5.png\" alt=\"figure\"></p>\n<p><strong>新生代垃圾回收</strong></p>\n<p>通过一个 Scavenge 算法进行垃圾回收，将堆内存一分为二，一个是处于使用状态的空间我们暂且称为 使用区，一个是处于闲置状态的空间称之为 空闲区</p>\n<p><img src=\"//psilocine.github.io/2022/07/18/GC-垃圾回收/6.png\" alt=\"figure\"></p>\n<p>新加入的对象都会存放到使用区，当使用区快被写满时，就需要执行一次垃圾清理操作</p>\n<p>开始回收时，新生代垃圾回收器会对使用区中的活动对象做标记，标记完成后将使用区的活动对象复制进空闲区并进行排序，随后进入垃圾清理阶段，即将非活动对象占用的空间清理掉。最后进行角色互换，把原来的使用区变成空闲区，把原来的空闲区变成使用区</p>\n<p>当一个对象经过多次复制后依赖存活，它将会被认为是生命周期较长的对象，随后会被移动到老生代中，采用老生代的垃圾回收策略进行管理</p>\n<p>当复制一个对象到空闲区时，空闲区空间占用超过 25%，那么这个对象会被直接移动到老生代空间中，因为两个区域互换的时候，如果占比较大，会影响后续内存分配。</p>\n<p><strong>老生代垃圾回收</strong></p>\n<p>标记清除 + 标记整理</p>\n<p><strong>为什么需要分代式</strong></p>\n<p>分代式机制把一些新、小、存活时间短的对象作为新生代，采用一小块内存频率较高的快速清理，而一些大、老、存活时间较长的对象作为老生代，使其很少接受检查，新老生代的回收机制及频率是不同的，可以说此机制的出现很大程序提高了垃圾回收机制的效率</p>\n<p><strong>并行回收（Parallel）</strong></p>\n<p>在介绍并行之前，要了解 全停顿（Stop-The-World）概念，我们都知道 JavaScript 是一门单线程的语言，它是运行在主线程上的，那在进行垃圾回收时就会阻塞 JavaScript 脚本的执行，需等待垃圾回收完毕后再恢复脚本执行，称为全停顿</p>\n<p>比如一次 GC 需要 60ms，那我们的应用逻辑就得暂停 60ms，所谓并行，指的是垃圾回收器在主线程上执行的过程中，开启多个辅助线程，同时执行同样的回收工作</p>\n<p><img src=\"//psilocine.github.io/2022/07/18/GC-垃圾回收/7.png\" alt=\"figure\"></p>\n<p>简单来说，使用并行回收，加入本来主线程一个人干活，它需要 3s，现在叫上 2 个辅助线程一起干活，加上多人协同（同步开销）的时间（0.5s），本来需要 3s 的活现在 1.5s 就可以干完</p>\n<p>新生代对象空间就采用并行策略，在执行垃圾回收的过程中，会启动多个线程来负责新生代中的垃圾清理操作，这些线程同时将对象空间中的数据移动到空闲区域，这个过程中由于数据地址会发生改变，所以还需要同步更新引用这些对象的指针，即并行回收</p>\n<p><strong>增量标记与惰性清理</strong></p>\n<p>并行策略虽然可以增加垃圾回收的效率，对于新生代垃圾回收器能够有很好的优化，但是其实它还是一种全停顿式的垃圾回收方式，对于老生代来说，它的内部存放的都是一些比较大的对象，对于这些大的对象 GC 时哪怕我们使用并行策略依然会消耗大量时间</p>\n<p>所以为了减少全停顿的时间，在 2011 年，V8 对老生代的标记进行老优化，从全停顿标记切换到增量标记</p>\n<p><strong>什么是增量标记</strong></p>\n<p>增量就是将一次 GC 标记的过程，分成了很多小步，每执行完一小步就让应用逻辑执行一会，这样交替多次后完成一轮 GC</p>\n<p><img src=\"//psilocine.github.io/2022/07/18/GC-垃圾回收/8.png\" alt=\"figure\"></p>\n<p>将一次完整的 GC 标记分次执行，那么在每一小次 GC 标记执行完后如何暂停下来去执行任务程序，而后又怎么恢复呢？假如我们在一次完整的 GC 标记分块暂停后，执行任务程序时内存中标记好的对象引用关系被修改老又怎么办呢？V8 针对这两个问题对应的解决方案分别是 三色标记法 和 写屏障</p>\n<p><strong>三色标记法</strong></p>\n<p>我们知道老生代是采用标记清理算法，而上文的标记清理中我们说过，也就是在没有采用增量算法前，单纯使用黑色和白色来标记数据就可以来，在执行一次完整的 GC 标记前，垃圾回收器会将所有的数据置为白色，然后垃圾回收器在从一组根对象触发，将所有能访问到的数据标记为黑色，遍历结束后，标记为白色的对象就是待清理对象</p>\n<p>如果采用这种非黑即白的标记策略，那么在垃圾回收器执行来一段增量回收后，暂停启用主线程去执行应用程序中的一段 JavaScript 代码，随后当垃圾回收器再次被启动，这时候内存中黑白色都有，我们无法得知下一步走到哪里了</p>\n<p>三色标记法使用每个对象的两个标记位和一个标记工作表来实现标记，两个标记位编码三种颜色：白、灰、黑</p>\n<ul>\n<li>白色指的是未被标记的对象</li>\n<li>灰色指的是自身被标记，成员变量（该对象的引用对象）未被标记</li>\n<li>黑色指自身和成员皆被标记</li>\n</ul>\n<p><img src=\"//psilocine.github.io/2022/07/18/GC-垃圾回收/9.png\" alt=\"figure\"></p>\n<p>直到没有可标记灰色的对象时，那么剩下的白色对象就是无法到达的，等待回收（如上图 C、E）</p>\n<p><strong>写屏障（增量中修改引用）</strong></p>\n<p>一次完整的 GC 标记分块暂停后，执行任务程序时内存中标记好的对象引用关系被修改了</p>\n<p><img src=\"//psilocine.github.io/2022/07/18/GC-垃圾回收/10.png\" alt=\"figure\"></p>\n<p>修改后，没有灰色对象，新修改的白色对象 D 将在次轮 GC 的清理阶段被回收。为了解决这个问题， V8 增量回收使用 写屏障（Write-barrier）机制，一旦又黑色对象引用白色对象，该机制会强制将引用的白色对象改为灰色，保证下一次增量 GC 标记阶段可以正确标记，这个机制也称做 强三色不变性</p>\n<p><strong>惰性清理</strong></p>\n<p>增量标记其实只是对活动对象和非活动对象进行标记，对于真正的清理释放内存 V8 采用的是惰性清理（Lazy Sweeping）</p>\n<p>增量标记完成后，惰性清理就开始了。当增量标记完成后，假如当前的可用内存足以让我们快速的执行代码，其实我们是没必要立即清理内存的，可将清理过程稍微延迟一下，让 JavaScript 脚本代码先执行，也无需一次性清理完所有非活动对象的内存，可用按需逐一进行清理直到所有的非活动对象内存都清理完毕，后面再接着执行增量标记</p>\n<p><strong>增量标记与惰性清理的优缺</strong></p>\n<p>增量标记与惰性清理的出现，使得主线程的停顿时间大大减少了，让用户与浏览器交互的过程变得更加流畅。但是由于每个小的增量标记之间执行了 JavaScript 代码，堆中的对象指针可能发生变化，需要使用写屏障计数来记录引用关系的变化，所以增量标记缺点也很明显：</p>\n<p>首先是并没有减少主线程的总暂停时间，甚至会略微增加，其次由于写屏障机制的成本，增量标记可能会降低应用程序的吞吐量</p>\n<h3 id=\"并发回收（Concurrent）\"><a href=\"#并发回收（Concurrent）\" class=\"headerlink\" title=\"并发回收（Concurrent）\"></a>并发回收（Concurrent）</h3><p>并行回收依然会阻塞主线程，增量标记也会增加总暂停时间、降低应用程序吞吐量两个缺点。并发回收能在主线程执行 JavaScript 过程中，辅助线程能够在后台完成执行垃圾回收的操作，辅助线程在执行垃圾回收的时候，主线程也可以自由执行而不会被挂起</p>\n<p><img src=\"//psilocine.github.io/2022/07/18/GC-垃圾回收/11.png\" alt=\"figure\"></p>\n<p>辅助线程在执行垃圾回收的时候，主线程也可以自由执行而不会被挂起，这是并发的优点也是并发实现的难点，因为它需要考虑主线程在执行 JavaScript 时，堆中对象引用关系随时都有可能发生变化，这时辅助线程之前做的一些标记活着正在进行的标记就会有所改变，所以它需要额外实现一些读写锁机制来控制</p>\n<p><strong>V8 中 GC 优化</strong></p>\n<p>我们说过新生代垃圾回收器，使用并行回收可以很好的增加垃圾回收的效率，那老生代垃圾回收器是用哪种策略呢？上面说来并行回收、增量标记与惰性清理、并发回收这几种回收方式来提高效率、优化体验，其实老生代垃圾回收器都是融合使用的。</p>\n<p>老生代主要使用并发标记，主线程在开始执行 JavaScript 时，辅助线程也同时执行标记操作</p>\n<p>标记完成后，再执行并行清理操作</p>\n<p>同时，清理的任务会采用增量的方式分批在各个 JavaScript 任务间执行</p>\n","site":{"data":{}},"excerpt":"<h3 id=\"GC-是什么\"><a href=\"#GC-是什么\" class=\"headerlink\" title=\"GC 是什么\"></a>GC 是什么</h3><p>Garbage Collection，程序工作过程中会产生很多垃圾，这些垃圾是程序不用的内存或者是之前用过了，以后不会再用的空间，而 GC 负责回收。不是所有的语言都有 GC，Java、JavaScript、Python 自带 GC；再比如 C、C++ 没有 GC，需要手动管理内存，相对麻烦</p>\n<h3 id=\"垃圾产生-amp-为何回收\"><a href=\"#垃圾产生-amp-为何回收\" class=\"headerlink\" title=\"垃圾产生&amp;为何回收\"></a>垃圾产生&amp;为何回收</h3><p>我们知道写代码时创建一个基本类型、对象、函数……都是需要占用内存的</p>\n<figure class=\"highlight jsx\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> test = &#123;</span><br><span class=\"line\">  name: <span class=\"string\">\"psilo\"</span>,</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">test = [<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>, <span class=\"number\">4</span>, <span class=\"number\">5</span>];</span><br></pre></td></tr></table></figure>\n\n<p>我们知道 JavaScript 的引用数据类型是保存在堆内存中，然后在栈内存中保存一个对堆内存中实际对象的引用。上图所示，{ name: ‘psilo’ } 对象没有了引用关系，如果不清理（回收），内存会越来越大。</p>","more":"<p><img src=\"//psilocine.github.io/2022/07/18/GC-垃圾回收/1.png\" alt=\"figure\"></p>\n<h3 id=\"垃圾回收策略\"><a href=\"#垃圾回收策略\" class=\"headerlink\" title=\"垃圾回收策略\"></a>垃圾回收策略</h3><p>在 JavaScript 中，垃圾回收的机制是定期找出不再用到的内存（变量），然后释放其内存。</p>\n<p>常见策略：</p>\n<ol>\n<li>标记清除</li>\n<li>引用计数</li>\n</ol>\n<h3 id=\"标记清除（Mark-Sweep）\"><a href=\"#标记清除（Mark-Sweep）\" class=\"headerlink\" title=\"标记清除（Mark-Sweep）\"></a>标记清除（Mark-Sweep）</h3><p>在 JavaScript 是最常用的，分别 标记 和 清除 两个阶段，标记阶段为所有活动对象做上标记，清除阶段则把没有标记的对象销毁。</p>\n<p>引擎在执行 GC 时，需要从出发点去遍历内存中所有的对象打标记，而这个出发点有很多，我们称之为一组 根 对象，而所谓的根对象，其实在浏览器环境中包括又不止于全局 Window 对象、文档 DOM 树 等。整个算法过程大致如下：</p>\n<ul>\n<li>垃圾收集器在运行时会给内存中的所有变量都加上一个标记，假设内存中所有对象都是垃圾，全标记为 0</li>\n<li>然后从各个根对象开始遍历，把不是垃圾的节点改成 1</li>\n<li>清理所有标记为 0 的垃圾，销毁并回收它们所占用的内存空间</li>\n<li>把所有内存中对象标记修改为 0，等待下一轮垃圾回收</li>\n</ul>\n<p><strong>优点：</strong></p>\n<p>实现比较简单，只需要一个二进制（0 和 1）位就可以标记</p>\n<p><strong>缺点：</strong></p>\n<p>清除后剩余对象的内存位置是不变的，导致空闲内存空间是不连续的，出现了 内存碎片，这就牵扯除了内存分配问题</p>\n<p><img src=\"//psilocine.github.io/2022/07/18/GC-垃圾回收/2.png\" alt=\"figure\"></p>\n<p>假设我们新建对象分配内存时需要大小为 size，由于空闲内存是间断的、不连续的，则需要对空间内存列表进行一次单向遍历找出大于等于 size 的块才能为其分配</p>\n<p><img src=\"//psilocine.github.io/2022/07/18/GC-垃圾回收/3.png\" alt=\"figure\"></p>\n<p>那如何找到合适的块呢？有三种分配策略：</p>\n<ul>\n<li>First-fit，找到大于等于 size 的块立即返回</li>\n<li>Best-fit，遍历整个空闲列表，返回大于等于 size 的最小分块</li>\n<li>Worst-fit，遍历整个空闲列表，找到最大的分块，然后切成两部分，一部分 size 大小，并将该部分返回</li>\n</ul>\n<p>看起来 Worst-fit 的空间利用率最合理，但实际上切分之后会造成更多的小块（回收后），形成内存碎片。对于 First-fit 和 Best-fit 来说，考虑分配的速度和效率 First-fit 才是更名明智的选择。</p>\n<p>综上所述，标记清除算法有两个缺点：</p>\n<ul>\n<li><strong>内存碎片化，</strong>空闲内存块是不连续的，容易出现很多空闲内存块</li>\n<li><strong>分配速度慢，</strong>即便是 First-fit，其操作仍是一个 O(n) 的操作</li>\n</ul>\n<p>归根结底，标记清除的缺点在于内存碎片化，<strong>标记整理（Mark-Compact）</strong>就可以有效地解决：在标记结束后，标记整理会将活着的对象向内存的一端移动，最后清理掉边界的内存</p>\n<p><img src=\"//psilocine.github.io/2022/07/18/GC-垃圾回收/4.png\" alt=\"figure\"></p>\n<h3 id=\"引用计数（Reference-Counting）\"><a href=\"#引用计数（Reference-Counting）\" class=\"headerlink\" title=\"引用计数（Reference Counting）\"></a>引用计数（Reference Counting）</h3><p>因为它问题很多，目前很少使用这种算法了。策略是跟踪记录每个变量值被使用的次数</p>\n<ul>\n<li>当声明一个变量并且将一个引用类型赋值给该变量的时候这个值的引用次数就为 1</li>\n<li>如果同一个值又被赋给另一个变量，那么引用数加 1</li>\n<li>如果该变量的值被其他的值覆盖了，则引用次数减 1</li>\n<li>当这个值引用次数变为 0 的时候，说明没有变量在使用，这个值没法被访问了，回收</li>\n</ul>\n<figure class=\"highlight jsx\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> a = <span class=\"keyword\">new</span> <span class=\"built_in\">Object</span>() \t<span class=\"comment\">// 此对象的引用计数为 1（a引用）</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> b = a \t\t<span class=\"comment\">// 此对象的引用计数是 2（a,b引用）</span></span><br><span class=\"line\">a = <span class=\"literal\">null</span>  \t\t<span class=\"comment\">// 此对象的引用计数为 1（b引用）</span></span><br><span class=\"line\">b = <span class=\"literal\">null</span> \t \t<span class=\"comment\">// 此对象的引用计数为 0（无引用）</span></span><br><span class=\"line\">...\t\t\t<span class=\"comment\">// GC 回收此对象</span></span><br></pre></td></tr></table></figure>\n\n<p>虽然看起来简单，但是有一个很严重的问题：循环引用，即：</p>\n<figure class=\"highlight jsx\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">test</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> A = <span class=\"keyword\">new</span> <span class=\"built_in\">Object</span>();</span><br><span class=\"line\">  <span class=\"keyword\">let</span> B = <span class=\"keyword\">new</span> <span class=\"built_in\">Object</span>();</span><br><span class=\"line\"></span><br><span class=\"line\">  A.b = B;</span><br><span class=\"line\">  B.a = A;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>按照上文的引用计数策略，对象 A 和 B 的引用数量都为 2，但是在 test 函数执行完是需要被清理的</p>\n<p><strong>优点</strong></p>\n<p>在引用值为 0 的时候可以立即被回收，而标记清除需要每隔一段时间进行，而且需要 JS 脚本暂停去执行 GC</p>\n<p><strong>缺点</strong></p>\n<p>需要一个很大内存的计数器，因为我们不知道被引用数量的上限；循环引用问题无法解决</p>\n<h3 id=\"V8-对-GC-的优化\"><a href=\"#V8-对-GC-的优化\" class=\"headerlink\" title=\"V8 对 GC 的优化\"></a>V8 对 GC 的优化</h3><p>V8 是基于标记清除算法，但是也做了一些优化</p>\n<p><strong>分代式垃圾回收</strong></p>\n<p>标记清除在每次回收时都要检查内存中所有对象，分代进行 GC 效率会更好，且一些大、老、存活时间厂的对象来说不需要频繁进行清理。</p>\n<p>V8 将堆内存分为新生代和老生代两区域，采用不同的 GC 策略管理</p>\n<p>新生代的对象为存活时间较短的对象，简单来说就是新产生的对象，通常只支持 1 ～ 8M 的容量，而老生代的对象为存活事件较长或常驻内存的对象。</p>\n<p><img src=\"//psilocine.github.io/2022/07/18/GC-垃圾回收/5.png\" alt=\"figure\"></p>\n<p><strong>新生代垃圾回收</strong></p>\n<p>通过一个 Scavenge 算法进行垃圾回收，将堆内存一分为二，一个是处于使用状态的空间我们暂且称为 使用区，一个是处于闲置状态的空间称之为 空闲区</p>\n<p><img src=\"//psilocine.github.io/2022/07/18/GC-垃圾回收/6.png\" alt=\"figure\"></p>\n<p>新加入的对象都会存放到使用区，当使用区快被写满时，就需要执行一次垃圾清理操作</p>\n<p>开始回收时，新生代垃圾回收器会对使用区中的活动对象做标记，标记完成后将使用区的活动对象复制进空闲区并进行排序，随后进入垃圾清理阶段，即将非活动对象占用的空间清理掉。最后进行角色互换，把原来的使用区变成空闲区，把原来的空闲区变成使用区</p>\n<p>当一个对象经过多次复制后依赖存活，它将会被认为是生命周期较长的对象，随后会被移动到老生代中，采用老生代的垃圾回收策略进行管理</p>\n<p>当复制一个对象到空闲区时，空闲区空间占用超过 25%，那么这个对象会被直接移动到老生代空间中，因为两个区域互换的时候，如果占比较大，会影响后续内存分配。</p>\n<p><strong>老生代垃圾回收</strong></p>\n<p>标记清除 + 标记整理</p>\n<p><strong>为什么需要分代式</strong></p>\n<p>分代式机制把一些新、小、存活时间短的对象作为新生代，采用一小块内存频率较高的快速清理，而一些大、老、存活时间较长的对象作为老生代，使其很少接受检查，新老生代的回收机制及频率是不同的，可以说此机制的出现很大程序提高了垃圾回收机制的效率</p>\n<p><strong>并行回收（Parallel）</strong></p>\n<p>在介绍并行之前，要了解 全停顿（Stop-The-World）概念，我们都知道 JavaScript 是一门单线程的语言，它是运行在主线程上的，那在进行垃圾回收时就会阻塞 JavaScript 脚本的执行，需等待垃圾回收完毕后再恢复脚本执行，称为全停顿</p>\n<p>比如一次 GC 需要 60ms，那我们的应用逻辑就得暂停 60ms，所谓并行，指的是垃圾回收器在主线程上执行的过程中，开启多个辅助线程，同时执行同样的回收工作</p>\n<p><img src=\"//psilocine.github.io/2022/07/18/GC-垃圾回收/7.png\" alt=\"figure\"></p>\n<p>简单来说，使用并行回收，加入本来主线程一个人干活，它需要 3s，现在叫上 2 个辅助线程一起干活，加上多人协同（同步开销）的时间（0.5s），本来需要 3s 的活现在 1.5s 就可以干完</p>\n<p>新生代对象空间就采用并行策略，在执行垃圾回收的过程中，会启动多个线程来负责新生代中的垃圾清理操作，这些线程同时将对象空间中的数据移动到空闲区域，这个过程中由于数据地址会发生改变，所以还需要同步更新引用这些对象的指针，即并行回收</p>\n<p><strong>增量标记与惰性清理</strong></p>\n<p>并行策略虽然可以增加垃圾回收的效率，对于新生代垃圾回收器能够有很好的优化，但是其实它还是一种全停顿式的垃圾回收方式，对于老生代来说，它的内部存放的都是一些比较大的对象，对于这些大的对象 GC 时哪怕我们使用并行策略依然会消耗大量时间</p>\n<p>所以为了减少全停顿的时间，在 2011 年，V8 对老生代的标记进行老优化，从全停顿标记切换到增量标记</p>\n<p><strong>什么是增量标记</strong></p>\n<p>增量就是将一次 GC 标记的过程，分成了很多小步，每执行完一小步就让应用逻辑执行一会，这样交替多次后完成一轮 GC</p>\n<p><img src=\"//psilocine.github.io/2022/07/18/GC-垃圾回收/8.png\" alt=\"figure\"></p>\n<p>将一次完整的 GC 标记分次执行，那么在每一小次 GC 标记执行完后如何暂停下来去执行任务程序，而后又怎么恢复呢？假如我们在一次完整的 GC 标记分块暂停后，执行任务程序时内存中标记好的对象引用关系被修改老又怎么办呢？V8 针对这两个问题对应的解决方案分别是 三色标记法 和 写屏障</p>\n<p><strong>三色标记法</strong></p>\n<p>我们知道老生代是采用标记清理算法，而上文的标记清理中我们说过，也就是在没有采用增量算法前，单纯使用黑色和白色来标记数据就可以来，在执行一次完整的 GC 标记前，垃圾回收器会将所有的数据置为白色，然后垃圾回收器在从一组根对象触发，将所有能访问到的数据标记为黑色，遍历结束后，标记为白色的对象就是待清理对象</p>\n<p>如果采用这种非黑即白的标记策略，那么在垃圾回收器执行来一段增量回收后，暂停启用主线程去执行应用程序中的一段 JavaScript 代码，随后当垃圾回收器再次被启动，这时候内存中黑白色都有，我们无法得知下一步走到哪里了</p>\n<p>三色标记法使用每个对象的两个标记位和一个标记工作表来实现标记，两个标记位编码三种颜色：白、灰、黑</p>\n<ul>\n<li>白色指的是未被标记的对象</li>\n<li>灰色指的是自身被标记，成员变量（该对象的引用对象）未被标记</li>\n<li>黑色指自身和成员皆被标记</li>\n</ul>\n<p><img src=\"//psilocine.github.io/2022/07/18/GC-垃圾回收/9.png\" alt=\"figure\"></p>\n<p>直到没有可标记灰色的对象时，那么剩下的白色对象就是无法到达的，等待回收（如上图 C、E）</p>\n<p><strong>写屏障（增量中修改引用）</strong></p>\n<p>一次完整的 GC 标记分块暂停后，执行任务程序时内存中标记好的对象引用关系被修改了</p>\n<p><img src=\"//psilocine.github.io/2022/07/18/GC-垃圾回收/10.png\" alt=\"figure\"></p>\n<p>修改后，没有灰色对象，新修改的白色对象 D 将在次轮 GC 的清理阶段被回收。为了解决这个问题， V8 增量回收使用 写屏障（Write-barrier）机制，一旦又黑色对象引用白色对象，该机制会强制将引用的白色对象改为灰色，保证下一次增量 GC 标记阶段可以正确标记，这个机制也称做 强三色不变性</p>\n<p><strong>惰性清理</strong></p>\n<p>增量标记其实只是对活动对象和非活动对象进行标记，对于真正的清理释放内存 V8 采用的是惰性清理（Lazy Sweeping）</p>\n<p>增量标记完成后，惰性清理就开始了。当增量标记完成后，假如当前的可用内存足以让我们快速的执行代码，其实我们是没必要立即清理内存的，可将清理过程稍微延迟一下，让 JavaScript 脚本代码先执行，也无需一次性清理完所有非活动对象的内存，可用按需逐一进行清理直到所有的非活动对象内存都清理完毕，后面再接着执行增量标记</p>\n<p><strong>增量标记与惰性清理的优缺</strong></p>\n<p>增量标记与惰性清理的出现，使得主线程的停顿时间大大减少了，让用户与浏览器交互的过程变得更加流畅。但是由于每个小的增量标记之间执行了 JavaScript 代码，堆中的对象指针可能发生变化，需要使用写屏障计数来记录引用关系的变化，所以增量标记缺点也很明显：</p>\n<p>首先是并没有减少主线程的总暂停时间，甚至会略微增加，其次由于写屏障机制的成本，增量标记可能会降低应用程序的吞吐量</p>\n<h3 id=\"并发回收（Concurrent）\"><a href=\"#并发回收（Concurrent）\" class=\"headerlink\" title=\"并发回收（Concurrent）\"></a>并发回收（Concurrent）</h3><p>并行回收依然会阻塞主线程，增量标记也会增加总暂停时间、降低应用程序吞吐量两个缺点。并发回收能在主线程执行 JavaScript 过程中，辅助线程能够在后台完成执行垃圾回收的操作，辅助线程在执行垃圾回收的时候，主线程也可以自由执行而不会被挂起</p>\n<p><img src=\"//psilocine.github.io/2022/07/18/GC-垃圾回收/11.png\" alt=\"figure\"></p>\n<p>辅助线程在执行垃圾回收的时候，主线程也可以自由执行而不会被挂起，这是并发的优点也是并发实现的难点，因为它需要考虑主线程在执行 JavaScript 时，堆中对象引用关系随时都有可能发生变化，这时辅助线程之前做的一些标记活着正在进行的标记就会有所改变，所以它需要额外实现一些读写锁机制来控制</p>\n<p><strong>V8 中 GC 优化</strong></p>\n<p>我们说过新生代垃圾回收器，使用并行回收可以很好的增加垃圾回收的效率，那老生代垃圾回收器是用哪种策略呢？上面说来并行回收、增量标记与惰性清理、并发回收这几种回收方式来提高效率、优化体验，其实老生代垃圾回收器都是融合使用的。</p>\n<p>老生代主要使用并发标记，主线程在开始执行 JavaScript 时，辅助线程也同时执行标记操作</p>\n<p>标记完成后，再执行并行清理操作</p>\n<p>同时，清理的任务会采用增量的方式分批在各个 JavaScript 任务间执行</p>"},{"title":"JSON必知必会","date":"2017-09-13T12:19:04.000Z","_content":"##### 写在前面\n文章标题和O'Reilly动物书同名, 记录这本书的一些重点(个人觉得)\n\n### 什么是JSON\nJSON是一种数据交换格式\n\n### JSON语法\n1. JSON基于JavaScript对象字面量, 用{}或[]包裹.\n2. JSON采用(键:值)来表示, 键值对可以是字符串, 数字, 布尔值, null, 数组, 对象. 字符串必须用双引号包裹起来, 不能用单引号, 也不能用引号.\n3. 正确的JSON语法. 一般为了JSON的可移植性, 键最好不要在字符串中使用空格或特殊字符即[a-zA-Z0-9]其他的字符. 如\"my girl\"写成\"myGirl\", \"Psilo's blog\"写成\"psilosBlog\".\n4. JSON文件的后缀是.json\n\n### JSON的数据类型\n\n* 对象数据类型\n\n<!--more-->\n```json\n{\n  \"person\": {\n    \"name\": \"Psilo\",\n    \"age\": 23,\n    \"head\": {\n      \"hair\": {\n        \"color\": \"black\",\n        \"length\": \"short\"\n      },\n      \"eyes\": \"brown\"\n    }\n  }\n}\n```\n\n* 字符串类型, 需要转义的字符还是要转义, 另外JSON中没有制表符\\t和换行符\\n\n\n```json\n{\n  \"animal\": \"cat\"\n  \"promo\": \"Say \\\"Hello\\\" to China.\" \n}\n```\n\n* 数字类型, json中的数字可以是正数, 小数, 负数或者指数. 指数常常用科学表示法来表示.\n\n```json\n{\n  \"widgetInventory\": 289,\n  \"savingsAccount\": 22.59,\n  \"earthsMass\": 5.97219e+24\n}\n```\n\n* 布尔类型, json中用小写的true false表示布尔值.\n\n```json\n{\n  \"tea\": false,\n  \"coffee\": true\n}\n```\n\n* null类型, null表示不存在, 没有. 与0的意义不同, 0是数字.\n\n```json\n{\n  \"person\": {\n    \"name\": \"psilo\",\n    \"car\": null\n  }\n}\n```\n\n* 数组类型, 一个放了一些鸡蛋的容器, 拿走了两个鸡蛋, 就成了第二个json, 把5将最后一个鸡蛋替换掉, 并不会报错, 成了第三个json, 这是因为JavaScript是弱语言, 基本类型可以任意改变\n\n```json\n{\n  \"eggCarton\": [\n    \"egg\",\n    \"egg\",\n    \"egg\",\n    \"egg\",\n    \"egg\",\n    \"egg\",\n    \"egg\",\n    \"egg\",\n  ]\n}\n{\n  \"eggCarton\": [\n    \"egg\",\n    null,\n    \"egg\",\n    \"egg\",\n    \"egg\",\n    \"egg\",\n    null,\n    \"egg\",\n  ]\n}\n{\n  \"eggCarton\": [\n    \"egg\",\n    null,\n    \"egg\",\n    \"egg\",\n    \"egg\",\n    \"egg\",\n    null,\n    5,\n  ]\n}\n```\n\n### JSON Schema\n数据交换中的一种虚拟的\"合同\", JSON Schema是数据接收方的第一道防线, 也是数据发送方节约时间保证数据正确的工具.\n```json\n// 验证猫的JSON   注意:JSON里不能写注释\n{\n  \"$schema\": \"http://json-schema.org/draft-04/schema#\",\n  \"title\": \"Cat\",\n  \"properties\": {\n    \"name\": {\n      \"type\": \"string\",\n      \"minLength\": 3,\n      \"maxLength\": 20\n    },\n    \"age\": {\n      \"type\": \"number\",\n      \"description\": \"Your cat's age in years.\",\n      \"minimun\": 0\n    },\n    \"description\": {\n      \"type\": \"string\"\n    }\n  },\n  \"required\": [ // JSON必须要有的属性\n    \"name\",\n    \"age\"\n  ]\n}\n不能通过验证的JSON\n{\n  \"name\": \"Fluffy the greatest cat in thewhole wide world\",\n  \"age\": -2,\n  \"description\": \"Fluffy loves to sleep all day.\"\n}\n名字太长; 年龄小于0.\n能通过验证的JSON\n{\n  \"name\": \"Fluffy\",\n  \"age\": 3\n}\n```\n\n### JSON中的安全问题\n跨站请求伪造CSRF和跨站脚本攻击CSS\n#### 跨站请求伪造: 利用站点对用户浏览器的信任进行的攻击.\n1. 不要使用顶级数组. 顶级数组是合法的JavaScript脚本, 他们可以用script标签链接并使用.\n2. 对于不想公开的资源, 仅允许使用HTTP POST方法请求, 而不是GET方法. GET方法可以用过URL来请求, 甚至可以放在script标签中.\n```json\n[\n  {\n    \"user\": \"psilo\"\n  },\n  {\n    \"phone\": \"555-555-5555\"\n  }\n]\n// 将数组存放到对象之中, 这样说的非法的JavaScript, 不会被script变迁加载\n{\n  \"info\": [\n    {\n      \"user\": \"psilo\"\n    },\n    {\n      \"phone\": \"555-555-5555\"\n    }\n  ]\n}\n```\n#### 跨站脚本攻击: 通过截取或将站点中所使用的第三方代码更换为恶意脚本, 来对站点进行的一种注入攻击.\n1. 使用JSON.parse()来代替eval(). eval()函数会将传入的字符串编译并执行, 这会让你的代码易被攻击. 应仅适用JSON.parse()来解析JSON数据.\n\n### JavaScript中的XMLHttpRequest与Web API\nXMLHttpRequest负责在客户端发起请求, 而Web API负责在服务端返回响应\n\n#### JavaScript中的XMLHttpRequest对象\n```JavaScript\n// XMLHttpRequest对象用法\nvar xml = new XMLHttpRequest();\nxml.open(method, url, async(可选), user(可选), password(可选));\nxml.send();\n\n// XMLHttpRequest对象的一些属性\n// 可以在代码中给它负值为一个函数\nonreadystatechange \n/* 返回一个0-4的值, 用来表示状态码\n * 0表示open()函数还没有执行.\n * 1表示open()已执行, 但send()函数还没有执行\n * 2表示send()函数已执行切头部和状态码都可以获取了\n * 3表示头部已经收到, 但响应体正在解析中\n * 4表示请求完成, 包括响应头和响应体的内容都已经接受到了\n*/\nreadyState\n// 返回HTTP状态码 如200\nstatus\n// 当请求成功时, 该属性会包含作为文本的响应体\nresponseText \n\n// eg\nvar xml = new XMLHttpRequest();\nvar url = \"http://api.openweathermap.org/data/2.5/weather?lat=35&lon=139\";\n\nxml.onreadystatechange = function() {\n  if(xml.readyState == 4 && xml.status == 200) {\n    var myObject = JSON.parse(xml.responseText);\n    var myJson = JSON.stringify(myObject);\n  }\n}\n\nxml.openk(\"GET\", url, true);\nxml.send();\n```\n很明显, url的地址和请求的地址不太可能是同一域名, 显然这违背了同源策略, 所以我们需要资源共享. 有些开发人员可以持续多年通过JavaScript的AJAX技术向公共API发送请求, 而不会收到同源策略的影响, 这是因为这些公共API的开发者在他们的服务器上实现了跨域资源共享CORS. 这些服务器会在响应头额外加上一些带有Access-Control-Allow前缀的属性. 如Access-Control-Allow-Origin:*; 定义了任意域名都是允许使用的. 之前跨站请求伪造也可以通过在其响应头加入具体站点域名来禁止其他站点去获取资源, 这样script里的站点地址也就失效了.\n\n#### JSONP\n带有padding的JSON. 将JavaScript加入JSON文档, 内联与JSON文档的JavaScript调用一个函数, 函数参数是JSON. 函数参数提供了一种将数据传递给函数的方式. JSON-P还需要服务端的不少支持,  因为JSON资源必须包含JavaScript内联..\n\n### JSON与客户端框架\n框架可以节省时间, 让我们更专注于功能的构建. \n#### jQuery\njQuery是一种允许开发者专注于操作DOM构建功能的抽象化工具. 如JSON.parse(), 在老版本的IE, Firefox, chrome并不支持. jQuery帮我们解决了大部分兼容问题.\n```JavaScript\nvar myAnimal = JSON.parse('{ \"animal\": \"cat\"}'); // 有兼容问题\n\n// jQuery内置的方法来解析JSON\nvar myAnimal = jQuery.parseJSON('{\"animal\": \"cat\"}');\n\n// 用JQuery创建新的XMLHttpRequest对象, 并从OpenWeatherMap API 获取JSON\nvar url = \"http://api.openweathermap.org/data/2.5/weather?lat=35&lon=139\";\n$.getJSON(url, function(data) {\n  // 对天气数据操作\n})\n```\n#### AngularJS\nAngularJS是为DOM操作服务的抽象化工具, 专注单页Web应用的开发. 是基于实现MVC构架概念的框架. \n```JavaScript\n/* MVC\n * JSON是模型\n * HTML是试图\n * 控制器是使用AngularJS语法来定义和操作与模型和试图间的交互的JavaScript文件.\n */\n// 从OpenWeatherMap API获取天气数据\nangular.module('myApp', []).controller('myAppController', function($scope, $http) {\n  $http.get(\"http://api.openweathermap.org/data/2.5/weather?lat=35&lon=139\").success(function(data, status, headers, config) {\n    $scope.weatherData = data;\n  });\n});\n```\n从OpenWeatherMap API返回的JSON数据会被$http反序列化, 然后将名为wetherData的对象呗添加到全局作用域. 这样就能通过HTML试图的插值语法将其作为数据模型进行绑定了.\n\n### JSON与NoSQL\nSQL: 关系型数据库, 使用表格, 行和列来以结构化形式存储数据的. NoSQL: 顾名思义, 不是关系型数据库, 它可以是键值对存储.\n#### CouchDB: 使用JSON文档存储数据的文档存储数据库的NoSQL数据库\n在关系型数据库中, 对于一个账户对应多个地址这种一对多的关系, 需要执行联合查询, 以便把数据放在一起. 有了CouchDB, 数据就不需要因为它们之间的关系而被分开存储, 也不需要再读取时进行重组.\n```json\n{\n  \"firstName\": \"Bob\",\n  \"lastName\": \"Barker\",\n  \"age\": \"91\",\n  \"addresses\": [\n    {\n      \"street\": \"123 fake st\",\n      \"city\": \"somewhere\"\n    },\n    {\n      \"street\": \"456 fakey ln\",\n      \"city\": \"some place\"\n    }\n  ]\n}\n```\n由于CouchDB使用文档来存储数据, 因此从数据库查询一个账户时, 得到的直接就是一个结构化文档, 没有必要进行重组. 另一个好处是有利于数据的变化, 有些数据会随着时间而发生变化, 如电话号码, 当账户将来又有了新的号码, 只需要将其加入存储电话的数据即可\n\n#### CouchDB API\n对于HTTP, 我们是通过URL的方式来请求资源的, 从CouchDB API中请求的资源是一份JSON文档\n```json\n// 本地名为accounts的数据库\n// http://localhost:8080/accounts\n{\n  \"db_name\": \"accounts\",\n  \"doc_count\": 3,\n  \"doc_del_count\": 0,\n  \"update_seq\": 7,\n  \"purge_seq\": 0,\n  \"compact_running\": false,\n  \"disk_size\": 29999,\n  \"data_size\": 1222,\n  \"instance_start_time\": \"1432493477586600\",\n  \"disk_format_version\": 6,\n  \"committed_update_seq\": 7\n}\n// 其中的\"doc_count\"表示数据库中包含多少份文档. 这里是3份, 可以通过每个文档的位移标识符来对其进行查询,可以通过http://localhost:8080/accounts/_all_docs这一URL来获取行标识符数组. 如标识符是3636fa3c716f9dd4f7407bd6f7000552. 访问http://localhost:8080/accounts/3636fa3c716f9dd4f7407bd6f7000552可得以下JSON资源\n{\n  \"_id\": \"3636fa3c716f9dd4f7407bd6f7000552\",\n  \"_rev\": \"1-8a9527cbfc22e28984dfb3a3e6062635\",\n  \"firstName\": \"Billy\",\n  \"lastName\": \"Bob\",\n  \"age\": \"91\",\n  \"addresses\": [\n    {\n      \"street\": \"123 fake st\",\n      \"city\": \"somewhere\"\n    },\n    {\n      \"street\": \"456 fakey ln\",\n      \"city\": \"some place\"\n    }\n  ]\n}\n// 上述是从CouchDB数据库请求数据, 下面说说如何向数据库发送数据\n// 通过向http://localhost:8080/accounts/这一URL post数据来实现\n// 通过post方法请求 http://localhost:8080/accounts/的HTTP请求头\nPOST /accounts/ HTTP/1.1\nHost: localhost:8080\nContent_type: application/json\nCache-control: no-cache\n// 通过post方法请求 http://localhost:8080/accounts/ 的HTTP请求体\n{\n  \"firstName\": \"Psilo\",\n  \"lastName\": \"Lau\",\n  \"age\": \"18\",\n  \"addresses\": [\n    {\n      \"street\": \"1234 fake st\",\n      \"city\": \"somehwhere\"\n    },\n    {\n      \"street\": \"4567 fakey ln\",\n      \"city\": \"some place\"\n    }\n  ]  \n}\n// http请求成功后, CounchDB API会将JSON格式的相应信息发送给你, 其中包含了新创建的文档的标识符.\n{\n  \"ok\": true,\n  \"id\": \"3asd564sa6451654v6sd4v6d4asv6\",\n  \"rev\": \"1-as564ff6sd31v6asd54v6ads4v\"\n}\n// 这时候可以用心的标识符来创建URL, 并从账户数据库中请求JSON文档.\n// http://localhost:8080/accounts/3asd564sa6451654v6sd4v6d4asv6的响应\n{\n  \"_id\": \"3asd564sa6451654v6sd4v6d4asv6\",\n  \"_rev\": \"1-as564ff6sd31v6asd54v6ads4v\",\n  \"firstName\": \"Psilo\",\n  \"lastName\": \"Lau\",\n  \"age\": \"18\",\n  \"addresses\": [\n    {\n      \"street\": \"1234 fake st\",\n      \"city\": \"somehwhere\"\n    },\n    {\n      \"street\": \"4567 fakey ln\",\n      \"city\": \"some place\"\n    }\n  ]\n}\n// 如果希望更新刚刚插入的JSON文档, 可以通过在post请求改子欧元deURL时, 将\"_id\" \"_rev\"加入请求体来实现, 成功后, API会响应一个说明状态的JSON文档, 其中会包含更新后的\"rev\"键值对.\n```\n\n### 服务端的JSON\n客户端: html css js  \n服务端: php asp.net nodejs ruby java go等  \n在服务端, 我们通过HTTP想服务端发送资源请求. 服务端会响应一份文档, 当文档是JSON时, 必须要用服务端代码来生成它. 同时, 服务端可能要先接受一个JSON文档才能返回一个JSON文档.\n\n#### 序列化、反序列化与请求JSON\n# ASP.NET\nASP.NET是由微软开发的服务端WEB框架, 在ASP.NET解析JSON不想js中那么简单, 需要第三方ASP.NET库. 最流行的库是Json.NET  \n有了ASP.NET和Json.NET 可以快速地将ASP.NET对象序列化为JSON. 首先需要一个用于操作的JSON对象.\n```java\npublic class CustomerAccount\n{\n  public string firstName { get; set; }\n  public string lastName { get; set; }\n  public string phone { get; set; }\n  public Address[] addresses { get; set; }\n  public bool famous { get; set;}\n}\n\npublic class Address\n{\n  public string street { get; set; }\n  public string city { get; set; }\n  public string state { get; set; }\n  public int zip { get; set; }\n}\n// 有了表示对象的类, 现在就创建一个新的对象以保存Bob Barker 的信息\nCustomerAccount bobsAccount = new CustomerAccount();\nbobsAccount.firstName = \"Bob\";\nbobsAccount.lastName = \"Barker\";\nbobsAccount.phone = \"555-55-55555\";\n\nAddress[] addresses;\naddresses = new Address[2];\nAddress bobsAddress1 = new Address();\nbobsAddress1.state = \"123 fakey st\";\nbobsAddress1.city = \"somewhere\";\n\naddresses[0] = bobsAddress1;\n\nAddress bobsAddress2 = new Address();\nbobsAddress2.state = \"456 fakei ln\";\nbobsAddress2.city = \"some place\";\n\naddresses[1] = bobsAddress1;\n\nstring json = JsonConvert.SerializeObject(bobsAccount);\n// 序列化后的ASP.NET CustomerAccount对象\n{\n  \"firstName\": \"Bob\",\n  \"lastName\": \"Barker\",\n  \"phone\": \"555-55-55555\",\n  \"addresses\": [\n    {\n      \"street\": \"123 fake st\",\n      \"city\": \"somehwhere\"\n    },\n    {\n      \"street\": \"456 fakey ln\",\n      \"city\": \"some place\"\n    }\n  ]\n}\n// 反序列化JSON\nCustomerAccount customerAccount = JsonConvert.DeserializeObject<CustomerAccount>(json);\n```\n\n# php\nphp是一种用于创建动态WEb页面的服务端脚本语言. php代码可以直接嵌入html文档中, 也支持对象数据类型.\n```php\n<?php \nclass Account {\n  public $firstName;\n  public $lastName;\n  public $phone;\n  public $addresses;\n}\n\nclass Address {\n  public $street;\n  public $city;\n}\n\n$address1 = new Address();\n$address1->street = \"123 fake st\";\n$address1->city = \"somewhere\";\n$address2 = new Address();\n$address2->street = \"456 fakey ln\";\n$address2->city = \"some place\";\n\n$account = new Account();\n$account->firstName = \"Bob\";\n$account->lastName = \"Barker\";\n$account->phone = \"555-55-55555\";\n$account->address = array($address1, address2);\n\n$json = json_encode($account);\n?>\n//json_encoude($account)返回的结果\n{\n  \"firstName\": \"Bob\",\n  \"lastName\": \"Barker\",\n  \"phone\": \"555-55-55555\",\n  \"addresses\": [\n    {\n      \"street\": \"123 fake st\",\n      \"city\": \"somehwhere\"\n    },\n    {\n      \"street\": \"456 fakey ln\",\n      \"city\": \"some place\"\n    }\n  ]\n}\n// 反序列化json 相对的使用json_decode\n```\n# nodejs\nnodejs是服务端的js, 在nodejs不再使用XMLHttpRequest对象, 在nodejs中通过get()函数来请求json\n```JavaScript\n// 通过向openweathermap API发送请求, 得到的JSON反序列化为JS对象, 然后通过console.log输出(coord)坐标对象 \nvar http = require('http');\nhttp.get({\n  host: 'api.openweathermap.org',\n  path: '/data/2.5/weather?q=london,uk'\n}, function(response) {\n  var body = '';\n  response.on('data', function(data) {\n    body += data;\n  });\n  response.on('end', function() {\n    var weatherData = JSON.parse(body);\n    console.log(weatherData.coord);\n  });\n});\n```","source":"_posts/JSON必知必会.md","raw":"---\ntitle: JSON必知必会\ndate: 2017-09-13 20:19:04\ntags: JSON\n---\n##### 写在前面\n文章标题和O'Reilly动物书同名, 记录这本书的一些重点(个人觉得)\n\n### 什么是JSON\nJSON是一种数据交换格式\n\n### JSON语法\n1. JSON基于JavaScript对象字面量, 用{}或[]包裹.\n2. JSON采用(键:值)来表示, 键值对可以是字符串, 数字, 布尔值, null, 数组, 对象. 字符串必须用双引号包裹起来, 不能用单引号, 也不能用引号.\n3. 正确的JSON语法. 一般为了JSON的可移植性, 键最好不要在字符串中使用空格或特殊字符即[a-zA-Z0-9]其他的字符. 如\"my girl\"写成\"myGirl\", \"Psilo's blog\"写成\"psilosBlog\".\n4. JSON文件的后缀是.json\n\n### JSON的数据类型\n\n* 对象数据类型\n\n<!--more-->\n```json\n{\n  \"person\": {\n    \"name\": \"Psilo\",\n    \"age\": 23,\n    \"head\": {\n      \"hair\": {\n        \"color\": \"black\",\n        \"length\": \"short\"\n      },\n      \"eyes\": \"brown\"\n    }\n  }\n}\n```\n\n* 字符串类型, 需要转义的字符还是要转义, 另外JSON中没有制表符\\t和换行符\\n\n\n```json\n{\n  \"animal\": \"cat\"\n  \"promo\": \"Say \\\"Hello\\\" to China.\" \n}\n```\n\n* 数字类型, json中的数字可以是正数, 小数, 负数或者指数. 指数常常用科学表示法来表示.\n\n```json\n{\n  \"widgetInventory\": 289,\n  \"savingsAccount\": 22.59,\n  \"earthsMass\": 5.97219e+24\n}\n```\n\n* 布尔类型, json中用小写的true false表示布尔值.\n\n```json\n{\n  \"tea\": false,\n  \"coffee\": true\n}\n```\n\n* null类型, null表示不存在, 没有. 与0的意义不同, 0是数字.\n\n```json\n{\n  \"person\": {\n    \"name\": \"psilo\",\n    \"car\": null\n  }\n}\n```\n\n* 数组类型, 一个放了一些鸡蛋的容器, 拿走了两个鸡蛋, 就成了第二个json, 把5将最后一个鸡蛋替换掉, 并不会报错, 成了第三个json, 这是因为JavaScript是弱语言, 基本类型可以任意改变\n\n```json\n{\n  \"eggCarton\": [\n    \"egg\",\n    \"egg\",\n    \"egg\",\n    \"egg\",\n    \"egg\",\n    \"egg\",\n    \"egg\",\n    \"egg\",\n  ]\n}\n{\n  \"eggCarton\": [\n    \"egg\",\n    null,\n    \"egg\",\n    \"egg\",\n    \"egg\",\n    \"egg\",\n    null,\n    \"egg\",\n  ]\n}\n{\n  \"eggCarton\": [\n    \"egg\",\n    null,\n    \"egg\",\n    \"egg\",\n    \"egg\",\n    \"egg\",\n    null,\n    5,\n  ]\n}\n```\n\n### JSON Schema\n数据交换中的一种虚拟的\"合同\", JSON Schema是数据接收方的第一道防线, 也是数据发送方节约时间保证数据正确的工具.\n```json\n// 验证猫的JSON   注意:JSON里不能写注释\n{\n  \"$schema\": \"http://json-schema.org/draft-04/schema#\",\n  \"title\": \"Cat\",\n  \"properties\": {\n    \"name\": {\n      \"type\": \"string\",\n      \"minLength\": 3,\n      \"maxLength\": 20\n    },\n    \"age\": {\n      \"type\": \"number\",\n      \"description\": \"Your cat's age in years.\",\n      \"minimun\": 0\n    },\n    \"description\": {\n      \"type\": \"string\"\n    }\n  },\n  \"required\": [ // JSON必须要有的属性\n    \"name\",\n    \"age\"\n  ]\n}\n不能通过验证的JSON\n{\n  \"name\": \"Fluffy the greatest cat in thewhole wide world\",\n  \"age\": -2,\n  \"description\": \"Fluffy loves to sleep all day.\"\n}\n名字太长; 年龄小于0.\n能通过验证的JSON\n{\n  \"name\": \"Fluffy\",\n  \"age\": 3\n}\n```\n\n### JSON中的安全问题\n跨站请求伪造CSRF和跨站脚本攻击CSS\n#### 跨站请求伪造: 利用站点对用户浏览器的信任进行的攻击.\n1. 不要使用顶级数组. 顶级数组是合法的JavaScript脚本, 他们可以用script标签链接并使用.\n2. 对于不想公开的资源, 仅允许使用HTTP POST方法请求, 而不是GET方法. GET方法可以用过URL来请求, 甚至可以放在script标签中.\n```json\n[\n  {\n    \"user\": \"psilo\"\n  },\n  {\n    \"phone\": \"555-555-5555\"\n  }\n]\n// 将数组存放到对象之中, 这样说的非法的JavaScript, 不会被script变迁加载\n{\n  \"info\": [\n    {\n      \"user\": \"psilo\"\n    },\n    {\n      \"phone\": \"555-555-5555\"\n    }\n  ]\n}\n```\n#### 跨站脚本攻击: 通过截取或将站点中所使用的第三方代码更换为恶意脚本, 来对站点进行的一种注入攻击.\n1. 使用JSON.parse()来代替eval(). eval()函数会将传入的字符串编译并执行, 这会让你的代码易被攻击. 应仅适用JSON.parse()来解析JSON数据.\n\n### JavaScript中的XMLHttpRequest与Web API\nXMLHttpRequest负责在客户端发起请求, 而Web API负责在服务端返回响应\n\n#### JavaScript中的XMLHttpRequest对象\n```JavaScript\n// XMLHttpRequest对象用法\nvar xml = new XMLHttpRequest();\nxml.open(method, url, async(可选), user(可选), password(可选));\nxml.send();\n\n// XMLHttpRequest对象的一些属性\n// 可以在代码中给它负值为一个函数\nonreadystatechange \n/* 返回一个0-4的值, 用来表示状态码\n * 0表示open()函数还没有执行.\n * 1表示open()已执行, 但send()函数还没有执行\n * 2表示send()函数已执行切头部和状态码都可以获取了\n * 3表示头部已经收到, 但响应体正在解析中\n * 4表示请求完成, 包括响应头和响应体的内容都已经接受到了\n*/\nreadyState\n// 返回HTTP状态码 如200\nstatus\n// 当请求成功时, 该属性会包含作为文本的响应体\nresponseText \n\n// eg\nvar xml = new XMLHttpRequest();\nvar url = \"http://api.openweathermap.org/data/2.5/weather?lat=35&lon=139\";\n\nxml.onreadystatechange = function() {\n  if(xml.readyState == 4 && xml.status == 200) {\n    var myObject = JSON.parse(xml.responseText);\n    var myJson = JSON.stringify(myObject);\n  }\n}\n\nxml.openk(\"GET\", url, true);\nxml.send();\n```\n很明显, url的地址和请求的地址不太可能是同一域名, 显然这违背了同源策略, 所以我们需要资源共享. 有些开发人员可以持续多年通过JavaScript的AJAX技术向公共API发送请求, 而不会收到同源策略的影响, 这是因为这些公共API的开发者在他们的服务器上实现了跨域资源共享CORS. 这些服务器会在响应头额外加上一些带有Access-Control-Allow前缀的属性. 如Access-Control-Allow-Origin:*; 定义了任意域名都是允许使用的. 之前跨站请求伪造也可以通过在其响应头加入具体站点域名来禁止其他站点去获取资源, 这样script里的站点地址也就失效了.\n\n#### JSONP\n带有padding的JSON. 将JavaScript加入JSON文档, 内联与JSON文档的JavaScript调用一个函数, 函数参数是JSON. 函数参数提供了一种将数据传递给函数的方式. JSON-P还需要服务端的不少支持,  因为JSON资源必须包含JavaScript内联..\n\n### JSON与客户端框架\n框架可以节省时间, 让我们更专注于功能的构建. \n#### jQuery\njQuery是一种允许开发者专注于操作DOM构建功能的抽象化工具. 如JSON.parse(), 在老版本的IE, Firefox, chrome并不支持. jQuery帮我们解决了大部分兼容问题.\n```JavaScript\nvar myAnimal = JSON.parse('{ \"animal\": \"cat\"}'); // 有兼容问题\n\n// jQuery内置的方法来解析JSON\nvar myAnimal = jQuery.parseJSON('{\"animal\": \"cat\"}');\n\n// 用JQuery创建新的XMLHttpRequest对象, 并从OpenWeatherMap API 获取JSON\nvar url = \"http://api.openweathermap.org/data/2.5/weather?lat=35&lon=139\";\n$.getJSON(url, function(data) {\n  // 对天气数据操作\n})\n```\n#### AngularJS\nAngularJS是为DOM操作服务的抽象化工具, 专注单页Web应用的开发. 是基于实现MVC构架概念的框架. \n```JavaScript\n/* MVC\n * JSON是模型\n * HTML是试图\n * 控制器是使用AngularJS语法来定义和操作与模型和试图间的交互的JavaScript文件.\n */\n// 从OpenWeatherMap API获取天气数据\nangular.module('myApp', []).controller('myAppController', function($scope, $http) {\n  $http.get(\"http://api.openweathermap.org/data/2.5/weather?lat=35&lon=139\").success(function(data, status, headers, config) {\n    $scope.weatherData = data;\n  });\n});\n```\n从OpenWeatherMap API返回的JSON数据会被$http反序列化, 然后将名为wetherData的对象呗添加到全局作用域. 这样就能通过HTML试图的插值语法将其作为数据模型进行绑定了.\n\n### JSON与NoSQL\nSQL: 关系型数据库, 使用表格, 行和列来以结构化形式存储数据的. NoSQL: 顾名思义, 不是关系型数据库, 它可以是键值对存储.\n#### CouchDB: 使用JSON文档存储数据的文档存储数据库的NoSQL数据库\n在关系型数据库中, 对于一个账户对应多个地址这种一对多的关系, 需要执行联合查询, 以便把数据放在一起. 有了CouchDB, 数据就不需要因为它们之间的关系而被分开存储, 也不需要再读取时进行重组.\n```json\n{\n  \"firstName\": \"Bob\",\n  \"lastName\": \"Barker\",\n  \"age\": \"91\",\n  \"addresses\": [\n    {\n      \"street\": \"123 fake st\",\n      \"city\": \"somewhere\"\n    },\n    {\n      \"street\": \"456 fakey ln\",\n      \"city\": \"some place\"\n    }\n  ]\n}\n```\n由于CouchDB使用文档来存储数据, 因此从数据库查询一个账户时, 得到的直接就是一个结构化文档, 没有必要进行重组. 另一个好处是有利于数据的变化, 有些数据会随着时间而发生变化, 如电话号码, 当账户将来又有了新的号码, 只需要将其加入存储电话的数据即可\n\n#### CouchDB API\n对于HTTP, 我们是通过URL的方式来请求资源的, 从CouchDB API中请求的资源是一份JSON文档\n```json\n// 本地名为accounts的数据库\n// http://localhost:8080/accounts\n{\n  \"db_name\": \"accounts\",\n  \"doc_count\": 3,\n  \"doc_del_count\": 0,\n  \"update_seq\": 7,\n  \"purge_seq\": 0,\n  \"compact_running\": false,\n  \"disk_size\": 29999,\n  \"data_size\": 1222,\n  \"instance_start_time\": \"1432493477586600\",\n  \"disk_format_version\": 6,\n  \"committed_update_seq\": 7\n}\n// 其中的\"doc_count\"表示数据库中包含多少份文档. 这里是3份, 可以通过每个文档的位移标识符来对其进行查询,可以通过http://localhost:8080/accounts/_all_docs这一URL来获取行标识符数组. 如标识符是3636fa3c716f9dd4f7407bd6f7000552. 访问http://localhost:8080/accounts/3636fa3c716f9dd4f7407bd6f7000552可得以下JSON资源\n{\n  \"_id\": \"3636fa3c716f9dd4f7407bd6f7000552\",\n  \"_rev\": \"1-8a9527cbfc22e28984dfb3a3e6062635\",\n  \"firstName\": \"Billy\",\n  \"lastName\": \"Bob\",\n  \"age\": \"91\",\n  \"addresses\": [\n    {\n      \"street\": \"123 fake st\",\n      \"city\": \"somewhere\"\n    },\n    {\n      \"street\": \"456 fakey ln\",\n      \"city\": \"some place\"\n    }\n  ]\n}\n// 上述是从CouchDB数据库请求数据, 下面说说如何向数据库发送数据\n// 通过向http://localhost:8080/accounts/这一URL post数据来实现\n// 通过post方法请求 http://localhost:8080/accounts/的HTTP请求头\nPOST /accounts/ HTTP/1.1\nHost: localhost:8080\nContent_type: application/json\nCache-control: no-cache\n// 通过post方法请求 http://localhost:8080/accounts/ 的HTTP请求体\n{\n  \"firstName\": \"Psilo\",\n  \"lastName\": \"Lau\",\n  \"age\": \"18\",\n  \"addresses\": [\n    {\n      \"street\": \"1234 fake st\",\n      \"city\": \"somehwhere\"\n    },\n    {\n      \"street\": \"4567 fakey ln\",\n      \"city\": \"some place\"\n    }\n  ]  \n}\n// http请求成功后, CounchDB API会将JSON格式的相应信息发送给你, 其中包含了新创建的文档的标识符.\n{\n  \"ok\": true,\n  \"id\": \"3asd564sa6451654v6sd4v6d4asv6\",\n  \"rev\": \"1-as564ff6sd31v6asd54v6ads4v\"\n}\n// 这时候可以用心的标识符来创建URL, 并从账户数据库中请求JSON文档.\n// http://localhost:8080/accounts/3asd564sa6451654v6sd4v6d4asv6的响应\n{\n  \"_id\": \"3asd564sa6451654v6sd4v6d4asv6\",\n  \"_rev\": \"1-as564ff6sd31v6asd54v6ads4v\",\n  \"firstName\": \"Psilo\",\n  \"lastName\": \"Lau\",\n  \"age\": \"18\",\n  \"addresses\": [\n    {\n      \"street\": \"1234 fake st\",\n      \"city\": \"somehwhere\"\n    },\n    {\n      \"street\": \"4567 fakey ln\",\n      \"city\": \"some place\"\n    }\n  ]\n}\n// 如果希望更新刚刚插入的JSON文档, 可以通过在post请求改子欧元deURL时, 将\"_id\" \"_rev\"加入请求体来实现, 成功后, API会响应一个说明状态的JSON文档, 其中会包含更新后的\"rev\"键值对.\n```\n\n### 服务端的JSON\n客户端: html css js  \n服务端: php asp.net nodejs ruby java go等  \n在服务端, 我们通过HTTP想服务端发送资源请求. 服务端会响应一份文档, 当文档是JSON时, 必须要用服务端代码来生成它. 同时, 服务端可能要先接受一个JSON文档才能返回一个JSON文档.\n\n#### 序列化、反序列化与请求JSON\n# ASP.NET\nASP.NET是由微软开发的服务端WEB框架, 在ASP.NET解析JSON不想js中那么简单, 需要第三方ASP.NET库. 最流行的库是Json.NET  \n有了ASP.NET和Json.NET 可以快速地将ASP.NET对象序列化为JSON. 首先需要一个用于操作的JSON对象.\n```java\npublic class CustomerAccount\n{\n  public string firstName { get; set; }\n  public string lastName { get; set; }\n  public string phone { get; set; }\n  public Address[] addresses { get; set; }\n  public bool famous { get; set;}\n}\n\npublic class Address\n{\n  public string street { get; set; }\n  public string city { get; set; }\n  public string state { get; set; }\n  public int zip { get; set; }\n}\n// 有了表示对象的类, 现在就创建一个新的对象以保存Bob Barker 的信息\nCustomerAccount bobsAccount = new CustomerAccount();\nbobsAccount.firstName = \"Bob\";\nbobsAccount.lastName = \"Barker\";\nbobsAccount.phone = \"555-55-55555\";\n\nAddress[] addresses;\naddresses = new Address[2];\nAddress bobsAddress1 = new Address();\nbobsAddress1.state = \"123 fakey st\";\nbobsAddress1.city = \"somewhere\";\n\naddresses[0] = bobsAddress1;\n\nAddress bobsAddress2 = new Address();\nbobsAddress2.state = \"456 fakei ln\";\nbobsAddress2.city = \"some place\";\n\naddresses[1] = bobsAddress1;\n\nstring json = JsonConvert.SerializeObject(bobsAccount);\n// 序列化后的ASP.NET CustomerAccount对象\n{\n  \"firstName\": \"Bob\",\n  \"lastName\": \"Barker\",\n  \"phone\": \"555-55-55555\",\n  \"addresses\": [\n    {\n      \"street\": \"123 fake st\",\n      \"city\": \"somehwhere\"\n    },\n    {\n      \"street\": \"456 fakey ln\",\n      \"city\": \"some place\"\n    }\n  ]\n}\n// 反序列化JSON\nCustomerAccount customerAccount = JsonConvert.DeserializeObject<CustomerAccount>(json);\n```\n\n# php\nphp是一种用于创建动态WEb页面的服务端脚本语言. php代码可以直接嵌入html文档中, 也支持对象数据类型.\n```php\n<?php \nclass Account {\n  public $firstName;\n  public $lastName;\n  public $phone;\n  public $addresses;\n}\n\nclass Address {\n  public $street;\n  public $city;\n}\n\n$address1 = new Address();\n$address1->street = \"123 fake st\";\n$address1->city = \"somewhere\";\n$address2 = new Address();\n$address2->street = \"456 fakey ln\";\n$address2->city = \"some place\";\n\n$account = new Account();\n$account->firstName = \"Bob\";\n$account->lastName = \"Barker\";\n$account->phone = \"555-55-55555\";\n$account->address = array($address1, address2);\n\n$json = json_encode($account);\n?>\n//json_encoude($account)返回的结果\n{\n  \"firstName\": \"Bob\",\n  \"lastName\": \"Barker\",\n  \"phone\": \"555-55-55555\",\n  \"addresses\": [\n    {\n      \"street\": \"123 fake st\",\n      \"city\": \"somehwhere\"\n    },\n    {\n      \"street\": \"456 fakey ln\",\n      \"city\": \"some place\"\n    }\n  ]\n}\n// 反序列化json 相对的使用json_decode\n```\n# nodejs\nnodejs是服务端的js, 在nodejs不再使用XMLHttpRequest对象, 在nodejs中通过get()函数来请求json\n```JavaScript\n// 通过向openweathermap API发送请求, 得到的JSON反序列化为JS对象, 然后通过console.log输出(coord)坐标对象 \nvar http = require('http');\nhttp.get({\n  host: 'api.openweathermap.org',\n  path: '/data/2.5/weather?q=london,uk'\n}, function(response) {\n  var body = '';\n  response.on('data', function(data) {\n    body += data;\n  });\n  response.on('end', function() {\n    var weatherData = JSON.parse(body);\n    console.log(weatherData.coord);\n  });\n});\n```","slug":"JSON必知必会","published":1,"updated":"2021-07-02T03:20:30.650Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl5sb8gg5002wxq0rq9i4vqf6","content":"<h5 id=\"写在前面\"><a href=\"#写在前面\" class=\"headerlink\" title=\"写在前面\"></a>写在前面</h5><p>文章标题和O’Reilly动物书同名, 记录这本书的一些重点(个人觉得)</p>\n<h3 id=\"什么是JSON\"><a href=\"#什么是JSON\" class=\"headerlink\" title=\"什么是JSON\"></a>什么是JSON</h3><p>JSON是一种数据交换格式</p>\n<h3 id=\"JSON语法\"><a href=\"#JSON语法\" class=\"headerlink\" title=\"JSON语法\"></a>JSON语法</h3><ol>\n<li>JSON基于JavaScript对象字面量, 用{}或[]包裹.</li>\n<li>JSON采用(键:值)来表示, 键值对可以是字符串, 数字, 布尔值, null, 数组, 对象. 字符串必须用双引号包裹起来, 不能用单引号, 也不能用引号.</li>\n<li>正确的JSON语法. 一般为了JSON的可移植性, 键最好不要在字符串中使用空格或特殊字符即[a-zA-Z0-9]其他的字符. 如”my girl”写成”myGirl”, “Psilo’s blog”写成”psilosBlog”.</li>\n<li>JSON文件的后缀是.json</li>\n</ol>\n<h3 id=\"JSON的数据类型\"><a href=\"#JSON的数据类型\" class=\"headerlink\" title=\"JSON的数据类型\"></a>JSON的数据类型</h3><ul>\n<li>对象数据类型</li>\n</ul>\n<a id=\"more\"></a>\n<figure class=\"highlight json\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;</span><br><span class=\"line\">  <span class=\"attr\">\"person\"</span>: &#123;</span><br><span class=\"line\">    <span class=\"attr\">\"name\"</span>: <span class=\"string\">\"Psilo\"</span>,</span><br><span class=\"line\">    <span class=\"attr\">\"age\"</span>: <span class=\"number\">23</span>,</span><br><span class=\"line\">    <span class=\"attr\">\"head\"</span>: &#123;</span><br><span class=\"line\">      <span class=\"attr\">\"hair\"</span>: &#123;</span><br><span class=\"line\">        <span class=\"attr\">\"color\"</span>: <span class=\"string\">\"black\"</span>,</span><br><span class=\"line\">        <span class=\"attr\">\"length\"</span>: <span class=\"string\">\"short\"</span></span><br><span class=\"line\">      &#125;,</span><br><span class=\"line\">      <span class=\"attr\">\"eyes\"</span>: <span class=\"string\">\"brown\"</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>字符串类型, 需要转义的字符还是要转义, 另外JSON中没有制表符\\t和换行符\\n</li>\n</ul>\n<figure class=\"highlight json\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;</span><br><span class=\"line\">  <span class=\"attr\">\"animal\"</span>: <span class=\"string\">\"cat\"</span></span><br><span class=\"line\">  <span class=\"string\">\"promo\"</span>: <span class=\"string\">\"Say \\\"Hello\\\" to China.\"</span> </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>数字类型, json中的数字可以是正数, 小数, 负数或者指数. 指数常常用科学表示法来表示.</li>\n</ul>\n<figure class=\"highlight json\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;</span><br><span class=\"line\">  <span class=\"attr\">\"widgetInventory\"</span>: <span class=\"number\">289</span>,</span><br><span class=\"line\">  <span class=\"attr\">\"savingsAccount\"</span>: <span class=\"number\">22.59</span>,</span><br><span class=\"line\">  <span class=\"attr\">\"earthsMass\"</span>: <span class=\"number\">5.97219e+24</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>布尔类型, json中用小写的true false表示布尔值.</li>\n</ul>\n<figure class=\"highlight json\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;</span><br><span class=\"line\">  <span class=\"attr\">\"tea\"</span>: <span class=\"literal\">false</span>,</span><br><span class=\"line\">  <span class=\"attr\">\"coffee\"</span>: <span class=\"literal\">true</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>null类型, null表示不存在, 没有. 与0的意义不同, 0是数字.</li>\n</ul>\n<figure class=\"highlight json\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;</span><br><span class=\"line\">  <span class=\"attr\">\"person\"</span>: &#123;</span><br><span class=\"line\">    <span class=\"attr\">\"name\"</span>: <span class=\"string\">\"psilo\"</span>,</span><br><span class=\"line\">    <span class=\"attr\">\"car\"</span>: <span class=\"literal\">null</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>数组类型, 一个放了一些鸡蛋的容器, 拿走了两个鸡蛋, 就成了第二个json, 把5将最后一个鸡蛋替换掉, 并不会报错, 成了第三个json, 这是因为JavaScript是弱语言, 基本类型可以任意改变</li>\n</ul>\n<figure class=\"highlight json\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;</span><br><span class=\"line\">  <span class=\"attr\">\"eggCarton\"</span>: [</span><br><span class=\"line\">    <span class=\"string\">\"egg\"</span>,</span><br><span class=\"line\">    <span class=\"string\">\"egg\"</span>,</span><br><span class=\"line\">    <span class=\"string\">\"egg\"</span>,</span><br><span class=\"line\">    <span class=\"string\">\"egg\"</span>,</span><br><span class=\"line\">    <span class=\"string\">\"egg\"</span>,</span><br><span class=\"line\">    <span class=\"string\">\"egg\"</span>,</span><br><span class=\"line\">    <span class=\"string\">\"egg\"</span>,</span><br><span class=\"line\">    <span class=\"string\">\"egg\"</span>,</span><br><span class=\"line\">  ]</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">  <span class=\"attr\">\"eggCarton\"</span>: [</span><br><span class=\"line\">    <span class=\"string\">\"egg\"</span>,</span><br><span class=\"line\">    <span class=\"literal\">null</span>,</span><br><span class=\"line\">    <span class=\"string\">\"egg\"</span>,</span><br><span class=\"line\">    <span class=\"string\">\"egg\"</span>,</span><br><span class=\"line\">    <span class=\"string\">\"egg\"</span>,</span><br><span class=\"line\">    <span class=\"string\">\"egg\"</span>,</span><br><span class=\"line\">    <span class=\"literal\">null</span>,</span><br><span class=\"line\">    <span class=\"string\">\"egg\"</span>,</span><br><span class=\"line\">  ]</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">  <span class=\"attr\">\"eggCarton\"</span>: [</span><br><span class=\"line\">    <span class=\"string\">\"egg\"</span>,</span><br><span class=\"line\">    <span class=\"literal\">null</span>,</span><br><span class=\"line\">    <span class=\"string\">\"egg\"</span>,</span><br><span class=\"line\">    <span class=\"string\">\"egg\"</span>,</span><br><span class=\"line\">    <span class=\"string\">\"egg\"</span>,</span><br><span class=\"line\">    <span class=\"string\">\"egg\"</span>,</span><br><span class=\"line\">    <span class=\"literal\">null</span>,</span><br><span class=\"line\">    <span class=\"number\">5</span>,</span><br><span class=\"line\">  ]</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"JSON-Schema\"><a href=\"#JSON-Schema\" class=\"headerlink\" title=\"JSON Schema\"></a>JSON Schema</h3><p>数据交换中的一种虚拟的”合同”, JSON Schema是数据接收方的第一道防线, 也是数据发送方节约时间保证数据正确的工具.</p>\n<figure class=\"highlight json\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 验证猫的JSON   注意:JSON里不能写注释</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">  <span class=\"attr\">\"$schema\"</span>: <span class=\"string\">\"http://json-schema.org/draft-04/schema#\"</span>,</span><br><span class=\"line\">  <span class=\"attr\">\"title\"</span>: <span class=\"string\">\"Cat\"</span>,</span><br><span class=\"line\">  <span class=\"attr\">\"properties\"</span>: &#123;</span><br><span class=\"line\">    <span class=\"attr\">\"name\"</span>: &#123;</span><br><span class=\"line\">      <span class=\"attr\">\"type\"</span>: <span class=\"string\">\"string\"</span>,</span><br><span class=\"line\">      <span class=\"attr\">\"minLength\"</span>: <span class=\"number\">3</span>,</span><br><span class=\"line\">      <span class=\"attr\">\"maxLength\"</span>: <span class=\"number\">20</span></span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    <span class=\"attr\">\"age\"</span>: &#123;</span><br><span class=\"line\">      <span class=\"attr\">\"type\"</span>: <span class=\"string\">\"number\"</span>,</span><br><span class=\"line\">      <span class=\"attr\">\"description\"</span>: <span class=\"string\">\"Your cat's age in years.\"</span>,</span><br><span class=\"line\">      <span class=\"attr\">\"minimun\"</span>: <span class=\"number\">0</span></span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    <span class=\"attr\">\"description\"</span>: &#123;</span><br><span class=\"line\">      <span class=\"attr\">\"type\"</span>: <span class=\"string\">\"string\"</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  <span class=\"attr\">\"required\"</span>: [ <span class=\"comment\">// JSON必须要有的属性</span></span><br><span class=\"line\">    <span class=\"string\">\"name\"</span>,</span><br><span class=\"line\">    <span class=\"string\">\"age\"</span></span><br><span class=\"line\">  ]</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">不能通过验证的JSON</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">  <span class=\"attr\">\"name\"</span>: <span class=\"string\">\"Fluffy the greatest cat in thewhole wide world\"</span>,</span><br><span class=\"line\">  <span class=\"attr\">\"age\"</span>: <span class=\"number\">-2</span>,</span><br><span class=\"line\">  <span class=\"attr\">\"description\"</span>: <span class=\"string\">\"Fluffy loves to sleep all day.\"</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\">名字太长; 年龄小于0.</span><br><span class=\"line\">能通过验证的JSON</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">  <span class=\"attr\">\"name\"</span>: <span class=\"string\">\"Fluffy\"</span>,</span><br><span class=\"line\">  <span class=\"attr\">\"age\"</span>: <span class=\"number\">3</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"JSON中的安全问题\"><a href=\"#JSON中的安全问题\" class=\"headerlink\" title=\"JSON中的安全问题\"></a>JSON中的安全问题</h3><p>跨站请求伪造CSRF和跨站脚本攻击CSS</p>\n<h4 id=\"跨站请求伪造-利用站点对用户浏览器的信任进行的攻击\"><a href=\"#跨站请求伪造-利用站点对用户浏览器的信任进行的攻击\" class=\"headerlink\" title=\"跨站请求伪造: 利用站点对用户浏览器的信任进行的攻击.\"></a>跨站请求伪造: 利用站点对用户浏览器的信任进行的攻击.</h4><ol>\n<li>不要使用顶级数组. 顶级数组是合法的JavaScript脚本, 他们可以用script标签链接并使用.</li>\n<li>对于不想公开的资源, 仅允许使用HTTP POST方法请求, 而不是GET方法. GET方法可以用过URL来请求, 甚至可以放在script标签中.<figure class=\"highlight json\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[</span><br><span class=\"line\">  &#123;</span><br><span class=\"line\">    <span class=\"attr\">\"user\"</span>: <span class=\"string\">\"psilo\"</span></span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  &#123;</span><br><span class=\"line\">    <span class=\"attr\">\"phone\"</span>: <span class=\"string\">\"555-555-5555\"</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">]</span><br><span class=\"line\"><span class=\"comment\">// 将数组存放到对象之中, 这样说的非法的JavaScript, 不会被script变迁加载</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">  <span class=\"attr\">\"info\"</span>: [</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">      <span class=\"attr\">\"user\"</span>: <span class=\"string\">\"psilo\"</span></span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">      <span class=\"attr\">\"phone\"</span>: <span class=\"string\">\"555-555-5555\"</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  ]</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n</li>\n</ol>\n<h4 id=\"跨站脚本攻击-通过截取或将站点中所使用的第三方代码更换为恶意脚本-来对站点进行的一种注入攻击\"><a href=\"#跨站脚本攻击-通过截取或将站点中所使用的第三方代码更换为恶意脚本-来对站点进行的一种注入攻击\" class=\"headerlink\" title=\"跨站脚本攻击: 通过截取或将站点中所使用的第三方代码更换为恶意脚本, 来对站点进行的一种注入攻击.\"></a>跨站脚本攻击: 通过截取或将站点中所使用的第三方代码更换为恶意脚本, 来对站点进行的一种注入攻击.</h4><ol>\n<li>使用JSON.parse()来代替eval(). eval()函数会将传入的字符串编译并执行, 这会让你的代码易被攻击. 应仅适用JSON.parse()来解析JSON数据.</li>\n</ol>\n<h3 id=\"JavaScript中的XMLHttpRequest与Web-API\"><a href=\"#JavaScript中的XMLHttpRequest与Web-API\" class=\"headerlink\" title=\"JavaScript中的XMLHttpRequest与Web API\"></a>JavaScript中的XMLHttpRequest与Web API</h3><p>XMLHttpRequest负责在客户端发起请求, 而Web API负责在服务端返回响应</p>\n<h4 id=\"JavaScript中的XMLHttpRequest对象\"><a href=\"#JavaScript中的XMLHttpRequest对象\" class=\"headerlink\" title=\"JavaScript中的XMLHttpRequest对象\"></a>JavaScript中的XMLHttpRequest对象</h4><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// XMLHttpRequest对象用法</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> xml = <span class=\"keyword\">new</span> XMLHttpRequest();</span><br><span class=\"line\">xml.open(method, url, <span class=\"keyword\">async</span>(可选), user(可选), password(可选));</span><br><span class=\"line\">xml.send();</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// XMLHttpRequest对象的一些属性</span></span><br><span class=\"line\"><span class=\"comment\">// 可以在代码中给它负值为一个函数</span></span><br><span class=\"line\">onreadystatechange </span><br><span class=\"line\"><span class=\"comment\">/* 返回一个0-4的值, 用来表示状态码</span></span><br><span class=\"line\"><span class=\"comment\"> * 0表示open()函数还没有执行.</span></span><br><span class=\"line\"><span class=\"comment\"> * 1表示open()已执行, 但send()函数还没有执行</span></span><br><span class=\"line\"><span class=\"comment\"> * 2表示send()函数已执行切头部和状态码都可以获取了</span></span><br><span class=\"line\"><span class=\"comment\"> * 3表示头部已经收到, 但响应体正在解析中</span></span><br><span class=\"line\"><span class=\"comment\"> * 4表示请求完成, 包括响应头和响应体的内容都已经接受到了</span></span><br><span class=\"line\"><span class=\"comment\">*/</span></span><br><span class=\"line\">readyState</span><br><span class=\"line\"><span class=\"comment\">// 返回HTTP状态码 如200</span></span><br><span class=\"line\">status</span><br><span class=\"line\"><span class=\"comment\">// 当请求成功时, 该属性会包含作为文本的响应体</span></span><br><span class=\"line\">responseText </span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// eg</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> xml = <span class=\"keyword\">new</span> XMLHttpRequest();</span><br><span class=\"line\"><span class=\"keyword\">var</span> url = <span class=\"string\">\"http://api.openweathermap.org/data/2.5/weather?lat=35&amp;lon=139\"</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">xml.onreadystatechange = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span>(xml.readyState == <span class=\"number\">4</span> &amp;&amp; xml.status == <span class=\"number\">200</span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> myObject = <span class=\"built_in\">JSON</span>.parse(xml.responseText);</span><br><span class=\"line\">    <span class=\"keyword\">var</span> myJson = <span class=\"built_in\">JSON</span>.stringify(myObject);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">xml.openk(<span class=\"string\">\"GET\"</span>, url, <span class=\"literal\">true</span>);</span><br><span class=\"line\">xml.send();</span><br></pre></td></tr></table></figure>\n\n<p>很明显, url的地址和请求的地址不太可能是同一域名, 显然这违背了同源策略, 所以我们需要资源共享. 有些开发人员可以持续多年通过JavaScript的AJAX技术向公共API发送请求, 而不会收到同源策略的影响, 这是因为这些公共API的开发者在他们的服务器上实现了跨域资源共享CORS. 这些服务器会在响应头额外加上一些带有Access-Control-Allow前缀的属性. 如Access-Control-Allow-Origin:*; 定义了任意域名都是允许使用的. 之前跨站请求伪造也可以通过在其响应头加入具体站点域名来禁止其他站点去获取资源, 这样script里的站点地址也就失效了.</p>\n<h4 id=\"JSONP\"><a href=\"#JSONP\" class=\"headerlink\" title=\"JSONP\"></a>JSONP</h4><p>带有padding的JSON. 将JavaScript加入JSON文档, 内联与JSON文档的JavaScript调用一个函数, 函数参数是JSON. 函数参数提供了一种将数据传递给函数的方式. JSON-P还需要服务端的不少支持,  因为JSON资源必须包含JavaScript内联..</p>\n<h3 id=\"JSON与客户端框架\"><a href=\"#JSON与客户端框架\" class=\"headerlink\" title=\"JSON与客户端框架\"></a>JSON与客户端框架</h3><p>框架可以节省时间, 让我们更专注于功能的构建. </p>\n<h4 id=\"jQuery\"><a href=\"#jQuery\" class=\"headerlink\" title=\"jQuery\"></a>jQuery</h4><p>jQuery是一种允许开发者专注于操作DOM构建功能的抽象化工具. 如JSON.parse(), 在老版本的IE, Firefox, chrome并不支持. jQuery帮我们解决了大部分兼容问题.</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> myAnimal = <span class=\"built_in\">JSON</span>.parse(<span class=\"string\">'&#123; \"animal\": \"cat\"&#125;'</span>); <span class=\"comment\">// 有兼容问题</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// jQuery内置的方法来解析JSON</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> myAnimal = jQuery.parseJSON(<span class=\"string\">'&#123;\"animal\": \"cat\"&#125;'</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 用JQuery创建新的XMLHttpRequest对象, 并从OpenWeatherMap API 获取JSON</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> url = <span class=\"string\">\"http://api.openweathermap.org/data/2.5/weather?lat=35&amp;lon=139\"</span>;</span><br><span class=\"line\">$.getJSON(url, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">data</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">// 对天气数据操作</span></span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"AngularJS\"><a href=\"#AngularJS\" class=\"headerlink\" title=\"AngularJS\"></a>AngularJS</h4><p>AngularJS是为DOM操作服务的抽象化工具, 专注单页Web应用的开发. 是基于实现MVC构架概念的框架. </p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/* MVC</span></span><br><span class=\"line\"><span class=\"comment\"> * JSON是模型</span></span><br><span class=\"line\"><span class=\"comment\"> * HTML是试图</span></span><br><span class=\"line\"><span class=\"comment\"> * 控制器是使用AngularJS语法来定义和操作与模型和试图间的交互的JavaScript文件.</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"comment\">// 从OpenWeatherMap API获取天气数据</span></span><br><span class=\"line\">angular.module(<span class=\"string\">'myApp'</span>, []).controller(<span class=\"string\">'myAppController'</span>, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">$scope, $http</span>) </span>&#123;</span><br><span class=\"line\">  $http.get(<span class=\"string\">\"http://api.openweathermap.org/data/2.5/weather?lat=35&amp;lon=139\"</span>).success(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">data, status, headers, config</span>) </span>&#123;</span><br><span class=\"line\">    $scope.weatherData = data;</span><br><span class=\"line\">  &#125;);</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n\n<p>从OpenWeatherMap API返回的JSON数据会被$http反序列化, 然后将名为wetherData的对象呗添加到全局作用域. 这样就能通过HTML试图的插值语法将其作为数据模型进行绑定了.</p>\n<h3 id=\"JSON与NoSQL\"><a href=\"#JSON与NoSQL\" class=\"headerlink\" title=\"JSON与NoSQL\"></a>JSON与NoSQL</h3><p>SQL: 关系型数据库, 使用表格, 行和列来以结构化形式存储数据的. NoSQL: 顾名思义, 不是关系型数据库, 它可以是键值对存储.</p>\n<h4 id=\"CouchDB-使用JSON文档存储数据的文档存储数据库的NoSQL数据库\"><a href=\"#CouchDB-使用JSON文档存储数据的文档存储数据库的NoSQL数据库\" class=\"headerlink\" title=\"CouchDB: 使用JSON文档存储数据的文档存储数据库的NoSQL数据库\"></a>CouchDB: 使用JSON文档存储数据的文档存储数据库的NoSQL数据库</h4><p>在关系型数据库中, 对于一个账户对应多个地址这种一对多的关系, 需要执行联合查询, 以便把数据放在一起. 有了CouchDB, 数据就不需要因为它们之间的关系而被分开存储, 也不需要再读取时进行重组.</p>\n<figure class=\"highlight json\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;</span><br><span class=\"line\">  <span class=\"attr\">\"firstName\"</span>: <span class=\"string\">\"Bob\"</span>,</span><br><span class=\"line\">  <span class=\"attr\">\"lastName\"</span>: <span class=\"string\">\"Barker\"</span>,</span><br><span class=\"line\">  <span class=\"attr\">\"age\"</span>: <span class=\"string\">\"91\"</span>,</span><br><span class=\"line\">  <span class=\"attr\">\"addresses\"</span>: [</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">      <span class=\"attr\">\"street\"</span>: <span class=\"string\">\"123 fake st\"</span>,</span><br><span class=\"line\">      <span class=\"attr\">\"city\"</span>: <span class=\"string\">\"somewhere\"</span></span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">      <span class=\"attr\">\"street\"</span>: <span class=\"string\">\"456 fakey ln\"</span>,</span><br><span class=\"line\">      <span class=\"attr\">\"city\"</span>: <span class=\"string\">\"some place\"</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  ]</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>由于CouchDB使用文档来存储数据, 因此从数据库查询一个账户时, 得到的直接就是一个结构化文档, 没有必要进行重组. 另一个好处是有利于数据的变化, 有些数据会随着时间而发生变化, 如电话号码, 当账户将来又有了新的号码, 只需要将其加入存储电话的数据即可</p>\n<h4 id=\"CouchDB-API\"><a href=\"#CouchDB-API\" class=\"headerlink\" title=\"CouchDB API\"></a>CouchDB API</h4><p>对于HTTP, 我们是通过URL的方式来请求资源的, 从CouchDB API中请求的资源是一份JSON文档</p>\n<figure class=\"highlight json\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 本地名为accounts的数据库</span></span><br><span class=\"line\"><span class=\"comment\">// http://localhost:8080/accounts</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">  <span class=\"attr\">\"db_name\"</span>: <span class=\"string\">\"accounts\"</span>,</span><br><span class=\"line\">  <span class=\"attr\">\"doc_count\"</span>: <span class=\"number\">3</span>,</span><br><span class=\"line\">  <span class=\"attr\">\"doc_del_count\"</span>: <span class=\"number\">0</span>,</span><br><span class=\"line\">  <span class=\"attr\">\"update_seq\"</span>: <span class=\"number\">7</span>,</span><br><span class=\"line\">  <span class=\"attr\">\"purge_seq\"</span>: <span class=\"number\">0</span>,</span><br><span class=\"line\">  <span class=\"attr\">\"compact_running\"</span>: <span class=\"literal\">false</span>,</span><br><span class=\"line\">  <span class=\"attr\">\"disk_size\"</span>: <span class=\"number\">29999</span>,</span><br><span class=\"line\">  <span class=\"attr\">\"data_size\"</span>: <span class=\"number\">1222</span>,</span><br><span class=\"line\">  <span class=\"attr\">\"instance_start_time\"</span>: <span class=\"string\">\"1432493477586600\"</span>,</span><br><span class=\"line\">  <span class=\"attr\">\"disk_format_version\"</span>: <span class=\"number\">6</span>,</span><br><span class=\"line\">  <span class=\"attr\">\"committed_update_seq\"</span>: <span class=\"number\">7</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// 其中的\"doc_count\"表示数据库中包含多少份文档. 这里是3份, 可以通过每个文档的位移标识符来对其进行查询,可以通过http://localhost:8080/accounts/_all_docs这一URL来获取行标识符数组. 如标识符是3636fa3c716f9dd4f7407bd6f7000552. 访问http://localhost:8080/accounts/3636fa3c716f9dd4f7407bd6f7000552可得以下JSON资源</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">  <span class=\"attr\">\"_id\"</span>: <span class=\"string\">\"3636fa3c716f9dd4f7407bd6f7000552\"</span>,</span><br><span class=\"line\">  <span class=\"attr\">\"_rev\"</span>: <span class=\"string\">\"1-8a9527cbfc22e28984dfb3a3e6062635\"</span>,</span><br><span class=\"line\">  <span class=\"attr\">\"firstName\"</span>: <span class=\"string\">\"Billy\"</span>,</span><br><span class=\"line\">  <span class=\"attr\">\"lastName\"</span>: <span class=\"string\">\"Bob\"</span>,</span><br><span class=\"line\">  <span class=\"attr\">\"age\"</span>: <span class=\"string\">\"91\"</span>,</span><br><span class=\"line\">  <span class=\"attr\">\"addresses\"</span>: [</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">      <span class=\"attr\">\"street\"</span>: <span class=\"string\">\"123 fake st\"</span>,</span><br><span class=\"line\">      <span class=\"attr\">\"city\"</span>: <span class=\"string\">\"somewhere\"</span></span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">      <span class=\"attr\">\"street\"</span>: <span class=\"string\">\"456 fakey ln\"</span>,</span><br><span class=\"line\">      <span class=\"attr\">\"city\"</span>: <span class=\"string\">\"some place\"</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  ]</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// 上述是从CouchDB数据库请求数据, 下面说说如何向数据库发送数据</span></span><br><span class=\"line\"><span class=\"comment\">// 通过向http://localhost:8080/accounts/这一URL post数据来实现</span></span><br><span class=\"line\"><span class=\"comment\">// 通过post方法请求 http://localhost:8080/accounts/的HTTP请求头</span></span><br><span class=\"line\">POST /accounts/ HTTP/1.1</span><br><span class=\"line\">Host: localhost:8080</span><br><span class=\"line\">Content_type: application/json</span><br><span class=\"line\">Cache-control: no-cache</span><br><span class=\"line\"><span class=\"comment\">// 通过post方法请求 http://localhost:8080/accounts/ 的HTTP请求体</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">  <span class=\"attr\">\"firstName\"</span>: <span class=\"string\">\"Psilo\"</span>,</span><br><span class=\"line\">  <span class=\"attr\">\"lastName\"</span>: <span class=\"string\">\"Lau\"</span>,</span><br><span class=\"line\">  <span class=\"attr\">\"age\"</span>: <span class=\"string\">\"18\"</span>,</span><br><span class=\"line\">  <span class=\"attr\">\"addresses\"</span>: [</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">      <span class=\"attr\">\"street\"</span>: <span class=\"string\">\"1234 fake st\"</span>,</span><br><span class=\"line\">      <span class=\"attr\">\"city\"</span>: <span class=\"string\">\"somehwhere\"</span></span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">      <span class=\"attr\">\"street\"</span>: <span class=\"string\">\"4567 fakey ln\"</span>,</span><br><span class=\"line\">      <span class=\"attr\">\"city\"</span>: <span class=\"string\">\"some place\"</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  ]  </span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// http请求成功后, CounchDB API会将JSON格式的相应信息发送给你, 其中包含了新创建的文档的标识符.</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">  <span class=\"attr\">\"ok\"</span>: <span class=\"literal\">true</span>,</span><br><span class=\"line\">  <span class=\"attr\">\"id\"</span>: <span class=\"string\">\"3asd564sa6451654v6sd4v6d4asv6\"</span>,</span><br><span class=\"line\">  <span class=\"attr\">\"rev\"</span>: <span class=\"string\">\"1-as564ff6sd31v6asd54v6ads4v\"</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// 这时候可以用心的标识符来创建URL, 并从账户数据库中请求JSON文档.</span></span><br><span class=\"line\"><span class=\"comment\">// http://localhost:8080/accounts/3asd564sa6451654v6sd4v6d4asv6的响应</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">  <span class=\"attr\">\"_id\"</span>: <span class=\"string\">\"3asd564sa6451654v6sd4v6d4asv6\"</span>,</span><br><span class=\"line\">  <span class=\"attr\">\"_rev\"</span>: <span class=\"string\">\"1-as564ff6sd31v6asd54v6ads4v\"</span>,</span><br><span class=\"line\">  <span class=\"attr\">\"firstName\"</span>: <span class=\"string\">\"Psilo\"</span>,</span><br><span class=\"line\">  <span class=\"attr\">\"lastName\"</span>: <span class=\"string\">\"Lau\"</span>,</span><br><span class=\"line\">  <span class=\"attr\">\"age\"</span>: <span class=\"string\">\"18\"</span>,</span><br><span class=\"line\">  <span class=\"attr\">\"addresses\"</span>: [</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">      <span class=\"attr\">\"street\"</span>: <span class=\"string\">\"1234 fake st\"</span>,</span><br><span class=\"line\">      <span class=\"attr\">\"city\"</span>: <span class=\"string\">\"somehwhere\"</span></span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">      <span class=\"attr\">\"street\"</span>: <span class=\"string\">\"4567 fakey ln\"</span>,</span><br><span class=\"line\">      <span class=\"attr\">\"city\"</span>: <span class=\"string\">\"some place\"</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  ]</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// 如果希望更新刚刚插入的JSON文档, 可以通过在post请求改子欧元deURL时, 将\"_id\" \"_rev\"加入请求体来实现, 成功后, API会响应一个说明状态的JSON文档, 其中会包含更新后的\"rev\"键值对.</span></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"服务端的JSON\"><a href=\"#服务端的JSON\" class=\"headerlink\" title=\"服务端的JSON\"></a>服务端的JSON</h3><p>客户端: html css js<br>服务端: php asp.net nodejs ruby java go等<br>在服务端, 我们通过HTTP想服务端发送资源请求. 服务端会响应一份文档, 当文档是JSON时, 必须要用服务端代码来生成它. 同时, 服务端可能要先接受一个JSON文档才能返回一个JSON文档.</p>\n<h4 id=\"序列化、反序列化与请求JSON\"><a href=\"#序列化、反序列化与请求JSON\" class=\"headerlink\" title=\"序列化、反序列化与请求JSON\"></a>序列化、反序列化与请求JSON</h4><h1 id=\"ASP-NET\"><a href=\"#ASP-NET\" class=\"headerlink\" title=\"ASP.NET\"></a>ASP.NET</h1><p>ASP.NET是由微软开发的服务端WEB框架, 在ASP.NET解析JSON不想js中那么简单, 需要第三方ASP.NET库. 最流行的库是Json.NET<br>有了ASP.NET和Json.NET 可以快速地将ASP.NET对象序列化为JSON. 首先需要一个用于操作的JSON对象.</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">CustomerAccount</span></span></span><br><span class=\"line\"><span class=\"class\"></span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">public</span> string firstName &#123; get; set; &#125;</span><br><span class=\"line\">  <span class=\"keyword\">public</span> string lastName &#123; get; set; &#125;</span><br><span class=\"line\">  <span class=\"keyword\">public</span> string phone &#123; get; set; &#125;</span><br><span class=\"line\">  <span class=\"keyword\">public</span> Address[] addresses &#123; get; set; &#125;</span><br><span class=\"line\">  <span class=\"keyword\">public</span> bool famous &#123; get; set;&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Address</span></span></span><br><span class=\"line\"><span class=\"class\"></span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">public</span> string street &#123; get; set; &#125;</span><br><span class=\"line\">  <span class=\"keyword\">public</span> string city &#123; get; set; &#125;</span><br><span class=\"line\">  <span class=\"keyword\">public</span> string state &#123; get; set; &#125;</span><br><span class=\"line\">  <span class=\"keyword\">public</span> <span class=\"keyword\">int</span> zip &#123; get; set; &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// 有了表示对象的类, 现在就创建一个新的对象以保存Bob Barker 的信息</span></span><br><span class=\"line\">CustomerAccount bobsAccount = <span class=\"keyword\">new</span> CustomerAccount();</span><br><span class=\"line\">bobsAccount.firstName = <span class=\"string\">\"Bob\"</span>;</span><br><span class=\"line\">bobsAccount.lastName = <span class=\"string\">\"Barker\"</span>;</span><br><span class=\"line\">bobsAccount.phone = <span class=\"string\">\"555-55-55555\"</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">Address[] addresses;</span><br><span class=\"line\">addresses = <span class=\"keyword\">new</span> Address[<span class=\"number\">2</span>];</span><br><span class=\"line\">Address bobsAddress1 = <span class=\"keyword\">new</span> Address();</span><br><span class=\"line\">bobsAddress1.state = <span class=\"string\">\"123 fakey st\"</span>;</span><br><span class=\"line\">bobsAddress1.city = <span class=\"string\">\"somewhere\"</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">addresses[<span class=\"number\">0</span>] = bobsAddress1;</span><br><span class=\"line\"></span><br><span class=\"line\">Address bobsAddress2 = <span class=\"keyword\">new</span> Address();</span><br><span class=\"line\">bobsAddress2.state = <span class=\"string\">\"456 fakei ln\"</span>;</span><br><span class=\"line\">bobsAddress2.city = <span class=\"string\">\"some place\"</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">addresses[<span class=\"number\">1</span>] = bobsAddress1;</span><br><span class=\"line\"></span><br><span class=\"line\">string json = JsonConvert.SerializeObject(bobsAccount);</span><br><span class=\"line\"><span class=\"comment\">// 序列化后的ASP.NET CustomerAccount对象</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">  <span class=\"string\">\"firstName\"</span>: <span class=\"string\">\"Bob\"</span>,</span><br><span class=\"line\">  <span class=\"string\">\"lastName\"</span>: <span class=\"string\">\"Barker\"</span>,</span><br><span class=\"line\">  <span class=\"string\">\"phone\"</span>: <span class=\"string\">\"555-55-55555\"</span>,</span><br><span class=\"line\">  <span class=\"string\">\"addresses\"</span>: [</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">      <span class=\"string\">\"street\"</span>: <span class=\"string\">\"123 fake st\"</span>,</span><br><span class=\"line\">      <span class=\"string\">\"city\"</span>: <span class=\"string\">\"somehwhere\"</span></span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">      <span class=\"string\">\"street\"</span>: <span class=\"string\">\"456 fakey ln\"</span>,</span><br><span class=\"line\">      <span class=\"string\">\"city\"</span>: <span class=\"string\">\"some place\"</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  ]</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// 反序列化JSON</span></span><br><span class=\"line\">CustomerAccount customerAccount = JsonConvert.DeserializeObject&lt;CustomerAccount&gt;(json);</span><br></pre></td></tr></table></figure>\n\n<h1 id=\"php\"><a href=\"#php\" class=\"headerlink\" title=\"php\"></a>php</h1><p>php是一种用于创建动态WEb页面的服务端脚本语言. php代码可以直接嵌入html文档中, 也支持对象数据类型.</p>\n<figure class=\"highlight php\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">&lt;?php</span> </span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Account</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">public</span> $firstName;</span><br><span class=\"line\">  <span class=\"keyword\">public</span> $lastName;</span><br><span class=\"line\">  <span class=\"keyword\">public</span> $phone;</span><br><span class=\"line\">  <span class=\"keyword\">public</span> $addresses;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Address</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">public</span> $street;</span><br><span class=\"line\">  <span class=\"keyword\">public</span> $city;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">$address1 = <span class=\"keyword\">new</span> Address();</span><br><span class=\"line\">$address1-&gt;street = <span class=\"string\">\"123 fake st\"</span>;</span><br><span class=\"line\">$address1-&gt;city = <span class=\"string\">\"somewhere\"</span>;</span><br><span class=\"line\">$address2 = <span class=\"keyword\">new</span> Address();</span><br><span class=\"line\">$address2-&gt;street = <span class=\"string\">\"456 fakey ln\"</span>;</span><br><span class=\"line\">$address2-&gt;city = <span class=\"string\">\"some place\"</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">$account = <span class=\"keyword\">new</span> Account();</span><br><span class=\"line\">$account-&gt;firstName = <span class=\"string\">\"Bob\"</span>;</span><br><span class=\"line\">$account-&gt;lastName = <span class=\"string\">\"Barker\"</span>;</span><br><span class=\"line\">$account-&gt;phone = <span class=\"string\">\"555-55-55555\"</span>;</span><br><span class=\"line\">$account-&gt;address = <span class=\"keyword\">array</span>($address1, address2);</span><br><span class=\"line\"></span><br><span class=\"line\">$json = json_encode($account);</span><br><span class=\"line\"><span class=\"meta\">?&gt;</span></span><br><span class=\"line\"><span class=\"comment\">//json_encoude($account)返回的结果</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">  <span class=\"string\">\"firstName\"</span>: <span class=\"string\">\"Bob\"</span>,</span><br><span class=\"line\">  <span class=\"string\">\"lastName\"</span>: <span class=\"string\">\"Barker\"</span>,</span><br><span class=\"line\">  <span class=\"string\">\"phone\"</span>: <span class=\"string\">\"555-55-55555\"</span>,</span><br><span class=\"line\">  <span class=\"string\">\"addresses\"</span>: [</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">      <span class=\"string\">\"street\"</span>: <span class=\"string\">\"123 fake st\"</span>,</span><br><span class=\"line\">      <span class=\"string\">\"city\"</span>: <span class=\"string\">\"somehwhere\"</span></span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">      <span class=\"string\">\"street\"</span>: <span class=\"string\">\"456 fakey ln\"</span>,</span><br><span class=\"line\">      <span class=\"string\">\"city\"</span>: <span class=\"string\">\"some place\"</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  ]</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// 反序列化json 相对的使用json_decode</span></span><br></pre></td></tr></table></figure>\n\n<h1 id=\"nodejs\"><a href=\"#nodejs\" class=\"headerlink\" title=\"nodejs\"></a>nodejs</h1><p>nodejs是服务端的js, 在nodejs不再使用XMLHttpRequest对象, 在nodejs中通过get()函数来请求json</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 通过向openweathermap API发送请求, 得到的JSON反序列化为JS对象, 然后通过console.log输出(coord)坐标对象 </span></span><br><span class=\"line\"><span class=\"keyword\">var</span> http = <span class=\"built_in\">require</span>(<span class=\"string\">'http'</span>);</span><br><span class=\"line\">http.get(&#123;</span><br><span class=\"line\">  host: <span class=\"string\">'api.openweathermap.org'</span>,</span><br><span class=\"line\">  path: <span class=\"string\">'/data/2.5/weather?q=london,uk'</span></span><br><span class=\"line\">&#125;, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">response</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> body = <span class=\"string\">''</span>;</span><br><span class=\"line\">  response.on(<span class=\"string\">'data'</span>, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">data</span>) </span>&#123;</span><br><span class=\"line\">    body += data;</span><br><span class=\"line\">  &#125;);</span><br><span class=\"line\">  response.on(<span class=\"string\">'end'</span>, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> weatherData = <span class=\"built_in\">JSON</span>.parse(body);</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(weatherData.coord);</span><br><span class=\"line\">  &#125;);</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>","site":{"data":{}},"excerpt":"<h5 id=\"写在前面\"><a href=\"#写在前面\" class=\"headerlink\" title=\"写在前面\"></a>写在前面</h5><p>文章标题和O’Reilly动物书同名, 记录这本书的一些重点(个人觉得)</p>\n<h3 id=\"什么是JSON\"><a href=\"#什么是JSON\" class=\"headerlink\" title=\"什么是JSON\"></a>什么是JSON</h3><p>JSON是一种数据交换格式</p>\n<h3 id=\"JSON语法\"><a href=\"#JSON语法\" class=\"headerlink\" title=\"JSON语法\"></a>JSON语法</h3><ol>\n<li>JSON基于JavaScript对象字面量, 用{}或[]包裹.</li>\n<li>JSON采用(键:值)来表示, 键值对可以是字符串, 数字, 布尔值, null, 数组, 对象. 字符串必须用双引号包裹起来, 不能用单引号, 也不能用引号.</li>\n<li>正确的JSON语法. 一般为了JSON的可移植性, 键最好不要在字符串中使用空格或特殊字符即[a-zA-Z0-9]其他的字符. 如”my girl”写成”myGirl”, “Psilo’s blog”写成”psilosBlog”.</li>\n<li>JSON文件的后缀是.json</li>\n</ol>\n<h3 id=\"JSON的数据类型\"><a href=\"#JSON的数据类型\" class=\"headerlink\" title=\"JSON的数据类型\"></a>JSON的数据类型</h3><ul>\n<li>对象数据类型</li>\n</ul>","more":"<figure class=\"highlight json\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;</span><br><span class=\"line\">  <span class=\"attr\">\"person\"</span>: &#123;</span><br><span class=\"line\">    <span class=\"attr\">\"name\"</span>: <span class=\"string\">\"Psilo\"</span>,</span><br><span class=\"line\">    <span class=\"attr\">\"age\"</span>: <span class=\"number\">23</span>,</span><br><span class=\"line\">    <span class=\"attr\">\"head\"</span>: &#123;</span><br><span class=\"line\">      <span class=\"attr\">\"hair\"</span>: &#123;</span><br><span class=\"line\">        <span class=\"attr\">\"color\"</span>: <span class=\"string\">\"black\"</span>,</span><br><span class=\"line\">        <span class=\"attr\">\"length\"</span>: <span class=\"string\">\"short\"</span></span><br><span class=\"line\">      &#125;,</span><br><span class=\"line\">      <span class=\"attr\">\"eyes\"</span>: <span class=\"string\">\"brown\"</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>字符串类型, 需要转义的字符还是要转义, 另外JSON中没有制表符\\t和换行符\\n</li>\n</ul>\n<figure class=\"highlight json\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;</span><br><span class=\"line\">  <span class=\"attr\">\"animal\"</span>: <span class=\"string\">\"cat\"</span></span><br><span class=\"line\">  <span class=\"string\">\"promo\"</span>: <span class=\"string\">\"Say \\\"Hello\\\" to China.\"</span> </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>数字类型, json中的数字可以是正数, 小数, 负数或者指数. 指数常常用科学表示法来表示.</li>\n</ul>\n<figure class=\"highlight json\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;</span><br><span class=\"line\">  <span class=\"attr\">\"widgetInventory\"</span>: <span class=\"number\">289</span>,</span><br><span class=\"line\">  <span class=\"attr\">\"savingsAccount\"</span>: <span class=\"number\">22.59</span>,</span><br><span class=\"line\">  <span class=\"attr\">\"earthsMass\"</span>: <span class=\"number\">5.97219e+24</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>布尔类型, json中用小写的true false表示布尔值.</li>\n</ul>\n<figure class=\"highlight json\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;</span><br><span class=\"line\">  <span class=\"attr\">\"tea\"</span>: <span class=\"literal\">false</span>,</span><br><span class=\"line\">  <span class=\"attr\">\"coffee\"</span>: <span class=\"literal\">true</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>null类型, null表示不存在, 没有. 与0的意义不同, 0是数字.</li>\n</ul>\n<figure class=\"highlight json\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;</span><br><span class=\"line\">  <span class=\"attr\">\"person\"</span>: &#123;</span><br><span class=\"line\">    <span class=\"attr\">\"name\"</span>: <span class=\"string\">\"psilo\"</span>,</span><br><span class=\"line\">    <span class=\"attr\">\"car\"</span>: <span class=\"literal\">null</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>数组类型, 一个放了一些鸡蛋的容器, 拿走了两个鸡蛋, 就成了第二个json, 把5将最后一个鸡蛋替换掉, 并不会报错, 成了第三个json, 这是因为JavaScript是弱语言, 基本类型可以任意改变</li>\n</ul>\n<figure class=\"highlight json\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;</span><br><span class=\"line\">  <span class=\"attr\">\"eggCarton\"</span>: [</span><br><span class=\"line\">    <span class=\"string\">\"egg\"</span>,</span><br><span class=\"line\">    <span class=\"string\">\"egg\"</span>,</span><br><span class=\"line\">    <span class=\"string\">\"egg\"</span>,</span><br><span class=\"line\">    <span class=\"string\">\"egg\"</span>,</span><br><span class=\"line\">    <span class=\"string\">\"egg\"</span>,</span><br><span class=\"line\">    <span class=\"string\">\"egg\"</span>,</span><br><span class=\"line\">    <span class=\"string\">\"egg\"</span>,</span><br><span class=\"line\">    <span class=\"string\">\"egg\"</span>,</span><br><span class=\"line\">  ]</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">  <span class=\"attr\">\"eggCarton\"</span>: [</span><br><span class=\"line\">    <span class=\"string\">\"egg\"</span>,</span><br><span class=\"line\">    <span class=\"literal\">null</span>,</span><br><span class=\"line\">    <span class=\"string\">\"egg\"</span>,</span><br><span class=\"line\">    <span class=\"string\">\"egg\"</span>,</span><br><span class=\"line\">    <span class=\"string\">\"egg\"</span>,</span><br><span class=\"line\">    <span class=\"string\">\"egg\"</span>,</span><br><span class=\"line\">    <span class=\"literal\">null</span>,</span><br><span class=\"line\">    <span class=\"string\">\"egg\"</span>,</span><br><span class=\"line\">  ]</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">  <span class=\"attr\">\"eggCarton\"</span>: [</span><br><span class=\"line\">    <span class=\"string\">\"egg\"</span>,</span><br><span class=\"line\">    <span class=\"literal\">null</span>,</span><br><span class=\"line\">    <span class=\"string\">\"egg\"</span>,</span><br><span class=\"line\">    <span class=\"string\">\"egg\"</span>,</span><br><span class=\"line\">    <span class=\"string\">\"egg\"</span>,</span><br><span class=\"line\">    <span class=\"string\">\"egg\"</span>,</span><br><span class=\"line\">    <span class=\"literal\">null</span>,</span><br><span class=\"line\">    <span class=\"number\">5</span>,</span><br><span class=\"line\">  ]</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"JSON-Schema\"><a href=\"#JSON-Schema\" class=\"headerlink\" title=\"JSON Schema\"></a>JSON Schema</h3><p>数据交换中的一种虚拟的”合同”, JSON Schema是数据接收方的第一道防线, 也是数据发送方节约时间保证数据正确的工具.</p>\n<figure class=\"highlight json\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 验证猫的JSON   注意:JSON里不能写注释</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">  <span class=\"attr\">\"$schema\"</span>: <span class=\"string\">\"http://json-schema.org/draft-04/schema#\"</span>,</span><br><span class=\"line\">  <span class=\"attr\">\"title\"</span>: <span class=\"string\">\"Cat\"</span>,</span><br><span class=\"line\">  <span class=\"attr\">\"properties\"</span>: &#123;</span><br><span class=\"line\">    <span class=\"attr\">\"name\"</span>: &#123;</span><br><span class=\"line\">      <span class=\"attr\">\"type\"</span>: <span class=\"string\">\"string\"</span>,</span><br><span class=\"line\">      <span class=\"attr\">\"minLength\"</span>: <span class=\"number\">3</span>,</span><br><span class=\"line\">      <span class=\"attr\">\"maxLength\"</span>: <span class=\"number\">20</span></span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    <span class=\"attr\">\"age\"</span>: &#123;</span><br><span class=\"line\">      <span class=\"attr\">\"type\"</span>: <span class=\"string\">\"number\"</span>,</span><br><span class=\"line\">      <span class=\"attr\">\"description\"</span>: <span class=\"string\">\"Your cat's age in years.\"</span>,</span><br><span class=\"line\">      <span class=\"attr\">\"minimun\"</span>: <span class=\"number\">0</span></span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    <span class=\"attr\">\"description\"</span>: &#123;</span><br><span class=\"line\">      <span class=\"attr\">\"type\"</span>: <span class=\"string\">\"string\"</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  <span class=\"attr\">\"required\"</span>: [ <span class=\"comment\">// JSON必须要有的属性</span></span><br><span class=\"line\">    <span class=\"string\">\"name\"</span>,</span><br><span class=\"line\">    <span class=\"string\">\"age\"</span></span><br><span class=\"line\">  ]</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">不能通过验证的JSON</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">  <span class=\"attr\">\"name\"</span>: <span class=\"string\">\"Fluffy the greatest cat in thewhole wide world\"</span>,</span><br><span class=\"line\">  <span class=\"attr\">\"age\"</span>: <span class=\"number\">-2</span>,</span><br><span class=\"line\">  <span class=\"attr\">\"description\"</span>: <span class=\"string\">\"Fluffy loves to sleep all day.\"</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\">名字太长; 年龄小于0.</span><br><span class=\"line\">能通过验证的JSON</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">  <span class=\"attr\">\"name\"</span>: <span class=\"string\">\"Fluffy\"</span>,</span><br><span class=\"line\">  <span class=\"attr\">\"age\"</span>: <span class=\"number\">3</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"JSON中的安全问题\"><a href=\"#JSON中的安全问题\" class=\"headerlink\" title=\"JSON中的安全问题\"></a>JSON中的安全问题</h3><p>跨站请求伪造CSRF和跨站脚本攻击CSS</p>\n<h4 id=\"跨站请求伪造-利用站点对用户浏览器的信任进行的攻击\"><a href=\"#跨站请求伪造-利用站点对用户浏览器的信任进行的攻击\" class=\"headerlink\" title=\"跨站请求伪造: 利用站点对用户浏览器的信任进行的攻击.\"></a>跨站请求伪造: 利用站点对用户浏览器的信任进行的攻击.</h4><ol>\n<li>不要使用顶级数组. 顶级数组是合法的JavaScript脚本, 他们可以用script标签链接并使用.</li>\n<li>对于不想公开的资源, 仅允许使用HTTP POST方法请求, 而不是GET方法. GET方法可以用过URL来请求, 甚至可以放在script标签中.<figure class=\"highlight json\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[</span><br><span class=\"line\">  &#123;</span><br><span class=\"line\">    <span class=\"attr\">\"user\"</span>: <span class=\"string\">\"psilo\"</span></span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  &#123;</span><br><span class=\"line\">    <span class=\"attr\">\"phone\"</span>: <span class=\"string\">\"555-555-5555\"</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">]</span><br><span class=\"line\"><span class=\"comment\">// 将数组存放到对象之中, 这样说的非法的JavaScript, 不会被script变迁加载</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">  <span class=\"attr\">\"info\"</span>: [</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">      <span class=\"attr\">\"user\"</span>: <span class=\"string\">\"psilo\"</span></span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">      <span class=\"attr\">\"phone\"</span>: <span class=\"string\">\"555-555-5555\"</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  ]</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n</li>\n</ol>\n<h4 id=\"跨站脚本攻击-通过截取或将站点中所使用的第三方代码更换为恶意脚本-来对站点进行的一种注入攻击\"><a href=\"#跨站脚本攻击-通过截取或将站点中所使用的第三方代码更换为恶意脚本-来对站点进行的一种注入攻击\" class=\"headerlink\" title=\"跨站脚本攻击: 通过截取或将站点中所使用的第三方代码更换为恶意脚本, 来对站点进行的一种注入攻击.\"></a>跨站脚本攻击: 通过截取或将站点中所使用的第三方代码更换为恶意脚本, 来对站点进行的一种注入攻击.</h4><ol>\n<li>使用JSON.parse()来代替eval(). eval()函数会将传入的字符串编译并执行, 这会让你的代码易被攻击. 应仅适用JSON.parse()来解析JSON数据.</li>\n</ol>\n<h3 id=\"JavaScript中的XMLHttpRequest与Web-API\"><a href=\"#JavaScript中的XMLHttpRequest与Web-API\" class=\"headerlink\" title=\"JavaScript中的XMLHttpRequest与Web API\"></a>JavaScript中的XMLHttpRequest与Web API</h3><p>XMLHttpRequest负责在客户端发起请求, 而Web API负责在服务端返回响应</p>\n<h4 id=\"JavaScript中的XMLHttpRequest对象\"><a href=\"#JavaScript中的XMLHttpRequest对象\" class=\"headerlink\" title=\"JavaScript中的XMLHttpRequest对象\"></a>JavaScript中的XMLHttpRequest对象</h4><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// XMLHttpRequest对象用法</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> xml = <span class=\"keyword\">new</span> XMLHttpRequest();</span><br><span class=\"line\">xml.open(method, url, <span class=\"keyword\">async</span>(可选), user(可选), password(可选));</span><br><span class=\"line\">xml.send();</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// XMLHttpRequest对象的一些属性</span></span><br><span class=\"line\"><span class=\"comment\">// 可以在代码中给它负值为一个函数</span></span><br><span class=\"line\">onreadystatechange </span><br><span class=\"line\"><span class=\"comment\">/* 返回一个0-4的值, 用来表示状态码</span></span><br><span class=\"line\"><span class=\"comment\"> * 0表示open()函数还没有执行.</span></span><br><span class=\"line\"><span class=\"comment\"> * 1表示open()已执行, 但send()函数还没有执行</span></span><br><span class=\"line\"><span class=\"comment\"> * 2表示send()函数已执行切头部和状态码都可以获取了</span></span><br><span class=\"line\"><span class=\"comment\"> * 3表示头部已经收到, 但响应体正在解析中</span></span><br><span class=\"line\"><span class=\"comment\"> * 4表示请求完成, 包括响应头和响应体的内容都已经接受到了</span></span><br><span class=\"line\"><span class=\"comment\">*/</span></span><br><span class=\"line\">readyState</span><br><span class=\"line\"><span class=\"comment\">// 返回HTTP状态码 如200</span></span><br><span class=\"line\">status</span><br><span class=\"line\"><span class=\"comment\">// 当请求成功时, 该属性会包含作为文本的响应体</span></span><br><span class=\"line\">responseText </span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// eg</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> xml = <span class=\"keyword\">new</span> XMLHttpRequest();</span><br><span class=\"line\"><span class=\"keyword\">var</span> url = <span class=\"string\">\"http://api.openweathermap.org/data/2.5/weather?lat=35&amp;lon=139\"</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">xml.onreadystatechange = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span>(xml.readyState == <span class=\"number\">4</span> &amp;&amp; xml.status == <span class=\"number\">200</span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> myObject = <span class=\"built_in\">JSON</span>.parse(xml.responseText);</span><br><span class=\"line\">    <span class=\"keyword\">var</span> myJson = <span class=\"built_in\">JSON</span>.stringify(myObject);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">xml.openk(<span class=\"string\">\"GET\"</span>, url, <span class=\"literal\">true</span>);</span><br><span class=\"line\">xml.send();</span><br></pre></td></tr></table></figure>\n\n<p>很明显, url的地址和请求的地址不太可能是同一域名, 显然这违背了同源策略, 所以我们需要资源共享. 有些开发人员可以持续多年通过JavaScript的AJAX技术向公共API发送请求, 而不会收到同源策略的影响, 这是因为这些公共API的开发者在他们的服务器上实现了跨域资源共享CORS. 这些服务器会在响应头额外加上一些带有Access-Control-Allow前缀的属性. 如Access-Control-Allow-Origin:*; 定义了任意域名都是允许使用的. 之前跨站请求伪造也可以通过在其响应头加入具体站点域名来禁止其他站点去获取资源, 这样script里的站点地址也就失效了.</p>\n<h4 id=\"JSONP\"><a href=\"#JSONP\" class=\"headerlink\" title=\"JSONP\"></a>JSONP</h4><p>带有padding的JSON. 将JavaScript加入JSON文档, 内联与JSON文档的JavaScript调用一个函数, 函数参数是JSON. 函数参数提供了一种将数据传递给函数的方式. JSON-P还需要服务端的不少支持,  因为JSON资源必须包含JavaScript内联..</p>\n<h3 id=\"JSON与客户端框架\"><a href=\"#JSON与客户端框架\" class=\"headerlink\" title=\"JSON与客户端框架\"></a>JSON与客户端框架</h3><p>框架可以节省时间, 让我们更专注于功能的构建. </p>\n<h4 id=\"jQuery\"><a href=\"#jQuery\" class=\"headerlink\" title=\"jQuery\"></a>jQuery</h4><p>jQuery是一种允许开发者专注于操作DOM构建功能的抽象化工具. 如JSON.parse(), 在老版本的IE, Firefox, chrome并不支持. jQuery帮我们解决了大部分兼容问题.</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> myAnimal = <span class=\"built_in\">JSON</span>.parse(<span class=\"string\">'&#123; \"animal\": \"cat\"&#125;'</span>); <span class=\"comment\">// 有兼容问题</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// jQuery内置的方法来解析JSON</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> myAnimal = jQuery.parseJSON(<span class=\"string\">'&#123;\"animal\": \"cat\"&#125;'</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 用JQuery创建新的XMLHttpRequest对象, 并从OpenWeatherMap API 获取JSON</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> url = <span class=\"string\">\"http://api.openweathermap.org/data/2.5/weather?lat=35&amp;lon=139\"</span>;</span><br><span class=\"line\">$.getJSON(url, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">data</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">// 对天气数据操作</span></span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"AngularJS\"><a href=\"#AngularJS\" class=\"headerlink\" title=\"AngularJS\"></a>AngularJS</h4><p>AngularJS是为DOM操作服务的抽象化工具, 专注单页Web应用的开发. 是基于实现MVC构架概念的框架. </p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/* MVC</span></span><br><span class=\"line\"><span class=\"comment\"> * JSON是模型</span></span><br><span class=\"line\"><span class=\"comment\"> * HTML是试图</span></span><br><span class=\"line\"><span class=\"comment\"> * 控制器是使用AngularJS语法来定义和操作与模型和试图间的交互的JavaScript文件.</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"comment\">// 从OpenWeatherMap API获取天气数据</span></span><br><span class=\"line\">angular.module(<span class=\"string\">'myApp'</span>, []).controller(<span class=\"string\">'myAppController'</span>, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">$scope, $http</span>) </span>&#123;</span><br><span class=\"line\">  $http.get(<span class=\"string\">\"http://api.openweathermap.org/data/2.5/weather?lat=35&amp;lon=139\"</span>).success(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">data, status, headers, config</span>) </span>&#123;</span><br><span class=\"line\">    $scope.weatherData = data;</span><br><span class=\"line\">  &#125;);</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n\n<p>从OpenWeatherMap API返回的JSON数据会被$http反序列化, 然后将名为wetherData的对象呗添加到全局作用域. 这样就能通过HTML试图的插值语法将其作为数据模型进行绑定了.</p>\n<h3 id=\"JSON与NoSQL\"><a href=\"#JSON与NoSQL\" class=\"headerlink\" title=\"JSON与NoSQL\"></a>JSON与NoSQL</h3><p>SQL: 关系型数据库, 使用表格, 行和列来以结构化形式存储数据的. NoSQL: 顾名思义, 不是关系型数据库, 它可以是键值对存储.</p>\n<h4 id=\"CouchDB-使用JSON文档存储数据的文档存储数据库的NoSQL数据库\"><a href=\"#CouchDB-使用JSON文档存储数据的文档存储数据库的NoSQL数据库\" class=\"headerlink\" title=\"CouchDB: 使用JSON文档存储数据的文档存储数据库的NoSQL数据库\"></a>CouchDB: 使用JSON文档存储数据的文档存储数据库的NoSQL数据库</h4><p>在关系型数据库中, 对于一个账户对应多个地址这种一对多的关系, 需要执行联合查询, 以便把数据放在一起. 有了CouchDB, 数据就不需要因为它们之间的关系而被分开存储, 也不需要再读取时进行重组.</p>\n<figure class=\"highlight json\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;</span><br><span class=\"line\">  <span class=\"attr\">\"firstName\"</span>: <span class=\"string\">\"Bob\"</span>,</span><br><span class=\"line\">  <span class=\"attr\">\"lastName\"</span>: <span class=\"string\">\"Barker\"</span>,</span><br><span class=\"line\">  <span class=\"attr\">\"age\"</span>: <span class=\"string\">\"91\"</span>,</span><br><span class=\"line\">  <span class=\"attr\">\"addresses\"</span>: [</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">      <span class=\"attr\">\"street\"</span>: <span class=\"string\">\"123 fake st\"</span>,</span><br><span class=\"line\">      <span class=\"attr\">\"city\"</span>: <span class=\"string\">\"somewhere\"</span></span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">      <span class=\"attr\">\"street\"</span>: <span class=\"string\">\"456 fakey ln\"</span>,</span><br><span class=\"line\">      <span class=\"attr\">\"city\"</span>: <span class=\"string\">\"some place\"</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  ]</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>由于CouchDB使用文档来存储数据, 因此从数据库查询一个账户时, 得到的直接就是一个结构化文档, 没有必要进行重组. 另一个好处是有利于数据的变化, 有些数据会随着时间而发生变化, 如电话号码, 当账户将来又有了新的号码, 只需要将其加入存储电话的数据即可</p>\n<h4 id=\"CouchDB-API\"><a href=\"#CouchDB-API\" class=\"headerlink\" title=\"CouchDB API\"></a>CouchDB API</h4><p>对于HTTP, 我们是通过URL的方式来请求资源的, 从CouchDB API中请求的资源是一份JSON文档</p>\n<figure class=\"highlight json\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 本地名为accounts的数据库</span></span><br><span class=\"line\"><span class=\"comment\">// http://localhost:8080/accounts</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">  <span class=\"attr\">\"db_name\"</span>: <span class=\"string\">\"accounts\"</span>,</span><br><span class=\"line\">  <span class=\"attr\">\"doc_count\"</span>: <span class=\"number\">3</span>,</span><br><span class=\"line\">  <span class=\"attr\">\"doc_del_count\"</span>: <span class=\"number\">0</span>,</span><br><span class=\"line\">  <span class=\"attr\">\"update_seq\"</span>: <span class=\"number\">7</span>,</span><br><span class=\"line\">  <span class=\"attr\">\"purge_seq\"</span>: <span class=\"number\">0</span>,</span><br><span class=\"line\">  <span class=\"attr\">\"compact_running\"</span>: <span class=\"literal\">false</span>,</span><br><span class=\"line\">  <span class=\"attr\">\"disk_size\"</span>: <span class=\"number\">29999</span>,</span><br><span class=\"line\">  <span class=\"attr\">\"data_size\"</span>: <span class=\"number\">1222</span>,</span><br><span class=\"line\">  <span class=\"attr\">\"instance_start_time\"</span>: <span class=\"string\">\"1432493477586600\"</span>,</span><br><span class=\"line\">  <span class=\"attr\">\"disk_format_version\"</span>: <span class=\"number\">6</span>,</span><br><span class=\"line\">  <span class=\"attr\">\"committed_update_seq\"</span>: <span class=\"number\">7</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// 其中的\"doc_count\"表示数据库中包含多少份文档. 这里是3份, 可以通过每个文档的位移标识符来对其进行查询,可以通过http://localhost:8080/accounts/_all_docs这一URL来获取行标识符数组. 如标识符是3636fa3c716f9dd4f7407bd6f7000552. 访问http://localhost:8080/accounts/3636fa3c716f9dd4f7407bd6f7000552可得以下JSON资源</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">  <span class=\"attr\">\"_id\"</span>: <span class=\"string\">\"3636fa3c716f9dd4f7407bd6f7000552\"</span>,</span><br><span class=\"line\">  <span class=\"attr\">\"_rev\"</span>: <span class=\"string\">\"1-8a9527cbfc22e28984dfb3a3e6062635\"</span>,</span><br><span class=\"line\">  <span class=\"attr\">\"firstName\"</span>: <span class=\"string\">\"Billy\"</span>,</span><br><span class=\"line\">  <span class=\"attr\">\"lastName\"</span>: <span class=\"string\">\"Bob\"</span>,</span><br><span class=\"line\">  <span class=\"attr\">\"age\"</span>: <span class=\"string\">\"91\"</span>,</span><br><span class=\"line\">  <span class=\"attr\">\"addresses\"</span>: [</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">      <span class=\"attr\">\"street\"</span>: <span class=\"string\">\"123 fake st\"</span>,</span><br><span class=\"line\">      <span class=\"attr\">\"city\"</span>: <span class=\"string\">\"somewhere\"</span></span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">      <span class=\"attr\">\"street\"</span>: <span class=\"string\">\"456 fakey ln\"</span>,</span><br><span class=\"line\">      <span class=\"attr\">\"city\"</span>: <span class=\"string\">\"some place\"</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  ]</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// 上述是从CouchDB数据库请求数据, 下面说说如何向数据库发送数据</span></span><br><span class=\"line\"><span class=\"comment\">// 通过向http://localhost:8080/accounts/这一URL post数据来实现</span></span><br><span class=\"line\"><span class=\"comment\">// 通过post方法请求 http://localhost:8080/accounts/的HTTP请求头</span></span><br><span class=\"line\">POST /accounts/ HTTP/1.1</span><br><span class=\"line\">Host: localhost:8080</span><br><span class=\"line\">Content_type: application/json</span><br><span class=\"line\">Cache-control: no-cache</span><br><span class=\"line\"><span class=\"comment\">// 通过post方法请求 http://localhost:8080/accounts/ 的HTTP请求体</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">  <span class=\"attr\">\"firstName\"</span>: <span class=\"string\">\"Psilo\"</span>,</span><br><span class=\"line\">  <span class=\"attr\">\"lastName\"</span>: <span class=\"string\">\"Lau\"</span>,</span><br><span class=\"line\">  <span class=\"attr\">\"age\"</span>: <span class=\"string\">\"18\"</span>,</span><br><span class=\"line\">  <span class=\"attr\">\"addresses\"</span>: [</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">      <span class=\"attr\">\"street\"</span>: <span class=\"string\">\"1234 fake st\"</span>,</span><br><span class=\"line\">      <span class=\"attr\">\"city\"</span>: <span class=\"string\">\"somehwhere\"</span></span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">      <span class=\"attr\">\"street\"</span>: <span class=\"string\">\"4567 fakey ln\"</span>,</span><br><span class=\"line\">      <span class=\"attr\">\"city\"</span>: <span class=\"string\">\"some place\"</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  ]  </span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// http请求成功后, CounchDB API会将JSON格式的相应信息发送给你, 其中包含了新创建的文档的标识符.</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">  <span class=\"attr\">\"ok\"</span>: <span class=\"literal\">true</span>,</span><br><span class=\"line\">  <span class=\"attr\">\"id\"</span>: <span class=\"string\">\"3asd564sa6451654v6sd4v6d4asv6\"</span>,</span><br><span class=\"line\">  <span class=\"attr\">\"rev\"</span>: <span class=\"string\">\"1-as564ff6sd31v6asd54v6ads4v\"</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// 这时候可以用心的标识符来创建URL, 并从账户数据库中请求JSON文档.</span></span><br><span class=\"line\"><span class=\"comment\">// http://localhost:8080/accounts/3asd564sa6451654v6sd4v6d4asv6的响应</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">  <span class=\"attr\">\"_id\"</span>: <span class=\"string\">\"3asd564sa6451654v6sd4v6d4asv6\"</span>,</span><br><span class=\"line\">  <span class=\"attr\">\"_rev\"</span>: <span class=\"string\">\"1-as564ff6sd31v6asd54v6ads4v\"</span>,</span><br><span class=\"line\">  <span class=\"attr\">\"firstName\"</span>: <span class=\"string\">\"Psilo\"</span>,</span><br><span class=\"line\">  <span class=\"attr\">\"lastName\"</span>: <span class=\"string\">\"Lau\"</span>,</span><br><span class=\"line\">  <span class=\"attr\">\"age\"</span>: <span class=\"string\">\"18\"</span>,</span><br><span class=\"line\">  <span class=\"attr\">\"addresses\"</span>: [</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">      <span class=\"attr\">\"street\"</span>: <span class=\"string\">\"1234 fake st\"</span>,</span><br><span class=\"line\">      <span class=\"attr\">\"city\"</span>: <span class=\"string\">\"somehwhere\"</span></span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">      <span class=\"attr\">\"street\"</span>: <span class=\"string\">\"4567 fakey ln\"</span>,</span><br><span class=\"line\">      <span class=\"attr\">\"city\"</span>: <span class=\"string\">\"some place\"</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  ]</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// 如果希望更新刚刚插入的JSON文档, 可以通过在post请求改子欧元deURL时, 将\"_id\" \"_rev\"加入请求体来实现, 成功后, API会响应一个说明状态的JSON文档, 其中会包含更新后的\"rev\"键值对.</span></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"服务端的JSON\"><a href=\"#服务端的JSON\" class=\"headerlink\" title=\"服务端的JSON\"></a>服务端的JSON</h3><p>客户端: html css js<br>服务端: php asp.net nodejs ruby java go等<br>在服务端, 我们通过HTTP想服务端发送资源请求. 服务端会响应一份文档, 当文档是JSON时, 必须要用服务端代码来生成它. 同时, 服务端可能要先接受一个JSON文档才能返回一个JSON文档.</p>\n<h4 id=\"序列化、反序列化与请求JSON\"><a href=\"#序列化、反序列化与请求JSON\" class=\"headerlink\" title=\"序列化、反序列化与请求JSON\"></a>序列化、反序列化与请求JSON</h4><h1 id=\"ASP-NET\"><a href=\"#ASP-NET\" class=\"headerlink\" title=\"ASP.NET\"></a>ASP.NET</h1><p>ASP.NET是由微软开发的服务端WEB框架, 在ASP.NET解析JSON不想js中那么简单, 需要第三方ASP.NET库. 最流行的库是Json.NET<br>有了ASP.NET和Json.NET 可以快速地将ASP.NET对象序列化为JSON. 首先需要一个用于操作的JSON对象.</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">CustomerAccount</span></span></span><br><span class=\"line\"><span class=\"class\"></span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">public</span> string firstName &#123; get; set; &#125;</span><br><span class=\"line\">  <span class=\"keyword\">public</span> string lastName &#123; get; set; &#125;</span><br><span class=\"line\">  <span class=\"keyword\">public</span> string phone &#123; get; set; &#125;</span><br><span class=\"line\">  <span class=\"keyword\">public</span> Address[] addresses &#123; get; set; &#125;</span><br><span class=\"line\">  <span class=\"keyword\">public</span> bool famous &#123; get; set;&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Address</span></span></span><br><span class=\"line\"><span class=\"class\"></span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">public</span> string street &#123; get; set; &#125;</span><br><span class=\"line\">  <span class=\"keyword\">public</span> string city &#123; get; set; &#125;</span><br><span class=\"line\">  <span class=\"keyword\">public</span> string state &#123; get; set; &#125;</span><br><span class=\"line\">  <span class=\"keyword\">public</span> <span class=\"keyword\">int</span> zip &#123; get; set; &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// 有了表示对象的类, 现在就创建一个新的对象以保存Bob Barker 的信息</span></span><br><span class=\"line\">CustomerAccount bobsAccount = <span class=\"keyword\">new</span> CustomerAccount();</span><br><span class=\"line\">bobsAccount.firstName = <span class=\"string\">\"Bob\"</span>;</span><br><span class=\"line\">bobsAccount.lastName = <span class=\"string\">\"Barker\"</span>;</span><br><span class=\"line\">bobsAccount.phone = <span class=\"string\">\"555-55-55555\"</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">Address[] addresses;</span><br><span class=\"line\">addresses = <span class=\"keyword\">new</span> Address[<span class=\"number\">2</span>];</span><br><span class=\"line\">Address bobsAddress1 = <span class=\"keyword\">new</span> Address();</span><br><span class=\"line\">bobsAddress1.state = <span class=\"string\">\"123 fakey st\"</span>;</span><br><span class=\"line\">bobsAddress1.city = <span class=\"string\">\"somewhere\"</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">addresses[<span class=\"number\">0</span>] = bobsAddress1;</span><br><span class=\"line\"></span><br><span class=\"line\">Address bobsAddress2 = <span class=\"keyword\">new</span> Address();</span><br><span class=\"line\">bobsAddress2.state = <span class=\"string\">\"456 fakei ln\"</span>;</span><br><span class=\"line\">bobsAddress2.city = <span class=\"string\">\"some place\"</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">addresses[<span class=\"number\">1</span>] = bobsAddress1;</span><br><span class=\"line\"></span><br><span class=\"line\">string json = JsonConvert.SerializeObject(bobsAccount);</span><br><span class=\"line\"><span class=\"comment\">// 序列化后的ASP.NET CustomerAccount对象</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">  <span class=\"string\">\"firstName\"</span>: <span class=\"string\">\"Bob\"</span>,</span><br><span class=\"line\">  <span class=\"string\">\"lastName\"</span>: <span class=\"string\">\"Barker\"</span>,</span><br><span class=\"line\">  <span class=\"string\">\"phone\"</span>: <span class=\"string\">\"555-55-55555\"</span>,</span><br><span class=\"line\">  <span class=\"string\">\"addresses\"</span>: [</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">      <span class=\"string\">\"street\"</span>: <span class=\"string\">\"123 fake st\"</span>,</span><br><span class=\"line\">      <span class=\"string\">\"city\"</span>: <span class=\"string\">\"somehwhere\"</span></span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">      <span class=\"string\">\"street\"</span>: <span class=\"string\">\"456 fakey ln\"</span>,</span><br><span class=\"line\">      <span class=\"string\">\"city\"</span>: <span class=\"string\">\"some place\"</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  ]</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// 反序列化JSON</span></span><br><span class=\"line\">CustomerAccount customerAccount = JsonConvert.DeserializeObject&lt;CustomerAccount&gt;(json);</span><br></pre></td></tr></table></figure>\n\n<h1 id=\"php\"><a href=\"#php\" class=\"headerlink\" title=\"php\"></a>php</h1><p>php是一种用于创建动态WEb页面的服务端脚本语言. php代码可以直接嵌入html文档中, 也支持对象数据类型.</p>\n<figure class=\"highlight php\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">&lt;?php</span> </span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Account</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">public</span> $firstName;</span><br><span class=\"line\">  <span class=\"keyword\">public</span> $lastName;</span><br><span class=\"line\">  <span class=\"keyword\">public</span> $phone;</span><br><span class=\"line\">  <span class=\"keyword\">public</span> $addresses;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Address</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">public</span> $street;</span><br><span class=\"line\">  <span class=\"keyword\">public</span> $city;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">$address1 = <span class=\"keyword\">new</span> Address();</span><br><span class=\"line\">$address1-&gt;street = <span class=\"string\">\"123 fake st\"</span>;</span><br><span class=\"line\">$address1-&gt;city = <span class=\"string\">\"somewhere\"</span>;</span><br><span class=\"line\">$address2 = <span class=\"keyword\">new</span> Address();</span><br><span class=\"line\">$address2-&gt;street = <span class=\"string\">\"456 fakey ln\"</span>;</span><br><span class=\"line\">$address2-&gt;city = <span class=\"string\">\"some place\"</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">$account = <span class=\"keyword\">new</span> Account();</span><br><span class=\"line\">$account-&gt;firstName = <span class=\"string\">\"Bob\"</span>;</span><br><span class=\"line\">$account-&gt;lastName = <span class=\"string\">\"Barker\"</span>;</span><br><span class=\"line\">$account-&gt;phone = <span class=\"string\">\"555-55-55555\"</span>;</span><br><span class=\"line\">$account-&gt;address = <span class=\"keyword\">array</span>($address1, address2);</span><br><span class=\"line\"></span><br><span class=\"line\">$json = json_encode($account);</span><br><span class=\"line\"><span class=\"meta\">?&gt;</span></span><br><span class=\"line\"><span class=\"comment\">//json_encoude($account)返回的结果</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">  <span class=\"string\">\"firstName\"</span>: <span class=\"string\">\"Bob\"</span>,</span><br><span class=\"line\">  <span class=\"string\">\"lastName\"</span>: <span class=\"string\">\"Barker\"</span>,</span><br><span class=\"line\">  <span class=\"string\">\"phone\"</span>: <span class=\"string\">\"555-55-55555\"</span>,</span><br><span class=\"line\">  <span class=\"string\">\"addresses\"</span>: [</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">      <span class=\"string\">\"street\"</span>: <span class=\"string\">\"123 fake st\"</span>,</span><br><span class=\"line\">      <span class=\"string\">\"city\"</span>: <span class=\"string\">\"somehwhere\"</span></span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">      <span class=\"string\">\"street\"</span>: <span class=\"string\">\"456 fakey ln\"</span>,</span><br><span class=\"line\">      <span class=\"string\">\"city\"</span>: <span class=\"string\">\"some place\"</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  ]</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// 反序列化json 相对的使用json_decode</span></span><br></pre></td></tr></table></figure>\n\n<h1 id=\"nodejs\"><a href=\"#nodejs\" class=\"headerlink\" title=\"nodejs\"></a>nodejs</h1><p>nodejs是服务端的js, 在nodejs不再使用XMLHttpRequest对象, 在nodejs中通过get()函数来请求json</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 通过向openweathermap API发送请求, 得到的JSON反序列化为JS对象, 然后通过console.log输出(coord)坐标对象 </span></span><br><span class=\"line\"><span class=\"keyword\">var</span> http = <span class=\"built_in\">require</span>(<span class=\"string\">'http'</span>);</span><br><span class=\"line\">http.get(&#123;</span><br><span class=\"line\">  host: <span class=\"string\">'api.openweathermap.org'</span>,</span><br><span class=\"line\">  path: <span class=\"string\">'/data/2.5/weather?q=london,uk'</span></span><br><span class=\"line\">&#125;, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">response</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> body = <span class=\"string\">''</span>;</span><br><span class=\"line\">  response.on(<span class=\"string\">'data'</span>, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">data</span>) </span>&#123;</span><br><span class=\"line\">    body += data;</span><br><span class=\"line\">  &#125;);</span><br><span class=\"line\">  response.on(<span class=\"string\">'end'</span>, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> weatherData = <span class=\"built_in\">JSON</span>.parse(body);</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(weatherData.coord);</span><br><span class=\"line\">  &#125;);</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>"},{"title":"IndexedDB浅析","date":"2021-03-25T03:21:02.000Z","_content":"\n##### 写在前面\n\n目前支撑的业务有大量数据存储在WebStorage的情况，考虑到WebStorage容量的限制，研究了一下浏览器提供的本地数据库————IndexedDB\n\n#### IndexedDB概述\n\nIndexedDB是一种底层的异步API，是一种在用户浏览器中持久存储数据的方法。它允许您在不考虑网络的可用性，创建具有丰富查询能力的可离线Web应用程序。对于在客户端存储大量的结构化数据和不需要持久在线网络连接的应用程序中很有用。  \n\n通俗地说，IndexedDB 就是浏览器提供的本地数据库，它可以被网页脚本创建和操作。IndexedDB 允许储存大量数据，提供查找接口，还能建立索引。就数据库类型而言，IndexedDB 不属于关系型数据库（不支持 SQL 查询语句），更接近 NoSQL 数据库（简单好使）。  \n\n值得一提的是，过去的竞争规范（WebSQL）数据库是关系型数据库（复杂），但是已经被W3C废弃。\n\n<!-- more -->\n\n##### 为何IndexedDB会诞生\n\n现有的浏览器数据储存方案，都不适合存储大量数据：\n\n1. Cookie的大小不超过4KB，且每次请求都会发送回服务器；\n2. LocalStorage约在5MB左右（各家浏览器不同，IE浏览器约3M左右），且不提供搜索功能，不能建立自定义索引。\n\n为了解决痛点，IndexedDB就应邀诞生了。\n\n##### IndexedDB目前的兼容性（2021.03）\n\n![兼容性](compatibility.png)\n\n##### IndexedDB的特性\n\n1. 键值对储存\n\nIndexedDB内部采用对象仓库（object store）存放数据。所有类型的数据都可以直接存入，包括JavaScript对象。对象仓库中，数据以“键值对”的形式保存，每一个数据记录都有对应的主键，主键是独一无二的，不能有重复。\n\n2. 异步\n\nIndexedDB操作时不会锁死浏览器，用户依然可以进行其他操作，这与LocalStorage形成对比，后者的操作是同步的。异步设计是为了防止大量数据的读写，拖慢网页的表现。值得注意的是，IndexedDB也有同步API，目前已从规范中移除。\n\n3. 支持事务\n\nIndexedDB支持事务（transaction），这意味着一系列操作步骤之中，只要有一步失败，整个事务就都取消，数据库回滚到事务发生之前的状态，不存在只改写一部分数据的情况。\n\n4. 同源策略\n\nIndexedDB受到同源限制，每一个数据库对应创建它的域名。网页只能访问自身域名下的数据库，而不能访问跨域的数据库。\n\n5. 储存空间大\n\nIndexedDB的储存空间比LocalStorage大得多，理论上取决于硬盘大小：为可用磁盘空间的50%。\n\n6. 支持二进制储存\n\nIndexedDB不仅可以储存字符串，还可以储存二进制数据（ArrayBuffer对象和Blob对象，理论上支持任意格式的数据）。\n\n##### IndexedDB的局限性\n\n以下情况不适合使用IndexedDB：\n\n* 多语言混合存储。国际化支持不好，需要自己处理。\n* 和服务器端数据库同步。得自己写同步代码。\n* 全文搜索。IndexedDB接口没有类型SQL语句中LIKE的功能。\n\n\n以下情况，数据库可能被清除：\n\n* 用户请求清除数据。\n* 浏览器处于隐私模式。最后退出浏览器的时候，数据会被清除。\n* 硬盘等存储设备的容量到限或损坏。\n\n#### IndexedDB的核心用法\n\nIndexedDB API是强大的，也是复杂的，涉及不少概念。它把不同的实体，抽象成一个个对象接口。学习这个API，就是学习它的各种对象接口。\n\n* indexedDB：挂载在window的构造函数\n* IDBRequest：操作请求\n* IDBDatabase：数据库对象\n* IDBObjectStore：对象仓库\n* IDBTransaction：事务\n* IDBIndex：索引\n* IDBCursor：指针\n* IDBKeyRange：主键集合\n\n\n##### indexedDB对象：\n* open(数据库名称, 数据库版本号 = 1)方法：用于打开数据库，如果不存在，会新建该数据库。异步回调（success、error、upgradeneeded、blocked）\n\n* deleteDatabase(数据库名称)方法：删除一个数据库。异步回调（success、error）\n \n* cmp(i, j)方法：比较两个主键的大小。返回整数（i === j为0、i > j为1、i < j为-1）\n\n![indexedDB对象](indexedDB_object.png)\n\n##### IDBRequest对象：\n操作请求，表示打开的数据库连接，数据库的操作都是通过这个对象执行的。indexedDB.open()和deleteDatabase()会返回这个对象。\n\n##### IDBDatabase对象：\n通过IDBRequest对象的回调result属性获得。后面对数据库的操作，都通过这个对象完成。\n\n* objectStoreNames(对象仓库名称)：包含当前数据库所有object store的名字，可以使用contains方法检查数据库是否包含某个对象仓库\n* createObjectStore(名, 对象仓库的可配置属性)：创建存放数据库的对象仓库，返回IDBObjectStore对象，\n* deleteObjectStore(对象仓库名称)：删除指定的对象仓库 \n* transaction(对象仓库名称，读取权限 = “readonly”)：返回一个IDBTransaction事务对象\n* close()：关闭数据库连接\n\n可配置属性：\nkeyPath：主键\nautoIncrement：自增主键，如果没有适合作主键的属性。\n\n##### IDBObjectStore对象\n对象仓库。由IDBDatabase.createObjectStore()返回。它是直接操作数据的对象。\n\n值得注意的是，IDBDatabase对象的transaction()返回一个事务对象，事务对象的objectStore()反回IDBObjectStore对象，因此可以采用链式写法\n\n* add(键值, 主键)方法：用于向对象仓库添加数据，返回一个IDBRequest对象。该方法只用于添加数据，如果主键相同则会报错，因此更新数据必须使用put()方法\n* put(数据, 主键)方法：用于更新某个主键对应的数据记录，如果不存在则插入一条新的记录。返回一个IDBRequest对象\n* clear()方法：删除当前对象仓库的所有记录，返回一个IDBRequest对象 \n* delelte(主键)方法：删除指定主键的记录，返回一个IDBRequest对象\n* count()方法：用于计算记录的数量，返回一个IDBRequest对象。不带参数时，返回当前对象仓库的所有记录数量。如果主键或IDBKeyRange对象作为参数，则返回对应的记录数量\n* getKey()、get(主键)、getAll()、getAllKeys()、index(name)、createIndex()、deleteIndex()、openCursor()、openKeyCursor()，etc。\n\n##### IDBTransaction对象\n事务，所有的读写操作都要通过这个对象，权限只有两种（readwrite、readonly）。IDBDatabase.transaction()返回就是事务对象。事务的执行顺序是按照创建的顺序，而不是发出请求的顺序。\n\n* abort()方法：终止当前事务，回滚所有已经进行的变更\n\n* objectStore(name)方法：返回指定名称的对象仓库\n\n##### IDBIndex对象\n索引，通过这个对象可以获取数据库里面的记录\n\n##### IDBCursor对象\n指针，用来遍历对象仓库或索引的记录\n\n##### IDBKeyRange对象\n主键集合，根据该集合的条件，可以获取数据仓库或索引里面的一组记录\n\n#### IndexedDB的打开方式\n\n比起干撸IndexedDB的API，社区已经有很多优秀而成熟的第三方库。上手简单，对开发者友好：\n\n[localForage](https://localforage.github.io/localForage/)\n\n[dexie](http://www.dexie.org/)\n\n[PouchDB](https://pouchdb.com/)\n\n目前来说，我们并不需要用到IndexedDB的很多API，我们只需要能够覆盖Web Storage的功能就可以了。上述的库对我们来说还是太大太复杂了。\n\n因此，干脆结合上述库的写法，自己动手封装一下API。几乎抹平了使用和学习成本。\n\n* getItem(key, value, callback)\n* setItem(key, callback)\n* removeItem(key, callback)\n* clear(callback)\n\n具体看下述代码：\n```javascript\nclass IndexedDB {\n  constructor (name = \"miaobao-store\") {\n    this.ready(name);\n  }\n  // 初始化\n  ready (name) {\n    return new Promise((resolve, reject) => {\n      if (this.db) {\n        resolve(this);\n      } else {\n        this.objectStoreName = name;\n        const request = window.indexedDB.open(\"MiaoBao\", 1);\n\n        request.onsuccess = (e) => {\n          this.db = e.target.result;\n          resolve(this);\n        };\n\n        request.onupgradeneeded = (e) => {\n          const db = e.target.result;\n          if (!db.objectStoreNames.contains(this.objectStoreName)) {\n            db.createObjectStore(this.objectStoreName);\n          }\n        };\n\n        request.onerror = (e) => {\n          reject(e);\n        };\n\n        request.onblocked = (e) => {\n          reject(e);\n        };\n      }\n    });\n  }\n  // 赋值\n  setItem (key, value, callback) {\n    return this.init((success, error) => {\n      const request = this.db\n        .transaction(this.objectStoreName, \"readwrite\")\n        .objectStore(this.objectStoreName)\n        .put(value, key);\n      request.onsuccess = () => success(value);\n      request.onerror = error;\n    }, callback);\n  }\n  // 取值\n  getItem (key, callback) {\n    return this.init((success, error) => {\n      const request = this.db\n        .transaction(this.objectStoreName)\n        .objectStore(this.objectStoreName)\n        .get(key);\n      request.onsuccess = () => success(request.result);\n      request.onerror = error;\n    }, callback);\n  }\n  // 清除\n  removeItem (key, callback) {\n    return this.init((success, error) => {\n      const request = this.db\n        .transaction(this.objectStoreName, \"readwrite\")\n        .objectStore(this.objectStoreName)\n        .delete(key);\n      request.onsuccess = () => success(key);\n      request.onerror = error;\n    }, callback);\n  }\n\n  clear (callback) {\n    return this.init((success, error) => {\n      const request = this.db\n        .transaction(this.objectStoreName, \"readwrite\")\n        .objectStore(this.objectStoreName)\n        .clear();\n      request.onsuccess = () => success(null);\n      request.onerror = error;\n    }, callback);\n  }\n\n  init (request, callback) {\n    return new Promise((resolve, reject) => {\n      const success = value => {\n        if (callback && typeof callback === \"function\") {\n          callback(false, value);\n        }\n        resolve(value);\n      }\n      const error = e => {\n        if (callback && typeof callback === \"function\") {\n          callback(e);\n        }\n        reject(e);\n      }\n      return this.ready(this.objectStoreName).then(() => {\n        request(success, error);\n      }).catch(error);\n    });\n  }\n}\n\nexport default IndexedDB;\n\n```\n\n","source":"_posts/indexedDB浅析.md","raw":"---\ntitle: IndexedDB浅析\ndate: 2021-03-25 11:21:02\ntags: [前端, JS]\n---\n\n##### 写在前面\n\n目前支撑的业务有大量数据存储在WebStorage的情况，考虑到WebStorage容量的限制，研究了一下浏览器提供的本地数据库————IndexedDB\n\n#### IndexedDB概述\n\nIndexedDB是一种底层的异步API，是一种在用户浏览器中持久存储数据的方法。它允许您在不考虑网络的可用性，创建具有丰富查询能力的可离线Web应用程序。对于在客户端存储大量的结构化数据和不需要持久在线网络连接的应用程序中很有用。  \n\n通俗地说，IndexedDB 就是浏览器提供的本地数据库，它可以被网页脚本创建和操作。IndexedDB 允许储存大量数据，提供查找接口，还能建立索引。就数据库类型而言，IndexedDB 不属于关系型数据库（不支持 SQL 查询语句），更接近 NoSQL 数据库（简单好使）。  \n\n值得一提的是，过去的竞争规范（WebSQL）数据库是关系型数据库（复杂），但是已经被W3C废弃。\n\n<!-- more -->\n\n##### 为何IndexedDB会诞生\n\n现有的浏览器数据储存方案，都不适合存储大量数据：\n\n1. Cookie的大小不超过4KB，且每次请求都会发送回服务器；\n2. LocalStorage约在5MB左右（各家浏览器不同，IE浏览器约3M左右），且不提供搜索功能，不能建立自定义索引。\n\n为了解决痛点，IndexedDB就应邀诞生了。\n\n##### IndexedDB目前的兼容性（2021.03）\n\n![兼容性](compatibility.png)\n\n##### IndexedDB的特性\n\n1. 键值对储存\n\nIndexedDB内部采用对象仓库（object store）存放数据。所有类型的数据都可以直接存入，包括JavaScript对象。对象仓库中，数据以“键值对”的形式保存，每一个数据记录都有对应的主键，主键是独一无二的，不能有重复。\n\n2. 异步\n\nIndexedDB操作时不会锁死浏览器，用户依然可以进行其他操作，这与LocalStorage形成对比，后者的操作是同步的。异步设计是为了防止大量数据的读写，拖慢网页的表现。值得注意的是，IndexedDB也有同步API，目前已从规范中移除。\n\n3. 支持事务\n\nIndexedDB支持事务（transaction），这意味着一系列操作步骤之中，只要有一步失败，整个事务就都取消，数据库回滚到事务发生之前的状态，不存在只改写一部分数据的情况。\n\n4. 同源策略\n\nIndexedDB受到同源限制，每一个数据库对应创建它的域名。网页只能访问自身域名下的数据库，而不能访问跨域的数据库。\n\n5. 储存空间大\n\nIndexedDB的储存空间比LocalStorage大得多，理论上取决于硬盘大小：为可用磁盘空间的50%。\n\n6. 支持二进制储存\n\nIndexedDB不仅可以储存字符串，还可以储存二进制数据（ArrayBuffer对象和Blob对象，理论上支持任意格式的数据）。\n\n##### IndexedDB的局限性\n\n以下情况不适合使用IndexedDB：\n\n* 多语言混合存储。国际化支持不好，需要自己处理。\n* 和服务器端数据库同步。得自己写同步代码。\n* 全文搜索。IndexedDB接口没有类型SQL语句中LIKE的功能。\n\n\n以下情况，数据库可能被清除：\n\n* 用户请求清除数据。\n* 浏览器处于隐私模式。最后退出浏览器的时候，数据会被清除。\n* 硬盘等存储设备的容量到限或损坏。\n\n#### IndexedDB的核心用法\n\nIndexedDB API是强大的，也是复杂的，涉及不少概念。它把不同的实体，抽象成一个个对象接口。学习这个API，就是学习它的各种对象接口。\n\n* indexedDB：挂载在window的构造函数\n* IDBRequest：操作请求\n* IDBDatabase：数据库对象\n* IDBObjectStore：对象仓库\n* IDBTransaction：事务\n* IDBIndex：索引\n* IDBCursor：指针\n* IDBKeyRange：主键集合\n\n\n##### indexedDB对象：\n* open(数据库名称, 数据库版本号 = 1)方法：用于打开数据库，如果不存在，会新建该数据库。异步回调（success、error、upgradeneeded、blocked）\n\n* deleteDatabase(数据库名称)方法：删除一个数据库。异步回调（success、error）\n \n* cmp(i, j)方法：比较两个主键的大小。返回整数（i === j为0、i > j为1、i < j为-1）\n\n![indexedDB对象](indexedDB_object.png)\n\n##### IDBRequest对象：\n操作请求，表示打开的数据库连接，数据库的操作都是通过这个对象执行的。indexedDB.open()和deleteDatabase()会返回这个对象。\n\n##### IDBDatabase对象：\n通过IDBRequest对象的回调result属性获得。后面对数据库的操作，都通过这个对象完成。\n\n* objectStoreNames(对象仓库名称)：包含当前数据库所有object store的名字，可以使用contains方法检查数据库是否包含某个对象仓库\n* createObjectStore(名, 对象仓库的可配置属性)：创建存放数据库的对象仓库，返回IDBObjectStore对象，\n* deleteObjectStore(对象仓库名称)：删除指定的对象仓库 \n* transaction(对象仓库名称，读取权限 = “readonly”)：返回一个IDBTransaction事务对象\n* close()：关闭数据库连接\n\n可配置属性：\nkeyPath：主键\nautoIncrement：自增主键，如果没有适合作主键的属性。\n\n##### IDBObjectStore对象\n对象仓库。由IDBDatabase.createObjectStore()返回。它是直接操作数据的对象。\n\n值得注意的是，IDBDatabase对象的transaction()返回一个事务对象，事务对象的objectStore()反回IDBObjectStore对象，因此可以采用链式写法\n\n* add(键值, 主键)方法：用于向对象仓库添加数据，返回一个IDBRequest对象。该方法只用于添加数据，如果主键相同则会报错，因此更新数据必须使用put()方法\n* put(数据, 主键)方法：用于更新某个主键对应的数据记录，如果不存在则插入一条新的记录。返回一个IDBRequest对象\n* clear()方法：删除当前对象仓库的所有记录，返回一个IDBRequest对象 \n* delelte(主键)方法：删除指定主键的记录，返回一个IDBRequest对象\n* count()方法：用于计算记录的数量，返回一个IDBRequest对象。不带参数时，返回当前对象仓库的所有记录数量。如果主键或IDBKeyRange对象作为参数，则返回对应的记录数量\n* getKey()、get(主键)、getAll()、getAllKeys()、index(name)、createIndex()、deleteIndex()、openCursor()、openKeyCursor()，etc。\n\n##### IDBTransaction对象\n事务，所有的读写操作都要通过这个对象，权限只有两种（readwrite、readonly）。IDBDatabase.transaction()返回就是事务对象。事务的执行顺序是按照创建的顺序，而不是发出请求的顺序。\n\n* abort()方法：终止当前事务，回滚所有已经进行的变更\n\n* objectStore(name)方法：返回指定名称的对象仓库\n\n##### IDBIndex对象\n索引，通过这个对象可以获取数据库里面的记录\n\n##### IDBCursor对象\n指针，用来遍历对象仓库或索引的记录\n\n##### IDBKeyRange对象\n主键集合，根据该集合的条件，可以获取数据仓库或索引里面的一组记录\n\n#### IndexedDB的打开方式\n\n比起干撸IndexedDB的API，社区已经有很多优秀而成熟的第三方库。上手简单，对开发者友好：\n\n[localForage](https://localforage.github.io/localForage/)\n\n[dexie](http://www.dexie.org/)\n\n[PouchDB](https://pouchdb.com/)\n\n目前来说，我们并不需要用到IndexedDB的很多API，我们只需要能够覆盖Web Storage的功能就可以了。上述的库对我们来说还是太大太复杂了。\n\n因此，干脆结合上述库的写法，自己动手封装一下API。几乎抹平了使用和学习成本。\n\n* getItem(key, value, callback)\n* setItem(key, callback)\n* removeItem(key, callback)\n* clear(callback)\n\n具体看下述代码：\n```javascript\nclass IndexedDB {\n  constructor (name = \"miaobao-store\") {\n    this.ready(name);\n  }\n  // 初始化\n  ready (name) {\n    return new Promise((resolve, reject) => {\n      if (this.db) {\n        resolve(this);\n      } else {\n        this.objectStoreName = name;\n        const request = window.indexedDB.open(\"MiaoBao\", 1);\n\n        request.onsuccess = (e) => {\n          this.db = e.target.result;\n          resolve(this);\n        };\n\n        request.onupgradeneeded = (e) => {\n          const db = e.target.result;\n          if (!db.objectStoreNames.contains(this.objectStoreName)) {\n            db.createObjectStore(this.objectStoreName);\n          }\n        };\n\n        request.onerror = (e) => {\n          reject(e);\n        };\n\n        request.onblocked = (e) => {\n          reject(e);\n        };\n      }\n    });\n  }\n  // 赋值\n  setItem (key, value, callback) {\n    return this.init((success, error) => {\n      const request = this.db\n        .transaction(this.objectStoreName, \"readwrite\")\n        .objectStore(this.objectStoreName)\n        .put(value, key);\n      request.onsuccess = () => success(value);\n      request.onerror = error;\n    }, callback);\n  }\n  // 取值\n  getItem (key, callback) {\n    return this.init((success, error) => {\n      const request = this.db\n        .transaction(this.objectStoreName)\n        .objectStore(this.objectStoreName)\n        .get(key);\n      request.onsuccess = () => success(request.result);\n      request.onerror = error;\n    }, callback);\n  }\n  // 清除\n  removeItem (key, callback) {\n    return this.init((success, error) => {\n      const request = this.db\n        .transaction(this.objectStoreName, \"readwrite\")\n        .objectStore(this.objectStoreName)\n        .delete(key);\n      request.onsuccess = () => success(key);\n      request.onerror = error;\n    }, callback);\n  }\n\n  clear (callback) {\n    return this.init((success, error) => {\n      const request = this.db\n        .transaction(this.objectStoreName, \"readwrite\")\n        .objectStore(this.objectStoreName)\n        .clear();\n      request.onsuccess = () => success(null);\n      request.onerror = error;\n    }, callback);\n  }\n\n  init (request, callback) {\n    return new Promise((resolve, reject) => {\n      const success = value => {\n        if (callback && typeof callback === \"function\") {\n          callback(false, value);\n        }\n        resolve(value);\n      }\n      const error = e => {\n        if (callback && typeof callback === \"function\") {\n          callback(e);\n        }\n        reject(e);\n      }\n      return this.ready(this.objectStoreName).then(() => {\n        request(success, error);\n      }).catch(error);\n    });\n  }\n}\n\nexport default IndexedDB;\n\n```\n\n","slug":"indexedDB浅析","published":1,"updated":"2021-07-02T05:57:23.366Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl5sb8gg6002yxq0rc3rkq0f1","content":"<h5 id=\"写在前面\"><a href=\"#写在前面\" class=\"headerlink\" title=\"写在前面\"></a>写在前面</h5><p>目前支撑的业务有大量数据存储在WebStorage的情况，考虑到WebStorage容量的限制，研究了一下浏览器提供的本地数据库————IndexedDB</p>\n<h4 id=\"IndexedDB概述\"><a href=\"#IndexedDB概述\" class=\"headerlink\" title=\"IndexedDB概述\"></a>IndexedDB概述</h4><p>IndexedDB是一种底层的异步API，是一种在用户浏览器中持久存储数据的方法。它允许您在不考虑网络的可用性，创建具有丰富查询能力的可离线Web应用程序。对于在客户端存储大量的结构化数据和不需要持久在线网络连接的应用程序中很有用。  </p>\n<p>通俗地说，IndexedDB 就是浏览器提供的本地数据库，它可以被网页脚本创建和操作。IndexedDB 允许储存大量数据，提供查找接口，还能建立索引。就数据库类型而言，IndexedDB 不属于关系型数据库（不支持 SQL 查询语句），更接近 NoSQL 数据库（简单好使）。  </p>\n<p>值得一提的是，过去的竞争规范（WebSQL）数据库是关系型数据库（复杂），但是已经被W3C废弃。</p>\n<a id=\"more\"></a>\n\n<h5 id=\"为何IndexedDB会诞生\"><a href=\"#为何IndexedDB会诞生\" class=\"headerlink\" title=\"为何IndexedDB会诞生\"></a>为何IndexedDB会诞生</h5><p>现有的浏览器数据储存方案，都不适合存储大量数据：</p>\n<ol>\n<li>Cookie的大小不超过4KB，且每次请求都会发送回服务器；</li>\n<li>LocalStorage约在5MB左右（各家浏览器不同，IE浏览器约3M左右），且不提供搜索功能，不能建立自定义索引。</li>\n</ol>\n<p>为了解决痛点，IndexedDB就应邀诞生了。</p>\n<h5 id=\"IndexedDB目前的兼容性（2021-03）\"><a href=\"#IndexedDB目前的兼容性（2021-03）\" class=\"headerlink\" title=\"IndexedDB目前的兼容性（2021.03）\"></a>IndexedDB目前的兼容性（2021.03）</h5><p><img src=\"//psilocine.github.io/2021/03/25/indexedDB浅析/compatibility.png\" alt=\"兼容性\"></p>\n<h5 id=\"IndexedDB的特性\"><a href=\"#IndexedDB的特性\" class=\"headerlink\" title=\"IndexedDB的特性\"></a>IndexedDB的特性</h5><ol>\n<li>键值对储存</li>\n</ol>\n<p>IndexedDB内部采用对象仓库（object store）存放数据。所有类型的数据都可以直接存入，包括JavaScript对象。对象仓库中，数据以“键值对”的形式保存，每一个数据记录都有对应的主键，主键是独一无二的，不能有重复。</p>\n<ol start=\"2\">\n<li>异步</li>\n</ol>\n<p>IndexedDB操作时不会锁死浏览器，用户依然可以进行其他操作，这与LocalStorage形成对比，后者的操作是同步的。异步设计是为了防止大量数据的读写，拖慢网页的表现。值得注意的是，IndexedDB也有同步API，目前已从规范中移除。</p>\n<ol start=\"3\">\n<li>支持事务</li>\n</ol>\n<p>IndexedDB支持事务（transaction），这意味着一系列操作步骤之中，只要有一步失败，整个事务就都取消，数据库回滚到事务发生之前的状态，不存在只改写一部分数据的情况。</p>\n<ol start=\"4\">\n<li>同源策略</li>\n</ol>\n<p>IndexedDB受到同源限制，每一个数据库对应创建它的域名。网页只能访问自身域名下的数据库，而不能访问跨域的数据库。</p>\n<ol start=\"5\">\n<li>储存空间大</li>\n</ol>\n<p>IndexedDB的储存空间比LocalStorage大得多，理论上取决于硬盘大小：为可用磁盘空间的50%。</p>\n<ol start=\"6\">\n<li>支持二进制储存</li>\n</ol>\n<p>IndexedDB不仅可以储存字符串，还可以储存二进制数据（ArrayBuffer对象和Blob对象，理论上支持任意格式的数据）。</p>\n<h5 id=\"IndexedDB的局限性\"><a href=\"#IndexedDB的局限性\" class=\"headerlink\" title=\"IndexedDB的局限性\"></a>IndexedDB的局限性</h5><p>以下情况不适合使用IndexedDB：</p>\n<ul>\n<li>多语言混合存储。国际化支持不好，需要自己处理。</li>\n<li>和服务器端数据库同步。得自己写同步代码。</li>\n<li>全文搜索。IndexedDB接口没有类型SQL语句中LIKE的功能。</li>\n</ul>\n<p>以下情况，数据库可能被清除：</p>\n<ul>\n<li>用户请求清除数据。</li>\n<li>浏览器处于隐私模式。最后退出浏览器的时候，数据会被清除。</li>\n<li>硬盘等存储设备的容量到限或损坏。</li>\n</ul>\n<h4 id=\"IndexedDB的核心用法\"><a href=\"#IndexedDB的核心用法\" class=\"headerlink\" title=\"IndexedDB的核心用法\"></a>IndexedDB的核心用法</h4><p>IndexedDB API是强大的，也是复杂的，涉及不少概念。它把不同的实体，抽象成一个个对象接口。学习这个API，就是学习它的各种对象接口。</p>\n<ul>\n<li>indexedDB：挂载在window的构造函数</li>\n<li>IDBRequest：操作请求</li>\n<li>IDBDatabase：数据库对象</li>\n<li>IDBObjectStore：对象仓库</li>\n<li>IDBTransaction：事务</li>\n<li>IDBIndex：索引</li>\n<li>IDBCursor：指针</li>\n<li>IDBKeyRange：主键集合</li>\n</ul>\n<h5 id=\"indexedDB对象：\"><a href=\"#indexedDB对象：\" class=\"headerlink\" title=\"indexedDB对象：\"></a>indexedDB对象：</h5><ul>\n<li><p>open(数据库名称, 数据库版本号 = 1)方法：用于打开数据库，如果不存在，会新建该数据库。异步回调（success、error、upgradeneeded、blocked）</p>\n</li>\n<li><p>deleteDatabase(数据库名称)方法：删除一个数据库。异步回调（success、error）</p>\n</li>\n<li><p>cmp(i, j)方法：比较两个主键的大小。返回整数（i === j为0、i &gt; j为1、i &lt; j为-1）</p>\n</li>\n</ul>\n<p><img src=\"//psilocine.github.io/2021/03/25/indexedDB浅析/indexedDB_object.png\" alt=\"indexedDB对象\"></p>\n<h5 id=\"IDBRequest对象：\"><a href=\"#IDBRequest对象：\" class=\"headerlink\" title=\"IDBRequest对象：\"></a>IDBRequest对象：</h5><p>操作请求，表示打开的数据库连接，数据库的操作都是通过这个对象执行的。indexedDB.open()和deleteDatabase()会返回这个对象。</p>\n<h5 id=\"IDBDatabase对象：\"><a href=\"#IDBDatabase对象：\" class=\"headerlink\" title=\"IDBDatabase对象：\"></a>IDBDatabase对象：</h5><p>通过IDBRequest对象的回调result属性获得。后面对数据库的操作，都通过这个对象完成。</p>\n<ul>\n<li>objectStoreNames(对象仓库名称)：包含当前数据库所有object store的名字，可以使用contains方法检查数据库是否包含某个对象仓库</li>\n<li>createObjectStore(名, 对象仓库的可配置属性)：创建存放数据库的对象仓库，返回IDBObjectStore对象，</li>\n<li>deleteObjectStore(对象仓库名称)：删除指定的对象仓库 </li>\n<li>transaction(对象仓库名称，读取权限 = “readonly”)：返回一个IDBTransaction事务对象</li>\n<li>close()：关闭数据库连接</li>\n</ul>\n<p>可配置属性：<br>keyPath：主键<br>autoIncrement：自增主键，如果没有适合作主键的属性。</p>\n<h5 id=\"IDBObjectStore对象\"><a href=\"#IDBObjectStore对象\" class=\"headerlink\" title=\"IDBObjectStore对象\"></a>IDBObjectStore对象</h5><p>对象仓库。由IDBDatabase.createObjectStore()返回。它是直接操作数据的对象。</p>\n<p>值得注意的是，IDBDatabase对象的transaction()返回一个事务对象，事务对象的objectStore()反回IDBObjectStore对象，因此可以采用链式写法</p>\n<ul>\n<li>add(键值, 主键)方法：用于向对象仓库添加数据，返回一个IDBRequest对象。该方法只用于添加数据，如果主键相同则会报错，因此更新数据必须使用put()方法</li>\n<li>put(数据, 主键)方法：用于更新某个主键对应的数据记录，如果不存在则插入一条新的记录。返回一个IDBRequest对象</li>\n<li>clear()方法：删除当前对象仓库的所有记录，返回一个IDBRequest对象 </li>\n<li>delelte(主键)方法：删除指定主键的记录，返回一个IDBRequest对象</li>\n<li>count()方法：用于计算记录的数量，返回一个IDBRequest对象。不带参数时，返回当前对象仓库的所有记录数量。如果主键或IDBKeyRange对象作为参数，则返回对应的记录数量</li>\n<li>getKey()、get(主键)、getAll()、getAllKeys()、index(name)、createIndex()、deleteIndex()、openCursor()、openKeyCursor()，etc。</li>\n</ul>\n<h5 id=\"IDBTransaction对象\"><a href=\"#IDBTransaction对象\" class=\"headerlink\" title=\"IDBTransaction对象\"></a>IDBTransaction对象</h5><p>事务，所有的读写操作都要通过这个对象，权限只有两种（readwrite、readonly）。IDBDatabase.transaction()返回就是事务对象。事务的执行顺序是按照创建的顺序，而不是发出请求的顺序。</p>\n<ul>\n<li><p>abort()方法：终止当前事务，回滚所有已经进行的变更</p>\n</li>\n<li><p>objectStore(name)方法：返回指定名称的对象仓库</p>\n</li>\n</ul>\n<h5 id=\"IDBIndex对象\"><a href=\"#IDBIndex对象\" class=\"headerlink\" title=\"IDBIndex对象\"></a>IDBIndex对象</h5><p>索引，通过这个对象可以获取数据库里面的记录</p>\n<h5 id=\"IDBCursor对象\"><a href=\"#IDBCursor对象\" class=\"headerlink\" title=\"IDBCursor对象\"></a>IDBCursor对象</h5><p>指针，用来遍历对象仓库或索引的记录</p>\n<h5 id=\"IDBKeyRange对象\"><a href=\"#IDBKeyRange对象\" class=\"headerlink\" title=\"IDBKeyRange对象\"></a>IDBKeyRange对象</h5><p>主键集合，根据该集合的条件，可以获取数据仓库或索引里面的一组记录</p>\n<h4 id=\"IndexedDB的打开方式\"><a href=\"#IndexedDB的打开方式\" class=\"headerlink\" title=\"IndexedDB的打开方式\"></a>IndexedDB的打开方式</h4><p>比起干撸IndexedDB的API，社区已经有很多优秀而成熟的第三方库。上手简单，对开发者友好：</p>\n<p><a href=\"https://localforage.github.io/localForage/\" target=\"_blank\" rel=\"noopener\">localForage</a></p>\n<p><a href=\"http://www.dexie.org/\" target=\"_blank\" rel=\"noopener\">dexie</a></p>\n<p><a href=\"https://pouchdb.com/\" target=\"_blank\" rel=\"noopener\">PouchDB</a></p>\n<p>目前来说，我们并不需要用到IndexedDB的很多API，我们只需要能够覆盖Web Storage的功能就可以了。上述的库对我们来说还是太大太复杂了。</p>\n<p>因此，干脆结合上述库的写法，自己动手封装一下API。几乎抹平了使用和学习成本。</p>\n<ul>\n<li>getItem(key, value, callback)</li>\n<li>setItem(key, callback)</li>\n<li>removeItem(key, callback)</li>\n<li>clear(callback)</li>\n</ul>\n<p>具体看下述代码：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">IndexedDB</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">constructor</span> (name = \"miaobao-store\") &#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.ready(name);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"comment\">// 初始化</span></span><br><span class=\"line\">  ready (name) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> <span class=\"built_in\">Promise</span>(<span class=\"function\">(<span class=\"params\">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (<span class=\"keyword\">this</span>.db) &#123;</span><br><span class=\"line\">        resolve(<span class=\"keyword\">this</span>);</span><br><span class=\"line\">      &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.objectStoreName = name;</span><br><span class=\"line\">        <span class=\"keyword\">const</span> request = <span class=\"built_in\">window</span>.indexedDB.open(<span class=\"string\">\"MiaoBao\"</span>, <span class=\"number\">1</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">        request.onsuccess = <span class=\"function\">(<span class=\"params\">e</span>) =&gt;</span> &#123;</span><br><span class=\"line\">          <span class=\"keyword\">this</span>.db = e.target.result;</span><br><span class=\"line\">          resolve(<span class=\"keyword\">this</span>);</span><br><span class=\"line\">        &#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">        request.onupgradeneeded = <span class=\"function\">(<span class=\"params\">e</span>) =&gt;</span> &#123;</span><br><span class=\"line\">          <span class=\"keyword\">const</span> db = e.target.result;</span><br><span class=\"line\">          <span class=\"keyword\">if</span> (!db.objectStoreNames.contains(<span class=\"keyword\">this</span>.objectStoreName)) &#123;</span><br><span class=\"line\">            db.createObjectStore(<span class=\"keyword\">this</span>.objectStoreName);</span><br><span class=\"line\">          &#125;</span><br><span class=\"line\">        &#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">        request.onerror = <span class=\"function\">(<span class=\"params\">e</span>) =&gt;</span> &#123;</span><br><span class=\"line\">          reject(e);</span><br><span class=\"line\">        &#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">        request.onblocked = <span class=\"function\">(<span class=\"params\">e</span>) =&gt;</span> &#123;</span><br><span class=\"line\">          reject(e);</span><br><span class=\"line\">        &#125;;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"comment\">// 赋值</span></span><br><span class=\"line\">  setItem (key, value, callback) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>.init(<span class=\"function\">(<span class=\"params\">success, error</span>) =&gt;</span> &#123;</span><br><span class=\"line\">      <span class=\"keyword\">const</span> request = <span class=\"keyword\">this</span>.db</span><br><span class=\"line\">        .transaction(<span class=\"keyword\">this</span>.objectStoreName, <span class=\"string\">\"readwrite\"</span>)</span><br><span class=\"line\">        .objectStore(<span class=\"keyword\">this</span>.objectStoreName)</span><br><span class=\"line\">        .put(value, key);</span><br><span class=\"line\">      request.onsuccess = <span class=\"function\"><span class=\"params\">()</span> =&gt;</span> success(value);</span><br><span class=\"line\">      request.onerror = error;</span><br><span class=\"line\">    &#125;, callback);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"comment\">// 取值</span></span><br><span class=\"line\">  getItem (key, callback) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>.init(<span class=\"function\">(<span class=\"params\">success, error</span>) =&gt;</span> &#123;</span><br><span class=\"line\">      <span class=\"keyword\">const</span> request = <span class=\"keyword\">this</span>.db</span><br><span class=\"line\">        .transaction(<span class=\"keyword\">this</span>.objectStoreName)</span><br><span class=\"line\">        .objectStore(<span class=\"keyword\">this</span>.objectStoreName)</span><br><span class=\"line\">        .get(key);</span><br><span class=\"line\">      request.onsuccess = <span class=\"function\"><span class=\"params\">()</span> =&gt;</span> success(request.result);</span><br><span class=\"line\">      request.onerror = error;</span><br><span class=\"line\">    &#125;, callback);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"comment\">// 清除</span></span><br><span class=\"line\">  removeItem (key, callback) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>.init(<span class=\"function\">(<span class=\"params\">success, error</span>) =&gt;</span> &#123;</span><br><span class=\"line\">      <span class=\"keyword\">const</span> request = <span class=\"keyword\">this</span>.db</span><br><span class=\"line\">        .transaction(<span class=\"keyword\">this</span>.objectStoreName, <span class=\"string\">\"readwrite\"</span>)</span><br><span class=\"line\">        .objectStore(<span class=\"keyword\">this</span>.objectStoreName)</span><br><span class=\"line\">        .delete(key);</span><br><span class=\"line\">      request.onsuccess = <span class=\"function\"><span class=\"params\">()</span> =&gt;</span> success(key);</span><br><span class=\"line\">      request.onerror = error;</span><br><span class=\"line\">    &#125;, callback);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  clear (callback) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>.init(<span class=\"function\">(<span class=\"params\">success, error</span>) =&gt;</span> &#123;</span><br><span class=\"line\">      <span class=\"keyword\">const</span> request = <span class=\"keyword\">this</span>.db</span><br><span class=\"line\">        .transaction(<span class=\"keyword\">this</span>.objectStoreName, <span class=\"string\">\"readwrite\"</span>)</span><br><span class=\"line\">        .objectStore(<span class=\"keyword\">this</span>.objectStoreName)</span><br><span class=\"line\">        .clear();</span><br><span class=\"line\">      request.onsuccess = <span class=\"function\"><span class=\"params\">()</span> =&gt;</span> success(<span class=\"literal\">null</span>);</span><br><span class=\"line\">      request.onerror = error;</span><br><span class=\"line\">    &#125;, callback);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  init (request, callback) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> <span class=\"built_in\">Promise</span>(<span class=\"function\">(<span class=\"params\">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class=\"line\">      <span class=\"keyword\">const</span> success = <span class=\"function\"><span class=\"params\">value</span> =&gt;</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (callback &amp;&amp; <span class=\"keyword\">typeof</span> callback === <span class=\"string\">\"function\"</span>) &#123;</span><br><span class=\"line\">          callback(<span class=\"literal\">false</span>, value);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        resolve(value);</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      <span class=\"keyword\">const</span> error = <span class=\"function\"><span class=\"params\">e</span> =&gt;</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (callback &amp;&amp; <span class=\"keyword\">typeof</span> callback === <span class=\"string\">\"function\"</span>) &#123;</span><br><span class=\"line\">          callback(e);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        reject(e);</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>.ready(<span class=\"keyword\">this</span>.objectStoreName).then(<span class=\"function\"><span class=\"params\">()</span> =&gt;</span> &#123;</span><br><span class=\"line\">        request(success, error);</span><br><span class=\"line\">      &#125;).catch(error);</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">default</span> IndexedDB;</span><br></pre></td></tr></table></figure>\n\n","site":{"data":{}},"excerpt":"<h5 id=\"写在前面\"><a href=\"#写在前面\" class=\"headerlink\" title=\"写在前面\"></a>写在前面</h5><p>目前支撑的业务有大量数据存储在WebStorage的情况，考虑到WebStorage容量的限制，研究了一下浏览器提供的本地数据库————IndexedDB</p>\n<h4 id=\"IndexedDB概述\"><a href=\"#IndexedDB概述\" class=\"headerlink\" title=\"IndexedDB概述\"></a>IndexedDB概述</h4><p>IndexedDB是一种底层的异步API，是一种在用户浏览器中持久存储数据的方法。它允许您在不考虑网络的可用性，创建具有丰富查询能力的可离线Web应用程序。对于在客户端存储大量的结构化数据和不需要持久在线网络连接的应用程序中很有用。  </p>\n<p>通俗地说，IndexedDB 就是浏览器提供的本地数据库，它可以被网页脚本创建和操作。IndexedDB 允许储存大量数据，提供查找接口，还能建立索引。就数据库类型而言，IndexedDB 不属于关系型数据库（不支持 SQL 查询语句），更接近 NoSQL 数据库（简单好使）。  </p>\n<p>值得一提的是，过去的竞争规范（WebSQL）数据库是关系型数据库（复杂），但是已经被W3C废弃。</p>","more":"<h5 id=\"为何IndexedDB会诞生\"><a href=\"#为何IndexedDB会诞生\" class=\"headerlink\" title=\"为何IndexedDB会诞生\"></a>为何IndexedDB会诞生</h5><p>现有的浏览器数据储存方案，都不适合存储大量数据：</p>\n<ol>\n<li>Cookie的大小不超过4KB，且每次请求都会发送回服务器；</li>\n<li>LocalStorage约在5MB左右（各家浏览器不同，IE浏览器约3M左右），且不提供搜索功能，不能建立自定义索引。</li>\n</ol>\n<p>为了解决痛点，IndexedDB就应邀诞生了。</p>\n<h5 id=\"IndexedDB目前的兼容性（2021-03）\"><a href=\"#IndexedDB目前的兼容性（2021-03）\" class=\"headerlink\" title=\"IndexedDB目前的兼容性（2021.03）\"></a>IndexedDB目前的兼容性（2021.03）</h5><p><img src=\"//psilocine.github.io/2021/03/25/indexedDB浅析/compatibility.png\" alt=\"兼容性\"></p>\n<h5 id=\"IndexedDB的特性\"><a href=\"#IndexedDB的特性\" class=\"headerlink\" title=\"IndexedDB的特性\"></a>IndexedDB的特性</h5><ol>\n<li>键值对储存</li>\n</ol>\n<p>IndexedDB内部采用对象仓库（object store）存放数据。所有类型的数据都可以直接存入，包括JavaScript对象。对象仓库中，数据以“键值对”的形式保存，每一个数据记录都有对应的主键，主键是独一无二的，不能有重复。</p>\n<ol start=\"2\">\n<li>异步</li>\n</ol>\n<p>IndexedDB操作时不会锁死浏览器，用户依然可以进行其他操作，这与LocalStorage形成对比，后者的操作是同步的。异步设计是为了防止大量数据的读写，拖慢网页的表现。值得注意的是，IndexedDB也有同步API，目前已从规范中移除。</p>\n<ol start=\"3\">\n<li>支持事务</li>\n</ol>\n<p>IndexedDB支持事务（transaction），这意味着一系列操作步骤之中，只要有一步失败，整个事务就都取消，数据库回滚到事务发生之前的状态，不存在只改写一部分数据的情况。</p>\n<ol start=\"4\">\n<li>同源策略</li>\n</ol>\n<p>IndexedDB受到同源限制，每一个数据库对应创建它的域名。网页只能访问自身域名下的数据库，而不能访问跨域的数据库。</p>\n<ol start=\"5\">\n<li>储存空间大</li>\n</ol>\n<p>IndexedDB的储存空间比LocalStorage大得多，理论上取决于硬盘大小：为可用磁盘空间的50%。</p>\n<ol start=\"6\">\n<li>支持二进制储存</li>\n</ol>\n<p>IndexedDB不仅可以储存字符串，还可以储存二进制数据（ArrayBuffer对象和Blob对象，理论上支持任意格式的数据）。</p>\n<h5 id=\"IndexedDB的局限性\"><a href=\"#IndexedDB的局限性\" class=\"headerlink\" title=\"IndexedDB的局限性\"></a>IndexedDB的局限性</h5><p>以下情况不适合使用IndexedDB：</p>\n<ul>\n<li>多语言混合存储。国际化支持不好，需要自己处理。</li>\n<li>和服务器端数据库同步。得自己写同步代码。</li>\n<li>全文搜索。IndexedDB接口没有类型SQL语句中LIKE的功能。</li>\n</ul>\n<p>以下情况，数据库可能被清除：</p>\n<ul>\n<li>用户请求清除数据。</li>\n<li>浏览器处于隐私模式。最后退出浏览器的时候，数据会被清除。</li>\n<li>硬盘等存储设备的容量到限或损坏。</li>\n</ul>\n<h4 id=\"IndexedDB的核心用法\"><a href=\"#IndexedDB的核心用法\" class=\"headerlink\" title=\"IndexedDB的核心用法\"></a>IndexedDB的核心用法</h4><p>IndexedDB API是强大的，也是复杂的，涉及不少概念。它把不同的实体，抽象成一个个对象接口。学习这个API，就是学习它的各种对象接口。</p>\n<ul>\n<li>indexedDB：挂载在window的构造函数</li>\n<li>IDBRequest：操作请求</li>\n<li>IDBDatabase：数据库对象</li>\n<li>IDBObjectStore：对象仓库</li>\n<li>IDBTransaction：事务</li>\n<li>IDBIndex：索引</li>\n<li>IDBCursor：指针</li>\n<li>IDBKeyRange：主键集合</li>\n</ul>\n<h5 id=\"indexedDB对象：\"><a href=\"#indexedDB对象：\" class=\"headerlink\" title=\"indexedDB对象：\"></a>indexedDB对象：</h5><ul>\n<li><p>open(数据库名称, 数据库版本号 = 1)方法：用于打开数据库，如果不存在，会新建该数据库。异步回调（success、error、upgradeneeded、blocked）</p>\n</li>\n<li><p>deleteDatabase(数据库名称)方法：删除一个数据库。异步回调（success、error）</p>\n</li>\n<li><p>cmp(i, j)方法：比较两个主键的大小。返回整数（i === j为0、i &gt; j为1、i &lt; j为-1）</p>\n</li>\n</ul>\n<p><img src=\"//psilocine.github.io/2021/03/25/indexedDB浅析/indexedDB_object.png\" alt=\"indexedDB对象\"></p>\n<h5 id=\"IDBRequest对象：\"><a href=\"#IDBRequest对象：\" class=\"headerlink\" title=\"IDBRequest对象：\"></a>IDBRequest对象：</h5><p>操作请求，表示打开的数据库连接，数据库的操作都是通过这个对象执行的。indexedDB.open()和deleteDatabase()会返回这个对象。</p>\n<h5 id=\"IDBDatabase对象：\"><a href=\"#IDBDatabase对象：\" class=\"headerlink\" title=\"IDBDatabase对象：\"></a>IDBDatabase对象：</h5><p>通过IDBRequest对象的回调result属性获得。后面对数据库的操作，都通过这个对象完成。</p>\n<ul>\n<li>objectStoreNames(对象仓库名称)：包含当前数据库所有object store的名字，可以使用contains方法检查数据库是否包含某个对象仓库</li>\n<li>createObjectStore(名, 对象仓库的可配置属性)：创建存放数据库的对象仓库，返回IDBObjectStore对象，</li>\n<li>deleteObjectStore(对象仓库名称)：删除指定的对象仓库 </li>\n<li>transaction(对象仓库名称，读取权限 = “readonly”)：返回一个IDBTransaction事务对象</li>\n<li>close()：关闭数据库连接</li>\n</ul>\n<p>可配置属性：<br>keyPath：主键<br>autoIncrement：自增主键，如果没有适合作主键的属性。</p>\n<h5 id=\"IDBObjectStore对象\"><a href=\"#IDBObjectStore对象\" class=\"headerlink\" title=\"IDBObjectStore对象\"></a>IDBObjectStore对象</h5><p>对象仓库。由IDBDatabase.createObjectStore()返回。它是直接操作数据的对象。</p>\n<p>值得注意的是，IDBDatabase对象的transaction()返回一个事务对象，事务对象的objectStore()反回IDBObjectStore对象，因此可以采用链式写法</p>\n<ul>\n<li>add(键值, 主键)方法：用于向对象仓库添加数据，返回一个IDBRequest对象。该方法只用于添加数据，如果主键相同则会报错，因此更新数据必须使用put()方法</li>\n<li>put(数据, 主键)方法：用于更新某个主键对应的数据记录，如果不存在则插入一条新的记录。返回一个IDBRequest对象</li>\n<li>clear()方法：删除当前对象仓库的所有记录，返回一个IDBRequest对象 </li>\n<li>delelte(主键)方法：删除指定主键的记录，返回一个IDBRequest对象</li>\n<li>count()方法：用于计算记录的数量，返回一个IDBRequest对象。不带参数时，返回当前对象仓库的所有记录数量。如果主键或IDBKeyRange对象作为参数，则返回对应的记录数量</li>\n<li>getKey()、get(主键)、getAll()、getAllKeys()、index(name)、createIndex()、deleteIndex()、openCursor()、openKeyCursor()，etc。</li>\n</ul>\n<h5 id=\"IDBTransaction对象\"><a href=\"#IDBTransaction对象\" class=\"headerlink\" title=\"IDBTransaction对象\"></a>IDBTransaction对象</h5><p>事务，所有的读写操作都要通过这个对象，权限只有两种（readwrite、readonly）。IDBDatabase.transaction()返回就是事务对象。事务的执行顺序是按照创建的顺序，而不是发出请求的顺序。</p>\n<ul>\n<li><p>abort()方法：终止当前事务，回滚所有已经进行的变更</p>\n</li>\n<li><p>objectStore(name)方法：返回指定名称的对象仓库</p>\n</li>\n</ul>\n<h5 id=\"IDBIndex对象\"><a href=\"#IDBIndex对象\" class=\"headerlink\" title=\"IDBIndex对象\"></a>IDBIndex对象</h5><p>索引，通过这个对象可以获取数据库里面的记录</p>\n<h5 id=\"IDBCursor对象\"><a href=\"#IDBCursor对象\" class=\"headerlink\" title=\"IDBCursor对象\"></a>IDBCursor对象</h5><p>指针，用来遍历对象仓库或索引的记录</p>\n<h5 id=\"IDBKeyRange对象\"><a href=\"#IDBKeyRange对象\" class=\"headerlink\" title=\"IDBKeyRange对象\"></a>IDBKeyRange对象</h5><p>主键集合，根据该集合的条件，可以获取数据仓库或索引里面的一组记录</p>\n<h4 id=\"IndexedDB的打开方式\"><a href=\"#IndexedDB的打开方式\" class=\"headerlink\" title=\"IndexedDB的打开方式\"></a>IndexedDB的打开方式</h4><p>比起干撸IndexedDB的API，社区已经有很多优秀而成熟的第三方库。上手简单，对开发者友好：</p>\n<p><a href=\"https://localforage.github.io/localForage/\" target=\"_blank\" rel=\"noopener\">localForage</a></p>\n<p><a href=\"http://www.dexie.org/\" target=\"_blank\" rel=\"noopener\">dexie</a></p>\n<p><a href=\"https://pouchdb.com/\" target=\"_blank\" rel=\"noopener\">PouchDB</a></p>\n<p>目前来说，我们并不需要用到IndexedDB的很多API，我们只需要能够覆盖Web Storage的功能就可以了。上述的库对我们来说还是太大太复杂了。</p>\n<p>因此，干脆结合上述库的写法，自己动手封装一下API。几乎抹平了使用和学习成本。</p>\n<ul>\n<li>getItem(key, value, callback)</li>\n<li>setItem(key, callback)</li>\n<li>removeItem(key, callback)</li>\n<li>clear(callback)</li>\n</ul>\n<p>具体看下述代码：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">IndexedDB</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">constructor</span> (name = \"miaobao-store\") &#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.ready(name);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"comment\">// 初始化</span></span><br><span class=\"line\">  ready (name) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> <span class=\"built_in\">Promise</span>(<span class=\"function\">(<span class=\"params\">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (<span class=\"keyword\">this</span>.db) &#123;</span><br><span class=\"line\">        resolve(<span class=\"keyword\">this</span>);</span><br><span class=\"line\">      &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.objectStoreName = name;</span><br><span class=\"line\">        <span class=\"keyword\">const</span> request = <span class=\"built_in\">window</span>.indexedDB.open(<span class=\"string\">\"MiaoBao\"</span>, <span class=\"number\">1</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">        request.onsuccess = <span class=\"function\">(<span class=\"params\">e</span>) =&gt;</span> &#123;</span><br><span class=\"line\">          <span class=\"keyword\">this</span>.db = e.target.result;</span><br><span class=\"line\">          resolve(<span class=\"keyword\">this</span>);</span><br><span class=\"line\">        &#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">        request.onupgradeneeded = <span class=\"function\">(<span class=\"params\">e</span>) =&gt;</span> &#123;</span><br><span class=\"line\">          <span class=\"keyword\">const</span> db = e.target.result;</span><br><span class=\"line\">          <span class=\"keyword\">if</span> (!db.objectStoreNames.contains(<span class=\"keyword\">this</span>.objectStoreName)) &#123;</span><br><span class=\"line\">            db.createObjectStore(<span class=\"keyword\">this</span>.objectStoreName);</span><br><span class=\"line\">          &#125;</span><br><span class=\"line\">        &#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">        request.onerror = <span class=\"function\">(<span class=\"params\">e</span>) =&gt;</span> &#123;</span><br><span class=\"line\">          reject(e);</span><br><span class=\"line\">        &#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">        request.onblocked = <span class=\"function\">(<span class=\"params\">e</span>) =&gt;</span> &#123;</span><br><span class=\"line\">          reject(e);</span><br><span class=\"line\">        &#125;;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"comment\">// 赋值</span></span><br><span class=\"line\">  setItem (key, value, callback) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>.init(<span class=\"function\">(<span class=\"params\">success, error</span>) =&gt;</span> &#123;</span><br><span class=\"line\">      <span class=\"keyword\">const</span> request = <span class=\"keyword\">this</span>.db</span><br><span class=\"line\">        .transaction(<span class=\"keyword\">this</span>.objectStoreName, <span class=\"string\">\"readwrite\"</span>)</span><br><span class=\"line\">        .objectStore(<span class=\"keyword\">this</span>.objectStoreName)</span><br><span class=\"line\">        .put(value, key);</span><br><span class=\"line\">      request.onsuccess = <span class=\"function\"><span class=\"params\">()</span> =&gt;</span> success(value);</span><br><span class=\"line\">      request.onerror = error;</span><br><span class=\"line\">    &#125;, callback);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"comment\">// 取值</span></span><br><span class=\"line\">  getItem (key, callback) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>.init(<span class=\"function\">(<span class=\"params\">success, error</span>) =&gt;</span> &#123;</span><br><span class=\"line\">      <span class=\"keyword\">const</span> request = <span class=\"keyword\">this</span>.db</span><br><span class=\"line\">        .transaction(<span class=\"keyword\">this</span>.objectStoreName)</span><br><span class=\"line\">        .objectStore(<span class=\"keyword\">this</span>.objectStoreName)</span><br><span class=\"line\">        .get(key);</span><br><span class=\"line\">      request.onsuccess = <span class=\"function\"><span class=\"params\">()</span> =&gt;</span> success(request.result);</span><br><span class=\"line\">      request.onerror = error;</span><br><span class=\"line\">    &#125;, callback);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"comment\">// 清除</span></span><br><span class=\"line\">  removeItem (key, callback) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>.init(<span class=\"function\">(<span class=\"params\">success, error</span>) =&gt;</span> &#123;</span><br><span class=\"line\">      <span class=\"keyword\">const</span> request = <span class=\"keyword\">this</span>.db</span><br><span class=\"line\">        .transaction(<span class=\"keyword\">this</span>.objectStoreName, <span class=\"string\">\"readwrite\"</span>)</span><br><span class=\"line\">        .objectStore(<span class=\"keyword\">this</span>.objectStoreName)</span><br><span class=\"line\">        .delete(key);</span><br><span class=\"line\">      request.onsuccess = <span class=\"function\"><span class=\"params\">()</span> =&gt;</span> success(key);</span><br><span class=\"line\">      request.onerror = error;</span><br><span class=\"line\">    &#125;, callback);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  clear (callback) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>.init(<span class=\"function\">(<span class=\"params\">success, error</span>) =&gt;</span> &#123;</span><br><span class=\"line\">      <span class=\"keyword\">const</span> request = <span class=\"keyword\">this</span>.db</span><br><span class=\"line\">        .transaction(<span class=\"keyword\">this</span>.objectStoreName, <span class=\"string\">\"readwrite\"</span>)</span><br><span class=\"line\">        .objectStore(<span class=\"keyword\">this</span>.objectStoreName)</span><br><span class=\"line\">        .clear();</span><br><span class=\"line\">      request.onsuccess = <span class=\"function\"><span class=\"params\">()</span> =&gt;</span> success(<span class=\"literal\">null</span>);</span><br><span class=\"line\">      request.onerror = error;</span><br><span class=\"line\">    &#125;, callback);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  init (request, callback) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> <span class=\"built_in\">Promise</span>(<span class=\"function\">(<span class=\"params\">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class=\"line\">      <span class=\"keyword\">const</span> success = <span class=\"function\"><span class=\"params\">value</span> =&gt;</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (callback &amp;&amp; <span class=\"keyword\">typeof</span> callback === <span class=\"string\">\"function\"</span>) &#123;</span><br><span class=\"line\">          callback(<span class=\"literal\">false</span>, value);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        resolve(value);</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      <span class=\"keyword\">const</span> error = <span class=\"function\"><span class=\"params\">e</span> =&gt;</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (callback &amp;&amp; <span class=\"keyword\">typeof</span> callback === <span class=\"string\">\"function\"</span>) &#123;</span><br><span class=\"line\">          callback(e);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        reject(e);</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>.ready(<span class=\"keyword\">this</span>.objectStoreName).then(<span class=\"function\"><span class=\"params\">()</span> =&gt;</span> &#123;</span><br><span class=\"line\">        request(success, error);</span><br><span class=\"line\">      &#125;).catch(error);</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">default</span> IndexedDB;</span><br></pre></td></tr></table></figure>"},{"title":"我认为的Vue官方文档重点(1)","date":"2018-01-15T08:18:09.000Z","_content":"##### 写在前面\n最近想系统学习一下Vue, 有时候看官方文档太庞大复杂, 会失去看下去的欲望, 不妨来看看我整理的一些知识. 当然前提是你懂基本的Vue语法和结构\n文章大体会根据Vue官方文档(教程2.X)提供的学习路线\n本文从 Vue实例 -> 组件\n\n### Vue实例\n1.Vue是数据驱动的, 但如果在创建实例后再去给Vue添加属性的话, 新添加的属性是不具备响应式的\n<!--more-->\n```JavaScript\n<p>{{name}}</p>\n<p>{{age}}</p>\n<p>{{sex}}</p>\n\nnew vm = new Vue({\n  ...\n  data () {\n    name: 'Psilo',\n    age: '24'\n  },\n  ...\n})\n\n// 因为还没有sex属性, 只渲染出前两个标签\n\nvm.sex = '男'\n// 添加属性成功, 但是渲染无效.\n// 查看后发现原因是因为name有setter和getter, 后添加的sex没有\n// 解决方法 1\nVue.set(vm, 'sex', '男')\n// 解决方法 2\nvm.$set(vm, 'sex', '男')\n```\n![response](1_newPropertyHaventGetterAndSetter.jpg)\n\n### 模板语法\n1.v-once只渲染一次, 适合渲染包含大量静态内容的标签\n```javascript\n<p v-once>我不会变化: {{msg}}</p>\n// msg改变, 上述标签内容也不会改变\n```\n2.v-html用法, 例如data有个属性包含html标签, 直接用双花括号渲染会原封不动将html标签渲染成字符串, v-html会将HTML标签渲染成html标签, 详情见下图. 但是官方并不推荐用, 因为容易导致xss攻击\n```javascript\n<p>{{text}}</p>\n<p v-html='text'></p>\n\nnew Vue({\n  data () {\n    text: '<span style=\"color: red\">This should be red.</span>'\n  }\n})\n```\n![vHtmlUsage](2_vHtmlUsage.jpg)\n\n3.双花括号里面能包括单个表达式\n```JavaScript\n{{ number + 1 }}\n{{ ok? 'Yes'; 'No' }}\n{{ message.split('').reverse().join('') }}\n// 还支持Math和Date\n{{ Math.floor(number) }}\n```\n4.利用v-bind响应式更新attribute\n```javascript\n<a v-bind:href='url'>...</a>\n<a :href='url'>...</a>\n\n<p class='active' :class='classObject'>...</p> // 最后渲染出三个class的p标签\n\n<p :style='styleObject'>...</p> // 渲染出行内样式\n\n// 也可以是组数\n<p :style='['styleObject', 'styleObjectB']'>...</p>\n\nnew Vue({\n  data () {\n    url: 'https://psilocine.github.io',\n    classObject: {\n      'text-red': true,\n      'text-bold': true\n    },\n    styleObject: {\n      color: 'red',\n      font-weight: 'bold'\n    },\n    styleObjectB: {\n      font-size: '20px'\n    }\n  }\n})\n\n// url变化时, a标签的href也动态变化\n```\n\n### 计算属性和侦听器\n1.在计算属性computed定义的方法和在methods里定义的方法有什么不同? computed里的方法适合性能开销大的计算, 因为它会缓存起来, 如果相应变量不改变, 它就只会计算一次, 后续的调用从缓存拿; methods每次都会重复算\n```javascript\nnew Vue({\n  ...,\n  computed: {\n    now () {\n      return Date.now()\n    }\n  },\n  ...\n})\n// 计算属性里的now方法将不再更新，因为 Date.now() 不是响应式依赖\n```\n2.计算属性默认只有getter, 不过也可以定义setter\n```javascript\ncomputed: {\n  fullName: {\n    // getter\n    get: function () {\n      return this.firstName + ' ' + this.lastName\n    },\n    // setter\n    set: function (newValue) {\n      var names = newValue.split(' ')\n      this.firstName = names[0]\n      this.lastName = names[names.length - 1]\n    }\n  }\n}\n```\n\n### Class 与 Style 绑定\n1.见模板语法的第3点, 另多补充三元表达式\n```JavaScript\n<div v-bind:class=\"isActive ? activeClass : ''\"></div>\n```\n2.v-bind:style添加css属性, 会自动侦测并添加浏览器前缀, 和postcss的autoprefixer相似\n\n### 条件渲染\n1.v-if也能给多个元素加, 和template标签配合即可. 最终的渲染结果不包括template标签\n```html\n<template v-if='condition'>\n  <p>hello</p>\n  <p>world</p>\n  <p>!!!!!</p>\n</template>\n```\n![template_code](3_template_code.jpg)\n![template_show](3_template_show.jpg)\n\n2.v-if和v-show的区别\n```javascript\n1. v-if能跟v-else连用, v-show不行\n2. v-if能和template标签配合, v-show不行\n3. 带有 v-show 的元素始终会被渲染并保留在 DOM 中, v-show 只是简单地切换元素的 CSS 属性 display; v-if如果不成立, 是不在DOM中渲染的\n4. v-if 有更高的切换开销, 而 v-show 有更高的初始渲染开销. 如果需要非常频繁地切换, 则使用 v-show 较好; 如果在运行时条件很少改变, 则使用 v-if 较好\n```\n3.v-if和v-for一起用, v-for比v-if高优先权\n```html\n<li v-for=\"todo in todos\" v-if=\"!todo.isComplete\">\n  {{ todo }}\n</li>\n上述只传递了未完成的 todos\n```\n\n### 列表渲染\n1.v-for遍历对象时, 是按Object.keys() 的结果遍历, 但是不能保证它的结果在不同的 JavaScript 引擎下是一致的\n2.v-for也可以和v-if一样, 和template标签渲染多个元素\n\n### 事件处理\n1.v-on的修饰符\n```javascript\n// 事件修饰符\n.stop // evnet.preventDefault() v-on:click.stop='doThis'\n.prevent // event.stopPropagation\n.capture // 事件捕获\n.once // 执行一次\n.self // event.target是当前元素才触发\n\n注意修饰符的顺序也有影响: \n@:click.self.prevent // 阻止自身元素默认行为 \n@:click.prevent.self // 阻止所有的点击\n\n// 按键修饰符\n@:keyup.13 = 'submit' // keyup且keyCode是13才触发\n@.keyup.enter = 'submit' // 同理\n\n.enter\n.tab // Tab键, 当focus到视口外失效, 如最后一个元素\n.delete (捕获“删除”和“退格”键)\n.esc\n.space\n.up // ↑键\n.down\n.left\n.right\n\n// 系统修饰键\n.ctrl\n.alt\n.shift\n.meta // mac对应command, windows对应左下微软标识键\n\n@keyup.ctrl.67='something' // ctrl + c 复制时候触发事件\n\n// 鼠标按键修饰符\n.left\n.right\n.middle\n```\n\n### 表单输入绑定\nv-model实现双向绑定, 有v-model指令的标签能实时改变绑定的值\n```html\nv-model实际上是v-bind和v-on的语法糖\n<input type='text' :value='message' ref='inp' @input='inputValue'>\n<p>{{message}}</p>\n\n...,\ndata () {\n  return {\n    message: 'hello'\n  },\n  methods: {\n    inputValue () {\n      this.message = this.$refs.inp.value\n    }\n  }\n}\n\n// 不用到ref的更简洁的方法 @input='inputValue($event)'\n    inputValue (event) {\n      this.message = event.target.value\n    }\n但这样还是显得太过臃肿, 于是引入v-model\n```\n1.关于教程里标注的'在文本区域textarea插值并不会生效', 是指的textarea如果是用花括号赋值, 当改变文本区域的内容, 不会实时变化\n```html\n{{num}}\n<input v-model='num'>\n<textarea>{{num}} asd</textarea>\n<textarea v-model='num'></textarea>\n\n假设num值是1.5\n1. 当我们改变有v-model指令的input和textarea标签, 4个值都会实时改变. 看图1 我们加了'change'\n2. 当我们改变直接插值的textarea以后, 发现其他三个并没有改变, 从这时候开始, 直接插值的textarea就已经不是双向绑定了. 看图2 我们又多加'111'\n3. 如果不在直接插值的文本区域修改属性, 还是可以生效的; 如果修改了, 哪怕不是修改属性值, 如上例子修改的是{{num}} 后面的 asd, 也会断开联系\n```\n<!--more-->\n图1  \n![图1](1_textarea_1.jpg)\n图2  \n![图2](1_textarea_2.jpg)\n\n2.在 iOS 中, select元素这会使用户无法选择第一个选项, 推荐像下面这样提供一个值为空的禁用选项.\n```html\n  <select v-model=\"selected\">\n    <option disabled value=\"\">请选择</option> // 空值选项\n    <option>A</option>\n    <option>B</option>\n    <option>C</option>\n  </select>\n```\n\n3.对于单选按钮, 复选框和选择框的选项, v-model绑定的值通常是静态字符串\n```JavaScript\n<select v-model=\"selected\">\n  <option v-for=\"option in options\" v-bind:value=\"option.value\">\n    {{ option.text }}\n  </option>\n</select>\n<span>Selected: {{ selected }}</span>\n\nnew Vue({\n  el: '...',\n  data: {\n    selected: 'A',\n    options: [\n      { text: 'One', value: 'A' },\n      { text: 'Two', value: 'B' },\n      { text: 'Three', value: 'C' }\n    ]\n  }\n})\n\n// 为什么明明没改变data里selected的值, 可是渲染出来的{{ selected }}却可以随select选择变化\n原因就是上面的话, 选择的option的value会传递给v-model\n```\n\n4.输入的修饰符\n```javascript\n1. (.lazy) v-model在change时才触发更新\n2. (.number) 输入的必须是数值类型, 如果不是, 在输入框blur时自动将非数值剔除. 如果已经有值, 那第一个字符应该就为数值, 不然无效\n3. (.trim) 过滤用户输入的首位空白字符\n```\n\n### 组件\n1.组件注册可以全局注也可以局部注册\n```JavaScript\n// 局部, 一种导入(假设为header) 一种当前作用域定义注册\nvar footer = {\n  template: '<div>i am footer</div>'\n}\nnew Vue({\n  ...,\n  components: {\n    'v-header': header // 导入\n    'v-footer': footer // 作用域注册 不常用\n  },\n  ...\n})\n// 全局\nvar footer = {\n  template: '<div>i am footer</div>'\n}\n// 注意 一定要在new之前注册, 否则无效\nVue.component('v-footer', {\n  footer\n})\nnew Vue({\n  ...\n})\n```\n2.data必须是函数, 这样每个组件都能有独立的状态\n3.一般来说只允许父组件向子组件传值(props), 称为props单向数据流, 为了防止子组件无意间改变父组件的状态\n```JavaScript\n// 子组件\nexport default {\n  props: ['name', 'age'] // 可以是数组\n  props: {               // 可以是对象\n    name: String, // 验证类型\n    age: {        // 验证类型 + 其他验证\n      type: Number,\n      dafault: 0,\n      required: true,\n      validator (val) {\n        return val >= 0\n      }\n    }\n  }\n}\n\n//补充 props 里的 type 支持的属性\nString\nNumber\nBoolean\nFunction\nObject\nArray\nSymbol\n\n// 父组件\n<Child name='Psilo' age='24' /> // 设子组件名为 <Child>, 传值成功\n```\n4.子组件向父组件怎么传值? 自定义事件. 父组件里用v-on:自定义事件名字='父组件方法'; 子组件在监听方法名里用this.$emit('自定义事件名字')\n```JavaScript\n使用 $on(eventName) 监听事件\n使用 $emit(eventName) 触发事件\n\n// 父组件\n<div id=\"counter-event-example\">\n  <p>{{ total }}</p>\n  <button-counter v-on:increment=\"incrementTotal\"></button-counter>\n  <button-counter v-on:increment=\"incrementTotal\"></button-counter>\n</div>\n\nnew Vue({\n  el: '#counter-event-example',\n  data: {\n    total: 0\n  },\n  methods: {\n    incrementTotal: function () {\n      this.total += 1\n    }\n  }\n})\n\n// 子组件\n<div>\n  <button v-on:click='incrementCounter'>{{ counter }}</button>\n</div>\n\nexport default {\n  data: function () {\n    return {\n      counter: 0\n    }\n  },\n  methods: {\n    incrementCounter: function () {\n      this.counter += 1\n      this.$emit('increment')\n    }\n  }\n}\n```\n\n5.非父子组件怎么通信\n```JavaScript\n// 可以使用一个空的Vue实例来做媒介\nvar bus = new Vue()\n\n// 需要传递值的组件\nbus.$emit('someMethods')\n\n// 需要接受值的组件\nbus.$on('someMethods', function (val) {\n  // 监听\n  // ...\n})\n\n// 情况复杂的话需要vuex状态管理\n```\n\n6.插槽分发slot标签. 在设计组合使用的组件时, 内容分发API非常有用\n7.动态组件\n```JavaScript\n// 可以通过保留component元素, 并对其 is 特性进行动态绑定.\nvar vm = new Vue ({\n  ...,\n  data () {\n    return {\n      currentView: 'home'\n    }\n  },\n  components: {\n    home: {\n      template: '<div>home</div>'\n    },\n    posts: { ... },\n    archive: { ... }\n  }\n})\n\n<component v-bind:is='currentView'>\n\n// 也可以直接绑定到组件\nvar Home = {\n  template: '<div>home</div>'\n}\n\nvar vm = new Vue ({\n  ...,\n  data: {\n    currentView: Home\n  }\n})\n```\n8.keep-alive标签\n```html\n<keep-alive>\n  <... />\n</keep-alive>\n<!-- 可以保留其内部的状态或者避免重新渲染 -->\n```\n9.$refs 只在组件渲染完成后才填充, 并且它是非响应式的. 它仅仅是一个直接操作子组件的应急方案——应当避免在模板或计算属性中使用 $refs\n\n\n前往[第二篇](https://psilocine.github.io/2018/03/03/%E6%88%91%E8%AE%A4%E4%B8%BA%E7%9A%84Vue%E5%AE%98%E6%96%B9%E6%96%87%E6%A1%A3%E9%87%8D%E7%82%B9-2/)","source":"_posts/我认为的Vue官方文档重点-1.md","raw":"---\ntitle: 我认为的Vue官方文档重点(1)\ndate: 2018-01-15 16:18:09\ntags: [VUE,前端]\n---\n##### 写在前面\n最近想系统学习一下Vue, 有时候看官方文档太庞大复杂, 会失去看下去的欲望, 不妨来看看我整理的一些知识. 当然前提是你懂基本的Vue语法和结构\n文章大体会根据Vue官方文档(教程2.X)提供的学习路线\n本文从 Vue实例 -> 组件\n\n### Vue实例\n1.Vue是数据驱动的, 但如果在创建实例后再去给Vue添加属性的话, 新添加的属性是不具备响应式的\n<!--more-->\n```JavaScript\n<p>{{name}}</p>\n<p>{{age}}</p>\n<p>{{sex}}</p>\n\nnew vm = new Vue({\n  ...\n  data () {\n    name: 'Psilo',\n    age: '24'\n  },\n  ...\n})\n\n// 因为还没有sex属性, 只渲染出前两个标签\n\nvm.sex = '男'\n// 添加属性成功, 但是渲染无效.\n// 查看后发现原因是因为name有setter和getter, 后添加的sex没有\n// 解决方法 1\nVue.set(vm, 'sex', '男')\n// 解决方法 2\nvm.$set(vm, 'sex', '男')\n```\n![response](1_newPropertyHaventGetterAndSetter.jpg)\n\n### 模板语法\n1.v-once只渲染一次, 适合渲染包含大量静态内容的标签\n```javascript\n<p v-once>我不会变化: {{msg}}</p>\n// msg改变, 上述标签内容也不会改变\n```\n2.v-html用法, 例如data有个属性包含html标签, 直接用双花括号渲染会原封不动将html标签渲染成字符串, v-html会将HTML标签渲染成html标签, 详情见下图. 但是官方并不推荐用, 因为容易导致xss攻击\n```javascript\n<p>{{text}}</p>\n<p v-html='text'></p>\n\nnew Vue({\n  data () {\n    text: '<span style=\"color: red\">This should be red.</span>'\n  }\n})\n```\n![vHtmlUsage](2_vHtmlUsage.jpg)\n\n3.双花括号里面能包括单个表达式\n```JavaScript\n{{ number + 1 }}\n{{ ok? 'Yes'; 'No' }}\n{{ message.split('').reverse().join('') }}\n// 还支持Math和Date\n{{ Math.floor(number) }}\n```\n4.利用v-bind响应式更新attribute\n```javascript\n<a v-bind:href='url'>...</a>\n<a :href='url'>...</a>\n\n<p class='active' :class='classObject'>...</p> // 最后渲染出三个class的p标签\n\n<p :style='styleObject'>...</p> // 渲染出行内样式\n\n// 也可以是组数\n<p :style='['styleObject', 'styleObjectB']'>...</p>\n\nnew Vue({\n  data () {\n    url: 'https://psilocine.github.io',\n    classObject: {\n      'text-red': true,\n      'text-bold': true\n    },\n    styleObject: {\n      color: 'red',\n      font-weight: 'bold'\n    },\n    styleObjectB: {\n      font-size: '20px'\n    }\n  }\n})\n\n// url变化时, a标签的href也动态变化\n```\n\n### 计算属性和侦听器\n1.在计算属性computed定义的方法和在methods里定义的方法有什么不同? computed里的方法适合性能开销大的计算, 因为它会缓存起来, 如果相应变量不改变, 它就只会计算一次, 后续的调用从缓存拿; methods每次都会重复算\n```javascript\nnew Vue({\n  ...,\n  computed: {\n    now () {\n      return Date.now()\n    }\n  },\n  ...\n})\n// 计算属性里的now方法将不再更新，因为 Date.now() 不是响应式依赖\n```\n2.计算属性默认只有getter, 不过也可以定义setter\n```javascript\ncomputed: {\n  fullName: {\n    // getter\n    get: function () {\n      return this.firstName + ' ' + this.lastName\n    },\n    // setter\n    set: function (newValue) {\n      var names = newValue.split(' ')\n      this.firstName = names[0]\n      this.lastName = names[names.length - 1]\n    }\n  }\n}\n```\n\n### Class 与 Style 绑定\n1.见模板语法的第3点, 另多补充三元表达式\n```JavaScript\n<div v-bind:class=\"isActive ? activeClass : ''\"></div>\n```\n2.v-bind:style添加css属性, 会自动侦测并添加浏览器前缀, 和postcss的autoprefixer相似\n\n### 条件渲染\n1.v-if也能给多个元素加, 和template标签配合即可. 最终的渲染结果不包括template标签\n```html\n<template v-if='condition'>\n  <p>hello</p>\n  <p>world</p>\n  <p>!!!!!</p>\n</template>\n```\n![template_code](3_template_code.jpg)\n![template_show](3_template_show.jpg)\n\n2.v-if和v-show的区别\n```javascript\n1. v-if能跟v-else连用, v-show不行\n2. v-if能和template标签配合, v-show不行\n3. 带有 v-show 的元素始终会被渲染并保留在 DOM 中, v-show 只是简单地切换元素的 CSS 属性 display; v-if如果不成立, 是不在DOM中渲染的\n4. v-if 有更高的切换开销, 而 v-show 有更高的初始渲染开销. 如果需要非常频繁地切换, 则使用 v-show 较好; 如果在运行时条件很少改变, 则使用 v-if 较好\n```\n3.v-if和v-for一起用, v-for比v-if高优先权\n```html\n<li v-for=\"todo in todos\" v-if=\"!todo.isComplete\">\n  {{ todo }}\n</li>\n上述只传递了未完成的 todos\n```\n\n### 列表渲染\n1.v-for遍历对象时, 是按Object.keys() 的结果遍历, 但是不能保证它的结果在不同的 JavaScript 引擎下是一致的\n2.v-for也可以和v-if一样, 和template标签渲染多个元素\n\n### 事件处理\n1.v-on的修饰符\n```javascript\n// 事件修饰符\n.stop // evnet.preventDefault() v-on:click.stop='doThis'\n.prevent // event.stopPropagation\n.capture // 事件捕获\n.once // 执行一次\n.self // event.target是当前元素才触发\n\n注意修饰符的顺序也有影响: \n@:click.self.prevent // 阻止自身元素默认行为 \n@:click.prevent.self // 阻止所有的点击\n\n// 按键修饰符\n@:keyup.13 = 'submit' // keyup且keyCode是13才触发\n@.keyup.enter = 'submit' // 同理\n\n.enter\n.tab // Tab键, 当focus到视口外失效, 如最后一个元素\n.delete (捕获“删除”和“退格”键)\n.esc\n.space\n.up // ↑键\n.down\n.left\n.right\n\n// 系统修饰键\n.ctrl\n.alt\n.shift\n.meta // mac对应command, windows对应左下微软标识键\n\n@keyup.ctrl.67='something' // ctrl + c 复制时候触发事件\n\n// 鼠标按键修饰符\n.left\n.right\n.middle\n```\n\n### 表单输入绑定\nv-model实现双向绑定, 有v-model指令的标签能实时改变绑定的值\n```html\nv-model实际上是v-bind和v-on的语法糖\n<input type='text' :value='message' ref='inp' @input='inputValue'>\n<p>{{message}}</p>\n\n...,\ndata () {\n  return {\n    message: 'hello'\n  },\n  methods: {\n    inputValue () {\n      this.message = this.$refs.inp.value\n    }\n  }\n}\n\n// 不用到ref的更简洁的方法 @input='inputValue($event)'\n    inputValue (event) {\n      this.message = event.target.value\n    }\n但这样还是显得太过臃肿, 于是引入v-model\n```\n1.关于教程里标注的'在文本区域textarea插值并不会生效', 是指的textarea如果是用花括号赋值, 当改变文本区域的内容, 不会实时变化\n```html\n{{num}}\n<input v-model='num'>\n<textarea>{{num}} asd</textarea>\n<textarea v-model='num'></textarea>\n\n假设num值是1.5\n1. 当我们改变有v-model指令的input和textarea标签, 4个值都会实时改变. 看图1 我们加了'change'\n2. 当我们改变直接插值的textarea以后, 发现其他三个并没有改变, 从这时候开始, 直接插值的textarea就已经不是双向绑定了. 看图2 我们又多加'111'\n3. 如果不在直接插值的文本区域修改属性, 还是可以生效的; 如果修改了, 哪怕不是修改属性值, 如上例子修改的是{{num}} 后面的 asd, 也会断开联系\n```\n<!--more-->\n图1  \n![图1](1_textarea_1.jpg)\n图2  \n![图2](1_textarea_2.jpg)\n\n2.在 iOS 中, select元素这会使用户无法选择第一个选项, 推荐像下面这样提供一个值为空的禁用选项.\n```html\n  <select v-model=\"selected\">\n    <option disabled value=\"\">请选择</option> // 空值选项\n    <option>A</option>\n    <option>B</option>\n    <option>C</option>\n  </select>\n```\n\n3.对于单选按钮, 复选框和选择框的选项, v-model绑定的值通常是静态字符串\n```JavaScript\n<select v-model=\"selected\">\n  <option v-for=\"option in options\" v-bind:value=\"option.value\">\n    {{ option.text }}\n  </option>\n</select>\n<span>Selected: {{ selected }}</span>\n\nnew Vue({\n  el: '...',\n  data: {\n    selected: 'A',\n    options: [\n      { text: 'One', value: 'A' },\n      { text: 'Two', value: 'B' },\n      { text: 'Three', value: 'C' }\n    ]\n  }\n})\n\n// 为什么明明没改变data里selected的值, 可是渲染出来的{{ selected }}却可以随select选择变化\n原因就是上面的话, 选择的option的value会传递给v-model\n```\n\n4.输入的修饰符\n```javascript\n1. (.lazy) v-model在change时才触发更新\n2. (.number) 输入的必须是数值类型, 如果不是, 在输入框blur时自动将非数值剔除. 如果已经有值, 那第一个字符应该就为数值, 不然无效\n3. (.trim) 过滤用户输入的首位空白字符\n```\n\n### 组件\n1.组件注册可以全局注也可以局部注册\n```JavaScript\n// 局部, 一种导入(假设为header) 一种当前作用域定义注册\nvar footer = {\n  template: '<div>i am footer</div>'\n}\nnew Vue({\n  ...,\n  components: {\n    'v-header': header // 导入\n    'v-footer': footer // 作用域注册 不常用\n  },\n  ...\n})\n// 全局\nvar footer = {\n  template: '<div>i am footer</div>'\n}\n// 注意 一定要在new之前注册, 否则无效\nVue.component('v-footer', {\n  footer\n})\nnew Vue({\n  ...\n})\n```\n2.data必须是函数, 这样每个组件都能有独立的状态\n3.一般来说只允许父组件向子组件传值(props), 称为props单向数据流, 为了防止子组件无意间改变父组件的状态\n```JavaScript\n// 子组件\nexport default {\n  props: ['name', 'age'] // 可以是数组\n  props: {               // 可以是对象\n    name: String, // 验证类型\n    age: {        // 验证类型 + 其他验证\n      type: Number,\n      dafault: 0,\n      required: true,\n      validator (val) {\n        return val >= 0\n      }\n    }\n  }\n}\n\n//补充 props 里的 type 支持的属性\nString\nNumber\nBoolean\nFunction\nObject\nArray\nSymbol\n\n// 父组件\n<Child name='Psilo' age='24' /> // 设子组件名为 <Child>, 传值成功\n```\n4.子组件向父组件怎么传值? 自定义事件. 父组件里用v-on:自定义事件名字='父组件方法'; 子组件在监听方法名里用this.$emit('自定义事件名字')\n```JavaScript\n使用 $on(eventName) 监听事件\n使用 $emit(eventName) 触发事件\n\n// 父组件\n<div id=\"counter-event-example\">\n  <p>{{ total }}</p>\n  <button-counter v-on:increment=\"incrementTotal\"></button-counter>\n  <button-counter v-on:increment=\"incrementTotal\"></button-counter>\n</div>\n\nnew Vue({\n  el: '#counter-event-example',\n  data: {\n    total: 0\n  },\n  methods: {\n    incrementTotal: function () {\n      this.total += 1\n    }\n  }\n})\n\n// 子组件\n<div>\n  <button v-on:click='incrementCounter'>{{ counter }}</button>\n</div>\n\nexport default {\n  data: function () {\n    return {\n      counter: 0\n    }\n  },\n  methods: {\n    incrementCounter: function () {\n      this.counter += 1\n      this.$emit('increment')\n    }\n  }\n}\n```\n\n5.非父子组件怎么通信\n```JavaScript\n// 可以使用一个空的Vue实例来做媒介\nvar bus = new Vue()\n\n// 需要传递值的组件\nbus.$emit('someMethods')\n\n// 需要接受值的组件\nbus.$on('someMethods', function (val) {\n  // 监听\n  // ...\n})\n\n// 情况复杂的话需要vuex状态管理\n```\n\n6.插槽分发slot标签. 在设计组合使用的组件时, 内容分发API非常有用\n7.动态组件\n```JavaScript\n// 可以通过保留component元素, 并对其 is 特性进行动态绑定.\nvar vm = new Vue ({\n  ...,\n  data () {\n    return {\n      currentView: 'home'\n    }\n  },\n  components: {\n    home: {\n      template: '<div>home</div>'\n    },\n    posts: { ... },\n    archive: { ... }\n  }\n})\n\n<component v-bind:is='currentView'>\n\n// 也可以直接绑定到组件\nvar Home = {\n  template: '<div>home</div>'\n}\n\nvar vm = new Vue ({\n  ...,\n  data: {\n    currentView: Home\n  }\n})\n```\n8.keep-alive标签\n```html\n<keep-alive>\n  <... />\n</keep-alive>\n<!-- 可以保留其内部的状态或者避免重新渲染 -->\n```\n9.$refs 只在组件渲染完成后才填充, 并且它是非响应式的. 它仅仅是一个直接操作子组件的应急方案——应当避免在模板或计算属性中使用 $refs\n\n\n前往[第二篇](https://psilocine.github.io/2018/03/03/%E6%88%91%E8%AE%A4%E4%B8%BA%E7%9A%84Vue%E5%AE%98%E6%96%B9%E6%96%87%E6%A1%A3%E9%87%8D%E7%82%B9-2/)","slug":"我认为的Vue官方文档重点-1","published":1,"updated":"2021-07-02T03:20:30.662Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl5sb8gg70031xq0rdpqa70pe","content":"<h5 id=\"写在前面\"><a href=\"#写在前面\" class=\"headerlink\" title=\"写在前面\"></a>写在前面</h5><p>最近想系统学习一下Vue, 有时候看官方文档太庞大复杂, 会失去看下去的欲望, 不妨来看看我整理的一些知识. 当然前提是你懂基本的Vue语法和结构<br>文章大体会根据Vue官方文档(教程2.X)提供的学习路线<br>本文从 Vue实例 -&gt; 组件</p>\n<h3 id=\"Vue实例\"><a href=\"#Vue实例\" class=\"headerlink\" title=\"Vue实例\"></a>Vue实例</h3><p>1.Vue是数据驱动的, 但如果在创建实例后再去给Vue添加属性的话, 新添加的属性是不具备响应式的</p>\n<a id=\"more\"></a>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;p&gt;&#123;&#123;name&#125;&#125;&lt;<span class=\"regexp\">/p&gt;</span></span><br><span class=\"line\"><span class=\"regexp\">&lt;p&gt;&#123;&#123;age&#125;&#125;&lt;/</span>p&gt;</span><br><span class=\"line\">&lt;p&gt;&#123;&#123;sex&#125;&#125;&lt;<span class=\"regexp\">/p&gt;</span></span><br><span class=\"line\"><span class=\"regexp\"></span></span><br><span class=\"line\"><span class=\"regexp\">new vm = new Vue(&#123;</span></span><br><span class=\"line\"><span class=\"regexp\">  ...</span></span><br><span class=\"line\"><span class=\"regexp\">  data () &#123;</span></span><br><span class=\"line\"><span class=\"regexp\">    name: 'Psilo',</span></span><br><span class=\"line\"><span class=\"regexp\">    age: '24'</span></span><br><span class=\"line\"><span class=\"regexp\">  &#125;,</span></span><br><span class=\"line\"><span class=\"regexp\">  ...</span></span><br><span class=\"line\"><span class=\"regexp\">&#125;)</span></span><br><span class=\"line\"><span class=\"regexp\"></span></span><br><span class=\"line\"><span class=\"regexp\">/</span><span class=\"regexp\">/ 因为还没有sex属性, 只渲染出前两个标签</span></span><br><span class=\"line\"><span class=\"regexp\"></span></span><br><span class=\"line\"><span class=\"regexp\">vm.sex = '男'</span></span><br><span class=\"line\"><span class=\"regexp\">/</span><span class=\"regexp\">/ 添加属性成功, 但是渲染无效.</span></span><br><span class=\"line\"><span class=\"regexp\">/</span><span class=\"regexp\">/ 查看后发现原因是因为name有setter和getter, 后添加的sex没有</span></span><br><span class=\"line\"><span class=\"regexp\">/</span><span class=\"regexp\">/ 解决方法 1</span></span><br><span class=\"line\"><span class=\"regexp\">Vue.set(vm, 'sex', '男')</span></span><br><span class=\"line\"><span class=\"regexp\">/</span><span class=\"regexp\">/ 解决方法 2</span></span><br><span class=\"line\"><span class=\"regexp\">vm.$set(vm, 'sex', '男')</span></span><br></pre></td></tr></table></figure>\n\n<p><img src=\"//psilocine.github.io/2018/01/15/我认为的Vue官方文档重点-1/1_newPropertyHaventGetterAndSetter.jpg\" alt=\"response\"></p>\n<h3 id=\"模板语法\"><a href=\"#模板语法\" class=\"headerlink\" title=\"模板语法\"></a>模板语法</h3><p>1.v-once只渲染一次, 适合渲染包含大量静态内容的标签</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;p v-once&gt;我不会变化: &#123;&#123;msg&#125;&#125;&lt;<span class=\"regexp\">/p&gt;</span></span><br><span class=\"line\"><span class=\"regexp\">/</span><span class=\"regexp\">/ msg改变, 上述标签内容也不会改变</span></span><br></pre></td></tr></table></figure>\n\n<p>2.v-html用法, 例如data有个属性包含html标签, 直接用双花括号渲染会原封不动将html标签渲染成字符串, v-html会将HTML标签渲染成html标签, 详情见下图. 但是官方并不推荐用, 因为容易导致xss攻击</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;p&gt;&#123;&#123;text&#125;&#125;&lt;<span class=\"regexp\">/p&gt;</span></span><br><span class=\"line\"><span class=\"regexp\">&lt;p v-html='text'&gt;&lt;/</span>p&gt;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">new</span> Vue(&#123;</span><br><span class=\"line\">  data () &#123;</span><br><span class=\"line\">    text: <span class=\"string\">'&lt;span style=\"color: red\"&gt;This should be red.&lt;/span&gt;'</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n\n<p><img src=\"//psilocine.github.io/2018/01/15/我认为的Vue官方文档重点-1/2_vHtmlUsage.jpg\" alt=\"vHtmlUsage\"></p>\n<p>3.双花括号里面能包括单个表达式</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;&#123; number + <span class=\"number\">1</span> &#125;&#125;</span><br><span class=\"line\">&#123;&#123; ok? <span class=\"string\">'Yes'</span>; <span class=\"string\">'No'</span> &#125;&#125;</span><br><span class=\"line\">&#123;&#123; message.split(<span class=\"string\">''</span>).reverse().join(<span class=\"string\">''</span>) &#125;&#125;</span><br><span class=\"line\"><span class=\"comment\">// 还支持Math和Date</span></span><br><span class=\"line\">&#123;&#123; <span class=\"built_in\">Math</span>.floor(number) &#125;&#125;</span><br></pre></td></tr></table></figure>\n\n<p>4.利用v-bind响应式更新attribute</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;a v-bind:href=<span class=\"string\">'url'</span>&gt;...&lt;<span class=\"regexp\">/a&gt;</span></span><br><span class=\"line\"><span class=\"regexp\">&lt;a :href='url'&gt;...&lt;/</span>a&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">&lt;p <span class=\"class\"><span class=\"keyword\">class</span></span>=<span class=\"string\">'active'</span> :<span class=\"class\"><span class=\"keyword\">class</span></span>=<span class=\"string\">'classObject'</span>&gt;...&lt;<span class=\"regexp\">/p&gt; /</span><span class=\"regexp\">/ 最后渲染出三个class的p标签</span></span><br><span class=\"line\"><span class=\"regexp\"></span></span><br><span class=\"line\"><span class=\"regexp\">&lt;p :style='styleObject'&gt;...&lt;/</span>p&gt; <span class=\"comment\">// 渲染出行内样式</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 也可以是组数</span></span><br><span class=\"line\">&lt;p :style=<span class=\"string\">'['</span>styleObject<span class=\"string\">', '</span>styleObjectB<span class=\"string\">']'</span>&gt;...&lt;<span class=\"regexp\">/p&gt;</span></span><br><span class=\"line\"><span class=\"regexp\"></span></span><br><span class=\"line\"><span class=\"regexp\">new Vue(&#123;</span></span><br><span class=\"line\"><span class=\"regexp\">  data () &#123;</span></span><br><span class=\"line\"><span class=\"regexp\">    url: 'https:/</span><span class=\"regexp\">/psilocine.github.io',</span></span><br><span class=\"line\"><span class=\"regexp\">    classObject: &#123;</span></span><br><span class=\"line\"><span class=\"regexp\">      'text-red': true,</span></span><br><span class=\"line\"><span class=\"regexp\">      'text-bold': true</span></span><br><span class=\"line\"><span class=\"regexp\">    &#125;,</span></span><br><span class=\"line\"><span class=\"regexp\">    styleObject: &#123;</span></span><br><span class=\"line\"><span class=\"regexp\">      color: 'red',</span></span><br><span class=\"line\"><span class=\"regexp\">      font-weight: 'bold'</span></span><br><span class=\"line\"><span class=\"regexp\">    &#125;,</span></span><br><span class=\"line\"><span class=\"regexp\">    styleObjectB: &#123;</span></span><br><span class=\"line\"><span class=\"regexp\">      font-size: '20px'</span></span><br><span class=\"line\"><span class=\"regexp\">    &#125;</span></span><br><span class=\"line\"><span class=\"regexp\">  &#125;</span></span><br><span class=\"line\"><span class=\"regexp\">&#125;)</span></span><br><span class=\"line\"><span class=\"regexp\"></span></span><br><span class=\"line\"><span class=\"regexp\">/</span><span class=\"regexp\">/ url变化时, a标签的href也动态变化</span></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"计算属性和侦听器\"><a href=\"#计算属性和侦听器\" class=\"headerlink\" title=\"计算属性和侦听器\"></a>计算属性和侦听器</h3><p>1.在计算属性computed定义的方法和在methods里定义的方法有什么不同? computed里的方法适合性能开销大的计算, 因为它会缓存起来, 如果相应变量不改变, 它就只会计算一次, 后续的调用从缓存拿; methods每次都会重复算</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">new</span> Vue(&#123;</span><br><span class=\"line\">  ...,</span><br><span class=\"line\">  computed: &#123;</span><br><span class=\"line\">    now () &#123;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> <span class=\"built_in\">Date</span>.now()</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  ...</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\"><span class=\"comment\">// 计算属性里的now方法将不再更新，因为 Date.now() 不是响应式依赖</span></span><br></pre></td></tr></table></figure>\n\n<p>2.计算属性默认只有getter, 不过也可以定义setter</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">computed: &#123;</span><br><span class=\"line\">  fullName: &#123;</span><br><span class=\"line\">    <span class=\"comment\">// getter</span></span><br><span class=\"line\">    <span class=\"keyword\">get</span>: function () &#123;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>.firstName + <span class=\"string\">' '</span> + <span class=\"keyword\">this</span>.lastName</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    <span class=\"comment\">// setter</span></span><br><span class=\"line\">    <span class=\"keyword\">set</span>: function (newValue) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">var</span> names = newValue.split(<span class=\"string\">' '</span>)</span><br><span class=\"line\">      <span class=\"keyword\">this</span>.firstName = names[<span class=\"number\">0</span>]</span><br><span class=\"line\">      <span class=\"keyword\">this</span>.lastName = names[names.length - <span class=\"number\">1</span>]</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"Class-与-Style-绑定\"><a href=\"#Class-与-Style-绑定\" class=\"headerlink\" title=\"Class 与 Style 绑定\"></a>Class 与 Style 绑定</h3><p>1.见模板语法的第3点, 另多补充三元表达式</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;div v-bind:<span class=\"class\"><span class=\"keyword\">class</span></span>=<span class=\"string\">\"isActive ? activeClass : ''\"</span>&gt;<span class=\"xml\"><span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span></span><br></pre></td></tr></table></figure>\n\n<p>2.v-bind:style添加css属性, 会自动侦测并添加浏览器前缀, 和postcss的autoprefixer相似</p>\n<h3 id=\"条件渲染\"><a href=\"#条件渲染\" class=\"headerlink\" title=\"条件渲染\"></a>条件渲染</h3><p>1.v-if也能给多个元素加, 和template标签配合即可. 最终的渲染结果不包括template标签</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">template</span> <span class=\"attr\">v-if</span>=<span class=\"string\">'condition'</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">p</span>&gt;</span>hello<span class=\"tag\">&lt;/<span class=\"name\">p</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">p</span>&gt;</span>world<span class=\"tag\">&lt;/<span class=\"name\">p</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">p</span>&gt;</span>!!!!!<span class=\"tag\">&lt;/<span class=\"name\">p</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">template</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n<p><img src=\"//psilocine.github.io/2018/01/15/我认为的Vue官方文档重点-1/3_template_code.jpg\" alt=\"template_code\"><br><img src=\"//psilocine.github.io/2018/01/15/我认为的Vue官方文档重点-1/3_template_show.jpg\" alt=\"template_show\"></p>\n<p>2.v-if和v-show的区别</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"number\">1.</span> v-<span class=\"keyword\">if</span>能跟v-<span class=\"keyword\">else</span>连用, v-show不行</span><br><span class=\"line\"><span class=\"number\">2.</span> v-<span class=\"keyword\">if</span>能和template标签配合, v-show不行</span><br><span class=\"line\"><span class=\"number\">3.</span> 带有 v-show 的元素始终会被渲染并保留在 DOM 中, v-show 只是简单地切换元素的 CSS 属性 display; v-<span class=\"keyword\">if</span>如果不成立, 是不在DOM中渲染的</span><br><span class=\"line\"><span class=\"number\">4.</span> v-<span class=\"keyword\">if</span> 有更高的切换开销, 而 v-show 有更高的初始渲染开销. 如果需要非常频繁地切换, 则使用 v-show 较好; 如果在运行时条件很少改变, 则使用 v-<span class=\"keyword\">if</span> 较好</span><br></pre></td></tr></table></figure>\n\n<p>3.v-if和v-for一起用, v-for比v-if高优先权</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">li</span> <span class=\"attr\">v-for</span>=<span class=\"string\">\"todo in todos\"</span> <span class=\"attr\">v-if</span>=<span class=\"string\">\"!todo.isComplete\"</span>&gt;</span></span><br><span class=\"line\">  &#123;&#123; todo &#125;&#125;</span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">li</span>&gt;</span></span><br><span class=\"line\">上述只传递了未完成的 todos</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"列表渲染\"><a href=\"#列表渲染\" class=\"headerlink\" title=\"列表渲染\"></a>列表渲染</h3><p>1.v-for遍历对象时, 是按Object.keys() 的结果遍历, 但是不能保证它的结果在不同的 JavaScript 引擎下是一致的<br>2.v-for也可以和v-if一样, 和template标签渲染多个元素</p>\n<h3 id=\"事件处理\"><a href=\"#事件处理\" class=\"headerlink\" title=\"事件处理\"></a>事件处理</h3><p>1.v-on的修饰符</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 事件修饰符</span></span><br><span class=\"line\">.stop <span class=\"comment\">// evnet.preventDefault() v-on:click.stop='doThis'</span></span><br><span class=\"line\">.prevent <span class=\"comment\">// event.stopPropagation</span></span><br><span class=\"line\">.capture <span class=\"comment\">// 事件捕获</span></span><br><span class=\"line\">.once <span class=\"comment\">// 执行一次</span></span><br><span class=\"line\">.self <span class=\"comment\">// event.target是当前元素才触发</span></span><br><span class=\"line\"></span><br><span class=\"line\">注意修饰符的顺序也有影响: </span><br><span class=\"line\">@:click.self.prevent <span class=\"comment\">// 阻止自身元素默认行为 </span></span><br><span class=\"line\">@:click.prevent.self <span class=\"comment\">// 阻止所有的点击</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 按键修饰符</span></span><br><span class=\"line\">@:keyup<span class=\"number\">.13</span> = <span class=\"string\">'submit'</span> <span class=\"comment\">// keyup且keyCode是13才触发</span></span><br><span class=\"line\">@.keyup.enter = <span class=\"string\">'submit'</span> <span class=\"comment\">// 同理</span></span><br><span class=\"line\"></span><br><span class=\"line\">.enter</span><br><span class=\"line\">.tab <span class=\"comment\">// Tab键, 当focus到视口外失效, 如最后一个元素</span></span><br><span class=\"line\">.delete (捕获“删除”和“退格”键)</span><br><span class=\"line\">.esc</span><br><span class=\"line\">.space</span><br><span class=\"line\">.up <span class=\"comment\">// ↑键</span></span><br><span class=\"line\">.down</span><br><span class=\"line\">.left</span><br><span class=\"line\">.right</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 系统修饰键</span></span><br><span class=\"line\">.ctrl</span><br><span class=\"line\">.alt</span><br><span class=\"line\">.shift</span><br><span class=\"line\">.meta <span class=\"comment\">// mac对应command, windows对应左下微软标识键</span></span><br><span class=\"line\"></span><br><span class=\"line\">@keyup.ctrl<span class=\"number\">.67</span>=<span class=\"string\">'something'</span> <span class=\"comment\">// ctrl + c 复制时候触发事件</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 鼠标按键修饰符</span></span><br><span class=\"line\">.left</span><br><span class=\"line\">.right</span><br><span class=\"line\">.middle</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"表单输入绑定\"><a href=\"#表单输入绑定\" class=\"headerlink\" title=\"表单输入绑定\"></a>表单输入绑定</h3><p>v-model实现双向绑定, 有v-model指令的标签能实时改变绑定的值</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">v-model实际上是v-bind和v-on的语法糖</span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">input</span> <span class=\"attr\">type</span>=<span class=\"string\">'text'</span> <span class=\"attr\">:value</span>=<span class=\"string\">'message'</span> <span class=\"attr\">ref</span>=<span class=\"string\">'inp'</span> @<span class=\"attr\">input</span>=<span class=\"string\">'inputValue'</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">p</span>&gt;</span>&#123;&#123;message&#125;&#125;<span class=\"tag\">&lt;/<span class=\"name\">p</span>&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\">...,</span><br><span class=\"line\">data () &#123;</span><br><span class=\"line\">  return &#123;</span><br><span class=\"line\">    message: 'hello'</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  methods: &#123;</span><br><span class=\"line\">    inputValue () &#123;</span><br><span class=\"line\">      this.message = this.$refs.inp.value</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">// 不用到ref的更简洁的方法 @input='inputValue($event)'</span><br><span class=\"line\">    inputValue (event) &#123;</span><br><span class=\"line\">      this.message = event.target.value</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">但这样还是显得太过臃肿, 于是引入v-model</span><br></pre></td></tr></table></figure>\n\n<p>1.关于教程里标注的’在文本区域textarea插值并不会生效’, 是指的textarea如果是用花括号赋值, 当改变文本区域的内容, 不会实时变化</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;&#123;num&#125;&#125;</span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">input</span> <span class=\"attr\">v-model</span>=<span class=\"string\">'num'</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">textarea</span>&gt;</span>&#123;&#123;num&#125;&#125; asd<span class=\"tag\">&lt;/<span class=\"name\">textarea</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">textarea</span> <span class=\"attr\">v-model</span>=<span class=\"string\">'num'</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">textarea</span>&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\">假设num值是1.5</span><br><span class=\"line\">1. 当我们改变有v-model指令的input和textarea标签, 4个值都会实时改变. 看图1 我们加了'change'</span><br><span class=\"line\">2. 当我们改变直接插值的textarea以后, 发现其他三个并没有改变, 从这时候开始, 直接插值的textarea就已经不是双向绑定了. 看图2 我们又多加'111'</span><br><span class=\"line\">3. 如果不在直接插值的文本区域修改属性, 还是可以生效的; 如果修改了, 哪怕不是修改属性值, 如上例子修改的是&#123;&#123;num&#125;&#125; 后面的 asd, 也会断开联系</span><br></pre></td></tr></table></figure>\n\n<!--more-->\n<p>图1<br><img src=\"//psilocine.github.io/2018/01/15/我认为的Vue官方文档重点-1/1_textarea_1.jpg\" alt=\"图1\"><br>图2<br><img src=\"//psilocine.github.io/2018/01/15/我认为的Vue官方文档重点-1/1_textarea_2.jpg\" alt=\"图2\"></p>\n<p>2.在 iOS 中, select元素这会使用户无法选择第一个选项, 推荐像下面这样提供一个值为空的禁用选项.</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">select</span> <span class=\"attr\">v-model</span>=<span class=\"string\">\"selected\"</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">option</span> <span class=\"attr\">disabled</span> <span class=\"attr\">value</span>=<span class=\"string\">\"\"</span>&gt;</span>请选择<span class=\"tag\">&lt;/<span class=\"name\">option</span>&gt;</span> // 空值选项</span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">option</span>&gt;</span>A<span class=\"tag\">&lt;/<span class=\"name\">option</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">option</span>&gt;</span>B<span class=\"tag\">&lt;/<span class=\"name\">option</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">option</span>&gt;</span>C<span class=\"tag\">&lt;/<span class=\"name\">option</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">select</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n<p>3.对于单选按钮, 复选框和选择框的选项, v-model绑定的值通常是静态字符串</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;select v-model=<span class=\"string\">\"selected\"</span>&gt;</span><br><span class=\"line\">  &lt;option v-<span class=\"keyword\">for</span>=<span class=\"string\">\"option in options\"</span> v-bind:value=<span class=\"string\">\"option.value\"</span>&gt;</span><br><span class=\"line\">    &#123;&#123; option.text &#125;&#125;</span><br><span class=\"line\">  &lt;<span class=\"regexp\">/option&gt;</span></span><br><span class=\"line\"><span class=\"regexp\">&lt;/</span>select&gt;</span><br><span class=\"line\">&lt;span&gt;Selected: &#123;&#123; selected &#125;&#125;&lt;<span class=\"regexp\">/span&gt;</span></span><br><span class=\"line\"><span class=\"regexp\"></span></span><br><span class=\"line\"><span class=\"regexp\">new Vue(&#123;</span></span><br><span class=\"line\"><span class=\"regexp\">  el: '...',</span></span><br><span class=\"line\"><span class=\"regexp\">  data: &#123;</span></span><br><span class=\"line\"><span class=\"regexp\">    selected: 'A',</span></span><br><span class=\"line\"><span class=\"regexp\">    options: [</span></span><br><span class=\"line\"><span class=\"regexp\">      &#123; text: 'One', value: 'A' &#125;,</span></span><br><span class=\"line\"><span class=\"regexp\">      &#123; text: 'Two', value: 'B' &#125;,</span></span><br><span class=\"line\"><span class=\"regexp\">      &#123; text: 'Three', value: 'C' &#125;</span></span><br><span class=\"line\"><span class=\"regexp\">    ]</span></span><br><span class=\"line\"><span class=\"regexp\">  &#125;</span></span><br><span class=\"line\"><span class=\"regexp\">&#125;)</span></span><br><span class=\"line\"><span class=\"regexp\"></span></span><br><span class=\"line\"><span class=\"regexp\">/</span><span class=\"regexp\">/ 为什么明明没改变data里selected的值, 可是渲染出来的&#123;&#123; selected &#125;&#125;却可以随select选择变化</span></span><br><span class=\"line\"><span class=\"regexp\">原因就是上面的话, 选择的option的value会传递给v-model</span></span><br></pre></td></tr></table></figure>\n\n<p>4.输入的修饰符</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"number\">1.</span> (.lazy) v-model在change时才触发更新</span><br><span class=\"line\"><span class=\"number\">2.</span> (.number) 输入的必须是数值类型, 如果不是, 在输入框blur时自动将非数值剔除. 如果已经有值, 那第一个字符应该就为数值, 不然无效</span><br><span class=\"line\"><span class=\"number\">3.</span> (.trim) 过滤用户输入的首位空白字符</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"组件\"><a href=\"#组件\" class=\"headerlink\" title=\"组件\"></a>组件</h3><p>1.组件注册可以全局注也可以局部注册</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 局部, 一种导入(假设为header) 一种当前作用域定义注册</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> footer = &#123;</span><br><span class=\"line\">  template: <span class=\"string\">'&lt;div&gt;i am footer&lt;/div&gt;'</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">new</span> Vue(&#123;</span><br><span class=\"line\">  ...,</span><br><span class=\"line\">  components: &#123;</span><br><span class=\"line\">    <span class=\"string\">'v-header'</span>: header <span class=\"comment\">// 导入</span></span><br><span class=\"line\">    <span class=\"string\">'v-footer'</span>: footer <span class=\"comment\">// 作用域注册 不常用</span></span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  ...</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\"><span class=\"comment\">// 全局</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> footer = &#123;</span><br><span class=\"line\">  template: <span class=\"string\">'&lt;div&gt;i am footer&lt;/div&gt;'</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// 注意 一定要在new之前注册, 否则无效</span></span><br><span class=\"line\">Vue.component(<span class=\"string\">'v-footer'</span>, &#123;</span><br><span class=\"line\">  footer</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\"><span class=\"keyword\">new</span> Vue(&#123;</span><br><span class=\"line\">  ...</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n\n<p>2.data必须是函数, 这样每个组件都能有独立的状态<br>3.一般来说只允许父组件向子组件传值(props), 称为props单向数据流, 为了防止子组件无意间改变父组件的状态</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 子组件</span></span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">default</span> &#123;</span><br><span class=\"line\">  props: [<span class=\"string\">'name'</span>, <span class=\"string\">'age'</span>] <span class=\"comment\">// 可以是数组</span></span><br><span class=\"line\">  props: &#123;               <span class=\"comment\">// 可以是对象</span></span><br><span class=\"line\">    name: <span class=\"built_in\">String</span>, <span class=\"comment\">// 验证类型</span></span><br><span class=\"line\">    age: &#123;        <span class=\"comment\">// 验证类型 + 其他验证</span></span><br><span class=\"line\">      type: <span class=\"built_in\">Number</span>,</span><br><span class=\"line\">      dafault: <span class=\"number\">0</span>,</span><br><span class=\"line\">      required: <span class=\"literal\">true</span>,</span><br><span class=\"line\">      validator (val) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> val &gt;= <span class=\"number\">0</span></span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//补充 props 里的 type 支持的属性</span></span><br><span class=\"line\"><span class=\"built_in\">String</span></span><br><span class=\"line\"><span class=\"built_in\">Number</span></span><br><span class=\"line\"><span class=\"built_in\">Boolean</span></span><br><span class=\"line\"><span class=\"built_in\">Function</span></span><br><span class=\"line\"><span class=\"built_in\">Object</span></span><br><span class=\"line\"><span class=\"built_in\">Array</span></span><br><span class=\"line\"><span class=\"built_in\">Symbol</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 父组件</span></span><br><span class=\"line\">&lt;Child name=<span class=\"string\">'Psilo'</span> age=<span class=\"string\">'24'</span> /&gt; <span class=\"comment\">// 设子组件名为 &lt;Child&gt;, 传值成功</span></span><br></pre></td></tr></table></figure>\n\n<p>4.子组件向父组件怎么传值? 自定义事件. 父组件里用v-on:自定义事件名字=’父组件方法’; 子组件在监听方法名里用this.$emit(‘自定义事件名字’)</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">使用 $on(eventName) 监听事件</span><br><span class=\"line\">使用 $emit(eventName) 触发事件</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 父组件</span></span><br><span class=\"line\">&lt;div id=<span class=\"string\">\"counter-event-example\"</span>&gt;</span><br><span class=\"line\">  &lt;p&gt;&#123;&#123; total &#125;&#125;&lt;<span class=\"regexp\">/p&gt;</span></span><br><span class=\"line\"><span class=\"regexp\">  &lt;button-counter v-on:increment=\"incrementTotal\"&gt;&lt;/</span>button-counter&gt;</span><br><span class=\"line\">  &lt;button-counter v-on:increment=<span class=\"string\">\"incrementTotal\"</span>&gt;<span class=\"xml\"><span class=\"tag\">&lt;/<span class=\"name\">button-counter</span>&gt;</span></span></span><br><span class=\"line\">&lt;<span class=\"regexp\">/div&gt;</span></span><br><span class=\"line\"><span class=\"regexp\"></span></span><br><span class=\"line\"><span class=\"regexp\">new Vue(&#123;</span></span><br><span class=\"line\"><span class=\"regexp\">  el: '#counter-event-example',</span></span><br><span class=\"line\"><span class=\"regexp\">  data: &#123;</span></span><br><span class=\"line\"><span class=\"regexp\">    total: 0</span></span><br><span class=\"line\"><span class=\"regexp\">  &#125;,</span></span><br><span class=\"line\"><span class=\"regexp\">  methods: &#123;</span></span><br><span class=\"line\"><span class=\"regexp\">    incrementTotal: function () &#123;</span></span><br><span class=\"line\"><span class=\"regexp\">      this.total += 1</span></span><br><span class=\"line\"><span class=\"regexp\">    &#125;</span></span><br><span class=\"line\"><span class=\"regexp\">  &#125;</span></span><br><span class=\"line\"><span class=\"regexp\">&#125;)</span></span><br><span class=\"line\"><span class=\"regexp\"></span></span><br><span class=\"line\"><span class=\"regexp\">/</span><span class=\"regexp\">/ 子组件</span></span><br><span class=\"line\"><span class=\"regexp\">&lt;div&gt;</span></span><br><span class=\"line\"><span class=\"regexp\">  &lt;button v-on:click='incrementCounter'&gt;&#123;&#123; counter &#125;&#125;&lt;/</span>button&gt;</span><br><span class=\"line\">&lt;<span class=\"regexp\">/div&gt;</span></span><br><span class=\"line\"><span class=\"regexp\"></span></span><br><span class=\"line\"><span class=\"regexp\">export default &#123;</span></span><br><span class=\"line\"><span class=\"regexp\">  data: function () &#123;</span></span><br><span class=\"line\"><span class=\"regexp\">    return &#123;</span></span><br><span class=\"line\"><span class=\"regexp\">      counter: 0</span></span><br><span class=\"line\"><span class=\"regexp\">    &#125;</span></span><br><span class=\"line\"><span class=\"regexp\">  &#125;,</span></span><br><span class=\"line\"><span class=\"regexp\">  methods: &#123;</span></span><br><span class=\"line\"><span class=\"regexp\">    incrementCounter: function () &#123;</span></span><br><span class=\"line\"><span class=\"regexp\">      this.counter += 1</span></span><br><span class=\"line\"><span class=\"regexp\">      this.$emit('increment')</span></span><br><span class=\"line\"><span class=\"regexp\">    &#125;</span></span><br><span class=\"line\"><span class=\"regexp\">  &#125;</span></span><br><span class=\"line\"><span class=\"regexp\">&#125;</span></span><br></pre></td></tr></table></figure>\n\n<p>5.非父子组件怎么通信</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 可以使用一个空的Vue实例来做媒介</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> bus = <span class=\"keyword\">new</span> Vue()</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 需要传递值的组件</span></span><br><span class=\"line\">bus.$emit(<span class=\"string\">'someMethods'</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 需要接受值的组件</span></span><br><span class=\"line\">bus.$on(<span class=\"string\">'someMethods'</span>, <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">val</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">// 监听</span></span><br><span class=\"line\">  <span class=\"comment\">// ...</span></span><br><span class=\"line\">&#125;)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 情况复杂的话需要vuex状态管理</span></span><br></pre></td></tr></table></figure>\n\n<p>6.插槽分发slot标签. 在设计组合使用的组件时, 内容分发API非常有用<br>7.动态组件</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 可以通过保留component元素, 并对其 is 特性进行动态绑定.</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> vm = <span class=\"keyword\">new</span> Vue (&#123;</span><br><span class=\"line\">  ...,</span><br><span class=\"line\">  data () &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> &#123;</span><br><span class=\"line\">      currentView: <span class=\"string\">'home'</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  components: &#123;</span><br><span class=\"line\">    home: &#123;</span><br><span class=\"line\">      template: <span class=\"string\">'&lt;div&gt;home&lt;/div&gt;'</span></span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    posts: &#123; ... &#125;,</span><br><span class=\"line\">    archive: &#123; ... &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\"></span><br><span class=\"line\">&lt;component v-bind:is=<span class=\"string\">'currentView'</span>&gt;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 也可以直接绑定到组件</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> Home = &#123;</span><br><span class=\"line\">  template: <span class=\"string\">'&lt;div&gt;home&lt;/div&gt;'</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> vm = <span class=\"keyword\">new</span> Vue (&#123;</span><br><span class=\"line\">  ...,</span><br><span class=\"line\">  data: &#123;</span><br><span class=\"line\">    currentView: Home</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n\n<p>8.keep-alive标签</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">keep-alive</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">...</span> /&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">keep-alive</span>&gt;</span></span><br><span class=\"line\"><span class=\"comment\">&lt;!-- 可以保留其内部的状态或者避免重新渲染 --&gt;</span></span><br></pre></td></tr></table></figure>\n\n<p>9.$refs 只在组件渲染完成后才填充, 并且它是非响应式的. 它仅仅是一个直接操作子组件的应急方案——应当避免在模板或计算属性中使用 $refs</p>\n<p>前往<a href=\"https://psilocine.github.io/2018/03/03/%E6%88%91%E8%AE%A4%E4%B8%BA%E7%9A%84Vue%E5%AE%98%E6%96%B9%E6%96%87%E6%A1%A3%E9%87%8D%E7%82%B9-2/\">第二篇</a></p>\n","site":{"data":{}},"excerpt":"<h5 id=\"写在前面\"><a href=\"#写在前面\" class=\"headerlink\" title=\"写在前面\"></a>写在前面</h5><p>最近想系统学习一下Vue, 有时候看官方文档太庞大复杂, 会失去看下去的欲望, 不妨来看看我整理的一些知识. 当然前提是你懂基本的Vue语法和结构<br>文章大体会根据Vue官方文档(教程2.X)提供的学习路线<br>本文从 Vue实例 -&gt; 组件</p>\n<h3 id=\"Vue实例\"><a href=\"#Vue实例\" class=\"headerlink\" title=\"Vue实例\"></a>Vue实例</h3><p>1.Vue是数据驱动的, 但如果在创建实例后再去给Vue添加属性的话, 新添加的属性是不具备响应式的</p>","more":"<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;p&gt;&#123;&#123;name&#125;&#125;&lt;<span class=\"regexp\">/p&gt;</span></span><br><span class=\"line\"><span class=\"regexp\">&lt;p&gt;&#123;&#123;age&#125;&#125;&lt;/</span>p&gt;</span><br><span class=\"line\">&lt;p&gt;&#123;&#123;sex&#125;&#125;&lt;<span class=\"regexp\">/p&gt;</span></span><br><span class=\"line\"><span class=\"regexp\"></span></span><br><span class=\"line\"><span class=\"regexp\">new vm = new Vue(&#123;</span></span><br><span class=\"line\"><span class=\"regexp\">  ...</span></span><br><span class=\"line\"><span class=\"regexp\">  data () &#123;</span></span><br><span class=\"line\"><span class=\"regexp\">    name: 'Psilo',</span></span><br><span class=\"line\"><span class=\"regexp\">    age: '24'</span></span><br><span class=\"line\"><span class=\"regexp\">  &#125;,</span></span><br><span class=\"line\"><span class=\"regexp\">  ...</span></span><br><span class=\"line\"><span class=\"regexp\">&#125;)</span></span><br><span class=\"line\"><span class=\"regexp\"></span></span><br><span class=\"line\"><span class=\"regexp\">/</span><span class=\"regexp\">/ 因为还没有sex属性, 只渲染出前两个标签</span></span><br><span class=\"line\"><span class=\"regexp\"></span></span><br><span class=\"line\"><span class=\"regexp\">vm.sex = '男'</span></span><br><span class=\"line\"><span class=\"regexp\">/</span><span class=\"regexp\">/ 添加属性成功, 但是渲染无效.</span></span><br><span class=\"line\"><span class=\"regexp\">/</span><span class=\"regexp\">/ 查看后发现原因是因为name有setter和getter, 后添加的sex没有</span></span><br><span class=\"line\"><span class=\"regexp\">/</span><span class=\"regexp\">/ 解决方法 1</span></span><br><span class=\"line\"><span class=\"regexp\">Vue.set(vm, 'sex', '男')</span></span><br><span class=\"line\"><span class=\"regexp\">/</span><span class=\"regexp\">/ 解决方法 2</span></span><br><span class=\"line\"><span class=\"regexp\">vm.$set(vm, 'sex', '男')</span></span><br></pre></td></tr></table></figure>\n\n<p><img src=\"//psilocine.github.io/2018/01/15/我认为的Vue官方文档重点-1/1_newPropertyHaventGetterAndSetter.jpg\" alt=\"response\"></p>\n<h3 id=\"模板语法\"><a href=\"#模板语法\" class=\"headerlink\" title=\"模板语法\"></a>模板语法</h3><p>1.v-once只渲染一次, 适合渲染包含大量静态内容的标签</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;p v-once&gt;我不会变化: &#123;&#123;msg&#125;&#125;&lt;<span class=\"regexp\">/p&gt;</span></span><br><span class=\"line\"><span class=\"regexp\">/</span><span class=\"regexp\">/ msg改变, 上述标签内容也不会改变</span></span><br></pre></td></tr></table></figure>\n\n<p>2.v-html用法, 例如data有个属性包含html标签, 直接用双花括号渲染会原封不动将html标签渲染成字符串, v-html会将HTML标签渲染成html标签, 详情见下图. 但是官方并不推荐用, 因为容易导致xss攻击</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;p&gt;&#123;&#123;text&#125;&#125;&lt;<span class=\"regexp\">/p&gt;</span></span><br><span class=\"line\"><span class=\"regexp\">&lt;p v-html='text'&gt;&lt;/</span>p&gt;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">new</span> Vue(&#123;</span><br><span class=\"line\">  data () &#123;</span><br><span class=\"line\">    text: <span class=\"string\">'&lt;span style=\"color: red\"&gt;This should be red.&lt;/span&gt;'</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n\n<p><img src=\"//psilocine.github.io/2018/01/15/我认为的Vue官方文档重点-1/2_vHtmlUsage.jpg\" alt=\"vHtmlUsage\"></p>\n<p>3.双花括号里面能包括单个表达式</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;&#123; number + <span class=\"number\">1</span> &#125;&#125;</span><br><span class=\"line\">&#123;&#123; ok? <span class=\"string\">'Yes'</span>; <span class=\"string\">'No'</span> &#125;&#125;</span><br><span class=\"line\">&#123;&#123; message.split(<span class=\"string\">''</span>).reverse().join(<span class=\"string\">''</span>) &#125;&#125;</span><br><span class=\"line\"><span class=\"comment\">// 还支持Math和Date</span></span><br><span class=\"line\">&#123;&#123; <span class=\"built_in\">Math</span>.floor(number) &#125;&#125;</span><br></pre></td></tr></table></figure>\n\n<p>4.利用v-bind响应式更新attribute</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;a v-bind:href=<span class=\"string\">'url'</span>&gt;...&lt;<span class=\"regexp\">/a&gt;</span></span><br><span class=\"line\"><span class=\"regexp\">&lt;a :href='url'&gt;...&lt;/</span>a&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">&lt;p <span class=\"class\"><span class=\"keyword\">class</span></span>=<span class=\"string\">'active'</span> :<span class=\"class\"><span class=\"keyword\">class</span></span>=<span class=\"string\">'classObject'</span>&gt;...&lt;<span class=\"regexp\">/p&gt; /</span><span class=\"regexp\">/ 最后渲染出三个class的p标签</span></span><br><span class=\"line\"><span class=\"regexp\"></span></span><br><span class=\"line\"><span class=\"regexp\">&lt;p :style='styleObject'&gt;...&lt;/</span>p&gt; <span class=\"comment\">// 渲染出行内样式</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 也可以是组数</span></span><br><span class=\"line\">&lt;p :style=<span class=\"string\">'['</span>styleObject<span class=\"string\">', '</span>styleObjectB<span class=\"string\">']'</span>&gt;...&lt;<span class=\"regexp\">/p&gt;</span></span><br><span class=\"line\"><span class=\"regexp\"></span></span><br><span class=\"line\"><span class=\"regexp\">new Vue(&#123;</span></span><br><span class=\"line\"><span class=\"regexp\">  data () &#123;</span></span><br><span class=\"line\"><span class=\"regexp\">    url: 'https:/</span><span class=\"regexp\">/psilocine.github.io',</span></span><br><span class=\"line\"><span class=\"regexp\">    classObject: &#123;</span></span><br><span class=\"line\"><span class=\"regexp\">      'text-red': true,</span></span><br><span class=\"line\"><span class=\"regexp\">      'text-bold': true</span></span><br><span class=\"line\"><span class=\"regexp\">    &#125;,</span></span><br><span class=\"line\"><span class=\"regexp\">    styleObject: &#123;</span></span><br><span class=\"line\"><span class=\"regexp\">      color: 'red',</span></span><br><span class=\"line\"><span class=\"regexp\">      font-weight: 'bold'</span></span><br><span class=\"line\"><span class=\"regexp\">    &#125;,</span></span><br><span class=\"line\"><span class=\"regexp\">    styleObjectB: &#123;</span></span><br><span class=\"line\"><span class=\"regexp\">      font-size: '20px'</span></span><br><span class=\"line\"><span class=\"regexp\">    &#125;</span></span><br><span class=\"line\"><span class=\"regexp\">  &#125;</span></span><br><span class=\"line\"><span class=\"regexp\">&#125;)</span></span><br><span class=\"line\"><span class=\"regexp\"></span></span><br><span class=\"line\"><span class=\"regexp\">/</span><span class=\"regexp\">/ url变化时, a标签的href也动态变化</span></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"计算属性和侦听器\"><a href=\"#计算属性和侦听器\" class=\"headerlink\" title=\"计算属性和侦听器\"></a>计算属性和侦听器</h3><p>1.在计算属性computed定义的方法和在methods里定义的方法有什么不同? computed里的方法适合性能开销大的计算, 因为它会缓存起来, 如果相应变量不改变, 它就只会计算一次, 后续的调用从缓存拿; methods每次都会重复算</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">new</span> Vue(&#123;</span><br><span class=\"line\">  ...,</span><br><span class=\"line\">  computed: &#123;</span><br><span class=\"line\">    now () &#123;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> <span class=\"built_in\">Date</span>.now()</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  ...</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\"><span class=\"comment\">// 计算属性里的now方法将不再更新，因为 Date.now() 不是响应式依赖</span></span><br></pre></td></tr></table></figure>\n\n<p>2.计算属性默认只有getter, 不过也可以定义setter</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">computed: &#123;</span><br><span class=\"line\">  fullName: &#123;</span><br><span class=\"line\">    <span class=\"comment\">// getter</span></span><br><span class=\"line\">    <span class=\"keyword\">get</span>: function () &#123;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>.firstName + <span class=\"string\">' '</span> + <span class=\"keyword\">this</span>.lastName</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    <span class=\"comment\">// setter</span></span><br><span class=\"line\">    <span class=\"keyword\">set</span>: function (newValue) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">var</span> names = newValue.split(<span class=\"string\">' '</span>)</span><br><span class=\"line\">      <span class=\"keyword\">this</span>.firstName = names[<span class=\"number\">0</span>]</span><br><span class=\"line\">      <span class=\"keyword\">this</span>.lastName = names[names.length - <span class=\"number\">1</span>]</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"Class-与-Style-绑定\"><a href=\"#Class-与-Style-绑定\" class=\"headerlink\" title=\"Class 与 Style 绑定\"></a>Class 与 Style 绑定</h3><p>1.见模板语法的第3点, 另多补充三元表达式</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;div v-bind:<span class=\"class\"><span class=\"keyword\">class</span></span>=<span class=\"string\">\"isActive ? activeClass : ''\"</span>&gt;<span class=\"xml\"><span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span></span><br></pre></td></tr></table></figure>\n\n<p>2.v-bind:style添加css属性, 会自动侦测并添加浏览器前缀, 和postcss的autoprefixer相似</p>\n<h3 id=\"条件渲染\"><a href=\"#条件渲染\" class=\"headerlink\" title=\"条件渲染\"></a>条件渲染</h3><p>1.v-if也能给多个元素加, 和template标签配合即可. 最终的渲染结果不包括template标签</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">template</span> <span class=\"attr\">v-if</span>=<span class=\"string\">'condition'</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">p</span>&gt;</span>hello<span class=\"tag\">&lt;/<span class=\"name\">p</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">p</span>&gt;</span>world<span class=\"tag\">&lt;/<span class=\"name\">p</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">p</span>&gt;</span>!!!!!<span class=\"tag\">&lt;/<span class=\"name\">p</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">template</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n<p><img src=\"//psilocine.github.io/2018/01/15/我认为的Vue官方文档重点-1/3_template_code.jpg\" alt=\"template_code\"><br><img src=\"//psilocine.github.io/2018/01/15/我认为的Vue官方文档重点-1/3_template_show.jpg\" alt=\"template_show\"></p>\n<p>2.v-if和v-show的区别</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"number\">1.</span> v-<span class=\"keyword\">if</span>能跟v-<span class=\"keyword\">else</span>连用, v-show不行</span><br><span class=\"line\"><span class=\"number\">2.</span> v-<span class=\"keyword\">if</span>能和template标签配合, v-show不行</span><br><span class=\"line\"><span class=\"number\">3.</span> 带有 v-show 的元素始终会被渲染并保留在 DOM 中, v-show 只是简单地切换元素的 CSS 属性 display; v-<span class=\"keyword\">if</span>如果不成立, 是不在DOM中渲染的</span><br><span class=\"line\"><span class=\"number\">4.</span> v-<span class=\"keyword\">if</span> 有更高的切换开销, 而 v-show 有更高的初始渲染开销. 如果需要非常频繁地切换, 则使用 v-show 较好; 如果在运行时条件很少改变, 则使用 v-<span class=\"keyword\">if</span> 较好</span><br></pre></td></tr></table></figure>\n\n<p>3.v-if和v-for一起用, v-for比v-if高优先权</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">li</span> <span class=\"attr\">v-for</span>=<span class=\"string\">\"todo in todos\"</span> <span class=\"attr\">v-if</span>=<span class=\"string\">\"!todo.isComplete\"</span>&gt;</span></span><br><span class=\"line\">  &#123;&#123; todo &#125;&#125;</span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">li</span>&gt;</span></span><br><span class=\"line\">上述只传递了未完成的 todos</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"列表渲染\"><a href=\"#列表渲染\" class=\"headerlink\" title=\"列表渲染\"></a>列表渲染</h3><p>1.v-for遍历对象时, 是按Object.keys() 的结果遍历, 但是不能保证它的结果在不同的 JavaScript 引擎下是一致的<br>2.v-for也可以和v-if一样, 和template标签渲染多个元素</p>\n<h3 id=\"事件处理\"><a href=\"#事件处理\" class=\"headerlink\" title=\"事件处理\"></a>事件处理</h3><p>1.v-on的修饰符</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 事件修饰符</span></span><br><span class=\"line\">.stop <span class=\"comment\">// evnet.preventDefault() v-on:click.stop='doThis'</span></span><br><span class=\"line\">.prevent <span class=\"comment\">// event.stopPropagation</span></span><br><span class=\"line\">.capture <span class=\"comment\">// 事件捕获</span></span><br><span class=\"line\">.once <span class=\"comment\">// 执行一次</span></span><br><span class=\"line\">.self <span class=\"comment\">// event.target是当前元素才触发</span></span><br><span class=\"line\"></span><br><span class=\"line\">注意修饰符的顺序也有影响: </span><br><span class=\"line\">@:click.self.prevent <span class=\"comment\">// 阻止自身元素默认行为 </span></span><br><span class=\"line\">@:click.prevent.self <span class=\"comment\">// 阻止所有的点击</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 按键修饰符</span></span><br><span class=\"line\">@:keyup<span class=\"number\">.13</span> = <span class=\"string\">'submit'</span> <span class=\"comment\">// keyup且keyCode是13才触发</span></span><br><span class=\"line\">@.keyup.enter = <span class=\"string\">'submit'</span> <span class=\"comment\">// 同理</span></span><br><span class=\"line\"></span><br><span class=\"line\">.enter</span><br><span class=\"line\">.tab <span class=\"comment\">// Tab键, 当focus到视口外失效, 如最后一个元素</span></span><br><span class=\"line\">.delete (捕获“删除”和“退格”键)</span><br><span class=\"line\">.esc</span><br><span class=\"line\">.space</span><br><span class=\"line\">.up <span class=\"comment\">// ↑键</span></span><br><span class=\"line\">.down</span><br><span class=\"line\">.left</span><br><span class=\"line\">.right</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 系统修饰键</span></span><br><span class=\"line\">.ctrl</span><br><span class=\"line\">.alt</span><br><span class=\"line\">.shift</span><br><span class=\"line\">.meta <span class=\"comment\">// mac对应command, windows对应左下微软标识键</span></span><br><span class=\"line\"></span><br><span class=\"line\">@keyup.ctrl<span class=\"number\">.67</span>=<span class=\"string\">'something'</span> <span class=\"comment\">// ctrl + c 复制时候触发事件</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 鼠标按键修饰符</span></span><br><span class=\"line\">.left</span><br><span class=\"line\">.right</span><br><span class=\"line\">.middle</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"表单输入绑定\"><a href=\"#表单输入绑定\" class=\"headerlink\" title=\"表单输入绑定\"></a>表单输入绑定</h3><p>v-model实现双向绑定, 有v-model指令的标签能实时改变绑定的值</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">v-model实际上是v-bind和v-on的语法糖</span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">input</span> <span class=\"attr\">type</span>=<span class=\"string\">'text'</span> <span class=\"attr\">:value</span>=<span class=\"string\">'message'</span> <span class=\"attr\">ref</span>=<span class=\"string\">'inp'</span> @<span class=\"attr\">input</span>=<span class=\"string\">'inputValue'</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">p</span>&gt;</span>&#123;&#123;message&#125;&#125;<span class=\"tag\">&lt;/<span class=\"name\">p</span>&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\">...,</span><br><span class=\"line\">data () &#123;</span><br><span class=\"line\">  return &#123;</span><br><span class=\"line\">    message: 'hello'</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  methods: &#123;</span><br><span class=\"line\">    inputValue () &#123;</span><br><span class=\"line\">      this.message = this.$refs.inp.value</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">// 不用到ref的更简洁的方法 @input='inputValue($event)'</span><br><span class=\"line\">    inputValue (event) &#123;</span><br><span class=\"line\">      this.message = event.target.value</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">但这样还是显得太过臃肿, 于是引入v-model</span><br></pre></td></tr></table></figure>\n\n<p>1.关于教程里标注的’在文本区域textarea插值并不会生效’, 是指的textarea如果是用花括号赋值, 当改变文本区域的内容, 不会实时变化</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;&#123;num&#125;&#125;</span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">input</span> <span class=\"attr\">v-model</span>=<span class=\"string\">'num'</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">textarea</span>&gt;</span>&#123;&#123;num&#125;&#125; asd<span class=\"tag\">&lt;/<span class=\"name\">textarea</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">textarea</span> <span class=\"attr\">v-model</span>=<span class=\"string\">'num'</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">textarea</span>&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\">假设num值是1.5</span><br><span class=\"line\">1. 当我们改变有v-model指令的input和textarea标签, 4个值都会实时改变. 看图1 我们加了'change'</span><br><span class=\"line\">2. 当我们改变直接插值的textarea以后, 发现其他三个并没有改变, 从这时候开始, 直接插值的textarea就已经不是双向绑定了. 看图2 我们又多加'111'</span><br><span class=\"line\">3. 如果不在直接插值的文本区域修改属性, 还是可以生效的; 如果修改了, 哪怕不是修改属性值, 如上例子修改的是&#123;&#123;num&#125;&#125; 后面的 asd, 也会断开联系</span><br></pre></td></tr></table></figure>\n\n<!--more-->\n<p>图1<br><img src=\"//psilocine.github.io/2018/01/15/我认为的Vue官方文档重点-1/1_textarea_1.jpg\" alt=\"图1\"><br>图2<br><img src=\"//psilocine.github.io/2018/01/15/我认为的Vue官方文档重点-1/1_textarea_2.jpg\" alt=\"图2\"></p>\n<p>2.在 iOS 中, select元素这会使用户无法选择第一个选项, 推荐像下面这样提供一个值为空的禁用选项.</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">select</span> <span class=\"attr\">v-model</span>=<span class=\"string\">\"selected\"</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">option</span> <span class=\"attr\">disabled</span> <span class=\"attr\">value</span>=<span class=\"string\">\"\"</span>&gt;</span>请选择<span class=\"tag\">&lt;/<span class=\"name\">option</span>&gt;</span> // 空值选项</span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">option</span>&gt;</span>A<span class=\"tag\">&lt;/<span class=\"name\">option</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">option</span>&gt;</span>B<span class=\"tag\">&lt;/<span class=\"name\">option</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">option</span>&gt;</span>C<span class=\"tag\">&lt;/<span class=\"name\">option</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">select</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n<p>3.对于单选按钮, 复选框和选择框的选项, v-model绑定的值通常是静态字符串</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;select v-model=<span class=\"string\">\"selected\"</span>&gt;</span><br><span class=\"line\">  &lt;option v-<span class=\"keyword\">for</span>=<span class=\"string\">\"option in options\"</span> v-bind:value=<span class=\"string\">\"option.value\"</span>&gt;</span><br><span class=\"line\">    &#123;&#123; option.text &#125;&#125;</span><br><span class=\"line\">  &lt;<span class=\"regexp\">/option&gt;</span></span><br><span class=\"line\"><span class=\"regexp\">&lt;/</span>select&gt;</span><br><span class=\"line\">&lt;span&gt;Selected: &#123;&#123; selected &#125;&#125;&lt;<span class=\"regexp\">/span&gt;</span></span><br><span class=\"line\"><span class=\"regexp\"></span></span><br><span class=\"line\"><span class=\"regexp\">new Vue(&#123;</span></span><br><span class=\"line\"><span class=\"regexp\">  el: '...',</span></span><br><span class=\"line\"><span class=\"regexp\">  data: &#123;</span></span><br><span class=\"line\"><span class=\"regexp\">    selected: 'A',</span></span><br><span class=\"line\"><span class=\"regexp\">    options: [</span></span><br><span class=\"line\"><span class=\"regexp\">      &#123; text: 'One', value: 'A' &#125;,</span></span><br><span class=\"line\"><span class=\"regexp\">      &#123; text: 'Two', value: 'B' &#125;,</span></span><br><span class=\"line\"><span class=\"regexp\">      &#123; text: 'Three', value: 'C' &#125;</span></span><br><span class=\"line\"><span class=\"regexp\">    ]</span></span><br><span class=\"line\"><span class=\"regexp\">  &#125;</span></span><br><span class=\"line\"><span class=\"regexp\">&#125;)</span></span><br><span class=\"line\"><span class=\"regexp\"></span></span><br><span class=\"line\"><span class=\"regexp\">/</span><span class=\"regexp\">/ 为什么明明没改变data里selected的值, 可是渲染出来的&#123;&#123; selected &#125;&#125;却可以随select选择变化</span></span><br><span class=\"line\"><span class=\"regexp\">原因就是上面的话, 选择的option的value会传递给v-model</span></span><br></pre></td></tr></table></figure>\n\n<p>4.输入的修饰符</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"number\">1.</span> (.lazy) v-model在change时才触发更新</span><br><span class=\"line\"><span class=\"number\">2.</span> (.number) 输入的必须是数值类型, 如果不是, 在输入框blur时自动将非数值剔除. 如果已经有值, 那第一个字符应该就为数值, 不然无效</span><br><span class=\"line\"><span class=\"number\">3.</span> (.trim) 过滤用户输入的首位空白字符</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"组件\"><a href=\"#组件\" class=\"headerlink\" title=\"组件\"></a>组件</h3><p>1.组件注册可以全局注也可以局部注册</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 局部, 一种导入(假设为header) 一种当前作用域定义注册</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> footer = &#123;</span><br><span class=\"line\">  template: <span class=\"string\">'&lt;div&gt;i am footer&lt;/div&gt;'</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">new</span> Vue(&#123;</span><br><span class=\"line\">  ...,</span><br><span class=\"line\">  components: &#123;</span><br><span class=\"line\">    <span class=\"string\">'v-header'</span>: header <span class=\"comment\">// 导入</span></span><br><span class=\"line\">    <span class=\"string\">'v-footer'</span>: footer <span class=\"comment\">// 作用域注册 不常用</span></span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  ...</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\"><span class=\"comment\">// 全局</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> footer = &#123;</span><br><span class=\"line\">  template: <span class=\"string\">'&lt;div&gt;i am footer&lt;/div&gt;'</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// 注意 一定要在new之前注册, 否则无效</span></span><br><span class=\"line\">Vue.component(<span class=\"string\">'v-footer'</span>, &#123;</span><br><span class=\"line\">  footer</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\"><span class=\"keyword\">new</span> Vue(&#123;</span><br><span class=\"line\">  ...</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n\n<p>2.data必须是函数, 这样每个组件都能有独立的状态<br>3.一般来说只允许父组件向子组件传值(props), 称为props单向数据流, 为了防止子组件无意间改变父组件的状态</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 子组件</span></span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">default</span> &#123;</span><br><span class=\"line\">  props: [<span class=\"string\">'name'</span>, <span class=\"string\">'age'</span>] <span class=\"comment\">// 可以是数组</span></span><br><span class=\"line\">  props: &#123;               <span class=\"comment\">// 可以是对象</span></span><br><span class=\"line\">    name: <span class=\"built_in\">String</span>, <span class=\"comment\">// 验证类型</span></span><br><span class=\"line\">    age: &#123;        <span class=\"comment\">// 验证类型 + 其他验证</span></span><br><span class=\"line\">      type: <span class=\"built_in\">Number</span>,</span><br><span class=\"line\">      dafault: <span class=\"number\">0</span>,</span><br><span class=\"line\">      required: <span class=\"literal\">true</span>,</span><br><span class=\"line\">      validator (val) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> val &gt;= <span class=\"number\">0</span></span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//补充 props 里的 type 支持的属性</span></span><br><span class=\"line\"><span class=\"built_in\">String</span></span><br><span class=\"line\"><span class=\"built_in\">Number</span></span><br><span class=\"line\"><span class=\"built_in\">Boolean</span></span><br><span class=\"line\"><span class=\"built_in\">Function</span></span><br><span class=\"line\"><span class=\"built_in\">Object</span></span><br><span class=\"line\"><span class=\"built_in\">Array</span></span><br><span class=\"line\"><span class=\"built_in\">Symbol</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 父组件</span></span><br><span class=\"line\">&lt;Child name=<span class=\"string\">'Psilo'</span> age=<span class=\"string\">'24'</span> /&gt; <span class=\"comment\">// 设子组件名为 &lt;Child&gt;, 传值成功</span></span><br></pre></td></tr></table></figure>\n\n<p>4.子组件向父组件怎么传值? 自定义事件. 父组件里用v-on:自定义事件名字=’父组件方法’; 子组件在监听方法名里用this.$emit(‘自定义事件名字’)</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">使用 $on(eventName) 监听事件</span><br><span class=\"line\">使用 $emit(eventName) 触发事件</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 父组件</span></span><br><span class=\"line\">&lt;div id=<span class=\"string\">\"counter-event-example\"</span>&gt;</span><br><span class=\"line\">  &lt;p&gt;&#123;&#123; total &#125;&#125;&lt;<span class=\"regexp\">/p&gt;</span></span><br><span class=\"line\"><span class=\"regexp\">  &lt;button-counter v-on:increment=\"incrementTotal\"&gt;&lt;/</span>button-counter&gt;</span><br><span class=\"line\">  &lt;button-counter v-on:increment=<span class=\"string\">\"incrementTotal\"</span>&gt;<span class=\"xml\"><span class=\"tag\">&lt;/<span class=\"name\">button-counter</span>&gt;</span></span></span><br><span class=\"line\">&lt;<span class=\"regexp\">/div&gt;</span></span><br><span class=\"line\"><span class=\"regexp\"></span></span><br><span class=\"line\"><span class=\"regexp\">new Vue(&#123;</span></span><br><span class=\"line\"><span class=\"regexp\">  el: '#counter-event-example',</span></span><br><span class=\"line\"><span class=\"regexp\">  data: &#123;</span></span><br><span class=\"line\"><span class=\"regexp\">    total: 0</span></span><br><span class=\"line\"><span class=\"regexp\">  &#125;,</span></span><br><span class=\"line\"><span class=\"regexp\">  methods: &#123;</span></span><br><span class=\"line\"><span class=\"regexp\">    incrementTotal: function () &#123;</span></span><br><span class=\"line\"><span class=\"regexp\">      this.total += 1</span></span><br><span class=\"line\"><span class=\"regexp\">    &#125;</span></span><br><span class=\"line\"><span class=\"regexp\">  &#125;</span></span><br><span class=\"line\"><span class=\"regexp\">&#125;)</span></span><br><span class=\"line\"><span class=\"regexp\"></span></span><br><span class=\"line\"><span class=\"regexp\">/</span><span class=\"regexp\">/ 子组件</span></span><br><span class=\"line\"><span class=\"regexp\">&lt;div&gt;</span></span><br><span class=\"line\"><span class=\"regexp\">  &lt;button v-on:click='incrementCounter'&gt;&#123;&#123; counter &#125;&#125;&lt;/</span>button&gt;</span><br><span class=\"line\">&lt;<span class=\"regexp\">/div&gt;</span></span><br><span class=\"line\"><span class=\"regexp\"></span></span><br><span class=\"line\"><span class=\"regexp\">export default &#123;</span></span><br><span class=\"line\"><span class=\"regexp\">  data: function () &#123;</span></span><br><span class=\"line\"><span class=\"regexp\">    return &#123;</span></span><br><span class=\"line\"><span class=\"regexp\">      counter: 0</span></span><br><span class=\"line\"><span class=\"regexp\">    &#125;</span></span><br><span class=\"line\"><span class=\"regexp\">  &#125;,</span></span><br><span class=\"line\"><span class=\"regexp\">  methods: &#123;</span></span><br><span class=\"line\"><span class=\"regexp\">    incrementCounter: function () &#123;</span></span><br><span class=\"line\"><span class=\"regexp\">      this.counter += 1</span></span><br><span class=\"line\"><span class=\"regexp\">      this.$emit('increment')</span></span><br><span class=\"line\"><span class=\"regexp\">    &#125;</span></span><br><span class=\"line\"><span class=\"regexp\">  &#125;</span></span><br><span class=\"line\"><span class=\"regexp\">&#125;</span></span><br></pre></td></tr></table></figure>\n\n<p>5.非父子组件怎么通信</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 可以使用一个空的Vue实例来做媒介</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> bus = <span class=\"keyword\">new</span> Vue()</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 需要传递值的组件</span></span><br><span class=\"line\">bus.$emit(<span class=\"string\">'someMethods'</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 需要接受值的组件</span></span><br><span class=\"line\">bus.$on(<span class=\"string\">'someMethods'</span>, <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">val</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">// 监听</span></span><br><span class=\"line\">  <span class=\"comment\">// ...</span></span><br><span class=\"line\">&#125;)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 情况复杂的话需要vuex状态管理</span></span><br></pre></td></tr></table></figure>\n\n<p>6.插槽分发slot标签. 在设计组合使用的组件时, 内容分发API非常有用<br>7.动态组件</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 可以通过保留component元素, 并对其 is 特性进行动态绑定.</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> vm = <span class=\"keyword\">new</span> Vue (&#123;</span><br><span class=\"line\">  ...,</span><br><span class=\"line\">  data () &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> &#123;</span><br><span class=\"line\">      currentView: <span class=\"string\">'home'</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  components: &#123;</span><br><span class=\"line\">    home: &#123;</span><br><span class=\"line\">      template: <span class=\"string\">'&lt;div&gt;home&lt;/div&gt;'</span></span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    posts: &#123; ... &#125;,</span><br><span class=\"line\">    archive: &#123; ... &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\"></span><br><span class=\"line\">&lt;component v-bind:is=<span class=\"string\">'currentView'</span>&gt;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 也可以直接绑定到组件</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> Home = &#123;</span><br><span class=\"line\">  template: <span class=\"string\">'&lt;div&gt;home&lt;/div&gt;'</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> vm = <span class=\"keyword\">new</span> Vue (&#123;</span><br><span class=\"line\">  ...,</span><br><span class=\"line\">  data: &#123;</span><br><span class=\"line\">    currentView: Home</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n\n<p>8.keep-alive标签</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">keep-alive</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">...</span> /&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">keep-alive</span>&gt;</span></span><br><span class=\"line\"><span class=\"comment\">&lt;!-- 可以保留其内部的状态或者避免重新渲染 --&gt;</span></span><br></pre></td></tr></table></figure>\n\n<p>9.$refs 只在组件渲染完成后才填充, 并且它是非响应式的. 它仅仅是一个直接操作子组件的应急方案——应当避免在模板或计算属性中使用 $refs</p>\n<p>前往<a href=\"https://psilocine.github.io/2018/03/03/%E6%88%91%E8%AE%A4%E4%B8%BA%E7%9A%84Vue%E5%AE%98%E6%96%B9%E6%96%87%E6%A1%A3%E9%87%8D%E7%82%B9-2/\">第二篇</a></p>"},{"title":"算法核心框架整理(1)","date":"2022-03-16T11:17:33.000Z","_content":"\n##### 写在前面\n\n如今算法已经越发成为程序员的必修功法，本文旨在归纳各经典算法。阅读本文后，相信可以对十大算法有进一步的理解。\n\n# 算法\n\n**是否稳定**：如果 a 原本在 b 前面，且 a=b，排序之后 a 仍然在 b 的前面，则为稳定算法\n\n**内排序**：所有排序操作都在内存中完成\n\n**外排序**：由于数据太大，把数据放在磁盘中，排序通过磁盘和内存的数据传输进行\n\n<!-- more -->\n\n**时间复杂度**：算法执行所耗费的时间\n\n**空间复杂度**：运行完一个程序所需内存的大小\n\n**算法总结**\n\n\n![summary](summary.png)\n\n上图名词解释：n 数据规模；k “桶”的个数；In-place 占用常数内存，不占用额外内存；Out-place 占用额外内存\n\n**分类**\n\n![type](type.png)\n\n### 冒泡排序（Bubble Sort）\n\n通过两层循环重复遍历数据，一次比较两个相邻元素，如果排序错误就交换。该算法的名字由来是因为越小的元素会经由交换慢慢“浮”到数据的顶端\n\n**实现（升序）**\n\n1. 比较相邻的元素，如果第一个比第二个大，交换位置\n2. 对每一对相邻元素作相同的工作，从开始第一对到结尾的最后一对，这样在最后的元素就是最大的数\n3. 针对所有的元素重复以上步骤，除了最后一个\n4. 重复步骤 1 ～ 3\n\n**稳定性**\n\n即使两个元素相等也不会交换，前后顺序没有改变，所以冒泡排序是稳定排序算法\n\n![bubble_1](bubble_1.png)\n\n![bubble_2](bubble_2.png)\n\n![bubble_3](bubble_3.png)\n\n**时间复杂度分析**\n\n- 最佳情况：T(n) = O(n)\n- 最差情况：T(n) = O(n²)\n- 平均情况：T(n) = O(n²)\n\n### 选择排序\n\n首先在未排序的数据中找到最小（大）元素，存放到数据的起始位置，然后再从剩余未排序元素中继续寻找最小（大）元素，放到已排序数据的末尾，以此类推\n\n**实现（升序）**\n\n1. 初始状态：无序区为 R[1..n]，有序区为空\n2. 第 i 趟排序（i=1,2,3...n-1）开始时，当前有序区和无序区分别为 R[1..i-1] 和 R[i..n]，该趟排序从当前无序区中选出最小的数据 R[k]，将它与无序区的第 1 个数据 R 交换，使 R[1..i] 和 R[i+1..n] 分别为记录个数增加 1 个 的新有序区和记录个数减少 1 个的新无序区\n3. n - 1 趟结束，数据有序化\n\n**稳定性**\n\n举个例子：序列 [5, 8, 5, 2, 9]，第一遍选择第一个元素 5 和第四个元素 2 交换，那么原序列中 2 个 5 的相对顺序就被破坏了，所以选择排序不是稳定排序算法\n\n![selection_1](selection_1.png)\n\n**时间复杂度分析**\n\n- 最佳情况：T(n) = O(n²)\n- 最差情况：T(n) = O(n²)\n- 平均情况：T(n) = O(n²)\n\n### 插入排序\n\n通过构建有序序列，对于未排序数据，在已排序序列中从后向前扫面，找到相应位置并插入。在实现上通常采用 In-place 排序。\n\n**实现**\n\n1. 从第一个元素开始，该元素认为已经被排序\n2. 取出下一个元素，在已经排序的元素序列中从后向前扫描\n3. 如果该元素（已排序）大于新元素，将该元素移到下一位置\n4. 重复步骤 3，直到找到已排序的元素小于或者等于新元素的位置\n5. 将新元素插入到该位置后\n6. 重复步骤 2 ～ 5\n\n**稳定性**\n\n插入排序是在一个已经有序的小序列上，从末尾每次插入一个元素，所以插入排序是稳定排序算法\n\n![insertion_1](insertion_1.png)\n\n**时间复杂度分析**\n\n- 最佳情况：T(n) = O(n)\n- 最坏情况：T(n) = O(n²)\n- 平均情况：T(n) = O(n²)\n\n### 希尔排序\n\n间隔序列的设定。既可以提前设定好间隔序列，也可以动态的定义间隔序列。希尔排序又叫缩小增量排序\n\n**实现**\n\n1. 选择一个增量序列 t1, t2, ..., tk，其中 ti > tj, tk = 1\n2. 按增量序列个数 k, 对序列进行 k 趟 排序\n3. 每趟排序，根据对应的增量 ti，将待排序列分割成若干长度为 m 的子序列，分别对各子表\n\n**稳定性**\n\n举个例子，序列 [1, 2, 2, 1]，排序完为 [1, 1, 2, 2]，两个 2 的相对顺序被破坏，所以希尔排序是不稳定的排序算法\n\n![shell_1](shell_1.png)\n\n**时间复杂度分析**\n\n- 最佳情况：T(n) = $O(nlog^2n)$\n- 最坏情况：T(n) = $O(nlog^2n)$)\n- 平均情况：T(n) = $O(nlogn)$\n\n### 归并排序\n\n是建立在归并操作上的一种有效的排序算法。该算法采用分治法，利用空间来换时间。它是稳定的排序方法。将已有序的子序列合并，得到完全有序的序列。若将两个有序表合并成一个有序表，成为 2-路归并。归并排序非常适合链表排序\n\n**实现**\n\n1. 将长度为 n 的输入序列分为两个长度为 n/2 的子序列\n2. 将两个子序列分别采用归并排序\n3. 将两个排序好的子序列合并成一个最终的排序序列\n\n**稳定性**\n\n归并排序是吧序列递归地分成短序列，没有涉及到元素相等的交换，所以是稳定的排序\n\n![merge_1](merge_1.png)\n\n**时间复杂度分析**\n\n- 最佳情况：T(n) = O(n)\n- 最差情况：T(n) = $O(nlogn)$\n- 平均情况：T(n) = $O(nlogn)$\n\n### 快速排序\n\n分而治之的思想，通过一趟排序将待排记录分割成独立的两部分，其中一部分记录的关键字均比另一部分的关键字小，则可分别对两部分记录继续进行排序，以打到整个序列有序\n\n**实现**\n\n1. 将数列中挑出一个元素，成为“基准”（pivot）\n2. 重新排序序列，所有元素比基准值小的摆放在基准前面，大的摆放在基准后面。在这个分区退出之后，该基准就处于数列的中间位置。成为分区（partition）操作\n3. 递归地（recursive）把小于基准值元素的子数列和大于基准值元素的子数列排序\n\n**稳定性**\n\n不考虑额外空间：基准与双指针 i, j 进行双向遍历，举个例子 [5 3 3 4 3 8 9 10 11]，基准 5 会与第五个元素 3 交换，破坏了 3 的相对顺序，所以是不稳定排序\n\n考虑额外空间：如下图代码所示，是稳定排序\n\n![quick_1](quick_1.png)\n\n**空间负责度分析**\n\n- 最佳情况：T(n) = O(nlogn)\n- 最差情况：T(n) = $O(n^2)$\n- 平均情况：T(n) = O(nlogn)\n\n### 堆排序\n\n利用堆数据结构的一种排序算法。堆积是一个近似完全二叉树的结构，并同事满足堆积的性质：即父节点的键值或索引总是大于（小于）它的左右子节点，称为大顶堆（小顶堆）\n\n**实现**\n\n1. 将初始待排序关键字序列（R1, R2...Rn）构成大顶堆，此堆为初始的无序区\n2. 将顶堆元素 R[1] 与最后一个元素 R[n] 交换，此时得到新的无序区（R1, R2, ...R(n-1)）和新的有序区（Rn），且满足 R[1, 2, ...n-1] ≤ R[n]\n3. 由于交换后新的堆顶 R[1] 可以违反堆的性质，因此需要对当前无序区（R1, R2, ...R(n-1)）调整为新堆，然后再次将 R[1] 与无序区最后一个元素交换，得到新的无序区（R1, R2, ...R(n-2)）和新的有序区（R(n-1), Rn）。不断重复此过程直到有序区的元素个数为 n-1，则整个排序过程完成\n\n**稳定性**\n\n涉及到没有额外空间的位置交换，就是不稳定排序\n\n![heap_1](heap_1.png)\n\n**时间复杂度分析**\n\n- 最佳情况：T(n) = O(nlogn)\n- 最差情况：T(n) = O(nlogn)\n- 平均情况：T(n) = O(nlogn)\n\n### 计数排序\n\n使用一个额外的数组 C，其中第 i 个元素是待排序数组 A 中值等于 i 的元素个数。然后根据数据 C 来将 A 中的元素排到正确的位置。它只能对整数进行排序，如果数据范围比要排序的数据大很多，则不适用\n\n**实现**\n\n1. 找出待排序的数组中最小值\n2. 统计数组中每个值为 i 的元素出现的次数，结合最小值存入数组 C 的第 i 项（存在则加 1，不存在则赋值为 1）\n3. 反向填充目标数组：将每个元素 i 放在新数组的第 C(i) 项，每放一个元素就将 C(i) 减去 1\n\n**稳定性**\n\n按顺序 push 进各自统计数组，所以是稳定排序算法\n\n![counting_1](counting_1.png)\n\n**时间复杂度分析**\n\n- 最佳情况：T(n) = O(n+k)\n- 最差情况：T(n) = O(n+k)\n- 平均情况：T(n) = O(n+k)\n\n### 桶排序（Bucket sort）\n\n是计数排序的升级版。假设输入数据服从均匀分布，将数据分到有限数量的桶里，每个桶再分别排序（有可能再使用别的排序算法或是以递归方式继续使用桶排序）\n\n**实现**\n\n1. 设置一个定量的数组当作空桶\n2. 遍历输入数据，并且把数据一个一个放到对应的桶里\n3. 对每个不是空的桶进行排序\n4. 从不是空的桶里把排序好的数据拼接起来\n\n**稳定型**\n\n按顺序 push 进各自桶数组，无涉及位置交换，所以是稳定的排序算法\n\n![bucket_1](bucket_1.png)\n\n**时间复杂度分析**\n\n- 最佳情况：T(n) = O(n+k)\n- 最差情况：T(n) = $O(n^2)$\n- 平均情况：T(n) = O(n+k)\n\n### 基数排序（Radix Sort）（也称鸽巢排序）\n\n是非比较的排序算法。每个数值都要大于等于 0，数据范围建议小于 1000。基数排序是按照低位先排序，收集；再按照高位排序，收集；以此类推，直到最高位。基于分别排序，分别收集，所以是稳定的。（LSD：从低位开始排序；MSD：从高位开始排序）\n\n**实现**\n\n1. 取得数组中的最大数，并取得位数\n2. arr 为原始数组，从最低位开始取每个位组成 radix 数组\n3. 对 radix 进行计数排序（利用计数排序适合于小范围数的特点）\n\n**稳定性**\n\n没有设计位置交换，是稳定排序算法\n\n![radix_1](radix_1.png)\n\n**时间复杂度分析**\n\n- 最佳情况：T(n) = O(n \\* k)\n- 最差情况：T(n) = O(n \\* k)\n- 平均情况：T(n) = O(n \\* k)\n\n### **基数排序 vs 计数排序 vs 桶排序**\n\n这三种排序算法都利用了桶的概念，但对桶的使用方法上有明显差异：\n\n1. 基数排序：根据键值的每位数字来分配桶\n2. 计数排序：每个桶只存储单一键值\n3. 桶排序：每个桶存储一定范围的数值\n","source":"_posts/算法核心框架整理-1.md","raw":"---\ntitle: 算法核心框架整理(1)\ndate: 2022-03-16 19:17:33\ntags: [算法]\n---\n\n##### 写在前面\n\n如今算法已经越发成为程序员的必修功法，本文旨在归纳各经典算法。阅读本文后，相信可以对十大算法有进一步的理解。\n\n# 算法\n\n**是否稳定**：如果 a 原本在 b 前面，且 a=b，排序之后 a 仍然在 b 的前面，则为稳定算法\n\n**内排序**：所有排序操作都在内存中完成\n\n**外排序**：由于数据太大，把数据放在磁盘中，排序通过磁盘和内存的数据传输进行\n\n<!-- more -->\n\n**时间复杂度**：算法执行所耗费的时间\n\n**空间复杂度**：运行完一个程序所需内存的大小\n\n**算法总结**\n\n\n![summary](summary.png)\n\n上图名词解释：n 数据规模；k “桶”的个数；In-place 占用常数内存，不占用额外内存；Out-place 占用额外内存\n\n**分类**\n\n![type](type.png)\n\n### 冒泡排序（Bubble Sort）\n\n通过两层循环重复遍历数据，一次比较两个相邻元素，如果排序错误就交换。该算法的名字由来是因为越小的元素会经由交换慢慢“浮”到数据的顶端\n\n**实现（升序）**\n\n1. 比较相邻的元素，如果第一个比第二个大，交换位置\n2. 对每一对相邻元素作相同的工作，从开始第一对到结尾的最后一对，这样在最后的元素就是最大的数\n3. 针对所有的元素重复以上步骤，除了最后一个\n4. 重复步骤 1 ～ 3\n\n**稳定性**\n\n即使两个元素相等也不会交换，前后顺序没有改变，所以冒泡排序是稳定排序算法\n\n![bubble_1](bubble_1.png)\n\n![bubble_2](bubble_2.png)\n\n![bubble_3](bubble_3.png)\n\n**时间复杂度分析**\n\n- 最佳情况：T(n) = O(n)\n- 最差情况：T(n) = O(n²)\n- 平均情况：T(n) = O(n²)\n\n### 选择排序\n\n首先在未排序的数据中找到最小（大）元素，存放到数据的起始位置，然后再从剩余未排序元素中继续寻找最小（大）元素，放到已排序数据的末尾，以此类推\n\n**实现（升序）**\n\n1. 初始状态：无序区为 R[1..n]，有序区为空\n2. 第 i 趟排序（i=1,2,3...n-1）开始时，当前有序区和无序区分别为 R[1..i-1] 和 R[i..n]，该趟排序从当前无序区中选出最小的数据 R[k]，将它与无序区的第 1 个数据 R 交换，使 R[1..i] 和 R[i+1..n] 分别为记录个数增加 1 个 的新有序区和记录个数减少 1 个的新无序区\n3. n - 1 趟结束，数据有序化\n\n**稳定性**\n\n举个例子：序列 [5, 8, 5, 2, 9]，第一遍选择第一个元素 5 和第四个元素 2 交换，那么原序列中 2 个 5 的相对顺序就被破坏了，所以选择排序不是稳定排序算法\n\n![selection_1](selection_1.png)\n\n**时间复杂度分析**\n\n- 最佳情况：T(n) = O(n²)\n- 最差情况：T(n) = O(n²)\n- 平均情况：T(n) = O(n²)\n\n### 插入排序\n\n通过构建有序序列，对于未排序数据，在已排序序列中从后向前扫面，找到相应位置并插入。在实现上通常采用 In-place 排序。\n\n**实现**\n\n1. 从第一个元素开始，该元素认为已经被排序\n2. 取出下一个元素，在已经排序的元素序列中从后向前扫描\n3. 如果该元素（已排序）大于新元素，将该元素移到下一位置\n4. 重复步骤 3，直到找到已排序的元素小于或者等于新元素的位置\n5. 将新元素插入到该位置后\n6. 重复步骤 2 ～ 5\n\n**稳定性**\n\n插入排序是在一个已经有序的小序列上，从末尾每次插入一个元素，所以插入排序是稳定排序算法\n\n![insertion_1](insertion_1.png)\n\n**时间复杂度分析**\n\n- 最佳情况：T(n) = O(n)\n- 最坏情况：T(n) = O(n²)\n- 平均情况：T(n) = O(n²)\n\n### 希尔排序\n\n间隔序列的设定。既可以提前设定好间隔序列，也可以动态的定义间隔序列。希尔排序又叫缩小增量排序\n\n**实现**\n\n1. 选择一个增量序列 t1, t2, ..., tk，其中 ti > tj, tk = 1\n2. 按增量序列个数 k, 对序列进行 k 趟 排序\n3. 每趟排序，根据对应的增量 ti，将待排序列分割成若干长度为 m 的子序列，分别对各子表\n\n**稳定性**\n\n举个例子，序列 [1, 2, 2, 1]，排序完为 [1, 1, 2, 2]，两个 2 的相对顺序被破坏，所以希尔排序是不稳定的排序算法\n\n![shell_1](shell_1.png)\n\n**时间复杂度分析**\n\n- 最佳情况：T(n) = $O(nlog^2n)$\n- 最坏情况：T(n) = $O(nlog^2n)$)\n- 平均情况：T(n) = $O(nlogn)$\n\n### 归并排序\n\n是建立在归并操作上的一种有效的排序算法。该算法采用分治法，利用空间来换时间。它是稳定的排序方法。将已有序的子序列合并，得到完全有序的序列。若将两个有序表合并成一个有序表，成为 2-路归并。归并排序非常适合链表排序\n\n**实现**\n\n1. 将长度为 n 的输入序列分为两个长度为 n/2 的子序列\n2. 将两个子序列分别采用归并排序\n3. 将两个排序好的子序列合并成一个最终的排序序列\n\n**稳定性**\n\n归并排序是吧序列递归地分成短序列，没有涉及到元素相等的交换，所以是稳定的排序\n\n![merge_1](merge_1.png)\n\n**时间复杂度分析**\n\n- 最佳情况：T(n) = O(n)\n- 最差情况：T(n) = $O(nlogn)$\n- 平均情况：T(n) = $O(nlogn)$\n\n### 快速排序\n\n分而治之的思想，通过一趟排序将待排记录分割成独立的两部分，其中一部分记录的关键字均比另一部分的关键字小，则可分别对两部分记录继续进行排序，以打到整个序列有序\n\n**实现**\n\n1. 将数列中挑出一个元素，成为“基准”（pivot）\n2. 重新排序序列，所有元素比基准值小的摆放在基准前面，大的摆放在基准后面。在这个分区退出之后，该基准就处于数列的中间位置。成为分区（partition）操作\n3. 递归地（recursive）把小于基准值元素的子数列和大于基准值元素的子数列排序\n\n**稳定性**\n\n不考虑额外空间：基准与双指针 i, j 进行双向遍历，举个例子 [5 3 3 4 3 8 9 10 11]，基准 5 会与第五个元素 3 交换，破坏了 3 的相对顺序，所以是不稳定排序\n\n考虑额外空间：如下图代码所示，是稳定排序\n\n![quick_1](quick_1.png)\n\n**空间负责度分析**\n\n- 最佳情况：T(n) = O(nlogn)\n- 最差情况：T(n) = $O(n^2)$\n- 平均情况：T(n) = O(nlogn)\n\n### 堆排序\n\n利用堆数据结构的一种排序算法。堆积是一个近似完全二叉树的结构，并同事满足堆积的性质：即父节点的键值或索引总是大于（小于）它的左右子节点，称为大顶堆（小顶堆）\n\n**实现**\n\n1. 将初始待排序关键字序列（R1, R2...Rn）构成大顶堆，此堆为初始的无序区\n2. 将顶堆元素 R[1] 与最后一个元素 R[n] 交换，此时得到新的无序区（R1, R2, ...R(n-1)）和新的有序区（Rn），且满足 R[1, 2, ...n-1] ≤ R[n]\n3. 由于交换后新的堆顶 R[1] 可以违反堆的性质，因此需要对当前无序区（R1, R2, ...R(n-1)）调整为新堆，然后再次将 R[1] 与无序区最后一个元素交换，得到新的无序区（R1, R2, ...R(n-2)）和新的有序区（R(n-1), Rn）。不断重复此过程直到有序区的元素个数为 n-1，则整个排序过程完成\n\n**稳定性**\n\n涉及到没有额外空间的位置交换，就是不稳定排序\n\n![heap_1](heap_1.png)\n\n**时间复杂度分析**\n\n- 最佳情况：T(n) = O(nlogn)\n- 最差情况：T(n) = O(nlogn)\n- 平均情况：T(n) = O(nlogn)\n\n### 计数排序\n\n使用一个额外的数组 C，其中第 i 个元素是待排序数组 A 中值等于 i 的元素个数。然后根据数据 C 来将 A 中的元素排到正确的位置。它只能对整数进行排序，如果数据范围比要排序的数据大很多，则不适用\n\n**实现**\n\n1. 找出待排序的数组中最小值\n2. 统计数组中每个值为 i 的元素出现的次数，结合最小值存入数组 C 的第 i 项（存在则加 1，不存在则赋值为 1）\n3. 反向填充目标数组：将每个元素 i 放在新数组的第 C(i) 项，每放一个元素就将 C(i) 减去 1\n\n**稳定性**\n\n按顺序 push 进各自统计数组，所以是稳定排序算法\n\n![counting_1](counting_1.png)\n\n**时间复杂度分析**\n\n- 最佳情况：T(n) = O(n+k)\n- 最差情况：T(n) = O(n+k)\n- 平均情况：T(n) = O(n+k)\n\n### 桶排序（Bucket sort）\n\n是计数排序的升级版。假设输入数据服从均匀分布，将数据分到有限数量的桶里，每个桶再分别排序（有可能再使用别的排序算法或是以递归方式继续使用桶排序）\n\n**实现**\n\n1. 设置一个定量的数组当作空桶\n2. 遍历输入数据，并且把数据一个一个放到对应的桶里\n3. 对每个不是空的桶进行排序\n4. 从不是空的桶里把排序好的数据拼接起来\n\n**稳定型**\n\n按顺序 push 进各自桶数组，无涉及位置交换，所以是稳定的排序算法\n\n![bucket_1](bucket_1.png)\n\n**时间复杂度分析**\n\n- 最佳情况：T(n) = O(n+k)\n- 最差情况：T(n) = $O(n^2)$\n- 平均情况：T(n) = O(n+k)\n\n### 基数排序（Radix Sort）（也称鸽巢排序）\n\n是非比较的排序算法。每个数值都要大于等于 0，数据范围建议小于 1000。基数排序是按照低位先排序，收集；再按照高位排序，收集；以此类推，直到最高位。基于分别排序，分别收集，所以是稳定的。（LSD：从低位开始排序；MSD：从高位开始排序）\n\n**实现**\n\n1. 取得数组中的最大数，并取得位数\n2. arr 为原始数组，从最低位开始取每个位组成 radix 数组\n3. 对 radix 进行计数排序（利用计数排序适合于小范围数的特点）\n\n**稳定性**\n\n没有设计位置交换，是稳定排序算法\n\n![radix_1](radix_1.png)\n\n**时间复杂度分析**\n\n- 最佳情况：T(n) = O(n \\* k)\n- 最差情况：T(n) = O(n \\* k)\n- 平均情况：T(n) = O(n \\* k)\n\n### **基数排序 vs 计数排序 vs 桶排序**\n\n这三种排序算法都利用了桶的概念，但对桶的使用方法上有明显差异：\n\n1. 基数排序：根据键值的每位数字来分配桶\n2. 计数排序：每个桶只存储单一键值\n3. 桶排序：每个桶存储一定范围的数值\n","slug":"算法核心框架整理-1","published":1,"updated":"2022-06-01T02:17:48.103Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl5sb8gg90033xq0ra9m0qbt6","content":"<h5 id=\"写在前面\"><a href=\"#写在前面\" class=\"headerlink\" title=\"写在前面\"></a>写在前面</h5><p>如今算法已经越发成为程序员的必修功法，本文旨在归纳各经典算法。阅读本文后，相信可以对十大算法有进一步的理解。</p>\n<h1 id=\"算法\"><a href=\"#算法\" class=\"headerlink\" title=\"算法\"></a>算法</h1><p><strong>是否稳定</strong>：如果 a 原本在 b 前面，且 a=b，排序之后 a 仍然在 b 的前面，则为稳定算法</p>\n<p><strong>内排序</strong>：所有排序操作都在内存中完成</p>\n<p><strong>外排序</strong>：由于数据太大，把数据放在磁盘中，排序通过磁盘和内存的数据传输进行</p>\n<a id=\"more\"></a>\n\n<p><strong>时间复杂度</strong>：算法执行所耗费的时间</p>\n<p><strong>空间复杂度</strong>：运行完一个程序所需内存的大小</p>\n<p><strong>算法总结</strong></p>\n<p><img src=\"//psilocine.github.io/2022/03/16/算法核心框架整理-1/summary.png\" alt=\"summary\"></p>\n<p>上图名词解释：n 数据规模；k “桶”的个数；In-place 占用常数内存，不占用额外内存；Out-place 占用额外内存</p>\n<p><strong>分类</strong></p>\n<p><img src=\"//psilocine.github.io/2022/03/16/算法核心框架整理-1/type.png\" alt=\"type\"></p>\n<h3 id=\"冒泡排序（Bubble-Sort）\"><a href=\"#冒泡排序（Bubble-Sort）\" class=\"headerlink\" title=\"冒泡排序（Bubble Sort）\"></a>冒泡排序（Bubble Sort）</h3><p>通过两层循环重复遍历数据，一次比较两个相邻元素，如果排序错误就交换。该算法的名字由来是因为越小的元素会经由交换慢慢“浮”到数据的顶端</p>\n<p><strong>实现（升序）</strong></p>\n<ol>\n<li>比较相邻的元素，如果第一个比第二个大，交换位置</li>\n<li>对每一对相邻元素作相同的工作，从开始第一对到结尾的最后一对，这样在最后的元素就是最大的数</li>\n<li>针对所有的元素重复以上步骤，除了最后一个</li>\n<li>重复步骤 1 ～ 3</li>\n</ol>\n<p><strong>稳定性</strong></p>\n<p>即使两个元素相等也不会交换，前后顺序没有改变，所以冒泡排序是稳定排序算法</p>\n<p><img src=\"//psilocine.github.io/2022/03/16/算法核心框架整理-1/bubble_1.png\" alt=\"bubble_1\"></p>\n<p><img src=\"//psilocine.github.io/2022/03/16/算法核心框架整理-1/bubble_2.png\" alt=\"bubble_2\"></p>\n<p><img src=\"//psilocine.github.io/2022/03/16/算法核心框架整理-1/bubble_3.png\" alt=\"bubble_3\"></p>\n<p><strong>时间复杂度分析</strong></p>\n<ul>\n<li>最佳情况：T(n) = O(n)</li>\n<li>最差情况：T(n) = O(n²)</li>\n<li>平均情况：T(n) = O(n²)</li>\n</ul>\n<h3 id=\"选择排序\"><a href=\"#选择排序\" class=\"headerlink\" title=\"选择排序\"></a>选择排序</h3><p>首先在未排序的数据中找到最小（大）元素，存放到数据的起始位置，然后再从剩余未排序元素中继续寻找最小（大）元素，放到已排序数据的末尾，以此类推</p>\n<p><strong>实现（升序）</strong></p>\n<ol>\n<li>初始状态：无序区为 R[1..n]，有序区为空</li>\n<li>第 i 趟排序（i=1,2,3…n-1）开始时，当前有序区和无序区分别为 R[1..i-1] 和 R[i..n]，该趟排序从当前无序区中选出最小的数据 R[k]，将它与无序区的第 1 个数据 R 交换，使 R[1..i] 和 R[i+1..n] 分别为记录个数增加 1 个 的新有序区和记录个数减少 1 个的新无序区</li>\n<li>n - 1 趟结束，数据有序化</li>\n</ol>\n<p><strong>稳定性</strong></p>\n<p>举个例子：序列 [5, 8, 5, 2, 9]，第一遍选择第一个元素 5 和第四个元素 2 交换，那么原序列中 2 个 5 的相对顺序就被破坏了，所以选择排序不是稳定排序算法</p>\n<p><img src=\"//psilocine.github.io/2022/03/16/算法核心框架整理-1/selection_1.png\" alt=\"selection_1\"></p>\n<p><strong>时间复杂度分析</strong></p>\n<ul>\n<li>最佳情况：T(n) = O(n²)</li>\n<li>最差情况：T(n) = O(n²)</li>\n<li>平均情况：T(n) = O(n²)</li>\n</ul>\n<h3 id=\"插入排序\"><a href=\"#插入排序\" class=\"headerlink\" title=\"插入排序\"></a>插入排序</h3><p>通过构建有序序列，对于未排序数据，在已排序序列中从后向前扫面，找到相应位置并插入。在实现上通常采用 In-place 排序。</p>\n<p><strong>实现</strong></p>\n<ol>\n<li>从第一个元素开始，该元素认为已经被排序</li>\n<li>取出下一个元素，在已经排序的元素序列中从后向前扫描</li>\n<li>如果该元素（已排序）大于新元素，将该元素移到下一位置</li>\n<li>重复步骤 3，直到找到已排序的元素小于或者等于新元素的位置</li>\n<li>将新元素插入到该位置后</li>\n<li>重复步骤 2 ～ 5</li>\n</ol>\n<p><strong>稳定性</strong></p>\n<p>插入排序是在一个已经有序的小序列上，从末尾每次插入一个元素，所以插入排序是稳定排序算法</p>\n<p><img src=\"//psilocine.github.io/2022/03/16/算法核心框架整理-1/insertion_1.png\" alt=\"insertion_1\"></p>\n<p><strong>时间复杂度分析</strong></p>\n<ul>\n<li>最佳情况：T(n) = O(n)</li>\n<li>最坏情况：T(n) = O(n²)</li>\n<li>平均情况：T(n) = O(n²)</li>\n</ul>\n<h3 id=\"希尔排序\"><a href=\"#希尔排序\" class=\"headerlink\" title=\"希尔排序\"></a>希尔排序</h3><p>间隔序列的设定。既可以提前设定好间隔序列，也可以动态的定义间隔序列。希尔排序又叫缩小增量排序</p>\n<p><strong>实现</strong></p>\n<ol>\n<li>选择一个增量序列 t1, t2, …, tk，其中 ti &gt; tj, tk = 1</li>\n<li>按增量序列个数 k, 对序列进行 k 趟 排序</li>\n<li>每趟排序，根据对应的增量 ti，将待排序列分割成若干长度为 m 的子序列，分别对各子表</li>\n</ol>\n<p><strong>稳定性</strong></p>\n<p>举个例子，序列 [1, 2, 2, 1]，排序完为 [1, 1, 2, 2]，两个 2 的相对顺序被破坏，所以希尔排序是不稳定的排序算法</p>\n<p><img src=\"//psilocine.github.io/2022/03/16/算法核心框架整理-1/shell_1.png\" alt=\"shell_1\"></p>\n<p><strong>时间复杂度分析</strong></p>\n<ul>\n<li>最佳情况：T(n) = $O(nlog^2n)$</li>\n<li>最坏情况：T(n) = $O(nlog^2n)$)</li>\n<li>平均情况：T(n) = $O(nlogn)$</li>\n</ul>\n<h3 id=\"归并排序\"><a href=\"#归并排序\" class=\"headerlink\" title=\"归并排序\"></a>归并排序</h3><p>是建立在归并操作上的一种有效的排序算法。该算法采用分治法，利用空间来换时间。它是稳定的排序方法。将已有序的子序列合并，得到完全有序的序列。若将两个有序表合并成一个有序表，成为 2-路归并。归并排序非常适合链表排序</p>\n<p><strong>实现</strong></p>\n<ol>\n<li>将长度为 n 的输入序列分为两个长度为 n/2 的子序列</li>\n<li>将两个子序列分别采用归并排序</li>\n<li>将两个排序好的子序列合并成一个最终的排序序列</li>\n</ol>\n<p><strong>稳定性</strong></p>\n<p>归并排序是吧序列递归地分成短序列，没有涉及到元素相等的交换，所以是稳定的排序</p>\n<p><img src=\"//psilocine.github.io/2022/03/16/算法核心框架整理-1/merge_1.png\" alt=\"merge_1\"></p>\n<p><strong>时间复杂度分析</strong></p>\n<ul>\n<li>最佳情况：T(n) = O(n)</li>\n<li>最差情况：T(n) = $O(nlogn)$</li>\n<li>平均情况：T(n) = $O(nlogn)$</li>\n</ul>\n<h3 id=\"快速排序\"><a href=\"#快速排序\" class=\"headerlink\" title=\"快速排序\"></a>快速排序</h3><p>分而治之的思想，通过一趟排序将待排记录分割成独立的两部分，其中一部分记录的关键字均比另一部分的关键字小，则可分别对两部分记录继续进行排序，以打到整个序列有序</p>\n<p><strong>实现</strong></p>\n<ol>\n<li>将数列中挑出一个元素，成为“基准”（pivot）</li>\n<li>重新排序序列，所有元素比基准值小的摆放在基准前面，大的摆放在基准后面。在这个分区退出之后，该基准就处于数列的中间位置。成为分区（partition）操作</li>\n<li>递归地（recursive）把小于基准值元素的子数列和大于基准值元素的子数列排序</li>\n</ol>\n<p><strong>稳定性</strong></p>\n<p>不考虑额外空间：基准与双指针 i, j 进行双向遍历，举个例子 [5 3 3 4 3 8 9 10 11]，基准 5 会与第五个元素 3 交换，破坏了 3 的相对顺序，所以是不稳定排序</p>\n<p>考虑额外空间：如下图代码所示，是稳定排序</p>\n<p><img src=\"//psilocine.github.io/2022/03/16/算法核心框架整理-1/quick_1.png\" alt=\"quick_1\"></p>\n<p><strong>空间负责度分析</strong></p>\n<ul>\n<li>最佳情况：T(n) = O(nlogn)</li>\n<li>最差情况：T(n) = $O(n^2)$</li>\n<li>平均情况：T(n) = O(nlogn)</li>\n</ul>\n<h3 id=\"堆排序\"><a href=\"#堆排序\" class=\"headerlink\" title=\"堆排序\"></a>堆排序</h3><p>利用堆数据结构的一种排序算法。堆积是一个近似完全二叉树的结构，并同事满足堆积的性质：即父节点的键值或索引总是大于（小于）它的左右子节点，称为大顶堆（小顶堆）</p>\n<p><strong>实现</strong></p>\n<ol>\n<li>将初始待排序关键字序列（R1, R2…Rn）构成大顶堆，此堆为初始的无序区</li>\n<li>将顶堆元素 R[1] 与最后一个元素 R[n] 交换，此时得到新的无序区（R1, R2, …R(n-1)）和新的有序区（Rn），且满足 R[1, 2, …n-1] ≤ R[n]</li>\n<li>由于交换后新的堆顶 R[1] 可以违反堆的性质，因此需要对当前无序区（R1, R2, …R(n-1)）调整为新堆，然后再次将 R[1] 与无序区最后一个元素交换，得到新的无序区（R1, R2, …R(n-2)）和新的有序区（R(n-1), Rn）。不断重复此过程直到有序区的元素个数为 n-1，则整个排序过程完成</li>\n</ol>\n<p><strong>稳定性</strong></p>\n<p>涉及到没有额外空间的位置交换，就是不稳定排序</p>\n<p><img src=\"//psilocine.github.io/2022/03/16/算法核心框架整理-1/heap_1.png\" alt=\"heap_1\"></p>\n<p><strong>时间复杂度分析</strong></p>\n<ul>\n<li>最佳情况：T(n) = O(nlogn)</li>\n<li>最差情况：T(n) = O(nlogn)</li>\n<li>平均情况：T(n) = O(nlogn)</li>\n</ul>\n<h3 id=\"计数排序\"><a href=\"#计数排序\" class=\"headerlink\" title=\"计数排序\"></a>计数排序</h3><p>使用一个额外的数组 C，其中第 i 个元素是待排序数组 A 中值等于 i 的元素个数。然后根据数据 C 来将 A 中的元素排到正确的位置。它只能对整数进行排序，如果数据范围比要排序的数据大很多，则不适用</p>\n<p><strong>实现</strong></p>\n<ol>\n<li>找出待排序的数组中最小值</li>\n<li>统计数组中每个值为 i 的元素出现的次数，结合最小值存入数组 C 的第 i 项（存在则加 1，不存在则赋值为 1）</li>\n<li>反向填充目标数组：将每个元素 i 放在新数组的第 C(i) 项，每放一个元素就将 C(i) 减去 1</li>\n</ol>\n<p><strong>稳定性</strong></p>\n<p>按顺序 push 进各自统计数组，所以是稳定排序算法</p>\n<p><img src=\"//psilocine.github.io/2022/03/16/算法核心框架整理-1/counting_1.png\" alt=\"counting_1\"></p>\n<p><strong>时间复杂度分析</strong></p>\n<ul>\n<li>最佳情况：T(n) = O(n+k)</li>\n<li>最差情况：T(n) = O(n+k)</li>\n<li>平均情况：T(n) = O(n+k)</li>\n</ul>\n<h3 id=\"桶排序（Bucket-sort）\"><a href=\"#桶排序（Bucket-sort）\" class=\"headerlink\" title=\"桶排序（Bucket sort）\"></a>桶排序（Bucket sort）</h3><p>是计数排序的升级版。假设输入数据服从均匀分布，将数据分到有限数量的桶里，每个桶再分别排序（有可能再使用别的排序算法或是以递归方式继续使用桶排序）</p>\n<p><strong>实现</strong></p>\n<ol>\n<li>设置一个定量的数组当作空桶</li>\n<li>遍历输入数据，并且把数据一个一个放到对应的桶里</li>\n<li>对每个不是空的桶进行排序</li>\n<li>从不是空的桶里把排序好的数据拼接起来</li>\n</ol>\n<p><strong>稳定型</strong></p>\n<p>按顺序 push 进各自桶数组，无涉及位置交换，所以是稳定的排序算法</p>\n<p><img src=\"//psilocine.github.io/2022/03/16/算法核心框架整理-1/bucket_1.png\" alt=\"bucket_1\"></p>\n<p><strong>时间复杂度分析</strong></p>\n<ul>\n<li>最佳情况：T(n) = O(n+k)</li>\n<li>最差情况：T(n) = $O(n^2)$</li>\n<li>平均情况：T(n) = O(n+k)</li>\n</ul>\n<h3 id=\"基数排序（Radix-Sort）（也称鸽巢排序）\"><a href=\"#基数排序（Radix-Sort）（也称鸽巢排序）\" class=\"headerlink\" title=\"基数排序（Radix Sort）（也称鸽巢排序）\"></a>基数排序（Radix Sort）（也称鸽巢排序）</h3><p>是非比较的排序算法。每个数值都要大于等于 0，数据范围建议小于 1000。基数排序是按照低位先排序，收集；再按照高位排序，收集；以此类推，直到最高位。基于分别排序，分别收集，所以是稳定的。（LSD：从低位开始排序；MSD：从高位开始排序）</p>\n<p><strong>实现</strong></p>\n<ol>\n<li>取得数组中的最大数，并取得位数</li>\n<li>arr 为原始数组，从最低位开始取每个位组成 radix 数组</li>\n<li>对 radix 进行计数排序（利用计数排序适合于小范围数的特点）</li>\n</ol>\n<p><strong>稳定性</strong></p>\n<p>没有设计位置交换，是稳定排序算法</p>\n<p><img src=\"//psilocine.github.io/2022/03/16/算法核心框架整理-1/radix_1.png\" alt=\"radix_1\"></p>\n<p><strong>时间复杂度分析</strong></p>\n<ul>\n<li>最佳情况：T(n) = O(n * k)</li>\n<li>最差情况：T(n) = O(n * k)</li>\n<li>平均情况：T(n) = O(n * k)</li>\n</ul>\n<h3 id=\"基数排序-vs-计数排序-vs-桶排序\"><a href=\"#基数排序-vs-计数排序-vs-桶排序\" class=\"headerlink\" title=\"基数排序 vs 计数排序 vs 桶排序\"></a><strong>基数排序 vs 计数排序 vs 桶排序</strong></h3><p>这三种排序算法都利用了桶的概念，但对桶的使用方法上有明显差异：</p>\n<ol>\n<li>基数排序：根据键值的每位数字来分配桶</li>\n<li>计数排序：每个桶只存储单一键值</li>\n<li>桶排序：每个桶存储一定范围的数值</li>\n</ol>\n","site":{"data":{}},"excerpt":"<h5 id=\"写在前面\"><a href=\"#写在前面\" class=\"headerlink\" title=\"写在前面\"></a>写在前面</h5><p>如今算法已经越发成为程序员的必修功法，本文旨在归纳各经典算法。阅读本文后，相信可以对十大算法有进一步的理解。</p>\n<h1 id=\"算法\"><a href=\"#算法\" class=\"headerlink\" title=\"算法\"></a>算法</h1><p><strong>是否稳定</strong>：如果 a 原本在 b 前面，且 a=b，排序之后 a 仍然在 b 的前面，则为稳定算法</p>\n<p><strong>内排序</strong>：所有排序操作都在内存中完成</p>\n<p><strong>外排序</strong>：由于数据太大，把数据放在磁盘中，排序通过磁盘和内存的数据传输进行</p>","more":"<p><strong>时间复杂度</strong>：算法执行所耗费的时间</p>\n<p><strong>空间复杂度</strong>：运行完一个程序所需内存的大小</p>\n<p><strong>算法总结</strong></p>\n<p><img src=\"//psilocine.github.io/2022/03/16/算法核心框架整理-1/summary.png\" alt=\"summary\"></p>\n<p>上图名词解释：n 数据规模；k “桶”的个数；In-place 占用常数内存，不占用额外内存；Out-place 占用额外内存</p>\n<p><strong>分类</strong></p>\n<p><img src=\"//psilocine.github.io/2022/03/16/算法核心框架整理-1/type.png\" alt=\"type\"></p>\n<h3 id=\"冒泡排序（Bubble-Sort）\"><a href=\"#冒泡排序（Bubble-Sort）\" class=\"headerlink\" title=\"冒泡排序（Bubble Sort）\"></a>冒泡排序（Bubble Sort）</h3><p>通过两层循环重复遍历数据，一次比较两个相邻元素，如果排序错误就交换。该算法的名字由来是因为越小的元素会经由交换慢慢“浮”到数据的顶端</p>\n<p><strong>实现（升序）</strong></p>\n<ol>\n<li>比较相邻的元素，如果第一个比第二个大，交换位置</li>\n<li>对每一对相邻元素作相同的工作，从开始第一对到结尾的最后一对，这样在最后的元素就是最大的数</li>\n<li>针对所有的元素重复以上步骤，除了最后一个</li>\n<li>重复步骤 1 ～ 3</li>\n</ol>\n<p><strong>稳定性</strong></p>\n<p>即使两个元素相等也不会交换，前后顺序没有改变，所以冒泡排序是稳定排序算法</p>\n<p><img src=\"//psilocine.github.io/2022/03/16/算法核心框架整理-1/bubble_1.png\" alt=\"bubble_1\"></p>\n<p><img src=\"//psilocine.github.io/2022/03/16/算法核心框架整理-1/bubble_2.png\" alt=\"bubble_2\"></p>\n<p><img src=\"//psilocine.github.io/2022/03/16/算法核心框架整理-1/bubble_3.png\" alt=\"bubble_3\"></p>\n<p><strong>时间复杂度分析</strong></p>\n<ul>\n<li>最佳情况：T(n) = O(n)</li>\n<li>最差情况：T(n) = O(n²)</li>\n<li>平均情况：T(n) = O(n²)</li>\n</ul>\n<h3 id=\"选择排序\"><a href=\"#选择排序\" class=\"headerlink\" title=\"选择排序\"></a>选择排序</h3><p>首先在未排序的数据中找到最小（大）元素，存放到数据的起始位置，然后再从剩余未排序元素中继续寻找最小（大）元素，放到已排序数据的末尾，以此类推</p>\n<p><strong>实现（升序）</strong></p>\n<ol>\n<li>初始状态：无序区为 R[1..n]，有序区为空</li>\n<li>第 i 趟排序（i=1,2,3…n-1）开始时，当前有序区和无序区分别为 R[1..i-1] 和 R[i..n]，该趟排序从当前无序区中选出最小的数据 R[k]，将它与无序区的第 1 个数据 R 交换，使 R[1..i] 和 R[i+1..n] 分别为记录个数增加 1 个 的新有序区和记录个数减少 1 个的新无序区</li>\n<li>n - 1 趟结束，数据有序化</li>\n</ol>\n<p><strong>稳定性</strong></p>\n<p>举个例子：序列 [5, 8, 5, 2, 9]，第一遍选择第一个元素 5 和第四个元素 2 交换，那么原序列中 2 个 5 的相对顺序就被破坏了，所以选择排序不是稳定排序算法</p>\n<p><img src=\"//psilocine.github.io/2022/03/16/算法核心框架整理-1/selection_1.png\" alt=\"selection_1\"></p>\n<p><strong>时间复杂度分析</strong></p>\n<ul>\n<li>最佳情况：T(n) = O(n²)</li>\n<li>最差情况：T(n) = O(n²)</li>\n<li>平均情况：T(n) = O(n²)</li>\n</ul>\n<h3 id=\"插入排序\"><a href=\"#插入排序\" class=\"headerlink\" title=\"插入排序\"></a>插入排序</h3><p>通过构建有序序列，对于未排序数据，在已排序序列中从后向前扫面，找到相应位置并插入。在实现上通常采用 In-place 排序。</p>\n<p><strong>实现</strong></p>\n<ol>\n<li>从第一个元素开始，该元素认为已经被排序</li>\n<li>取出下一个元素，在已经排序的元素序列中从后向前扫描</li>\n<li>如果该元素（已排序）大于新元素，将该元素移到下一位置</li>\n<li>重复步骤 3，直到找到已排序的元素小于或者等于新元素的位置</li>\n<li>将新元素插入到该位置后</li>\n<li>重复步骤 2 ～ 5</li>\n</ol>\n<p><strong>稳定性</strong></p>\n<p>插入排序是在一个已经有序的小序列上，从末尾每次插入一个元素，所以插入排序是稳定排序算法</p>\n<p><img src=\"//psilocine.github.io/2022/03/16/算法核心框架整理-1/insertion_1.png\" alt=\"insertion_1\"></p>\n<p><strong>时间复杂度分析</strong></p>\n<ul>\n<li>最佳情况：T(n) = O(n)</li>\n<li>最坏情况：T(n) = O(n²)</li>\n<li>平均情况：T(n) = O(n²)</li>\n</ul>\n<h3 id=\"希尔排序\"><a href=\"#希尔排序\" class=\"headerlink\" title=\"希尔排序\"></a>希尔排序</h3><p>间隔序列的设定。既可以提前设定好间隔序列，也可以动态的定义间隔序列。希尔排序又叫缩小增量排序</p>\n<p><strong>实现</strong></p>\n<ol>\n<li>选择一个增量序列 t1, t2, …, tk，其中 ti &gt; tj, tk = 1</li>\n<li>按增量序列个数 k, 对序列进行 k 趟 排序</li>\n<li>每趟排序，根据对应的增量 ti，将待排序列分割成若干长度为 m 的子序列，分别对各子表</li>\n</ol>\n<p><strong>稳定性</strong></p>\n<p>举个例子，序列 [1, 2, 2, 1]，排序完为 [1, 1, 2, 2]，两个 2 的相对顺序被破坏，所以希尔排序是不稳定的排序算法</p>\n<p><img src=\"//psilocine.github.io/2022/03/16/算法核心框架整理-1/shell_1.png\" alt=\"shell_1\"></p>\n<p><strong>时间复杂度分析</strong></p>\n<ul>\n<li>最佳情况：T(n) = $O(nlog^2n)$</li>\n<li>最坏情况：T(n) = $O(nlog^2n)$)</li>\n<li>平均情况：T(n) = $O(nlogn)$</li>\n</ul>\n<h3 id=\"归并排序\"><a href=\"#归并排序\" class=\"headerlink\" title=\"归并排序\"></a>归并排序</h3><p>是建立在归并操作上的一种有效的排序算法。该算法采用分治法，利用空间来换时间。它是稳定的排序方法。将已有序的子序列合并，得到完全有序的序列。若将两个有序表合并成一个有序表，成为 2-路归并。归并排序非常适合链表排序</p>\n<p><strong>实现</strong></p>\n<ol>\n<li>将长度为 n 的输入序列分为两个长度为 n/2 的子序列</li>\n<li>将两个子序列分别采用归并排序</li>\n<li>将两个排序好的子序列合并成一个最终的排序序列</li>\n</ol>\n<p><strong>稳定性</strong></p>\n<p>归并排序是吧序列递归地分成短序列，没有涉及到元素相等的交换，所以是稳定的排序</p>\n<p><img src=\"//psilocine.github.io/2022/03/16/算法核心框架整理-1/merge_1.png\" alt=\"merge_1\"></p>\n<p><strong>时间复杂度分析</strong></p>\n<ul>\n<li>最佳情况：T(n) = O(n)</li>\n<li>最差情况：T(n) = $O(nlogn)$</li>\n<li>平均情况：T(n) = $O(nlogn)$</li>\n</ul>\n<h3 id=\"快速排序\"><a href=\"#快速排序\" class=\"headerlink\" title=\"快速排序\"></a>快速排序</h3><p>分而治之的思想，通过一趟排序将待排记录分割成独立的两部分，其中一部分记录的关键字均比另一部分的关键字小，则可分别对两部分记录继续进行排序，以打到整个序列有序</p>\n<p><strong>实现</strong></p>\n<ol>\n<li>将数列中挑出一个元素，成为“基准”（pivot）</li>\n<li>重新排序序列，所有元素比基准值小的摆放在基准前面，大的摆放在基准后面。在这个分区退出之后，该基准就处于数列的中间位置。成为分区（partition）操作</li>\n<li>递归地（recursive）把小于基准值元素的子数列和大于基准值元素的子数列排序</li>\n</ol>\n<p><strong>稳定性</strong></p>\n<p>不考虑额外空间：基准与双指针 i, j 进行双向遍历，举个例子 [5 3 3 4 3 8 9 10 11]，基准 5 会与第五个元素 3 交换，破坏了 3 的相对顺序，所以是不稳定排序</p>\n<p>考虑额外空间：如下图代码所示，是稳定排序</p>\n<p><img src=\"//psilocine.github.io/2022/03/16/算法核心框架整理-1/quick_1.png\" alt=\"quick_1\"></p>\n<p><strong>空间负责度分析</strong></p>\n<ul>\n<li>最佳情况：T(n) = O(nlogn)</li>\n<li>最差情况：T(n) = $O(n^2)$</li>\n<li>平均情况：T(n) = O(nlogn)</li>\n</ul>\n<h3 id=\"堆排序\"><a href=\"#堆排序\" class=\"headerlink\" title=\"堆排序\"></a>堆排序</h3><p>利用堆数据结构的一种排序算法。堆积是一个近似完全二叉树的结构，并同事满足堆积的性质：即父节点的键值或索引总是大于（小于）它的左右子节点，称为大顶堆（小顶堆）</p>\n<p><strong>实现</strong></p>\n<ol>\n<li>将初始待排序关键字序列（R1, R2…Rn）构成大顶堆，此堆为初始的无序区</li>\n<li>将顶堆元素 R[1] 与最后一个元素 R[n] 交换，此时得到新的无序区（R1, R2, …R(n-1)）和新的有序区（Rn），且满足 R[1, 2, …n-1] ≤ R[n]</li>\n<li>由于交换后新的堆顶 R[1] 可以违反堆的性质，因此需要对当前无序区（R1, R2, …R(n-1)）调整为新堆，然后再次将 R[1] 与无序区最后一个元素交换，得到新的无序区（R1, R2, …R(n-2)）和新的有序区（R(n-1), Rn）。不断重复此过程直到有序区的元素个数为 n-1，则整个排序过程完成</li>\n</ol>\n<p><strong>稳定性</strong></p>\n<p>涉及到没有额外空间的位置交换，就是不稳定排序</p>\n<p><img src=\"//psilocine.github.io/2022/03/16/算法核心框架整理-1/heap_1.png\" alt=\"heap_1\"></p>\n<p><strong>时间复杂度分析</strong></p>\n<ul>\n<li>最佳情况：T(n) = O(nlogn)</li>\n<li>最差情况：T(n) = O(nlogn)</li>\n<li>平均情况：T(n) = O(nlogn)</li>\n</ul>\n<h3 id=\"计数排序\"><a href=\"#计数排序\" class=\"headerlink\" title=\"计数排序\"></a>计数排序</h3><p>使用一个额外的数组 C，其中第 i 个元素是待排序数组 A 中值等于 i 的元素个数。然后根据数据 C 来将 A 中的元素排到正确的位置。它只能对整数进行排序，如果数据范围比要排序的数据大很多，则不适用</p>\n<p><strong>实现</strong></p>\n<ol>\n<li>找出待排序的数组中最小值</li>\n<li>统计数组中每个值为 i 的元素出现的次数，结合最小值存入数组 C 的第 i 项（存在则加 1，不存在则赋值为 1）</li>\n<li>反向填充目标数组：将每个元素 i 放在新数组的第 C(i) 项，每放一个元素就将 C(i) 减去 1</li>\n</ol>\n<p><strong>稳定性</strong></p>\n<p>按顺序 push 进各自统计数组，所以是稳定排序算法</p>\n<p><img src=\"//psilocine.github.io/2022/03/16/算法核心框架整理-1/counting_1.png\" alt=\"counting_1\"></p>\n<p><strong>时间复杂度分析</strong></p>\n<ul>\n<li>最佳情况：T(n) = O(n+k)</li>\n<li>最差情况：T(n) = O(n+k)</li>\n<li>平均情况：T(n) = O(n+k)</li>\n</ul>\n<h3 id=\"桶排序（Bucket-sort）\"><a href=\"#桶排序（Bucket-sort）\" class=\"headerlink\" title=\"桶排序（Bucket sort）\"></a>桶排序（Bucket sort）</h3><p>是计数排序的升级版。假设输入数据服从均匀分布，将数据分到有限数量的桶里，每个桶再分别排序（有可能再使用别的排序算法或是以递归方式继续使用桶排序）</p>\n<p><strong>实现</strong></p>\n<ol>\n<li>设置一个定量的数组当作空桶</li>\n<li>遍历输入数据，并且把数据一个一个放到对应的桶里</li>\n<li>对每个不是空的桶进行排序</li>\n<li>从不是空的桶里把排序好的数据拼接起来</li>\n</ol>\n<p><strong>稳定型</strong></p>\n<p>按顺序 push 进各自桶数组，无涉及位置交换，所以是稳定的排序算法</p>\n<p><img src=\"//psilocine.github.io/2022/03/16/算法核心框架整理-1/bucket_1.png\" alt=\"bucket_1\"></p>\n<p><strong>时间复杂度分析</strong></p>\n<ul>\n<li>最佳情况：T(n) = O(n+k)</li>\n<li>最差情况：T(n) = $O(n^2)$</li>\n<li>平均情况：T(n) = O(n+k)</li>\n</ul>\n<h3 id=\"基数排序（Radix-Sort）（也称鸽巢排序）\"><a href=\"#基数排序（Radix-Sort）（也称鸽巢排序）\" class=\"headerlink\" title=\"基数排序（Radix Sort）（也称鸽巢排序）\"></a>基数排序（Radix Sort）（也称鸽巢排序）</h3><p>是非比较的排序算法。每个数值都要大于等于 0，数据范围建议小于 1000。基数排序是按照低位先排序，收集；再按照高位排序，收集；以此类推，直到最高位。基于分别排序，分别收集，所以是稳定的。（LSD：从低位开始排序；MSD：从高位开始排序）</p>\n<p><strong>实现</strong></p>\n<ol>\n<li>取得数组中的最大数，并取得位数</li>\n<li>arr 为原始数组，从最低位开始取每个位组成 radix 数组</li>\n<li>对 radix 进行计数排序（利用计数排序适合于小范围数的特点）</li>\n</ol>\n<p><strong>稳定性</strong></p>\n<p>没有设计位置交换，是稳定排序算法</p>\n<p><img src=\"//psilocine.github.io/2022/03/16/算法核心框架整理-1/radix_1.png\" alt=\"radix_1\"></p>\n<p><strong>时间复杂度分析</strong></p>\n<ul>\n<li>最佳情况：T(n) = O(n * k)</li>\n<li>最差情况：T(n) = O(n * k)</li>\n<li>平均情况：T(n) = O(n * k)</li>\n</ul>\n<h3 id=\"基数排序-vs-计数排序-vs-桶排序\"><a href=\"#基数排序-vs-计数排序-vs-桶排序\" class=\"headerlink\" title=\"基数排序 vs 计数排序 vs 桶排序\"></a><strong>基数排序 vs 计数排序 vs 桶排序</strong></h3><p>这三种排序算法都利用了桶的概念，但对桶的使用方法上有明显差异：</p>\n<ol>\n<li>基数排序：根据键值的每位数字来分配桶</li>\n<li>计数排序：每个桶只存储单一键值</li>\n<li>桶排序：每个桶存储一定范围的数值</li>\n</ol>"},{"title":"我收集的一些基础面试题","date":"2017-09-22T08:29:49.000Z","_content":"\n##### 写在前面\n\n我收集的也有我遇到过的面试题, 会持续更新.\n\n### HTML\n\n- 前端工程化的理解\n  模块化、组件化、规范化、自动化\n\n```html\n1.模块化 将文件拆分成互相依赖的小文件, 多人协作开发后, 再进行统一的拼装. js模块化 commonjs amd cmd\ncss模块化 命名风格. 在类前加规范, 如布局(grid)(.g-xxx) 功能(function)(.f-xxx) 2.组件化\n每个包含html+css+js完备的单元, 成为组件 3.规范化 目录结构的确定, 前后端接口规范, 组件命名规范\ncommit描述规范 4.自动化 简单的机械劳动, 让机器帮我们完成. 线上发布 => 使用脚本 图片<20kb =>\nwebpack转base64\n```\n\n- 如何 html 中开启和关闭 dns 预读取\n\n```html\n<!-- on打开 off关闭 -->\n<meta http-equiv=\"x-dns-prefetch-control\" content=\"off\" />\n\n<!-- 方法二 通过link的rel属性 -->\n<link rel=\"dns-prefetch\" href=\"//\" />\n```\n\n- doctype 的作用\n\n1. 告知浏览器的解析器用什么文档标准解析这个文档, doctype 不存在或不正确会导致文档以怪异模式呈现\n\n- 前端渲染和后端渲染的区别\n\n1. 后端渲染优势: 开发速度快, 不涉及前端交互; seo 友好度较高, 能够一次性渲染页面, 利于搜索引擎抓取. 劣势: 可维护性差, 因为是一次性渲染页面; 编码效率低, 前后端代码混在一起; 无法进行跨平台开发.\n2. 前端渲染优势: 端口分离, 专注于前端; 可维护性高; 跨平台; 响应速度快. 劣势: 不利于 seo 优化; 首次开发成本较高; 安全性低.\n\n- canvas 和 svg 在绘图有哪些优劣\n\n1. canvas 依赖分辨率; 不支持事件处理器; 弱的文本渲染能力; 能够以 .png 或 .jpg 格式保存结果图像; 最适合图像密集型的游戏，其中的许多对象会被频繁重绘\n2. svg 不依赖分辨率; 支持事件处理器; 最适合带有大型渲染区域的应用程序（比如谷歌地图）; 复杂度高会减慢渲染速度（任何过度使用 DOM 的应用都不快）; 不适合游戏应用\n\n<!-- more -->\n\n- 常见行内元素, 块级元素, 空(void)元素有哪些?\n\n1. 行内元素: a, b, span, img, input, label, select, strong\n2. 块级元素: p, div, h1-h6, ul, li\n3. 空元素: 没有内容的 HTML 元素被称为空元素, 是在开始标签中关闭的. br, hr, img, meta, link, input\n\n- HTML5 新增了哪些内容或 API, 使用过哪些\n\n1. 用于绘图的 canvas;\n2. 用于媒体的 video, audio 标签;\n3. 语义化更好的 article section 等标签;\n4. 用于表单控件的 email, number, date;\n5. 针对 cookie 的不足出现的本地离线存储;\n6. API 有 contextmenu 可以自定义右键菜单, 允许获取用户的地理位置 getCurrentPosition()\n\n- input 和 textarea 的区别\n  区别就是一个是只能单行输入, 还有 size 可以指定 input 的长度. 一个是多行输入, cols rows 指定整个 textarea 的大小.\n\n* 用一个 div 模拟 textarea 的实现\n  需要用到不常见的 html5 属性 contenteditable, 这是内容可编辑的意思,\n\n```html\n<div contenteditable=\"true\"></div>\n```\n\n这样 div 区域内就可以编辑.\n\n<div contenteditable = 'true'>这一个div可编辑</div>\n\n### CSS\n\n- 纯 css 实现三角形的方法(三种)\n\n```css\n1. border\n2. 利用\"◆\"字符\n3. css3旋转div transfrom rotate(45deg)\n```\n\n- CSS 隐藏元素的几种方法（至少说出三种）\n\n```css\nopacity: 元素本身依然占据它自己的位置并对网页的布局起作用。它也将响应用户交互;\nvisibility: 与 opacity 唯一不同的是它不会响应任何用户交互。此外，元素在读屏软件中也会被隐藏;\ndisplay: display 设为 none\n  任何对该元素直接打用户交互操作都不可能生效。此外，读屏软件也不会读到元素的内容。这种方式产生的效果就像元素完全不存在;\nposition: 不会影响布局，能让元素保持可以操作;\n```\n\n- CSS 清除浮动的几种方法（至少两种）\n\n```css\n使用带clear属性的空元素 // 在浮动元素后添加一个空元素div.clear\n使用CSS的overflow属性；// 父元素设置overflow: hidden即可\n使用CSS的:after伪元素；// 最常见\n\n<div class=\"news clearfix\">\n  <img src=\"news-pic.jpg\" />\n  <p>some text</p>\n</div>\n\n.news img {\n  float: left;\n}\n\n.news p {\n  float: right;\n}\n\n.clearfix:after {\n  content: \"020\";\n  display: block;\n  height: 0;\n  clear: both;\n  visibility: hidden;\n}\n\n.clearfix {\n  /* 触发 hasLayout, 兼容 ie6 7  */\n  zoom: 1;\n}\n```\n\n- 页面导入样式时，使用 link 和@import 有什么区别？\n\n1. link 属于 XHTML 标签, 除了加载 CSS 外, 还能用于定义 RSS, 定义 rel 连接属性等作用; 而@import 是 CSS 提供的, 只能用于加载 CSS;\n2. 页面被加载的时, link 会同时被加载, 而@import 引用的 CSS 会等到页面被加载完再加载;\n\n- 介绍一下 CSS 的盒子模型？\n\n1. 有两种, IE 盒子模型、标准 W3C 盒子模型; IE 的 content 部分包含了 border 和 padding; width, height = border+padding+content;\n2. 盒模型: 内容(content)、填充(padding)、边界(margin)、 边框(border). width, height = content;\n\n- 左右布局：左边定宽、右边自适应, 不少于 3 种方法\n\n```css\n<aside class='left'></aside>\n<section class='right'></section>\n\naside {\n  width: 200px;\n  height: 200px;\n  background: #f00;\n}\n\nsection {\n  height: 200px;\n  background: #0f0;\n}\n\n1. 左边左浮动, 右边宽100%\n.left {\n  float: left;\n}\n.right {\n  width: 100%;\n}\n2. 父元素flex布局, 右边flex:1\nbody {\n  display: flex;\n}\n.right {\n  flex: 1; // 通过设置 flex 的数值来控制所占空间的比例\n}\n3. 设置浮动, 用calc给右边宽度\n.left, .right {\n  float: left;\n}\n.right {\n  width: calc(100% - 200px); // 200px是左边盒子的宽度\n}\n4. margin负值法 (圣杯/双飞翼)\n这里要注意自适应的div要放在前面, 定宽放后面\n```\n\n- CSS3 用过哪些新特性\n  动画@keyframes, animation, transtion, box-shadow, text-shadow 等, 详情可看我的简述 CSS3 的一些属性系列\n\n- BFC、IFC\n  BFC: block formatting context 块级格式化上下文, 即块级作用域\n\n```css\n// 满足以下一项即可成为BFC\nfloat: left | right\nposition: fixed | absolute\ndisplay: inline-block | table-cell | table-caption | flex | inline-flex\noverflow: hidden | scroll | auto\n```\n\n用 BFC 来做什么:1.外边距折叠; 2.容器无高度包含浮动元素; 3.阻止文字环绕\nIFC: inline formatting context 内联格式化上下文\n用 IFC 来做什么:1.水平居中: 当一个块要在环境中水平居中时, 设置其为 inline-block 则会在外层产生 IFC, 通过 text-align 则可以使其水平居中; 2.垂直居中: 创建一个 IFC, 用其中一个元素撑开父元素的高度, 然后设置其 vertical-align:middle, 其他行内元素则可以在此父元素下垂直居中;\n\n- 对栅格的理解\n  栅格 12 列, 为什么取 12, 12 是 1, 2, 3, 4, 6 的最小公倍数. 栅格是通过一系列行 row 和列 col-xx-xx 的组合来创建页面布局的系统.\n\n- （水平）居中有哪些实现方式\n\n1. 需要居中的元素是块元素的话, 只需要 margin: 0 auto;\n2. 如果是内联元素, 需要 display 成内联块, 然后父元素 text-align: center 即可.\n\n- display:none 和 visibility:hidden 有什么区别\n\n1. 显示区域: display 设置为 none 后不会占据空间, visibility:hidden 会保留空间;\n2. reflow 回流和 repaint 重绘: display 因为改变元素位置, 会触发 relow 和 repaint, visibility 没有改变其位置, 只会触发 repaint;\n3. 子元素的显示: display 为 none 后子元素无论设置什么属性都会被连同隐藏, visibility 不同, 其子元素可以用 visibility:visible 来显示.\n\n### JS\n\n- cookie 和 session 的区别\n\n```JavaScript\n1.cookie存在客户端, session存在服务端\n2.session依赖session id, 而session id存于cookie, 如果禁用cookie, session也会失效. 除非在url里加session id验证\n3.session存放在服务器的文件里, cookie存于浏览器\n```\n\n- NodeJS 的优缺点\n\n```css\n优点：\n1. 高并发（最重要的优点）\n\n2. 适合I/O密集型应用\n\n缺点：\n1. 不适合CPU密集型应用；CPU密集型应用给Node带来的挑战主要是：由于JavaScript单线程的原因，如果有长时间运行的计算（比如大循环），将会导致CPU时间片不能释放，使得后续I/O无法发起；\n\n解决方案：分解大型运算任务为多个小任务，使得运算能够适时释放，不阻塞I/O调用的发起；\n\n2. 只支持单核CPU，不能充分利用CPU\n\n3. 可靠性低，一旦代码某个环节崩溃，整个系统都崩溃\n\n原因：单进程，单线程\n\n解决方案：\n（1）Nnigx反向代理，负载均衡，开多个进程，绑定多个端口；\n\n（2）开多个进程监听同一个端口，使用cluster模块；\n\n4. 开源组件库质量参差不齐，更新快，向下不兼容\n\n5. Debug不方便，错误没有stack trace\n```\n\n- js 对象的深度克隆代码实现\n\n```javascript\nfunction clone(Obj) {\n  var buf;\n  if (Obj instanceof Array) {\n    buf = []; // 创建一个空的数组\n    var i = Obj.length;\n    while (i--) {\n      buf[i] = clone(Obj[i]);\n    }\n    return buf;\n  } else if (Obj instanceof Object) {\n    buf = {}; // 创建一个空对象\n    for (var k in Obj) {\n      // 为这个对象添加新的属性\n      buf[k] = clone(Obj[k]);\n    }\n    return buf;\n  } else {\n    return Obj;\n  }\n}\n```\n\n- js 对象的深度克隆代码实现 (2)\n\n```javascript\nfunction deepCopy(p, c) {\n  var c = c || {};\n  for (var i in p) {\n    if (typeof p[i] === \"object\") {\n      c[i] = p[i].constructor === Array ? [] : {};\n      deepCopy(p[i], c[i]);\n    } else {\n      c[i] = p[i];\n    }\n  }\n  return c;\n}\n```\n\n- js 操作获取和设置 cookie\n\n```javascript\n/*cookie的三种操作：读取，写入，删除*/\nvar CookieUtil = {\n  get: function(name) {\n    var cookieName = encodeURIComponent(name) + \"=\",\n      cookieStart = document.cookie.indexOf(cookieName),\n      cookieValue = null;\n    if (cookieStart > -1) {\n      var cookieEnd = document.cookie.indexOf(\";\", cookieStart);\n      if (cookieEnd == -1) {\n        cookieEnd = document.cookie.length;\n      }\n      cookieValue = decodeURIComponent(\n        document.cookie.substring(cookieStart + cookieName.length, cookieEnd)\n      );\n    }\n    return cookieValue;\n  },\n  set: function(name, value, expires, path, domain, secure) {\n    var cookieText = encodeURIComponent(name) + \"=\" + encodeURIComponent(value);\n    if (expires instanceof Date) {\n      cookieText += \";expires=\" + expires.toGMTString();\n    }\n    if (path) {\n      cookieText += \";path=\" + path;\n    }\n    if (domain) {\n      cookieText += \";domain=\" + domain;\n    }\n    if (secure) {\n      cookieText += \";secure\";\n    }\n    document.cookie = cookieText;\n  },\n  unset: function(name, path, domain, secure) {\n    this.set(name, \"\", new Date(0), path, domain, secure);\n  }\n};\n```\n\n- 介绍一下你对浏览器内核的理解？\n  主要分成两部分：渲染引擎(layout engineer 或 Rendering Engine)和 JS 引擎。\n  渲染引擎：负责取得网页的内容（HTML、XML、图像等等）、整理讯息（例如加入 CSS 等），以及计算网页的显示方式，然后会输出至显示器或打印机。浏览器的内核的不同对于网页的语法解释会有不同，所以渲染的效果也不相同。所有网页浏览器、电子邮件客户端以及其它需要编辑、显示网络内容的应用程序都需要内核。\n  JS 引擎则：解析和执行 javascript 来实现网页的动态效果。  \n  最开始渲染引擎和 JS 引擎并没有区分的很明确，后来 JS 引擎越来越独立，内核就倾向于只指渲染引擎。\n\n- 常见浏览器内核\n\n1. Trident 内核: ie\n2. Gecko 内核: ff\n3. Presto 内核: Opera7 及以上, 现 O 内核为 Blink\n4. Webkit 内核: Safari, Chrome, 现 C 内核为 Blink\n\n- xss 和 csrf\n\n1. xss(cross site-scripting)跨站脚本攻击, 在被攻击者的浏览器中执行脚本, 采集被攻击者数据. 如盗用 cookie; 以被攻击者的身份执行操作\n2. csrf 跨站请求伪造. 造成 csrf 需要两步, 第一登录受信任网站 a, 在本地生成 cookie, 第二不登出 a 的情况下访问危险网站 b.\n\n- String.prototype.replace()用法. 注意不会改变原字符串, 而是返回新字符串.\n\n1. str.replace(regexp|substr, newStr)\n2. str.replace(regexp|substr, function)\n\n```javascript\n// substr\nvar str = \"ac\";\nstr.replace(\"a\", \"b\"); // 'bc'\n\n// 1.\nvar str = \"Twas the night before Xmas...\";\nvar newstr = str.replace(/xmas/i, \"Christmas\");\nconsole.log(newstr); // Twas the night before Christmas...\n\n// 2.\nfunction styleHyphenFormat(propertyName) {\n  function upperToHyphenLower(match) {\n    return \"-\" + match.toLowerCase();\n  }\n  return propertyName.replace(/[A-Z]/g, upperToHyphenLower);\n}\nstyleHyphenFormat(\"borderTop\"); // border-top\n```\n\n- JavaScript 的定义\n  JavaScript 是一种专门为与网页交互而设计的脚本语言。有下列三部分组成\n\n1. ECMAScript，提供核心语言功能\n2. 文档对象模型（DOM），提供访问与操作网页内容的方法与接口\n3. 浏览器对象模型（BOM），提供与浏览器交互的方法与接口\n\n- javascript 的 typeof 返回哪些数据类型\n  Object(对象, null) number string function boolean underfind (es6 symbol);\n\n- ajax 请求的时候 get 和 post 方式的区别?\n\n1. get 方法放在 url 后面, 不能大于 2kb, post 方法放在 http 消息的实体内容发送\n2. 安全问题, get 安全性低, post 安全性高\n\n- 图片懒加载原理\n  页面加载后只让文档可视区内的图片显示，其它不显示，随着用户对页面的滚动，判断其区域位置，生成 img 标签，让到可视区的图片加载出来\n\n- 谈谈 This 对象的理解\n\n1. this 是 js 的一个关键字, 随着函数使用场合不同, this 的值会发生变化.\n2. 但是有一个总原则, 那就是 this 指的是调用函数的那个对象.\n3. this 一般情况下: 是全局对象 Global. 作为方法调用, 那么 this 就是指这个对象\n\n- JSONP 原理\n  ajax 请求受同源策略影响，不允许进行跨域请求，而 script 标签 src 属性中的链接却可以访问跨域的 js 脚本，利用这个特性，服务端不再返回 JSON 格式的数据，而是返回一段调用某个函数的 js 代码，在 src 中进行了调用，这样实现了跨域。\n\n- ajax 的过程是怎样的\n\n1. 创建 XMLHttpRequest 对象,也就是创建一个异步调用对象\n2. 创建一个新的 HTTP 请求,并指定该 HTTP 请求的方法、URL 及验证信息\n3. 设置响应 HTTP 请求状态变化的函数\n4. 发送 HTTP 请求\n5. 获取异步调用返回的数据\n6. 使用 JavaScript 和 DOM 实现局部刷新\n\n- 详解单页面路由的几种实现原理\n\n1. url 完全不动型. 这一种的情况是 url 完全不动, 即你的页面怎么改变, 怎么跳转 url 都不会改变, 这种情况的原理就是纯 ajax 拿到页面后替换原页面中的元素.\n2. 带 hash(#)型. 这种类型的优点就是刷新页面, 页面也不会丢. 通过监听 hash(#)的变化来执行 js 代码, 从而实现页面的改变. 主要需要用到 hashchange 事件.\n\n```JavaScript\nwindow.addEventListener('hashchange', () => {\n  // 改变节点\n})\n```\n\n3. 无 hash(#)型. 这种类型是通过 html5 的最新 history api 来实现的能正常的回退前进. url 和普通的 url 一样, 但缺点就是一刷新页面页面就会丢失.\n\n```JavaScript\n主要需要用到history.pushState,\nhistory.replaceState, // 不会记录到历史栈\nhistory.state,\nwindow.onpopstate事件.\nwindow.addEventListener('popstate', () => {\n  // 更新节点\n})\n```\n\n- js 跨域的实现方法原理\n\n1. 通过 jsonp. 有个 a.html 页面, 假设这个 json 数据地址是http://example.com/data.php\n\n```javascript\n// a.html\n<script>\nfunction doSomething (jsondata) {\n  // 处理获得的data数据\n}\n</script>\n<script src='http://example.com/data.php?callback=doSomething'></script>\n// 也可以是php文件返回一个js函数的调用, 如 echo 'doSomething(...)', 这样就不用在url写callback\n// jsonp跨域缺点: 只支持get请求, 安全隐患, 必须双方都受信任.\n```\n\n2. 通过修改 document.domain 来跨子域. 比如，有一个页面, 它的地址是http://www.example.com/a.html, 在这个页面里面有一个 iframe, 它的 src 是http://example.com/b.html.\n\n```javascript\n// a.html与它里面的iframe框架是不同域的, 无法通过在页面中书写js代码来获取iframe中的东西\n<script>\nfunction onLoad () {\n  var iframe = document.getElementById('iframe');\n  var win = iframe.contentWindow;\n  var doc = win.document;  // 获取不到iframe里的document对象\n  var name = win.name;     // 获取不到\n}\n</script>\n<iframe id='iframe' src='http://example.com/b.html' onload = 'onLoad()'></iframe>\n```\n\n这时候, 只要把http://www.example.com/a.html和http://example.com/b.html的document.domain设成相同的. document.domain 只能往自身或更低一级的域. eg: a.b.example.com 可以设成 a.b.example.com、b.example.com、example.com 中的任意一个, 不能设 c.a.b.example.com.\n\n```javascript\n// a.html\n<iframe id='iframe' src='http://example.com/b.html' onload = 'onLoad()'></iframe>\n<script>\ndocument.domain = 'example.com'\nfunction onLoad() { ... }\n</script>\n\n// b.html\n<script>\ndocument.domain = 'example.com'\n</script>\n\n//domain缺点: 安全性, 当一个页面被攻击后, 另一个有安全隐患; 如果有多个iframe, 就要设置成大家都相同的domain\n```\n\n3. window.name. 把需要的值替换成 window.name 的值. 如 www.example.com/a.html, 需要 www.cnblogs.com/data.html 里的数据, 需要 iframe 充当中间人, 来获取 data.HTML 的数据, a.html 再去获取 iframe 获取到的数据, 这里注意 a.html 和 iframe 需要同源即可\n\n```JavaScript\nfunction getData () {\n  var iframe = document.getElementById('iframe');\n  iframe.onload = function () {\n    var data = iframe.contentWindow.name;\n    console.log(data);\n  }\n  iframe.src = 'http://www.example.com/b.html'; // 与a.html同源\n}\n<iframe id='iframe' src = 'http://www.cnblogs.com/data.html' style='display:none' onload = getData() ></iframe>\n// window.name缺点: window.name的值是字符串形式, 最大只能2M左右\n```\n\n4. HTML5 的 window.postMessage(message,targetOrigin)方法. 可以使用它来向其它的 window 对象发送消息, 无论这个 window 对象是属于同源或不同源. 该方法的第一个参数 message 为要发送的消息, 类型只能为字符串; 第二个参数 targetOrigin 用来限定接收消息的那个 window 对象所在的域, 如果不想限定域, 可以使用通配符 \\*\n\n```JavaScript\n// a.html\n<script>\nfunction onLoad() {\n  var iframe = document.getElementById('iframe');\n  var win = iframe.contentWindow;\n  win.postMessage('hello world', *);\n}\n</script>\n<iframe id='iframe' src='http://www.example.com/b.html' onload = onLoad() ></iframe>\n\n// b.html\n<script>\nwindow.onmessage = function (e) {\n  e = e || event;\n  console.log(e.data)  // hello world\n}\n</script>\n// h5方法缺点: IE6、IE7不支持\n```\n\n5. 服务端的方法 http 请求包含 Access-Control-Allow-Origin.\n\n- 因为引用计数产生的内存泄漏，在 ES6 中的解决办法是什么？\n  ES6 考虑到了这一点，推出了两种新的数据结构：WeakSet 和 WeakMap。它们对于值的引用都是不计入垃圾回收机制的，所以名字里面才会有一个”Weak”，表示这是弱引用。\n\n- js 中基本类型在内存中存储方式是什么，引用类型的存储方式是什么\n  基本类型在内存中占据固定大小的空间, 因此变量和值都存在栈中, 引用类型的存储方式是栈中存变量和堆内存地址, 堆里面是引用类型. 原因是因为引用类型是可扩展的, 内存可大可小, 内存不能给每一个引用类型都开一个新的空间, 采用指针引用科学很多.\n\n- 渐进增强和优雅降级\n  渐进增强（Progressive Enhancement）：一开始就针对低版本浏览器进行构建页面，完成基本的功能，然后再针对高级浏览器进行效果、交互、追加功能达到更好的体验。  \n  优雅降级（Graceful Degradation）：一开始就构建站点的完整功能，然后针对浏览器测试和修复。比如一开始使用 CSS3 的特性构建了一个应用，然后逐步针对各大浏览器进行 hack 使其可以在低版本浏览器上正常浏览。\n\n- 手写一个 jsonp\n\n```javascript\n(function(window, document) {\n  \"use strict\";\n  var jsonp = function(url, data, callback) {\n    // 1.将传入的data数据转化为url字符串形式\n    // {id:1,name:'zhangsan'} => id=1&name=zhangsan\n    var dataString = url.indexof(\"?\") == -1 ? \"?\" : \"&\";\n    for (var key in data) {\n      dataString += key + \"=\" + data[key] + \"&\";\n    }\n\n    // 2 处理url中的回调函数\n    // cbFuncName回调函数的名字 ：my_json_cb_名字的前缀 + 随机数（把小数点去掉）\n    var cbFuncName =\n      \"my_json_cb_\" +\n      Math.random()\n        .toString()\n        .replace(\".\", \"\");\n    dataString += \"callback=\" + cbFuncName;\n\n    // 3.创建一个script标签并插入到页面中\n    var scriptEle = document.createElement(\"script\");\n    scriptEle.src = url + dataString;\n\n    // 4.挂载回调函数\n    window[cbFuncName] = function(data) {\n      callback(data);\n      // 处理完回调函数的数据之后，删除jsonp的script标签\n      document.body.removeChild(scriptEle);\n    };\n\n    // 5.append到页面中\n    document.body.appendChild(scriptEle);\n  };\n\n  // 因为jsonp是一个私有函数外部不能调用，所有jsonp函数作文window对象的一个方法，供外部调用\n  window.$jsonp = jsonp;\n})(window, document);\n```\n\n### VUE\n\n- Vue 双向数据绑定的实现\n  vue 中有一个 observer 来观察所有的属性的变化, 一旦有变化, 就会发给 watcher, 然后 watcher 来告诉编译器 complie 来改变数值\n\n- vue 和其他两个框架的区别\n\n1. vue 更轻量级, gzip 后大小只有 20+k, react 有 40+k, angular 有 50+k. 移动端 vue 更适合\n2. vue 学习曲线平稳, angular 入门较难, 概念多, 因为其思想很多沿用后端技术, react 需要学很多, 附带全家桶.\n3. vue 吸收另外两家之长, 既有 angular 的指令, 也有 react 的组件化思想.\n\n- vue.js 的核心思想\n\n1. 数据驱动\n2. 组件化\n\n- 数据响应原理\n  有一个数据 a.b,在 vue 对象实例化过程中，会给 a,b 通过 ES5 的 defineProperty()方法，添加 getter 和 setter 方法，同时 vue.js 会对模板做编译，解析生成一个指令对象，比如 v-text 指令，每个指令对象都会关联一个 watcher，当对指令对象求值时，就会触发 getter，并将依赖收集到 watcher 中；当再次改变 a.b 值时，就会触发 setter 方法，会通知到对应关联的 watcher,watcher 则再次对 a.b 求值，计算对比新旧值，当值改变时，watcher 会通知到指令，调用指令的 update 方法，由于指令是对 dom 的封装，所以会调用原生 dom 的方法，去更新视图。\n\n- vue-loader 是什么？使用它的用途有哪些？\n  解析.vue 文件的一个加载器，跟 template/js/style 转换成 js 模块。\n  用途：js 可以写 es6、style 样式可以 scss 或 less、template 可以加 jade 等\n\n- vue 生命周期总共有几个阶段？\n  它可以总共分为 8 个阶段：创建前/后, 载入前/后,更新前/后,销毁前/销毁后\n\n- 简单描述每个周期具体适合哪些场景？\n  生命周期钩子的一些使用方法：  \n  beforecreate : 可以在这加个 loading 事件，在加载实例时触发  \n  created : 初始化完成时的事件写在这里，如在这结束 loading 事件，异步请求也适宜在这里调用  \n  mounted : 挂载元素，获取到 DOM 节点  \n  updated : 如果对数据统一处理，在这里写上相应函数  \n  beforeDestroy : 可以做一个确认停止事件的确认框  \n  nextTick : 更新数据后立即操作 dom\n\n### 移动端 bug\n\n- fixed 遮罩滚动穿透问题\n\n```JavaScript\n// 1.touchmove + preventDefault\nmask.addEventListener('touchmove', (e) {\n  e.preventDefault()\n}, false)\n// 缺点, 当弹出层需要滚动时也会被阻止\n\n// 2.position +js保存滚动条位置\n// css\n.mask {\n  position: fixed;\n  width: 100%;\n}\n\n// js\n// 遮罩开启时保存当前滚动位置, 关闭时还原之前滚动位置\n```\n\n- 移动设备忽略将页面中的数字识别为电话号码的方法\n  在 head 里面加一个\n\n```html\n<meta name=\"format-detection\" content=\"telephone=no\" />\n```\n\n即可, 响应的还可以有 email=no 让邮箱不可点击.\n\n- 上下拉动滚动条时卡顿、慢\n\n```css\nbody {\n  -webkit-overflow-scrolling: touch;\n  overflow-scrolling: touch;\n}\n```\n\n- 禁止复制、选中文本\n\n```css\nelement {\n  -webkit-user-select: none;\n  -moz-user-select: none;\n  -khtml-user-select: none;\n  user-select: none;\n}\n```\n\n### 计网\n\n- 在浏览器中输入 URL 并回车后都发生了什么?\n\n1. 解析 URL\n2. DNS 解析\n3. 浏览器与网站建立 TCP 连接（三次握手）\n4. 请求和传输数据\n5. 浏览器渲染页面\n\n- http 强缓存和协商缓存\n  所谓的强缓存就是本地缓存. 浏览器第一次请求时, 一定是强缓存, 返回状态码 200; 第二次请求时, 会先获取该资源缓存的 header 信息(cache-control, expires; cache-control 与 expires 同时存在的话，cache-control 的优先级高于 expires), 两者都符合成立的话就不去服务器请求, 直接拿本地的缓存. 如果上面两个不成立, 就会发送请求到服务器(Etag/if-none-match, Last-modified/if-modified-since; Last-Modified 与 ETag 是可以一起使用的，服务器会优先验证 ETag，一致的情况下，才会继续比对 Last-Modified，最后才决定是否返回 304。), 由服务器根据请求中的相关 header 信息来对比结果是否协商缓存成立, 二者如果有一个和服务器上的不一致, 那就重新返回资源, 如果都没变化则返回 304 not modified, 浏览器收到 304 后, 从本地缓存中加载资源.\n\n- HTTP2 与 1.1 区别\n\n1. HTTP2.0 采用二进制格式而非文本格式（二进制解析更加高效，错误更少）\n2. HTTP2 是完全的多路复用（能同时传输多个请求和响应）\n3. 使用报头压缩，降低了开销\n4. 可以让服务器主动把响应推送到客户端\n\n- HTTP1.0 与 1.1 区别\n  HTTP 1.0 规定浏览器与服务器只保持短暂的连接，浏览器的每次请求都需要与服务器建立一个 TCP 连接，服务器完成请求处理后立即断开 TCP 连接，服务器不跟踪每个客户也不记录过去的请求。但是，这也造成了一些性能上的缺陷，例如，一个包含有许多图像的网页文件中并没有包含真正的图像数据内容，而只是指明了这些图像的 URL 地址，当 WEB 浏览器访问这个网页文件时，浏览器首先要发出针对该网页文件的请求，当浏览器解析 WEB 服务器返回的该网页文档中的 HTML 内容时，发现其中的<img>图像标签后，浏览器将根据<img>标签中的 src 属性所指定的 URL 地址再次向服务器发出下载图像数据的请求\n  HTTP 1.1 支持持久连接（connection 默认 keep-alive），在一个 TCP 连接上可以传送多个 HTTP 请求和响应，减少了建立和关闭连接的消耗和延迟。一个包含有许多图像的网页文件的多个请求和应答可以在一个连接中传输，但每个单独的网页文件的请求和应答仍然需要使用各自的连接。  在 HTTP1.0 和 HTTP1.1 协议中都有对长连接的支持。其中 HTTP1.0 需要在 request 中增加”Connection： keep-alive“ header 才能够支持，而 HTTP1.1 默认支持.\n  HTTP 1.1 还允许客户端不用等待上一次请求结果返回，就可以发出下一次请求（流水线处理），但服务器端必须按照接收到客户端请求的先后顺序依次回送响应结果，以保证客户端能够区分出每次请求的响应内容，这样也显著地减少了整个下载过程所需要的时间。\n\n- HTTP 与 HTTPS\n  HTTP 协议传输的数据都是未加密的，也就是明文的，因此使用 HTTP 协议传输隐私信息非常不安全，为了保证这些隐私数据能加密传输，于是网景公司设计了 SSL（Secure Sockets Layer）协议用于对 HTTP 协议传输的数据进行加密，从而就诞生了 HTTPS。简单来说，HTTPS 协议是由 SSL+HTTP 协议构建的可进行加密传输、身份认证的网络协议，要比 http 协议安全。HTTPS 使用不同于 HTTP 协议的默认端口及一个加密、身份验证层（HTTP 与 TCP 之间）\n  　　 HTTPS 和 HTTP 的区别主要如下：\n  　　 1、https 协议需要到 ca 申请证书，一般免费证书较少，因而需要一定费用。\n  　　 2、http 是超文本传输协议，信息是明文传输，https 则是具有安全性的 ssl 加密传输协议。\n  　　 3、http 和 https 使用的是完全不同的连接方式，用的端口也不一样，前者是 80，后者是 443。\n  　　 4、http 的连接很简单，是无状态的；HTTPS 协议是由 SSL+HTTP 协议构建的可进行加密传输、身份认证的网络协议，比 http 协议安全。\n\n虽然说 HTTPS 有很大的优势，但其相对来说，还是存在不足之处的：\n　　（1）HTTPS 协议握手阶段比较费时，会使页面的加载时间延长近 50%，增加 10%到 20%的耗电；\n　　（2）HTTPS 连接缓存不如 HTTP 高效，会增加数据开销和功耗，甚至已有的安全措施也会因此而受到影响；\n　　（3）SSL 证书需要钱，功能越强大的证书费用越高，个人网站、小网站没有必要一般不会用。\n　 （4）SSL 证书通常需要绑定 IP，不能在同一 IP 上绑定多个域名，IPv4 资源不可能支撑这个消耗。\n　　（5）HTTPS 协议的加密范围也比较有限，在黑客攻击、拒绝服务攻击、服务器劫持等方面几乎起不到什么作用。最关键的，SSL 证书的信用链体系并不安全，特别是在某些国家可以控制 CA 根证书的情况下，中间人攻击一样可行。\n\n客户端在使用 HTTPS 方式与 Web 服务器通信时有以下几个步骤，如图所示。（先非对称，在对称）\n　　（1）客户使用 https 的 URL 访问 Web 服务器，要求与 Web 服务器建立 SSL 连接。\n　　（2）Web 服务器收到客户端请求后，会将网站的证书信息（证书中包含公钥）传送一份给客户端。\n　　（3）客户端的浏览器与 Web 服务器开始协商 SSL 连接的安全等级，也就是信息加密的等级。\n　　（4）客户端的浏览器根据双方同意的安全等级，建立会话密钥，然后利用网站的公钥将会话密钥加密，并传送给网站。\n　　（5）Web 服务器利用自己的私钥解密出会话密钥。\n（6）Web 服务器利用会话密钥加密与客户端之间的通信。\n\n### 数据结构\n\n- 两个队列实现一个栈\n  A 队列作为主队列, B 队列. 判断 A 队列长度是否为 1, 如果是直接出队列. 如果不是, 出(长度-1)队列到 B 队列里, 然后最后一个出队列, 依次列推\n\n- 两个栈实现一个队列\n  入栈都给 A 栈, 要出栈时判断 B 栈是否为空, 为空, 将 A 栈全部 pop 后, push 到 B 栈, 然后 B 栈顺序 pop. 如果不为空, 将 B 栈里的先 pop.\n\n- 有哪些数据结构\n  图, 树, 线性, 集合.\n\n### 操作系统\n\n- 线程和进程的区别和联系\n  线程是 CPU 调度的一个基本单位; 进程是资源分配的基本单位.  \n  两者的联系: 进程和线程都是操作系统所运行的程序运行的基本单元.  \n  区别：  \n  （1）进程具有独立的空间地址，一个进程崩溃后，在保护模式下不会对其它进程产生影响。  \n  （2）线程只是一个进程的不同执行路径，线程有自己的堆栈和局部变量，但线程之间没有单独的地址空间，一个线程死掉就等于整个进程死掉。\n","source":"_posts/我收集的一些基础面试题.md","raw":"---\ntitle: 我收集的一些基础面试题\ndate: 2017-09-22 16:29:49\ntags: [面试, 前端]\n---\n\n##### 写在前面\n\n我收集的也有我遇到过的面试题, 会持续更新.\n\n### HTML\n\n- 前端工程化的理解\n  模块化、组件化、规范化、自动化\n\n```html\n1.模块化 将文件拆分成互相依赖的小文件, 多人协作开发后, 再进行统一的拼装. js模块化 commonjs amd cmd\ncss模块化 命名风格. 在类前加规范, 如布局(grid)(.g-xxx) 功能(function)(.f-xxx) 2.组件化\n每个包含html+css+js完备的单元, 成为组件 3.规范化 目录结构的确定, 前后端接口规范, 组件命名规范\ncommit描述规范 4.自动化 简单的机械劳动, 让机器帮我们完成. 线上发布 => 使用脚本 图片<20kb =>\nwebpack转base64\n```\n\n- 如何 html 中开启和关闭 dns 预读取\n\n```html\n<!-- on打开 off关闭 -->\n<meta http-equiv=\"x-dns-prefetch-control\" content=\"off\" />\n\n<!-- 方法二 通过link的rel属性 -->\n<link rel=\"dns-prefetch\" href=\"//\" />\n```\n\n- doctype 的作用\n\n1. 告知浏览器的解析器用什么文档标准解析这个文档, doctype 不存在或不正确会导致文档以怪异模式呈现\n\n- 前端渲染和后端渲染的区别\n\n1. 后端渲染优势: 开发速度快, 不涉及前端交互; seo 友好度较高, 能够一次性渲染页面, 利于搜索引擎抓取. 劣势: 可维护性差, 因为是一次性渲染页面; 编码效率低, 前后端代码混在一起; 无法进行跨平台开发.\n2. 前端渲染优势: 端口分离, 专注于前端; 可维护性高; 跨平台; 响应速度快. 劣势: 不利于 seo 优化; 首次开发成本较高; 安全性低.\n\n- canvas 和 svg 在绘图有哪些优劣\n\n1. canvas 依赖分辨率; 不支持事件处理器; 弱的文本渲染能力; 能够以 .png 或 .jpg 格式保存结果图像; 最适合图像密集型的游戏，其中的许多对象会被频繁重绘\n2. svg 不依赖分辨率; 支持事件处理器; 最适合带有大型渲染区域的应用程序（比如谷歌地图）; 复杂度高会减慢渲染速度（任何过度使用 DOM 的应用都不快）; 不适合游戏应用\n\n<!-- more -->\n\n- 常见行内元素, 块级元素, 空(void)元素有哪些?\n\n1. 行内元素: a, b, span, img, input, label, select, strong\n2. 块级元素: p, div, h1-h6, ul, li\n3. 空元素: 没有内容的 HTML 元素被称为空元素, 是在开始标签中关闭的. br, hr, img, meta, link, input\n\n- HTML5 新增了哪些内容或 API, 使用过哪些\n\n1. 用于绘图的 canvas;\n2. 用于媒体的 video, audio 标签;\n3. 语义化更好的 article section 等标签;\n4. 用于表单控件的 email, number, date;\n5. 针对 cookie 的不足出现的本地离线存储;\n6. API 有 contextmenu 可以自定义右键菜单, 允许获取用户的地理位置 getCurrentPosition()\n\n- input 和 textarea 的区别\n  区别就是一个是只能单行输入, 还有 size 可以指定 input 的长度. 一个是多行输入, cols rows 指定整个 textarea 的大小.\n\n* 用一个 div 模拟 textarea 的实现\n  需要用到不常见的 html5 属性 contenteditable, 这是内容可编辑的意思,\n\n```html\n<div contenteditable=\"true\"></div>\n```\n\n这样 div 区域内就可以编辑.\n\n<div contenteditable = 'true'>这一个div可编辑</div>\n\n### CSS\n\n- 纯 css 实现三角形的方法(三种)\n\n```css\n1. border\n2. 利用\"◆\"字符\n3. css3旋转div transfrom rotate(45deg)\n```\n\n- CSS 隐藏元素的几种方法（至少说出三种）\n\n```css\nopacity: 元素本身依然占据它自己的位置并对网页的布局起作用。它也将响应用户交互;\nvisibility: 与 opacity 唯一不同的是它不会响应任何用户交互。此外，元素在读屏软件中也会被隐藏;\ndisplay: display 设为 none\n  任何对该元素直接打用户交互操作都不可能生效。此外，读屏软件也不会读到元素的内容。这种方式产生的效果就像元素完全不存在;\nposition: 不会影响布局，能让元素保持可以操作;\n```\n\n- CSS 清除浮动的几种方法（至少两种）\n\n```css\n使用带clear属性的空元素 // 在浮动元素后添加一个空元素div.clear\n使用CSS的overflow属性；// 父元素设置overflow: hidden即可\n使用CSS的:after伪元素；// 最常见\n\n<div class=\"news clearfix\">\n  <img src=\"news-pic.jpg\" />\n  <p>some text</p>\n</div>\n\n.news img {\n  float: left;\n}\n\n.news p {\n  float: right;\n}\n\n.clearfix:after {\n  content: \"020\";\n  display: block;\n  height: 0;\n  clear: both;\n  visibility: hidden;\n}\n\n.clearfix {\n  /* 触发 hasLayout, 兼容 ie6 7  */\n  zoom: 1;\n}\n```\n\n- 页面导入样式时，使用 link 和@import 有什么区别？\n\n1. link 属于 XHTML 标签, 除了加载 CSS 外, 还能用于定义 RSS, 定义 rel 连接属性等作用; 而@import 是 CSS 提供的, 只能用于加载 CSS;\n2. 页面被加载的时, link 会同时被加载, 而@import 引用的 CSS 会等到页面被加载完再加载;\n\n- 介绍一下 CSS 的盒子模型？\n\n1. 有两种, IE 盒子模型、标准 W3C 盒子模型; IE 的 content 部分包含了 border 和 padding; width, height = border+padding+content;\n2. 盒模型: 内容(content)、填充(padding)、边界(margin)、 边框(border). width, height = content;\n\n- 左右布局：左边定宽、右边自适应, 不少于 3 种方法\n\n```css\n<aside class='left'></aside>\n<section class='right'></section>\n\naside {\n  width: 200px;\n  height: 200px;\n  background: #f00;\n}\n\nsection {\n  height: 200px;\n  background: #0f0;\n}\n\n1. 左边左浮动, 右边宽100%\n.left {\n  float: left;\n}\n.right {\n  width: 100%;\n}\n2. 父元素flex布局, 右边flex:1\nbody {\n  display: flex;\n}\n.right {\n  flex: 1; // 通过设置 flex 的数值来控制所占空间的比例\n}\n3. 设置浮动, 用calc给右边宽度\n.left, .right {\n  float: left;\n}\n.right {\n  width: calc(100% - 200px); // 200px是左边盒子的宽度\n}\n4. margin负值法 (圣杯/双飞翼)\n这里要注意自适应的div要放在前面, 定宽放后面\n```\n\n- CSS3 用过哪些新特性\n  动画@keyframes, animation, transtion, box-shadow, text-shadow 等, 详情可看我的简述 CSS3 的一些属性系列\n\n- BFC、IFC\n  BFC: block formatting context 块级格式化上下文, 即块级作用域\n\n```css\n// 满足以下一项即可成为BFC\nfloat: left | right\nposition: fixed | absolute\ndisplay: inline-block | table-cell | table-caption | flex | inline-flex\noverflow: hidden | scroll | auto\n```\n\n用 BFC 来做什么:1.外边距折叠; 2.容器无高度包含浮动元素; 3.阻止文字环绕\nIFC: inline formatting context 内联格式化上下文\n用 IFC 来做什么:1.水平居中: 当一个块要在环境中水平居中时, 设置其为 inline-block 则会在外层产生 IFC, 通过 text-align 则可以使其水平居中; 2.垂直居中: 创建一个 IFC, 用其中一个元素撑开父元素的高度, 然后设置其 vertical-align:middle, 其他行内元素则可以在此父元素下垂直居中;\n\n- 对栅格的理解\n  栅格 12 列, 为什么取 12, 12 是 1, 2, 3, 4, 6 的最小公倍数. 栅格是通过一系列行 row 和列 col-xx-xx 的组合来创建页面布局的系统.\n\n- （水平）居中有哪些实现方式\n\n1. 需要居中的元素是块元素的话, 只需要 margin: 0 auto;\n2. 如果是内联元素, 需要 display 成内联块, 然后父元素 text-align: center 即可.\n\n- display:none 和 visibility:hidden 有什么区别\n\n1. 显示区域: display 设置为 none 后不会占据空间, visibility:hidden 会保留空间;\n2. reflow 回流和 repaint 重绘: display 因为改变元素位置, 会触发 relow 和 repaint, visibility 没有改变其位置, 只会触发 repaint;\n3. 子元素的显示: display 为 none 后子元素无论设置什么属性都会被连同隐藏, visibility 不同, 其子元素可以用 visibility:visible 来显示.\n\n### JS\n\n- cookie 和 session 的区别\n\n```JavaScript\n1.cookie存在客户端, session存在服务端\n2.session依赖session id, 而session id存于cookie, 如果禁用cookie, session也会失效. 除非在url里加session id验证\n3.session存放在服务器的文件里, cookie存于浏览器\n```\n\n- NodeJS 的优缺点\n\n```css\n优点：\n1. 高并发（最重要的优点）\n\n2. 适合I/O密集型应用\n\n缺点：\n1. 不适合CPU密集型应用；CPU密集型应用给Node带来的挑战主要是：由于JavaScript单线程的原因，如果有长时间运行的计算（比如大循环），将会导致CPU时间片不能释放，使得后续I/O无法发起；\n\n解决方案：分解大型运算任务为多个小任务，使得运算能够适时释放，不阻塞I/O调用的发起；\n\n2. 只支持单核CPU，不能充分利用CPU\n\n3. 可靠性低，一旦代码某个环节崩溃，整个系统都崩溃\n\n原因：单进程，单线程\n\n解决方案：\n（1）Nnigx反向代理，负载均衡，开多个进程，绑定多个端口；\n\n（2）开多个进程监听同一个端口，使用cluster模块；\n\n4. 开源组件库质量参差不齐，更新快，向下不兼容\n\n5. Debug不方便，错误没有stack trace\n```\n\n- js 对象的深度克隆代码实现\n\n```javascript\nfunction clone(Obj) {\n  var buf;\n  if (Obj instanceof Array) {\n    buf = []; // 创建一个空的数组\n    var i = Obj.length;\n    while (i--) {\n      buf[i] = clone(Obj[i]);\n    }\n    return buf;\n  } else if (Obj instanceof Object) {\n    buf = {}; // 创建一个空对象\n    for (var k in Obj) {\n      // 为这个对象添加新的属性\n      buf[k] = clone(Obj[k]);\n    }\n    return buf;\n  } else {\n    return Obj;\n  }\n}\n```\n\n- js 对象的深度克隆代码实现 (2)\n\n```javascript\nfunction deepCopy(p, c) {\n  var c = c || {};\n  for (var i in p) {\n    if (typeof p[i] === \"object\") {\n      c[i] = p[i].constructor === Array ? [] : {};\n      deepCopy(p[i], c[i]);\n    } else {\n      c[i] = p[i];\n    }\n  }\n  return c;\n}\n```\n\n- js 操作获取和设置 cookie\n\n```javascript\n/*cookie的三种操作：读取，写入，删除*/\nvar CookieUtil = {\n  get: function(name) {\n    var cookieName = encodeURIComponent(name) + \"=\",\n      cookieStart = document.cookie.indexOf(cookieName),\n      cookieValue = null;\n    if (cookieStart > -1) {\n      var cookieEnd = document.cookie.indexOf(\";\", cookieStart);\n      if (cookieEnd == -1) {\n        cookieEnd = document.cookie.length;\n      }\n      cookieValue = decodeURIComponent(\n        document.cookie.substring(cookieStart + cookieName.length, cookieEnd)\n      );\n    }\n    return cookieValue;\n  },\n  set: function(name, value, expires, path, domain, secure) {\n    var cookieText = encodeURIComponent(name) + \"=\" + encodeURIComponent(value);\n    if (expires instanceof Date) {\n      cookieText += \";expires=\" + expires.toGMTString();\n    }\n    if (path) {\n      cookieText += \";path=\" + path;\n    }\n    if (domain) {\n      cookieText += \";domain=\" + domain;\n    }\n    if (secure) {\n      cookieText += \";secure\";\n    }\n    document.cookie = cookieText;\n  },\n  unset: function(name, path, domain, secure) {\n    this.set(name, \"\", new Date(0), path, domain, secure);\n  }\n};\n```\n\n- 介绍一下你对浏览器内核的理解？\n  主要分成两部分：渲染引擎(layout engineer 或 Rendering Engine)和 JS 引擎。\n  渲染引擎：负责取得网页的内容（HTML、XML、图像等等）、整理讯息（例如加入 CSS 等），以及计算网页的显示方式，然后会输出至显示器或打印机。浏览器的内核的不同对于网页的语法解释会有不同，所以渲染的效果也不相同。所有网页浏览器、电子邮件客户端以及其它需要编辑、显示网络内容的应用程序都需要内核。\n  JS 引擎则：解析和执行 javascript 来实现网页的动态效果。  \n  最开始渲染引擎和 JS 引擎并没有区分的很明确，后来 JS 引擎越来越独立，内核就倾向于只指渲染引擎。\n\n- 常见浏览器内核\n\n1. Trident 内核: ie\n2. Gecko 内核: ff\n3. Presto 内核: Opera7 及以上, 现 O 内核为 Blink\n4. Webkit 内核: Safari, Chrome, 现 C 内核为 Blink\n\n- xss 和 csrf\n\n1. xss(cross site-scripting)跨站脚本攻击, 在被攻击者的浏览器中执行脚本, 采集被攻击者数据. 如盗用 cookie; 以被攻击者的身份执行操作\n2. csrf 跨站请求伪造. 造成 csrf 需要两步, 第一登录受信任网站 a, 在本地生成 cookie, 第二不登出 a 的情况下访问危险网站 b.\n\n- String.prototype.replace()用法. 注意不会改变原字符串, 而是返回新字符串.\n\n1. str.replace(regexp|substr, newStr)\n2. str.replace(regexp|substr, function)\n\n```javascript\n// substr\nvar str = \"ac\";\nstr.replace(\"a\", \"b\"); // 'bc'\n\n// 1.\nvar str = \"Twas the night before Xmas...\";\nvar newstr = str.replace(/xmas/i, \"Christmas\");\nconsole.log(newstr); // Twas the night before Christmas...\n\n// 2.\nfunction styleHyphenFormat(propertyName) {\n  function upperToHyphenLower(match) {\n    return \"-\" + match.toLowerCase();\n  }\n  return propertyName.replace(/[A-Z]/g, upperToHyphenLower);\n}\nstyleHyphenFormat(\"borderTop\"); // border-top\n```\n\n- JavaScript 的定义\n  JavaScript 是一种专门为与网页交互而设计的脚本语言。有下列三部分组成\n\n1. ECMAScript，提供核心语言功能\n2. 文档对象模型（DOM），提供访问与操作网页内容的方法与接口\n3. 浏览器对象模型（BOM），提供与浏览器交互的方法与接口\n\n- javascript 的 typeof 返回哪些数据类型\n  Object(对象, null) number string function boolean underfind (es6 symbol);\n\n- ajax 请求的时候 get 和 post 方式的区别?\n\n1. get 方法放在 url 后面, 不能大于 2kb, post 方法放在 http 消息的实体内容发送\n2. 安全问题, get 安全性低, post 安全性高\n\n- 图片懒加载原理\n  页面加载后只让文档可视区内的图片显示，其它不显示，随着用户对页面的滚动，判断其区域位置，生成 img 标签，让到可视区的图片加载出来\n\n- 谈谈 This 对象的理解\n\n1. this 是 js 的一个关键字, 随着函数使用场合不同, this 的值会发生变化.\n2. 但是有一个总原则, 那就是 this 指的是调用函数的那个对象.\n3. this 一般情况下: 是全局对象 Global. 作为方法调用, 那么 this 就是指这个对象\n\n- JSONP 原理\n  ajax 请求受同源策略影响，不允许进行跨域请求，而 script 标签 src 属性中的链接却可以访问跨域的 js 脚本，利用这个特性，服务端不再返回 JSON 格式的数据，而是返回一段调用某个函数的 js 代码，在 src 中进行了调用，这样实现了跨域。\n\n- ajax 的过程是怎样的\n\n1. 创建 XMLHttpRequest 对象,也就是创建一个异步调用对象\n2. 创建一个新的 HTTP 请求,并指定该 HTTP 请求的方法、URL 及验证信息\n3. 设置响应 HTTP 请求状态变化的函数\n4. 发送 HTTP 请求\n5. 获取异步调用返回的数据\n6. 使用 JavaScript 和 DOM 实现局部刷新\n\n- 详解单页面路由的几种实现原理\n\n1. url 完全不动型. 这一种的情况是 url 完全不动, 即你的页面怎么改变, 怎么跳转 url 都不会改变, 这种情况的原理就是纯 ajax 拿到页面后替换原页面中的元素.\n2. 带 hash(#)型. 这种类型的优点就是刷新页面, 页面也不会丢. 通过监听 hash(#)的变化来执行 js 代码, 从而实现页面的改变. 主要需要用到 hashchange 事件.\n\n```JavaScript\nwindow.addEventListener('hashchange', () => {\n  // 改变节点\n})\n```\n\n3. 无 hash(#)型. 这种类型是通过 html5 的最新 history api 来实现的能正常的回退前进. url 和普通的 url 一样, 但缺点就是一刷新页面页面就会丢失.\n\n```JavaScript\n主要需要用到history.pushState,\nhistory.replaceState, // 不会记录到历史栈\nhistory.state,\nwindow.onpopstate事件.\nwindow.addEventListener('popstate', () => {\n  // 更新节点\n})\n```\n\n- js 跨域的实现方法原理\n\n1. 通过 jsonp. 有个 a.html 页面, 假设这个 json 数据地址是http://example.com/data.php\n\n```javascript\n// a.html\n<script>\nfunction doSomething (jsondata) {\n  // 处理获得的data数据\n}\n</script>\n<script src='http://example.com/data.php?callback=doSomething'></script>\n// 也可以是php文件返回一个js函数的调用, 如 echo 'doSomething(...)', 这样就不用在url写callback\n// jsonp跨域缺点: 只支持get请求, 安全隐患, 必须双方都受信任.\n```\n\n2. 通过修改 document.domain 来跨子域. 比如，有一个页面, 它的地址是http://www.example.com/a.html, 在这个页面里面有一个 iframe, 它的 src 是http://example.com/b.html.\n\n```javascript\n// a.html与它里面的iframe框架是不同域的, 无法通过在页面中书写js代码来获取iframe中的东西\n<script>\nfunction onLoad () {\n  var iframe = document.getElementById('iframe');\n  var win = iframe.contentWindow;\n  var doc = win.document;  // 获取不到iframe里的document对象\n  var name = win.name;     // 获取不到\n}\n</script>\n<iframe id='iframe' src='http://example.com/b.html' onload = 'onLoad()'></iframe>\n```\n\n这时候, 只要把http://www.example.com/a.html和http://example.com/b.html的document.domain设成相同的. document.domain 只能往自身或更低一级的域. eg: a.b.example.com 可以设成 a.b.example.com、b.example.com、example.com 中的任意一个, 不能设 c.a.b.example.com.\n\n```javascript\n// a.html\n<iframe id='iframe' src='http://example.com/b.html' onload = 'onLoad()'></iframe>\n<script>\ndocument.domain = 'example.com'\nfunction onLoad() { ... }\n</script>\n\n// b.html\n<script>\ndocument.domain = 'example.com'\n</script>\n\n//domain缺点: 安全性, 当一个页面被攻击后, 另一个有安全隐患; 如果有多个iframe, 就要设置成大家都相同的domain\n```\n\n3. window.name. 把需要的值替换成 window.name 的值. 如 www.example.com/a.html, 需要 www.cnblogs.com/data.html 里的数据, 需要 iframe 充当中间人, 来获取 data.HTML 的数据, a.html 再去获取 iframe 获取到的数据, 这里注意 a.html 和 iframe 需要同源即可\n\n```JavaScript\nfunction getData () {\n  var iframe = document.getElementById('iframe');\n  iframe.onload = function () {\n    var data = iframe.contentWindow.name;\n    console.log(data);\n  }\n  iframe.src = 'http://www.example.com/b.html'; // 与a.html同源\n}\n<iframe id='iframe' src = 'http://www.cnblogs.com/data.html' style='display:none' onload = getData() ></iframe>\n// window.name缺点: window.name的值是字符串形式, 最大只能2M左右\n```\n\n4. HTML5 的 window.postMessage(message,targetOrigin)方法. 可以使用它来向其它的 window 对象发送消息, 无论这个 window 对象是属于同源或不同源. 该方法的第一个参数 message 为要发送的消息, 类型只能为字符串; 第二个参数 targetOrigin 用来限定接收消息的那个 window 对象所在的域, 如果不想限定域, 可以使用通配符 \\*\n\n```JavaScript\n// a.html\n<script>\nfunction onLoad() {\n  var iframe = document.getElementById('iframe');\n  var win = iframe.contentWindow;\n  win.postMessage('hello world', *);\n}\n</script>\n<iframe id='iframe' src='http://www.example.com/b.html' onload = onLoad() ></iframe>\n\n// b.html\n<script>\nwindow.onmessage = function (e) {\n  e = e || event;\n  console.log(e.data)  // hello world\n}\n</script>\n// h5方法缺点: IE6、IE7不支持\n```\n\n5. 服务端的方法 http 请求包含 Access-Control-Allow-Origin.\n\n- 因为引用计数产生的内存泄漏，在 ES6 中的解决办法是什么？\n  ES6 考虑到了这一点，推出了两种新的数据结构：WeakSet 和 WeakMap。它们对于值的引用都是不计入垃圾回收机制的，所以名字里面才会有一个”Weak”，表示这是弱引用。\n\n- js 中基本类型在内存中存储方式是什么，引用类型的存储方式是什么\n  基本类型在内存中占据固定大小的空间, 因此变量和值都存在栈中, 引用类型的存储方式是栈中存变量和堆内存地址, 堆里面是引用类型. 原因是因为引用类型是可扩展的, 内存可大可小, 内存不能给每一个引用类型都开一个新的空间, 采用指针引用科学很多.\n\n- 渐进增强和优雅降级\n  渐进增强（Progressive Enhancement）：一开始就针对低版本浏览器进行构建页面，完成基本的功能，然后再针对高级浏览器进行效果、交互、追加功能达到更好的体验。  \n  优雅降级（Graceful Degradation）：一开始就构建站点的完整功能，然后针对浏览器测试和修复。比如一开始使用 CSS3 的特性构建了一个应用，然后逐步针对各大浏览器进行 hack 使其可以在低版本浏览器上正常浏览。\n\n- 手写一个 jsonp\n\n```javascript\n(function(window, document) {\n  \"use strict\";\n  var jsonp = function(url, data, callback) {\n    // 1.将传入的data数据转化为url字符串形式\n    // {id:1,name:'zhangsan'} => id=1&name=zhangsan\n    var dataString = url.indexof(\"?\") == -1 ? \"?\" : \"&\";\n    for (var key in data) {\n      dataString += key + \"=\" + data[key] + \"&\";\n    }\n\n    // 2 处理url中的回调函数\n    // cbFuncName回调函数的名字 ：my_json_cb_名字的前缀 + 随机数（把小数点去掉）\n    var cbFuncName =\n      \"my_json_cb_\" +\n      Math.random()\n        .toString()\n        .replace(\".\", \"\");\n    dataString += \"callback=\" + cbFuncName;\n\n    // 3.创建一个script标签并插入到页面中\n    var scriptEle = document.createElement(\"script\");\n    scriptEle.src = url + dataString;\n\n    // 4.挂载回调函数\n    window[cbFuncName] = function(data) {\n      callback(data);\n      // 处理完回调函数的数据之后，删除jsonp的script标签\n      document.body.removeChild(scriptEle);\n    };\n\n    // 5.append到页面中\n    document.body.appendChild(scriptEle);\n  };\n\n  // 因为jsonp是一个私有函数外部不能调用，所有jsonp函数作文window对象的一个方法，供外部调用\n  window.$jsonp = jsonp;\n})(window, document);\n```\n\n### VUE\n\n- Vue 双向数据绑定的实现\n  vue 中有一个 observer 来观察所有的属性的变化, 一旦有变化, 就会发给 watcher, 然后 watcher 来告诉编译器 complie 来改变数值\n\n- vue 和其他两个框架的区别\n\n1. vue 更轻量级, gzip 后大小只有 20+k, react 有 40+k, angular 有 50+k. 移动端 vue 更适合\n2. vue 学习曲线平稳, angular 入门较难, 概念多, 因为其思想很多沿用后端技术, react 需要学很多, 附带全家桶.\n3. vue 吸收另外两家之长, 既有 angular 的指令, 也有 react 的组件化思想.\n\n- vue.js 的核心思想\n\n1. 数据驱动\n2. 组件化\n\n- 数据响应原理\n  有一个数据 a.b,在 vue 对象实例化过程中，会给 a,b 通过 ES5 的 defineProperty()方法，添加 getter 和 setter 方法，同时 vue.js 会对模板做编译，解析生成一个指令对象，比如 v-text 指令，每个指令对象都会关联一个 watcher，当对指令对象求值时，就会触发 getter，并将依赖收集到 watcher 中；当再次改变 a.b 值时，就会触发 setter 方法，会通知到对应关联的 watcher,watcher 则再次对 a.b 求值，计算对比新旧值，当值改变时，watcher 会通知到指令，调用指令的 update 方法，由于指令是对 dom 的封装，所以会调用原生 dom 的方法，去更新视图。\n\n- vue-loader 是什么？使用它的用途有哪些？\n  解析.vue 文件的一个加载器，跟 template/js/style 转换成 js 模块。\n  用途：js 可以写 es6、style 样式可以 scss 或 less、template 可以加 jade 等\n\n- vue 生命周期总共有几个阶段？\n  它可以总共分为 8 个阶段：创建前/后, 载入前/后,更新前/后,销毁前/销毁后\n\n- 简单描述每个周期具体适合哪些场景？\n  生命周期钩子的一些使用方法：  \n  beforecreate : 可以在这加个 loading 事件，在加载实例时触发  \n  created : 初始化完成时的事件写在这里，如在这结束 loading 事件，异步请求也适宜在这里调用  \n  mounted : 挂载元素，获取到 DOM 节点  \n  updated : 如果对数据统一处理，在这里写上相应函数  \n  beforeDestroy : 可以做一个确认停止事件的确认框  \n  nextTick : 更新数据后立即操作 dom\n\n### 移动端 bug\n\n- fixed 遮罩滚动穿透问题\n\n```JavaScript\n// 1.touchmove + preventDefault\nmask.addEventListener('touchmove', (e) {\n  e.preventDefault()\n}, false)\n// 缺点, 当弹出层需要滚动时也会被阻止\n\n// 2.position +js保存滚动条位置\n// css\n.mask {\n  position: fixed;\n  width: 100%;\n}\n\n// js\n// 遮罩开启时保存当前滚动位置, 关闭时还原之前滚动位置\n```\n\n- 移动设备忽略将页面中的数字识别为电话号码的方法\n  在 head 里面加一个\n\n```html\n<meta name=\"format-detection\" content=\"telephone=no\" />\n```\n\n即可, 响应的还可以有 email=no 让邮箱不可点击.\n\n- 上下拉动滚动条时卡顿、慢\n\n```css\nbody {\n  -webkit-overflow-scrolling: touch;\n  overflow-scrolling: touch;\n}\n```\n\n- 禁止复制、选中文本\n\n```css\nelement {\n  -webkit-user-select: none;\n  -moz-user-select: none;\n  -khtml-user-select: none;\n  user-select: none;\n}\n```\n\n### 计网\n\n- 在浏览器中输入 URL 并回车后都发生了什么?\n\n1. 解析 URL\n2. DNS 解析\n3. 浏览器与网站建立 TCP 连接（三次握手）\n4. 请求和传输数据\n5. 浏览器渲染页面\n\n- http 强缓存和协商缓存\n  所谓的强缓存就是本地缓存. 浏览器第一次请求时, 一定是强缓存, 返回状态码 200; 第二次请求时, 会先获取该资源缓存的 header 信息(cache-control, expires; cache-control 与 expires 同时存在的话，cache-control 的优先级高于 expires), 两者都符合成立的话就不去服务器请求, 直接拿本地的缓存. 如果上面两个不成立, 就会发送请求到服务器(Etag/if-none-match, Last-modified/if-modified-since; Last-Modified 与 ETag 是可以一起使用的，服务器会优先验证 ETag，一致的情况下，才会继续比对 Last-Modified，最后才决定是否返回 304。), 由服务器根据请求中的相关 header 信息来对比结果是否协商缓存成立, 二者如果有一个和服务器上的不一致, 那就重新返回资源, 如果都没变化则返回 304 not modified, 浏览器收到 304 后, 从本地缓存中加载资源.\n\n- HTTP2 与 1.1 区别\n\n1. HTTP2.0 采用二进制格式而非文本格式（二进制解析更加高效，错误更少）\n2. HTTP2 是完全的多路复用（能同时传输多个请求和响应）\n3. 使用报头压缩，降低了开销\n4. 可以让服务器主动把响应推送到客户端\n\n- HTTP1.0 与 1.1 区别\n  HTTP 1.0 规定浏览器与服务器只保持短暂的连接，浏览器的每次请求都需要与服务器建立一个 TCP 连接，服务器完成请求处理后立即断开 TCP 连接，服务器不跟踪每个客户也不记录过去的请求。但是，这也造成了一些性能上的缺陷，例如，一个包含有许多图像的网页文件中并没有包含真正的图像数据内容，而只是指明了这些图像的 URL 地址，当 WEB 浏览器访问这个网页文件时，浏览器首先要发出针对该网页文件的请求，当浏览器解析 WEB 服务器返回的该网页文档中的 HTML 内容时，发现其中的<img>图像标签后，浏览器将根据<img>标签中的 src 属性所指定的 URL 地址再次向服务器发出下载图像数据的请求\n  HTTP 1.1 支持持久连接（connection 默认 keep-alive），在一个 TCP 连接上可以传送多个 HTTP 请求和响应，减少了建立和关闭连接的消耗和延迟。一个包含有许多图像的网页文件的多个请求和应答可以在一个连接中传输，但每个单独的网页文件的请求和应答仍然需要使用各自的连接。  在 HTTP1.0 和 HTTP1.1 协议中都有对长连接的支持。其中 HTTP1.0 需要在 request 中增加”Connection： keep-alive“ header 才能够支持，而 HTTP1.1 默认支持.\n  HTTP 1.1 还允许客户端不用等待上一次请求结果返回，就可以发出下一次请求（流水线处理），但服务器端必须按照接收到客户端请求的先后顺序依次回送响应结果，以保证客户端能够区分出每次请求的响应内容，这样也显著地减少了整个下载过程所需要的时间。\n\n- HTTP 与 HTTPS\n  HTTP 协议传输的数据都是未加密的，也就是明文的，因此使用 HTTP 协议传输隐私信息非常不安全，为了保证这些隐私数据能加密传输，于是网景公司设计了 SSL（Secure Sockets Layer）协议用于对 HTTP 协议传输的数据进行加密，从而就诞生了 HTTPS。简单来说，HTTPS 协议是由 SSL+HTTP 协议构建的可进行加密传输、身份认证的网络协议，要比 http 协议安全。HTTPS 使用不同于 HTTP 协议的默认端口及一个加密、身份验证层（HTTP 与 TCP 之间）\n  　　 HTTPS 和 HTTP 的区别主要如下：\n  　　 1、https 协议需要到 ca 申请证书，一般免费证书较少，因而需要一定费用。\n  　　 2、http 是超文本传输协议，信息是明文传输，https 则是具有安全性的 ssl 加密传输协议。\n  　　 3、http 和 https 使用的是完全不同的连接方式，用的端口也不一样，前者是 80，后者是 443。\n  　　 4、http 的连接很简单，是无状态的；HTTPS 协议是由 SSL+HTTP 协议构建的可进行加密传输、身份认证的网络协议，比 http 协议安全。\n\n虽然说 HTTPS 有很大的优势，但其相对来说，还是存在不足之处的：\n　　（1）HTTPS 协议握手阶段比较费时，会使页面的加载时间延长近 50%，增加 10%到 20%的耗电；\n　　（2）HTTPS 连接缓存不如 HTTP 高效，会增加数据开销和功耗，甚至已有的安全措施也会因此而受到影响；\n　　（3）SSL 证书需要钱，功能越强大的证书费用越高，个人网站、小网站没有必要一般不会用。\n　 （4）SSL 证书通常需要绑定 IP，不能在同一 IP 上绑定多个域名，IPv4 资源不可能支撑这个消耗。\n　　（5）HTTPS 协议的加密范围也比较有限，在黑客攻击、拒绝服务攻击、服务器劫持等方面几乎起不到什么作用。最关键的，SSL 证书的信用链体系并不安全，特别是在某些国家可以控制 CA 根证书的情况下，中间人攻击一样可行。\n\n客户端在使用 HTTPS 方式与 Web 服务器通信时有以下几个步骤，如图所示。（先非对称，在对称）\n　　（1）客户使用 https 的 URL 访问 Web 服务器，要求与 Web 服务器建立 SSL 连接。\n　　（2）Web 服务器收到客户端请求后，会将网站的证书信息（证书中包含公钥）传送一份给客户端。\n　　（3）客户端的浏览器与 Web 服务器开始协商 SSL 连接的安全等级，也就是信息加密的等级。\n　　（4）客户端的浏览器根据双方同意的安全等级，建立会话密钥，然后利用网站的公钥将会话密钥加密，并传送给网站。\n　　（5）Web 服务器利用自己的私钥解密出会话密钥。\n（6）Web 服务器利用会话密钥加密与客户端之间的通信。\n\n### 数据结构\n\n- 两个队列实现一个栈\n  A 队列作为主队列, B 队列. 判断 A 队列长度是否为 1, 如果是直接出队列. 如果不是, 出(长度-1)队列到 B 队列里, 然后最后一个出队列, 依次列推\n\n- 两个栈实现一个队列\n  入栈都给 A 栈, 要出栈时判断 B 栈是否为空, 为空, 将 A 栈全部 pop 后, push 到 B 栈, 然后 B 栈顺序 pop. 如果不为空, 将 B 栈里的先 pop.\n\n- 有哪些数据结构\n  图, 树, 线性, 集合.\n\n### 操作系统\n\n- 线程和进程的区别和联系\n  线程是 CPU 调度的一个基本单位; 进程是资源分配的基本单位.  \n  两者的联系: 进程和线程都是操作系统所运行的程序运行的基本单元.  \n  区别：  \n  （1）进程具有独立的空间地址，一个进程崩溃后，在保护模式下不会对其它进程产生影响。  \n  （2）线程只是一个进程的不同执行路径，线程有自己的堆栈和局部变量，但线程之间没有单独的地址空间，一个线程死掉就等于整个进程死掉。\n","slug":"我收集的一些基础面试题","published":1,"updated":"2021-07-02T03:20:30.662Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl5sb8gha003dxq0r4hip8tp3","content":"<h5 id=\"写在前面\"><a href=\"#写在前面\" class=\"headerlink\" title=\"写在前面\"></a>写在前面</h5><p>我收集的也有我遇到过的面试题, 会持续更新.</p>\n<h3 id=\"HTML\"><a href=\"#HTML\" class=\"headerlink\" title=\"HTML\"></a>HTML</h3><ul>\n<li>前端工程化的理解<br>模块化、组件化、规范化、自动化</li>\n</ul>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">1.模块化 将文件拆分成互相依赖的小文件, 多人协作开发后, 再进行统一的拼装. js模块化 commonjs amd cmd</span><br><span class=\"line\">css模块化 命名风格. 在类前加规范, 如布局(grid)(.g-xxx) 功能(function)(.f-xxx) 2.组件化</span><br><span class=\"line\">每个包含html+css+js完备的单元, 成为组件 3.规范化 目录结构的确定, 前后端接口规范, 组件命名规范</span><br><span class=\"line\">commit描述规范 4.自动化 简单的机械劳动, 让机器帮我们完成. 线上发布 =&gt; 使用脚本 图片<span class=\"tag\">&lt;<span class=\"name\">20kb</span> =&gt;</span></span><br><span class=\"line\">webpack转base64</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>如何 html 中开启和关闭 dns 预读取</li>\n</ul>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">&lt;!-- on打开 off关闭 --&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">meta</span> <span class=\"attr\">http-equiv</span>=<span class=\"string\">\"x-dns-prefetch-control\"</span> <span class=\"attr\">content</span>=<span class=\"string\">\"off\"</span> /&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">&lt;!-- 方法二 通过link的rel属性 --&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">link</span> <span class=\"attr\">rel</span>=<span class=\"string\">\"dns-prefetch\"</span> <span class=\"attr\">href</span>=<span class=\"string\">\"//\"</span> /&gt;</span></span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>doctype 的作用</li>\n</ul>\n<ol>\n<li>告知浏览器的解析器用什么文档标准解析这个文档, doctype 不存在或不正确会导致文档以怪异模式呈现</li>\n</ol>\n<ul>\n<li>前端渲染和后端渲染的区别</li>\n</ul>\n<ol>\n<li>后端渲染优势: 开发速度快, 不涉及前端交互; seo 友好度较高, 能够一次性渲染页面, 利于搜索引擎抓取. 劣势: 可维护性差, 因为是一次性渲染页面; 编码效率低, 前后端代码混在一起; 无法进行跨平台开发.</li>\n<li>前端渲染优势: 端口分离, 专注于前端; 可维护性高; 跨平台; 响应速度快. 劣势: 不利于 seo 优化; 首次开发成本较高; 安全性低.</li>\n</ol>\n<ul>\n<li>canvas 和 svg 在绘图有哪些优劣</li>\n</ul>\n<ol>\n<li>canvas 依赖分辨率; 不支持事件处理器; 弱的文本渲染能力; 能够以 .png 或 .jpg 格式保存结果图像; 最适合图像密集型的游戏，其中的许多对象会被频繁重绘</li>\n<li>svg 不依赖分辨率; 支持事件处理器; 最适合带有大型渲染区域的应用程序（比如谷歌地图）; 复杂度高会减慢渲染速度（任何过度使用 DOM 的应用都不快）; 不适合游戏应用</li>\n</ol>\n<a id=\"more\"></a>\n\n<ul>\n<li>常见行内元素, 块级元素, 空(void)元素有哪些?</li>\n</ul>\n<ol>\n<li>行内元素: a, b, span, img, input, label, select, strong</li>\n<li>块级元素: p, div, h1-h6, ul, li</li>\n<li>空元素: 没有内容的 HTML 元素被称为空元素, 是在开始标签中关闭的. br, hr, img, meta, link, input</li>\n</ol>\n<ul>\n<li>HTML5 新增了哪些内容或 API, 使用过哪些</li>\n</ul>\n<ol>\n<li>用于绘图的 canvas;</li>\n<li>用于媒体的 video, audio 标签;</li>\n<li>语义化更好的 article section 等标签;</li>\n<li>用于表单控件的 email, number, date;</li>\n<li>针对 cookie 的不足出现的本地离线存储;</li>\n<li>API 有 contextmenu 可以自定义右键菜单, 允许获取用户的地理位置 getCurrentPosition()</li>\n</ol>\n<ul>\n<li>input 和 textarea 的区别<br>区别就是一个是只能单行输入, 还有 size 可以指定 input 的长度. 一个是多行输入, cols rows 指定整个 textarea 的大小.</li>\n</ul>\n<ul>\n<li>用一个 div 模拟 textarea 的实现<br>需要用到不常见的 html5 属性 contenteditable, 这是内容可编辑的意思,</li>\n</ul>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">contenteditable</span>=<span class=\"string\">\"true\"</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n<p>这样 div 区域内就可以编辑.</p>\n<div contenteditable=\"true\">这一个div可编辑</div>\n\n<h3 id=\"CSS\"><a href=\"#CSS\" class=\"headerlink\" title=\"CSS\"></a>CSS</h3><ul>\n<li>纯 css 实现三角形的方法(三种)</li>\n</ul>\n<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">1. <span class=\"selector-tag\">border</span></span><br><span class=\"line\">2. 利用\"◆\"字符</span><br><span class=\"line\">3. <span class=\"selector-tag\">css3</span>旋转<span class=\"selector-tag\">div</span> <span class=\"selector-tag\">transfrom</span> <span class=\"selector-tag\">rotate</span>(45<span class=\"selector-tag\">deg</span>)</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>CSS 隐藏元素的几种方法（至少说出三种）</li>\n</ul>\n<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-tag\">opacity</span>: 元素本身依然占据它自己的位置并对网页的布局起作用。它也将响应用户交互;</span><br><span class=\"line\"><span class=\"selector-tag\">visibility</span>: 与 <span class=\"selector-tag\">opacity</span> 唯一不同的是它不会响应任何用户交互。此外，元素在读屏软件中也会被隐藏;</span><br><span class=\"line\"><span class=\"selector-tag\">display</span>: <span class=\"selector-tag\">display</span> 设为 <span class=\"selector-tag\">none</span></span><br><span class=\"line\">  任何对该元素直接打用户交互操作都不可能生效。此外，读屏软件也不会读到元素的内容。这种方式产生的效果就像元素完全不存在;</span><br><span class=\"line\"><span class=\"selector-tag\">position</span>: 不会影响布局，能让元素保持可以操作;</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>CSS 清除浮动的几种方法（至少两种）</li>\n</ul>\n<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">使用带clear属性的空元素 // 在浮动元素后添加一个空元素div.clear</span><br><span class=\"line\">使用CSS的overflow属性；// 父元素设置overflow: hidden即可</span><br><span class=\"line\">使用CSS的:after伪元素；// 最常见</span><br><span class=\"line\"></span><br><span class=\"line\">&lt;div class=\"news clearfix\"&gt;</span><br><span class=\"line\">  &lt;img src=\"news-pic.jpg\" /&gt;</span><br><span class=\"line\">  &lt;p&gt;some text&lt;/p&gt;</span><br><span class=\"line\">&lt;/div&gt;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"selector-class\">.news</span> <span class=\"selector-tag\">img</span> &#123;</span><br><span class=\"line\">  <span class=\"attribute\">float</span>: left;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"selector-class\">.news</span> <span class=\"selector-tag\">p</span> &#123;</span><br><span class=\"line\">  <span class=\"attribute\">float</span>: right;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"selector-class\">.clearfix</span><span class=\"selector-pseudo\">:after</span> &#123;</span><br><span class=\"line\">  <span class=\"attribute\">content</span>: <span class=\"string\">\"020\"</span>;</span><br><span class=\"line\">  <span class=\"attribute\">display</span>: block;</span><br><span class=\"line\">  <span class=\"attribute\">height</span>: <span class=\"number\">0</span>;</span><br><span class=\"line\">  <span class=\"attribute\">clear</span>: both;</span><br><span class=\"line\">  <span class=\"attribute\">visibility</span>: hidden;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"selector-class\">.clearfix</span> &#123;</span><br><span class=\"line\">  <span class=\"comment\">/* 触发 hasLayout, 兼容 ie6 7  */</span></span><br><span class=\"line\">  <span class=\"attribute\">zoom</span>: <span class=\"number\">1</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>页面导入样式时，使用 link 和@import 有什么区别？</li>\n</ul>\n<ol>\n<li>link 属于 XHTML 标签, 除了加载 CSS 外, 还能用于定义 RSS, 定义 rel 连接属性等作用; 而@import 是 CSS 提供的, 只能用于加载 CSS;</li>\n<li>页面被加载的时, link 会同时被加载, 而@import 引用的 CSS 会等到页面被加载完再加载;</li>\n</ol>\n<ul>\n<li>介绍一下 CSS 的盒子模型？</li>\n</ul>\n<ol>\n<li>有两种, IE 盒子模型、标准 W3C 盒子模型; IE 的 content 部分包含了 border 和 padding; width, height = border+padding+content;</li>\n<li>盒模型: 内容(content)、填充(padding)、边界(margin)、 边框(border). width, height = content;</li>\n</ol>\n<ul>\n<li>左右布局：左边定宽、右边自适应, 不少于 3 种方法</li>\n</ul>\n<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;aside class='left'&gt;&lt;/aside&gt;</span><br><span class=\"line\">&lt;section class='right'&gt;&lt;/section&gt;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"selector-tag\">aside</span> &#123;</span><br><span class=\"line\">  <span class=\"attribute\">width</span>: <span class=\"number\">200px</span>;</span><br><span class=\"line\">  <span class=\"attribute\">height</span>: <span class=\"number\">200px</span>;</span><br><span class=\"line\">  <span class=\"attribute\">background</span>: <span class=\"number\">#f00</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"selector-tag\">section</span> &#123;</span><br><span class=\"line\">  <span class=\"attribute\">height</span>: <span class=\"number\">200px</span>;</span><br><span class=\"line\">  <span class=\"attribute\">background</span>: <span class=\"number\">#0f0</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">1. 左边左浮动, 右边宽100%</span><br><span class=\"line\"><span class=\"selector-class\">.left</span> &#123;</span><br><span class=\"line\">  <span class=\"attribute\">float</span>: left;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"selector-class\">.right</span> &#123;</span><br><span class=\"line\">  <span class=\"attribute\">width</span>: <span class=\"number\">100%</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">2. 父元素<span class=\"selector-tag\">flex</span>布局, 右边<span class=\"selector-tag\">flex</span><span class=\"selector-pseudo\">:1</span></span><br><span class=\"line\"><span class=\"selector-tag\">body</span> &#123;</span><br><span class=\"line\">  <span class=\"attribute\">display</span>: flex;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"selector-class\">.right</span> &#123;</span><br><span class=\"line\">  flex: 1; // 通过设置 flex 的数值来控制所占空间的比例</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">3. 设置浮动, 用<span class=\"selector-tag\">calc</span>给右边宽度</span><br><span class=\"line\"><span class=\"selector-class\">.left</span>, <span class=\"selector-class\">.right</span> &#123;</span><br><span class=\"line\">  <span class=\"attribute\">float</span>: left;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"selector-class\">.right</span> &#123;</span><br><span class=\"line\">  width: calc(100% - 200px); // 200px是左边盒子的宽度</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">4. margin负值法 (圣杯/双飞翼)</span><br><span class=\"line\">这里要注意自适应的<span class=\"selector-tag\">div</span>要放在前面, 定宽放后面</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li><p>CSS3 用过哪些新特性<br>动画@keyframes, animation, transtion, box-shadow, text-shadow 等, 详情可看我的简述 CSS3 的一些属性系列</p>\n</li>\n<li><p>BFC、IFC<br>BFC: block formatting context 块级格式化上下文, 即块级作用域</p>\n</li>\n</ul>\n<figure class=\"highlight\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// 满足以下一项即可成为BFC</span><br><span class=\"line\">float: left | right</span><br><span class=\"line\">position: fixed | absolute</span><br><span class=\"line\">display: inline-block | table-cell | table-caption | flex | inline-flex</span><br><span class=\"line\">overflow: hidden | scroll | auto</span><br></pre></td></tr></table></figure>\n\n<p>用 BFC 来做什么:1.外边距折叠; 2.容器无高度包含浮动元素; 3.阻止文字环绕<br>IFC: inline formatting context 内联格式化上下文<br>用 IFC 来做什么:1.水平居中: 当一个块要在环境中水平居中时, 设置其为 inline-block 则会在外层产生 IFC, 通过 text-align 则可以使其水平居中; 2.垂直居中: 创建一个 IFC, 用其中一个元素撑开父元素的高度, 然后设置其 vertical-align:middle, 其他行内元素则可以在此父元素下垂直居中;</p>\n<ul>\n<li><p>对栅格的理解<br>栅格 12 列, 为什么取 12, 12 是 1, 2, 3, 4, 6 的最小公倍数. 栅格是通过一系列行 row 和列 col-xx-xx 的组合来创建页面布局的系统.</p>\n</li>\n<li><p>（水平）居中有哪些实现方式</p>\n</li>\n</ul>\n<ol>\n<li>需要居中的元素是块元素的话, 只需要 margin: 0 auto;</li>\n<li>如果是内联元素, 需要 display 成内联块, 然后父元素 text-align: center 即可.</li>\n</ol>\n<ul>\n<li>display:none 和 visibility:hidden 有什么区别</li>\n</ul>\n<ol>\n<li>显示区域: display 设置为 none 后不会占据空间, visibility:hidden 会保留空间;</li>\n<li>reflow 回流和 repaint 重绘: display 因为改变元素位置, 会触发 relow 和 repaint, visibility 没有改变其位置, 只会触发 repaint;</li>\n<li>子元素的显示: display 为 none 后子元素无论设置什么属性都会被连同隐藏, visibility 不同, 其子元素可以用 visibility:visible 来显示.</li>\n</ol>\n<h3 id=\"JS\"><a href=\"#JS\" class=\"headerlink\" title=\"JS\"></a>JS</h3><ul>\n<li>cookie 和 session 的区别</li>\n</ul>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"number\">1.</span>cookie存在客户端, session存在服务端</span><br><span class=\"line\"><span class=\"number\">2.</span>session依赖session id, 而session id存于cookie, 如果禁用cookie, session也会失效. 除非在url里加session id验证</span><br><span class=\"line\"><span class=\"number\">3.</span>session存放在服务器的文件里, cookie存于浏览器</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>NodeJS 的优缺点</li>\n</ul>\n<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">优点：</span><br><span class=\"line\">1. 高并发（最重要的优点）</span><br><span class=\"line\"></span><br><span class=\"line\">2. 适合I/O密集型应用</span><br><span class=\"line\"></span><br><span class=\"line\">缺点：</span><br><span class=\"line\">1. 不适合CPU密集型应用；CPU密集型应用给Node带来的挑战主要是：由于JavaScript单线程的原因，如果有长时间运行的计算（比如大循环），将会导致CPU时间片不能释放，使得后续I/O无法发起；</span><br><span class=\"line\"></span><br><span class=\"line\">解决方案：分解大型运算任务为多个小任务，使得运算能够适时释放，不阻塞I/O调用的发起；</span><br><span class=\"line\"></span><br><span class=\"line\">2. 只支持单核<span class=\"selector-tag\">CPU</span>，不能充分利用<span class=\"selector-tag\">CPU</span></span><br><span class=\"line\"></span><br><span class=\"line\">3. 可靠性低，一旦代码某个环节崩溃，整个系统都崩溃</span><br><span class=\"line\"></span><br><span class=\"line\">原因：单进程，单线程</span><br><span class=\"line\"></span><br><span class=\"line\">解决方案：</span><br><span class=\"line\">（1）<span class=\"selector-tag\">Nnigx</span>反向代理，负载均衡，开多个进程，绑定多个端口；</span><br><span class=\"line\"></span><br><span class=\"line\">（2）开多个进程监听同一个端口，使用<span class=\"selector-tag\">cluster</span>模块；</span><br><span class=\"line\"></span><br><span class=\"line\">4. 开源组件库质量参差不齐，更新快，向下不兼容</span><br><span class=\"line\"></span><br><span class=\"line\">5. <span class=\"selector-tag\">Debug</span>不方便，错误没有<span class=\"selector-tag\">stack</span> <span class=\"selector-tag\">trace</span></span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>js 对象的深度克隆代码实现</li>\n</ul>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">clone</span>(<span class=\"params\">Obj</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> buf;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (Obj <span class=\"keyword\">instanceof</span> <span class=\"built_in\">Array</span>) &#123;</span><br><span class=\"line\">    buf = []; <span class=\"comment\">// 创建一个空的数组</span></span><br><span class=\"line\">    <span class=\"keyword\">var</span> i = Obj.length;</span><br><span class=\"line\">    <span class=\"keyword\">while</span> (i--) &#123;</span><br><span class=\"line\">      buf[i] = clone(Obj[i]);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> buf;</span><br><span class=\"line\">  &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (Obj <span class=\"keyword\">instanceof</span> <span class=\"built_in\">Object</span>) &#123;</span><br><span class=\"line\">    buf = &#123;&#125;; <span class=\"comment\">// 创建一个空对象</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">var</span> k <span class=\"keyword\">in</span> Obj) &#123;</span><br><span class=\"line\">      <span class=\"comment\">// 为这个对象添加新的属性</span></span><br><span class=\"line\">      buf[k] = clone(Obj[k]);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> buf;</span><br><span class=\"line\">  &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> Obj;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>js 对象的深度克隆代码实现 (2)</li>\n</ul>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">deepCopy</span>(<span class=\"params\">p, c</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> c = c || &#123;&#125;;</span><br><span class=\"line\">  <span class=\"keyword\">for</span> (<span class=\"keyword\">var</span> i <span class=\"keyword\">in</span> p) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (<span class=\"keyword\">typeof</span> p[i] === <span class=\"string\">\"object\"</span>) &#123;</span><br><span class=\"line\">      c[i] = p[i].constructor === <span class=\"built_in\">Array</span> ? [] : &#123;&#125;;</span><br><span class=\"line\">      deepCopy(p[i], c[i]);</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">      c[i] = p[i];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> c;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>js 操作获取和设置 cookie</li>\n</ul>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/*cookie的三种操作：读取，写入，删除*/</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> CookieUtil = &#123;</span><br><span class=\"line\">  <span class=\"keyword\">get</span>: function(name) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> cookieName = <span class=\"built_in\">encodeURIComponent</span>(name) + <span class=\"string\">\"=\"</span>,</span><br><span class=\"line\">      cookieStart = <span class=\"built_in\">document</span>.cookie.indexOf(cookieName),</span><br><span class=\"line\">      cookieValue = <span class=\"literal\">null</span>;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (cookieStart &gt; <span class=\"number\">-1</span>) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">var</span> cookieEnd = <span class=\"built_in\">document</span>.cookie.indexOf(<span class=\"string\">\";\"</span>, cookieStart);</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (cookieEnd == <span class=\"number\">-1</span>) &#123;</span><br><span class=\"line\">        cookieEnd = <span class=\"built_in\">document</span>.cookie.length;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      cookieValue = <span class=\"built_in\">decodeURIComponent</span>(</span><br><span class=\"line\">        <span class=\"built_in\">document</span>.cookie.substring(cookieStart + cookieName.length, cookieEnd)</span><br><span class=\"line\">      );</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> cookieValue;</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  <span class=\"keyword\">set</span>: function(name, value, expires, path, domain, secure) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> cookieText = <span class=\"built_in\">encodeURIComponent</span>(name) + <span class=\"string\">\"=\"</span> + <span class=\"built_in\">encodeURIComponent</span>(value);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (expires <span class=\"keyword\">instanceof</span> <span class=\"built_in\">Date</span>) &#123;</span><br><span class=\"line\">      cookieText += <span class=\"string\">\";expires=\"</span> + expires.toGMTString();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (path) &#123;</span><br><span class=\"line\">      cookieText += <span class=\"string\">\";path=\"</span> + path;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (domain) &#123;</span><br><span class=\"line\">      cookieText += <span class=\"string\">\";domain=\"</span> + domain;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (secure) &#123;</span><br><span class=\"line\">      cookieText += <span class=\"string\">\";secure\"</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"built_in\">document</span>.cookie = cookieText;</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  unset: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">name, path, domain, secure</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.set(name, <span class=\"string\">\"\"</span>, <span class=\"keyword\">new</span> <span class=\"built_in\">Date</span>(<span class=\"number\">0</span>), path, domain, secure);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li><p>介绍一下你对浏览器内核的理解？<br>主要分成两部分：渲染引擎(layout engineer 或 Rendering Engine)和 JS 引擎。<br>渲染引擎：负责取得网页的内容（HTML、XML、图像等等）、整理讯息（例如加入 CSS 等），以及计算网页的显示方式，然后会输出至显示器或打印机。浏览器的内核的不同对于网页的语法解释会有不同，所以渲染的效果也不相同。所有网页浏览器、电子邮件客户端以及其它需要编辑、显示网络内容的应用程序都需要内核。<br>JS 引擎则：解析和执行 javascript 来实现网页的动态效果。<br>最开始渲染引擎和 JS 引擎并没有区分的很明确，后来 JS 引擎越来越独立，内核就倾向于只指渲染引擎。</p>\n</li>\n<li><p>常见浏览器内核</p>\n</li>\n</ul>\n<ol>\n<li>Trident 内核: ie</li>\n<li>Gecko 内核: ff</li>\n<li>Presto 内核: Opera7 及以上, 现 O 内核为 Blink</li>\n<li>Webkit 内核: Safari, Chrome, 现 C 内核为 Blink</li>\n</ol>\n<ul>\n<li>xss 和 csrf</li>\n</ul>\n<ol>\n<li>xss(cross site-scripting)跨站脚本攻击, 在被攻击者的浏览器中执行脚本, 采集被攻击者数据. 如盗用 cookie; 以被攻击者的身份执行操作</li>\n<li>csrf 跨站请求伪造. 造成 csrf 需要两步, 第一登录受信任网站 a, 在本地生成 cookie, 第二不登出 a 的情况下访问危险网站 b.</li>\n</ol>\n<ul>\n<li>String.prototype.replace()用法. 注意不会改变原字符串, 而是返回新字符串.</li>\n</ul>\n<ol>\n<li>str.replace(regexp|substr, newStr)</li>\n<li>str.replace(regexp|substr, function)</li>\n</ol>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// substr</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> str = <span class=\"string\">\"ac\"</span>;</span><br><span class=\"line\">str.replace(<span class=\"string\">\"a\"</span>, <span class=\"string\">\"b\"</span>); <span class=\"comment\">// 'bc'</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 1.</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> str = <span class=\"string\">\"Twas the night before Xmas...\"</span>;</span><br><span class=\"line\"><span class=\"keyword\">var</span> newstr = str.replace(<span class=\"regexp\">/xmas/i</span>, <span class=\"string\">\"Christmas\"</span>);</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(newstr); <span class=\"comment\">// Twas the night before Christmas...</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 2.</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">styleHyphenFormat</span>(<span class=\"params\">propertyName</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">upperToHyphenLower</span>(<span class=\"params\">match</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"string\">\"-\"</span> + match.toLowerCase();</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> propertyName.replace(<span class=\"regexp\">/[A-Z]/g</span>, upperToHyphenLower);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">styleHyphenFormat(<span class=\"string\">\"borderTop\"</span>); <span class=\"comment\">// border-top</span></span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>JavaScript 的定义<br>JavaScript 是一种专门为与网页交互而设计的脚本语言。有下列三部分组成</li>\n</ul>\n<ol>\n<li>ECMAScript，提供核心语言功能</li>\n<li>文档对象模型（DOM），提供访问与操作网页内容的方法与接口</li>\n<li>浏览器对象模型（BOM），提供与浏览器交互的方法与接口</li>\n</ol>\n<ul>\n<li><p>javascript 的 typeof 返回哪些数据类型<br>Object(对象, null) number string function boolean underfind (es6 symbol);</p>\n</li>\n<li><p>ajax 请求的时候 get 和 post 方式的区别?</p>\n</li>\n</ul>\n<ol>\n<li>get 方法放在 url 后面, 不能大于 2kb, post 方法放在 http 消息的实体内容发送</li>\n<li>安全问题, get 安全性低, post 安全性高</li>\n</ol>\n<ul>\n<li><p>图片懒加载原理<br>页面加载后只让文档可视区内的图片显示，其它不显示，随着用户对页面的滚动，判断其区域位置，生成 img 标签，让到可视区的图片加载出来</p>\n</li>\n<li><p>谈谈 This 对象的理解</p>\n</li>\n</ul>\n<ol>\n<li>this 是 js 的一个关键字, 随着函数使用场合不同, this 的值会发生变化.</li>\n<li>但是有一个总原则, 那就是 this 指的是调用函数的那个对象.</li>\n<li>this 一般情况下: 是全局对象 Global. 作为方法调用, 那么 this 就是指这个对象</li>\n</ol>\n<ul>\n<li><p>JSONP 原理<br>ajax 请求受同源策略影响，不允许进行跨域请求，而 script 标签 src 属性中的链接却可以访问跨域的 js 脚本，利用这个特性，服务端不再返回 JSON 格式的数据，而是返回一段调用某个函数的 js 代码，在 src 中进行了调用，这样实现了跨域。</p>\n</li>\n<li><p>ajax 的过程是怎样的</p>\n</li>\n</ul>\n<ol>\n<li>创建 XMLHttpRequest 对象,也就是创建一个异步调用对象</li>\n<li>创建一个新的 HTTP 请求,并指定该 HTTP 请求的方法、URL 及验证信息</li>\n<li>设置响应 HTTP 请求状态变化的函数</li>\n<li>发送 HTTP 请求</li>\n<li>获取异步调用返回的数据</li>\n<li>使用 JavaScript 和 DOM 实现局部刷新</li>\n</ol>\n<ul>\n<li>详解单页面路由的几种实现原理</li>\n</ul>\n<ol>\n<li>url 完全不动型. 这一种的情况是 url 完全不动, 即你的页面怎么改变, 怎么跳转 url 都不会改变, 这种情况的原理就是纯 ajax 拿到页面后替换原页面中的元素.</li>\n<li>带 hash(#)型. 这种类型的优点就是刷新页面, 页面也不会丢. 通过监听 hash(#)的变化来执行 js 代码, 从而实现页面的改变. 主要需要用到 hashchange 事件.</li>\n</ol>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">window</span>.addEventListener(<span class=\"string\">'hashchange'</span>, () =&gt; &#123;</span><br><span class=\"line\">  <span class=\"comment\">// 改变节点</span></span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n\n<ol start=\"3\">\n<li>无 hash(#)型. 这种类型是通过 html5 的最新 history api 来实现的能正常的回退前进. url 和普通的 url 一样, 但缺点就是一刷新页面页面就会丢失.</li>\n</ol>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">主要需要用到history.pushState,</span><br><span class=\"line\">history.replaceState, <span class=\"comment\">// 不会记录到历史栈</span></span><br><span class=\"line\">history.state,</span><br><span class=\"line\"><span class=\"built_in\">window</span>.onpopstate事件.</span><br><span class=\"line\"><span class=\"built_in\">window</span>.addEventListener(<span class=\"string\">'popstate'</span>, () =&gt; &#123;</span><br><span class=\"line\">  <span class=\"comment\">// 更新节点</span></span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>js 跨域的实现方法原理</li>\n</ul>\n<ol>\n<li>通过 jsonp. 有个 a.html 页面, 假设这个 json 数据地址是<a href=\"http://example.com/data.php\" target=\"_blank\" rel=\"noopener\">http://example.com/data.php</a></li>\n</ol>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// a.html</span></span><br><span class=\"line\">&lt;script&gt;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">doSomething</span> (<span class=\"params\">jsondata</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">// 处理获得的data数据</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\">&lt;<span class=\"regexp\">/script&gt;</span></span><br><span class=\"line\"><span class=\"regexp\">&lt;script src='http:/</span><span class=\"regexp\">/example.com/</span>data.php?callback=doSomething<span class=\"string\">'&gt;&lt;/script&gt;</span></span><br><span class=\"line\"><span class=\"string\">// 也可以是php文件返回一个js函数的调用, 如 echo '</span>doSomething(...)<span class=\"string\">', 这样就不用在url写callback</span></span><br><span class=\"line\"><span class=\"string\">// jsonp跨域缺点: 只支持get请求, 安全隐患, 必须双方都受信任.</span></span><br></pre></td></tr></table></figure>\n\n<ol start=\"2\">\n<li>通过修改 document.domain 来跨子域. 比如，有一个页面, 它的地址是<a href=\"http://www.example.com/a.html\" target=\"_blank\" rel=\"noopener\">http://www.example.com/a.html</a>, 在这个页面里面有一个 iframe, 它的 src 是<a href=\"http://example.com/b.html\" target=\"_blank\" rel=\"noopener\">http://example.com/b.html</a>.</li>\n</ol>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// a.html与它里面的iframe框架是不同域的, 无法通过在页面中书写js代码来获取iframe中的东西</span></span><br><span class=\"line\">&lt;script&gt;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">onLoad</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> iframe = <span class=\"built_in\">document</span>.getElementById(<span class=\"string\">'iframe'</span>);</span><br><span class=\"line\">  <span class=\"keyword\">var</span> win = iframe.contentWindow;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> doc = win.document;  <span class=\"comment\">// 获取不到iframe里的document对象</span></span><br><span class=\"line\">  <span class=\"keyword\">var</span> name = win.name;     <span class=\"comment\">// 获取不到</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\">&lt;<span class=\"regexp\">/script&gt;</span></span><br><span class=\"line\"><span class=\"regexp\">&lt;iframe id='iframe' src='http:/</span><span class=\"regexp\">/example.com/</span>b.html<span class=\"string\">' onload = '</span>onLoad()<span class=\"string\">'&gt;&lt;/iframe&gt;</span></span><br></pre></td></tr></table></figure>\n\n<p>这时候, 只要把<a href=\"http://www.example.com/a.html和http://example.com/b.html的document.domain设成相同的\" target=\"_blank\" rel=\"noopener\">http://www.example.com/a.html和http://example.com/b.html的document.domain设成相同的</a>. document.domain 只能往自身或更低一级的域. eg: a.b.example.com 可以设成 a.b.example.com、b.example.com、example.com 中的任意一个, 不能设 c.a.b.example.com.</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// a.html</span></span><br><span class=\"line\">&lt;iframe id=<span class=\"string\">'iframe'</span> src=<span class=\"string\">'http://example.com/b.html'</span> onload = <span class=\"string\">'onLoad()'</span>&gt;<span class=\"xml\"><span class=\"tag\">&lt;/<span class=\"name\">iframe</span>&gt;</span></span></span><br><span class=\"line\">&lt;script&gt;</span><br><span class=\"line\"><span class=\"built_in\">document</span>.domain = <span class=\"string\">'example.com'</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">onLoad</span>(<span class=\"params\"></span>) </span>&#123; ... &#125;</span><br><span class=\"line\">&lt;<span class=\"regexp\">/script&gt;</span></span><br><span class=\"line\"><span class=\"regexp\"></span></span><br><span class=\"line\"><span class=\"regexp\">/</span><span class=\"regexp\">/ b.html</span></span><br><span class=\"line\"><span class=\"regexp\">&lt;script&gt;</span></span><br><span class=\"line\"><span class=\"regexp\">document.domain = 'example.com'</span></span><br><span class=\"line\"><span class=\"regexp\">&lt;/</span>script&gt;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//domain缺点: 安全性, 当一个页面被攻击后, 另一个有安全隐患; 如果有多个iframe, 就要设置成大家都相同的domain</span></span><br></pre></td></tr></table></figure>\n\n<ol start=\"3\">\n<li>window.name. 把需要的值替换成 window.name 的值. 如 <a href=\"http://www.example.com/a.html\" target=\"_blank\" rel=\"noopener\">www.example.com/a.html</a>, 需要 <a href=\"http://www.cnblogs.com/data.html\" target=\"_blank\" rel=\"noopener\">www.cnblogs.com/data.html</a> 里的数据, 需要 iframe 充当中间人, 来获取 data.HTML 的数据, a.html 再去获取 iframe 获取到的数据, 这里注意 a.html 和 iframe 需要同源即可</li>\n</ol>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">getData</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> iframe = <span class=\"built_in\">document</span>.getElementById(<span class=\"string\">'iframe'</span>);</span><br><span class=\"line\">  iframe.onload = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> data = iframe.contentWindow.name;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(data);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  iframe.src = <span class=\"string\">'http://www.example.com/b.html'</span>; <span class=\"comment\">// 与a.html同源</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\">&lt;iframe id=<span class=\"string\">'iframe'</span> src = <span class=\"string\">'http://www.cnblogs.com/data.html'</span> style=<span class=\"string\">'display:none'</span> onload = getData() &gt;<span class=\"xml\"><span class=\"tag\">&lt;/<span class=\"name\">iframe</span>&gt;</span></span></span><br><span class=\"line\"><span class=\"comment\">// window.name缺点: window.name的值是字符串形式, 最大只能2M左右</span></span><br></pre></td></tr></table></figure>\n\n<ol start=\"4\">\n<li>HTML5 的 window.postMessage(message,targetOrigin)方法. 可以使用它来向其它的 window 对象发送消息, 无论这个 window 对象是属于同源或不同源. 该方法的第一个参数 message 为要发送的消息, 类型只能为字符串; 第二个参数 targetOrigin 用来限定接收消息的那个 window 对象所在的域, 如果不想限定域, 可以使用通配符 *</li>\n</ol>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// a.html</span></span><br><span class=\"line\">&lt;script&gt;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">onLoad</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> iframe = <span class=\"built_in\">document</span>.getElementById(<span class=\"string\">'iframe'</span>);</span><br><span class=\"line\">  <span class=\"keyword\">var</span> win = iframe.contentWindow;</span><br><span class=\"line\">  win.postMessage(<span class=\"string\">'hello world'</span>, *);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">&lt;<span class=\"regexp\">/script&gt;</span></span><br><span class=\"line\"><span class=\"regexp\">&lt;iframe id='iframe' src='http:/</span><span class=\"regexp\">/www.example.com/</span>b.html<span class=\"string\">' onload = onLoad() &gt;&lt;/iframe&gt;</span></span><br><span class=\"line\"><span class=\"string\"></span></span><br><span class=\"line\"><span class=\"string\">// b.html</span></span><br><span class=\"line\"><span class=\"string\">&lt;script&gt;</span></span><br><span class=\"line\"><span class=\"string\">window.onmessage = function (e) &#123;</span></span><br><span class=\"line\"><span class=\"string\">  e = e || event;</span></span><br><span class=\"line\"><span class=\"string\">  console.log(e.data)  // hello world</span></span><br><span class=\"line\"><span class=\"string\">&#125;</span></span><br><span class=\"line\"><span class=\"string\">&lt;/script&gt;</span></span><br><span class=\"line\"><span class=\"string\">// h5方法缺点: IE6、IE7不支持</span></span><br></pre></td></tr></table></figure>\n\n<ol start=\"5\">\n<li>服务端的方法 http 请求包含 Access-Control-Allow-Origin.</li>\n</ol>\n<ul>\n<li><p>因为引用计数产生的内存泄漏，在 ES6 中的解决办法是什么？<br>ES6 考虑到了这一点，推出了两种新的数据结构：WeakSet 和 WeakMap。它们对于值的引用都是不计入垃圾回收机制的，所以名字里面才会有一个”Weak”，表示这是弱引用。</p>\n</li>\n<li><p>js 中基本类型在内存中存储方式是什么，引用类型的存储方式是什么<br>基本类型在内存中占据固定大小的空间, 因此变量和值都存在栈中, 引用类型的存储方式是栈中存变量和堆内存地址, 堆里面是引用类型. 原因是因为引用类型是可扩展的, 内存可大可小, 内存不能给每一个引用类型都开一个新的空间, 采用指针引用科学很多.</p>\n</li>\n<li><p>渐进增强和优雅降级<br>渐进增强（Progressive Enhancement）：一开始就针对低版本浏览器进行构建页面，完成基本的功能，然后再针对高级浏览器进行效果、交互、追加功能达到更好的体验。<br>优雅降级（Graceful Degradation）：一开始就构建站点的完整功能，然后针对浏览器测试和修复。比如一开始使用 CSS3 的特性构建了一个应用，然后逐步针对各大浏览器进行 hack 使其可以在低版本浏览器上正常浏览。</p>\n</li>\n<li><p>手写一个 jsonp</p>\n</li>\n</ul>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">window, document</span>) </span>&#123;</span><br><span class=\"line\"><span class=\"meta\">  \"use strict\"</span>;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> jsonp = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">url, data, callback</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 1.将传入的data数据转化为url字符串形式</span></span><br><span class=\"line\">    <span class=\"comment\">// &#123;id:1,name:'zhangsan'&#125; =&gt; id=1&amp;name=zhangsan</span></span><br><span class=\"line\">    <span class=\"keyword\">var</span> dataString = url.indexof(<span class=\"string\">\"?\"</span>) == <span class=\"number\">-1</span> ? <span class=\"string\">\"?\"</span> : <span class=\"string\">\"&amp;\"</span>;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">var</span> key <span class=\"keyword\">in</span> data) &#123;</span><br><span class=\"line\">      dataString += key + <span class=\"string\">\"=\"</span> + data[key] + <span class=\"string\">\"&amp;\"</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 2 处理url中的回调函数</span></span><br><span class=\"line\">    <span class=\"comment\">// cbFuncName回调函数的名字 ：my_json_cb_名字的前缀 + 随机数（把小数点去掉）</span></span><br><span class=\"line\">    <span class=\"keyword\">var</span> cbFuncName =</span><br><span class=\"line\">      <span class=\"string\">\"my_json_cb_\"</span> +</span><br><span class=\"line\">      <span class=\"built_in\">Math</span>.random()</span><br><span class=\"line\">        .toString()</span><br><span class=\"line\">        .replace(<span class=\"string\">\".\"</span>, <span class=\"string\">\"\"</span>);</span><br><span class=\"line\">    dataString += <span class=\"string\">\"callback=\"</span> + cbFuncName;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 3.创建一个script标签并插入到页面中</span></span><br><span class=\"line\">    <span class=\"keyword\">var</span> scriptEle = <span class=\"built_in\">document</span>.createElement(<span class=\"string\">\"script\"</span>);</span><br><span class=\"line\">    scriptEle.src = url + dataString;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 4.挂载回调函数</span></span><br><span class=\"line\">    <span class=\"built_in\">window</span>[cbFuncName] = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">data</span>) </span>&#123;</span><br><span class=\"line\">      callback(data);</span><br><span class=\"line\">      <span class=\"comment\">// 处理完回调函数的数据之后，删除jsonp的script标签</span></span><br><span class=\"line\">      <span class=\"built_in\">document</span>.body.removeChild(scriptEle);</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 5.append到页面中</span></span><br><span class=\"line\">    <span class=\"built_in\">document</span>.body.appendChild(scriptEle);</span><br><span class=\"line\">  &#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// 因为jsonp是一个私有函数外部不能调用，所有jsonp函数作文window对象的一个方法，供外部调用</span></span><br><span class=\"line\">  <span class=\"built_in\">window</span>.$jsonp = jsonp;</span><br><span class=\"line\">&#125;)(<span class=\"built_in\">window</span>, <span class=\"built_in\">document</span>);</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"VUE\"><a href=\"#VUE\" class=\"headerlink\" title=\"VUE\"></a>VUE</h3><ul>\n<li><p>Vue 双向数据绑定的实现<br>vue 中有一个 observer 来观察所有的属性的变化, 一旦有变化, 就会发给 watcher, 然后 watcher 来告诉编译器 complie 来改变数值</p>\n</li>\n<li><p>vue 和其他两个框架的区别</p>\n</li>\n</ul>\n<ol>\n<li>vue 更轻量级, gzip 后大小只有 20+k, react 有 40+k, angular 有 50+k. 移动端 vue 更适合</li>\n<li>vue 学习曲线平稳, angular 入门较难, 概念多, 因为其思想很多沿用后端技术, react 需要学很多, 附带全家桶.</li>\n<li>vue 吸收另外两家之长, 既有 angular 的指令, 也有 react 的组件化思想.</li>\n</ol>\n<ul>\n<li>vue.js 的核心思想</li>\n</ul>\n<ol>\n<li>数据驱动</li>\n<li>组件化</li>\n</ol>\n<ul>\n<li><p>数据响应原理<br>有一个数据 a.b,在 vue 对象实例化过程中，会给 a,b 通过 ES5 的 defineProperty()方法，添加 getter 和 setter 方法，同时 vue.js 会对模板做编译，解析生成一个指令对象，比如 v-text 指令，每个指令对象都会关联一个 watcher，当对指令对象求值时，就会触发 getter，并将依赖收集到 watcher 中；当再次改变 a.b 值时，就会触发 setter 方法，会通知到对应关联的 watcher,watcher 则再次对 a.b 求值，计算对比新旧值，当值改变时，watcher 会通知到指令，调用指令的 update 方法，由于指令是对 dom 的封装，所以会调用原生 dom 的方法，去更新视图。</p>\n</li>\n<li><p>vue-loader 是什么？使用它的用途有哪些？<br>解析.vue 文件的一个加载器，跟 template/js/style 转换成 js 模块。<br>用途：js 可以写 es6、style 样式可以 scss 或 less、template 可以加 jade 等</p>\n</li>\n<li><p>vue 生命周期总共有几个阶段？<br>它可以总共分为 8 个阶段：创建前/后, 载入前/后,更新前/后,销毁前/销毁后</p>\n</li>\n<li><p>简单描述每个周期具体适合哪些场景？<br>生命周期钩子的一些使用方法：<br>beforecreate : 可以在这加个 loading 事件，在加载实例时触发<br>created : 初始化完成时的事件写在这里，如在这结束 loading 事件，异步请求也适宜在这里调用<br>mounted : 挂载元素，获取到 DOM 节点<br>updated : 如果对数据统一处理，在这里写上相应函数<br>beforeDestroy : 可以做一个确认停止事件的确认框<br>nextTick : 更新数据后立即操作 dom</p>\n</li>\n</ul>\n<h3 id=\"移动端-bug\"><a href=\"#移动端-bug\" class=\"headerlink\" title=\"移动端 bug\"></a>移动端 bug</h3><ul>\n<li>fixed 遮罩滚动穿透问题</li>\n</ul>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 1.touchmove + preventDefault</span></span><br><span class=\"line\">mask.addEventListener(<span class=\"string\">'touchmove'</span>, (e) &#123;</span><br><span class=\"line\">  e.preventDefault()</span><br><span class=\"line\">&#125;, <span class=\"literal\">false</span>)</span><br><span class=\"line\"><span class=\"comment\">// 缺点, 当弹出层需要滚动时也会被阻止</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 2.position +js保存滚动条位置</span></span><br><span class=\"line\"><span class=\"comment\">// css</span></span><br><span class=\"line\">.mask &#123;</span><br><span class=\"line\">  position: fixed;</span><br><span class=\"line\">  width: <span class=\"number\">100</span>%;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// js</span></span><br><span class=\"line\"><span class=\"comment\">// 遮罩开启时保存当前滚动位置, 关闭时还原之前滚动位置</span></span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>移动设备忽略将页面中的数字识别为电话号码的方法<br>在 head 里面加一个</li>\n</ul>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">meta</span> <span class=\"attr\">name</span>=<span class=\"string\">\"format-detection\"</span> <span class=\"attr\">content</span>=<span class=\"string\">\"telephone=no\"</span> /&gt;</span></span><br></pre></td></tr></table></figure>\n\n<p>即可, 响应的还可以有 email=no 让邮箱不可点击.</p>\n<ul>\n<li>上下拉动滚动条时卡顿、慢</li>\n</ul>\n<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-tag\">body</span> &#123;</span><br><span class=\"line\">  <span class=\"attribute\">-webkit-overflow-scrolling</span>: touch;</span><br><span class=\"line\">  <span class=\"attribute\">overflow-scrolling</span>: touch;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>禁止复制、选中文本</li>\n</ul>\n<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-tag\">element</span> &#123;</span><br><span class=\"line\">  <span class=\"attribute\">-webkit-user-select</span>: none;</span><br><span class=\"line\">  <span class=\"attribute\">-moz-user-select</span>: none;</span><br><span class=\"line\">  <span class=\"attribute\">-khtml-user-select</span>: none;</span><br><span class=\"line\">  <span class=\"attribute\">user-select</span>: none;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"计网\"><a href=\"#计网\" class=\"headerlink\" title=\"计网\"></a>计网</h3><ul>\n<li>在浏览器中输入 URL 并回车后都发生了什么?</li>\n</ul>\n<ol>\n<li>解析 URL</li>\n<li>DNS 解析</li>\n<li>浏览器与网站建立 TCP 连接（三次握手）</li>\n<li>请求和传输数据</li>\n<li>浏览器渲染页面</li>\n</ol>\n<ul>\n<li><p>http 强缓存和协商缓存<br>所谓的强缓存就是本地缓存. 浏览器第一次请求时, 一定是强缓存, 返回状态码 200; 第二次请求时, 会先获取该资源缓存的 header 信息(cache-control, expires; cache-control 与 expires 同时存在的话，cache-control 的优先级高于 expires), 两者都符合成立的话就不去服务器请求, 直接拿本地的缓存. 如果上面两个不成立, 就会发送请求到服务器(Etag/if-none-match, Last-modified/if-modified-since; Last-Modified 与 ETag 是可以一起使用的，服务器会优先验证 ETag，一致的情况下，才会继续比对 Last-Modified，最后才决定是否返回 304。), 由服务器根据请求中的相关 header 信息来对比结果是否协商缓存成立, 二者如果有一个和服务器上的不一致, 那就重新返回资源, 如果都没变化则返回 304 not modified, 浏览器收到 304 后, 从本地缓存中加载资源.</p>\n</li>\n<li><p>HTTP2 与 1.1 区别</p>\n</li>\n</ul>\n<ol>\n<li>HTTP2.0 采用二进制格式而非文本格式（二进制解析更加高效，错误更少）</li>\n<li>HTTP2 是完全的多路复用（能同时传输多个请求和响应）</li>\n<li>使用报头压缩，降低了开销</li>\n<li>可以让服务器主动把响应推送到客户端</li>\n</ol>\n<ul>\n<li><p>HTTP1.0 与 1.1 区别<br>HTTP 1.0 规定浏览器与服务器只保持短暂的连接，浏览器的每次请求都需要与服务器建立一个 TCP 连接，服务器完成请求处理后立即断开 TCP 连接，服务器不跟踪每个客户也不记录过去的请求。但是，这也造成了一些性能上的缺陷，例如，一个包含有许多图像的网页文件中并没有包含真正的图像数据内容，而只是指明了这些图像的 URL 地址，当 WEB 浏览器访问这个网页文件时，浏览器首先要发出针对该网页文件的请求，当浏览器解析 WEB 服务器返回的该网页文档中的 HTML 内容时，发现其中的<img>图像标签后，浏览器将根据<img>标签中的 src 属性所指定的 URL 地址再次向服务器发出下载图像数据的请求<br>HTTP 1.1 支持持久连接（connection 默认 keep-alive），在一个 TCP 连接上可以传送多个 HTTP 请求和响应，减少了建立和关闭连接的消耗和延迟。一个包含有许多图像的网页文件的多个请求和应答可以在一个连接中传输，但每个单独的网页文件的请求和应答仍然需要使用各自的连接。  在 HTTP1.0 和 HTTP1.1 协议中都有对长连接的支持。其中 HTTP1.0 需要在 request 中增加”Connection： keep-alive“ header 才能够支持，而 HTTP1.1 默认支持.<br>HTTP 1.1 还允许客户端不用等待上一次请求结果返回，就可以发出下一次请求（流水线处理），但服务器端必须按照接收到客户端请求的先后顺序依次回送响应结果，以保证客户端能够区分出每次请求的响应内容，这样也显著地减少了整个下载过程所需要的时间。</p>\n</li>\n<li><p>HTTP 与 HTTPS<br>HTTP 协议传输的数据都是未加密的，也就是明文的，因此使用 HTTP 协议传输隐私信息非常不安全，为了保证这些隐私数据能加密传输，于是网景公司设计了 SSL（Secure Sockets Layer）协议用于对 HTTP 协议传输的数据进行加密，从而就诞生了 HTTPS。简单来说，HTTPS 协议是由 SSL+HTTP 协议构建的可进行加密传输、身份认证的网络协议，要比 http 协议安全。HTTPS 使用不同于 HTTP 协议的默认端口及一个加密、身份验证层（HTTP 与 TCP 之间）<br>　　 HTTPS 和 HTTP 的区别主要如下：<br>　　 1、https 协议需要到 ca 申请证书，一般免费证书较少，因而需要一定费用。<br>　　 2、http 是超文本传输协议，信息是明文传输，https 则是具有安全性的 ssl 加密传输协议。<br>　　 3、http 和 https 使用的是完全不同的连接方式，用的端口也不一样，前者是 80，后者是 443。<br>　　 4、http 的连接很简单，是无状态的；HTTPS 协议是由 SSL+HTTP 协议构建的可进行加密传输、身份认证的网络协议，比 http 协议安全。</p>\n</li>\n</ul>\n<p>虽然说 HTTPS 有很大的优势，但其相对来说，还是存在不足之处的：<br>　　（1）HTTPS 协议握手阶段比较费时，会使页面的加载时间延长近 50%，增加 10%到 20%的耗电；<br>　　（2）HTTPS 连接缓存不如 HTTP 高效，会增加数据开销和功耗，甚至已有的安全措施也会因此而受到影响；<br>　　（3）SSL 证书需要钱，功能越强大的证书费用越高，个人网站、小网站没有必要一般不会用。<br>　 （4）SSL 证书通常需要绑定 IP，不能在同一 IP 上绑定多个域名，IPv4 资源不可能支撑这个消耗。<br>　　（5）HTTPS 协议的加密范围也比较有限，在黑客攻击、拒绝服务攻击、服务器劫持等方面几乎起不到什么作用。最关键的，SSL 证书的信用链体系并不安全，特别是在某些国家可以控制 CA 根证书的情况下，中间人攻击一样可行。</p>\n<p>客户端在使用 HTTPS 方式与 Web 服务器通信时有以下几个步骤，如图所示。（先非对称，在对称）<br>　　（1）客户使用 https 的 URL 访问 Web 服务器，要求与 Web 服务器建立 SSL 连接。<br>　　（2）Web 服务器收到客户端请求后，会将网站的证书信息（证书中包含公钥）传送一份给客户端。<br>　　（3）客户端的浏览器与 Web 服务器开始协商 SSL 连接的安全等级，也就是信息加密的等级。<br>　　（4）客户端的浏览器根据双方同意的安全等级，建立会话密钥，然后利用网站的公钥将会话密钥加密，并传送给网站。<br>　　（5）Web 服务器利用自己的私钥解密出会话密钥。<br>（6）Web 服务器利用会话密钥加密与客户端之间的通信。</p>\n<h3 id=\"数据结构\"><a href=\"#数据结构\" class=\"headerlink\" title=\"数据结构\"></a>数据结构</h3><ul>\n<li><p>两个队列实现一个栈<br>A 队列作为主队列, B 队列. 判断 A 队列长度是否为 1, 如果是直接出队列. 如果不是, 出(长度-1)队列到 B 队列里, 然后最后一个出队列, 依次列推</p>\n</li>\n<li><p>两个栈实现一个队列<br>入栈都给 A 栈, 要出栈时判断 B 栈是否为空, 为空, 将 A 栈全部 pop 后, push 到 B 栈, 然后 B 栈顺序 pop. 如果不为空, 将 B 栈里的先 pop.</p>\n</li>\n<li><p>有哪些数据结构<br>图, 树, 线性, 集合.</p>\n</li>\n</ul>\n<h3 id=\"操作系统\"><a href=\"#操作系统\" class=\"headerlink\" title=\"操作系统\"></a>操作系统</h3><ul>\n<li>线程和进程的区别和联系<br>线程是 CPU 调度的一个基本单位; 进程是资源分配的基本单位.<br>两者的联系: 进程和线程都是操作系统所运行的程序运行的基本单元.<br>区别：<br>（1）进程具有独立的空间地址，一个进程崩溃后，在保护模式下不会对其它进程产生影响。<br>（2）线程只是一个进程的不同执行路径，线程有自己的堆栈和局部变量，但线程之间没有单独的地址空间，一个线程死掉就等于整个进程死掉。</li>\n</ul>\n","site":{"data":{}},"excerpt":"<h5 id=\"写在前面\"><a href=\"#写在前面\" class=\"headerlink\" title=\"写在前面\"></a>写在前面</h5><p>我收集的也有我遇到过的面试题, 会持续更新.</p>\n<h3 id=\"HTML\"><a href=\"#HTML\" class=\"headerlink\" title=\"HTML\"></a>HTML</h3><ul>\n<li>前端工程化的理解<br>模块化、组件化、规范化、自动化</li>\n</ul>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">1.模块化 将文件拆分成互相依赖的小文件, 多人协作开发后, 再进行统一的拼装. js模块化 commonjs amd cmd</span><br><span class=\"line\">css模块化 命名风格. 在类前加规范, 如布局(grid)(.g-xxx) 功能(function)(.f-xxx) 2.组件化</span><br><span class=\"line\">每个包含html+css+js完备的单元, 成为组件 3.规范化 目录结构的确定, 前后端接口规范, 组件命名规范</span><br><span class=\"line\">commit描述规范 4.自动化 简单的机械劳动, 让机器帮我们完成. 线上发布 =&gt; 使用脚本 图片<span class=\"tag\">&lt;<span class=\"name\">20kb</span> =&gt;</span></span><br><span class=\"line\">webpack转base64</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>如何 html 中开启和关闭 dns 预读取</li>\n</ul>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">&lt;!-- on打开 off关闭 --&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">meta</span> <span class=\"attr\">http-equiv</span>=<span class=\"string\">\"x-dns-prefetch-control\"</span> <span class=\"attr\">content</span>=<span class=\"string\">\"off\"</span> /&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">&lt;!-- 方法二 通过link的rel属性 --&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">link</span> <span class=\"attr\">rel</span>=<span class=\"string\">\"dns-prefetch\"</span> <span class=\"attr\">href</span>=<span class=\"string\">\"//\"</span> /&gt;</span></span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>doctype 的作用</li>\n</ul>\n<ol>\n<li>告知浏览器的解析器用什么文档标准解析这个文档, doctype 不存在或不正确会导致文档以怪异模式呈现</li>\n</ol>\n<ul>\n<li>前端渲染和后端渲染的区别</li>\n</ul>\n<ol>\n<li>后端渲染优势: 开发速度快, 不涉及前端交互; seo 友好度较高, 能够一次性渲染页面, 利于搜索引擎抓取. 劣势: 可维护性差, 因为是一次性渲染页面; 编码效率低, 前后端代码混在一起; 无法进行跨平台开发.</li>\n<li>前端渲染优势: 端口分离, 专注于前端; 可维护性高; 跨平台; 响应速度快. 劣势: 不利于 seo 优化; 首次开发成本较高; 安全性低.</li>\n</ol>\n<ul>\n<li>canvas 和 svg 在绘图有哪些优劣</li>\n</ul>\n<ol>\n<li>canvas 依赖分辨率; 不支持事件处理器; 弱的文本渲染能力; 能够以 .png 或 .jpg 格式保存结果图像; 最适合图像密集型的游戏，其中的许多对象会被频繁重绘</li>\n<li>svg 不依赖分辨率; 支持事件处理器; 最适合带有大型渲染区域的应用程序（比如谷歌地图）; 复杂度高会减慢渲染速度（任何过度使用 DOM 的应用都不快）; 不适合游戏应用</li>\n</ol>","more":"<ul>\n<li>常见行内元素, 块级元素, 空(void)元素有哪些?</li>\n</ul>\n<ol>\n<li>行内元素: a, b, span, img, input, label, select, strong</li>\n<li>块级元素: p, div, h1-h6, ul, li</li>\n<li>空元素: 没有内容的 HTML 元素被称为空元素, 是在开始标签中关闭的. br, hr, img, meta, link, input</li>\n</ol>\n<ul>\n<li>HTML5 新增了哪些内容或 API, 使用过哪些</li>\n</ul>\n<ol>\n<li>用于绘图的 canvas;</li>\n<li>用于媒体的 video, audio 标签;</li>\n<li>语义化更好的 article section 等标签;</li>\n<li>用于表单控件的 email, number, date;</li>\n<li>针对 cookie 的不足出现的本地离线存储;</li>\n<li>API 有 contextmenu 可以自定义右键菜单, 允许获取用户的地理位置 getCurrentPosition()</li>\n</ol>\n<ul>\n<li>input 和 textarea 的区别<br>区别就是一个是只能单行输入, 还有 size 可以指定 input 的长度. 一个是多行输入, cols rows 指定整个 textarea 的大小.</li>\n</ul>\n<ul>\n<li>用一个 div 模拟 textarea 的实现<br>需要用到不常见的 html5 属性 contenteditable, 这是内容可编辑的意思,</li>\n</ul>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">contenteditable</span>=<span class=\"string\">\"true\"</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n<p>这样 div 区域内就可以编辑.</p>\n<div contenteditable=\"true\">这一个div可编辑</div>\n\n<h3 id=\"CSS\"><a href=\"#CSS\" class=\"headerlink\" title=\"CSS\"></a>CSS</h3><ul>\n<li>纯 css 实现三角形的方法(三种)</li>\n</ul>\n<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">1. <span class=\"selector-tag\">border</span></span><br><span class=\"line\">2. 利用\"◆\"字符</span><br><span class=\"line\">3. <span class=\"selector-tag\">css3</span>旋转<span class=\"selector-tag\">div</span> <span class=\"selector-tag\">transfrom</span> <span class=\"selector-tag\">rotate</span>(45<span class=\"selector-tag\">deg</span>)</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>CSS 隐藏元素的几种方法（至少说出三种）</li>\n</ul>\n<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-tag\">opacity</span>: 元素本身依然占据它自己的位置并对网页的布局起作用。它也将响应用户交互;</span><br><span class=\"line\"><span class=\"selector-tag\">visibility</span>: 与 <span class=\"selector-tag\">opacity</span> 唯一不同的是它不会响应任何用户交互。此外，元素在读屏软件中也会被隐藏;</span><br><span class=\"line\"><span class=\"selector-tag\">display</span>: <span class=\"selector-tag\">display</span> 设为 <span class=\"selector-tag\">none</span></span><br><span class=\"line\">  任何对该元素直接打用户交互操作都不可能生效。此外，读屏软件也不会读到元素的内容。这种方式产生的效果就像元素完全不存在;</span><br><span class=\"line\"><span class=\"selector-tag\">position</span>: 不会影响布局，能让元素保持可以操作;</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>CSS 清除浮动的几种方法（至少两种）</li>\n</ul>\n<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">使用带clear属性的空元素 // 在浮动元素后添加一个空元素div.clear</span><br><span class=\"line\">使用CSS的overflow属性；// 父元素设置overflow: hidden即可</span><br><span class=\"line\">使用CSS的:after伪元素；// 最常见</span><br><span class=\"line\"></span><br><span class=\"line\">&lt;div class=\"news clearfix\"&gt;</span><br><span class=\"line\">  &lt;img src=\"news-pic.jpg\" /&gt;</span><br><span class=\"line\">  &lt;p&gt;some text&lt;/p&gt;</span><br><span class=\"line\">&lt;/div&gt;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"selector-class\">.news</span> <span class=\"selector-tag\">img</span> &#123;</span><br><span class=\"line\">  <span class=\"attribute\">float</span>: left;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"selector-class\">.news</span> <span class=\"selector-tag\">p</span> &#123;</span><br><span class=\"line\">  <span class=\"attribute\">float</span>: right;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"selector-class\">.clearfix</span><span class=\"selector-pseudo\">:after</span> &#123;</span><br><span class=\"line\">  <span class=\"attribute\">content</span>: <span class=\"string\">\"020\"</span>;</span><br><span class=\"line\">  <span class=\"attribute\">display</span>: block;</span><br><span class=\"line\">  <span class=\"attribute\">height</span>: <span class=\"number\">0</span>;</span><br><span class=\"line\">  <span class=\"attribute\">clear</span>: both;</span><br><span class=\"line\">  <span class=\"attribute\">visibility</span>: hidden;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"selector-class\">.clearfix</span> &#123;</span><br><span class=\"line\">  <span class=\"comment\">/* 触发 hasLayout, 兼容 ie6 7  */</span></span><br><span class=\"line\">  <span class=\"attribute\">zoom</span>: <span class=\"number\">1</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>页面导入样式时，使用 link 和@import 有什么区别？</li>\n</ul>\n<ol>\n<li>link 属于 XHTML 标签, 除了加载 CSS 外, 还能用于定义 RSS, 定义 rel 连接属性等作用; 而@import 是 CSS 提供的, 只能用于加载 CSS;</li>\n<li>页面被加载的时, link 会同时被加载, 而@import 引用的 CSS 会等到页面被加载完再加载;</li>\n</ol>\n<ul>\n<li>介绍一下 CSS 的盒子模型？</li>\n</ul>\n<ol>\n<li>有两种, IE 盒子模型、标准 W3C 盒子模型; IE 的 content 部分包含了 border 和 padding; width, height = border+padding+content;</li>\n<li>盒模型: 内容(content)、填充(padding)、边界(margin)、 边框(border). width, height = content;</li>\n</ol>\n<ul>\n<li>左右布局：左边定宽、右边自适应, 不少于 3 种方法</li>\n</ul>\n<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;aside class='left'&gt;&lt;/aside&gt;</span><br><span class=\"line\">&lt;section class='right'&gt;&lt;/section&gt;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"selector-tag\">aside</span> &#123;</span><br><span class=\"line\">  <span class=\"attribute\">width</span>: <span class=\"number\">200px</span>;</span><br><span class=\"line\">  <span class=\"attribute\">height</span>: <span class=\"number\">200px</span>;</span><br><span class=\"line\">  <span class=\"attribute\">background</span>: <span class=\"number\">#f00</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"selector-tag\">section</span> &#123;</span><br><span class=\"line\">  <span class=\"attribute\">height</span>: <span class=\"number\">200px</span>;</span><br><span class=\"line\">  <span class=\"attribute\">background</span>: <span class=\"number\">#0f0</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">1. 左边左浮动, 右边宽100%</span><br><span class=\"line\"><span class=\"selector-class\">.left</span> &#123;</span><br><span class=\"line\">  <span class=\"attribute\">float</span>: left;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"selector-class\">.right</span> &#123;</span><br><span class=\"line\">  <span class=\"attribute\">width</span>: <span class=\"number\">100%</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">2. 父元素<span class=\"selector-tag\">flex</span>布局, 右边<span class=\"selector-tag\">flex</span><span class=\"selector-pseudo\">:1</span></span><br><span class=\"line\"><span class=\"selector-tag\">body</span> &#123;</span><br><span class=\"line\">  <span class=\"attribute\">display</span>: flex;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"selector-class\">.right</span> &#123;</span><br><span class=\"line\">  flex: 1; // 通过设置 flex 的数值来控制所占空间的比例</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">3. 设置浮动, 用<span class=\"selector-tag\">calc</span>给右边宽度</span><br><span class=\"line\"><span class=\"selector-class\">.left</span>, <span class=\"selector-class\">.right</span> &#123;</span><br><span class=\"line\">  <span class=\"attribute\">float</span>: left;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"selector-class\">.right</span> &#123;</span><br><span class=\"line\">  width: calc(100% - 200px); // 200px是左边盒子的宽度</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">4. margin负值法 (圣杯/双飞翼)</span><br><span class=\"line\">这里要注意自适应的<span class=\"selector-tag\">div</span>要放在前面, 定宽放后面</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li><p>CSS3 用过哪些新特性<br>动画@keyframes, animation, transtion, box-shadow, text-shadow 等, 详情可看我的简述 CSS3 的一些属性系列</p>\n</li>\n<li><p>BFC、IFC<br>BFC: block formatting context 块级格式化上下文, 即块级作用域</p>\n</li>\n</ul>\n<figure class=\"highlight\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// 满足以下一项即可成为BFC</span><br><span class=\"line\">float: left | right</span><br><span class=\"line\">position: fixed | absolute</span><br><span class=\"line\">display: inline-block | table-cell | table-caption | flex | inline-flex</span><br><span class=\"line\">overflow: hidden | scroll | auto</span><br></pre></td></tr></table></figure>\n\n<p>用 BFC 来做什么:1.外边距折叠; 2.容器无高度包含浮动元素; 3.阻止文字环绕<br>IFC: inline formatting context 内联格式化上下文<br>用 IFC 来做什么:1.水平居中: 当一个块要在环境中水平居中时, 设置其为 inline-block 则会在外层产生 IFC, 通过 text-align 则可以使其水平居中; 2.垂直居中: 创建一个 IFC, 用其中一个元素撑开父元素的高度, 然后设置其 vertical-align:middle, 其他行内元素则可以在此父元素下垂直居中;</p>\n<ul>\n<li><p>对栅格的理解<br>栅格 12 列, 为什么取 12, 12 是 1, 2, 3, 4, 6 的最小公倍数. 栅格是通过一系列行 row 和列 col-xx-xx 的组合来创建页面布局的系统.</p>\n</li>\n<li><p>（水平）居中有哪些实现方式</p>\n</li>\n</ul>\n<ol>\n<li>需要居中的元素是块元素的话, 只需要 margin: 0 auto;</li>\n<li>如果是内联元素, 需要 display 成内联块, 然后父元素 text-align: center 即可.</li>\n</ol>\n<ul>\n<li>display:none 和 visibility:hidden 有什么区别</li>\n</ul>\n<ol>\n<li>显示区域: display 设置为 none 后不会占据空间, visibility:hidden 会保留空间;</li>\n<li>reflow 回流和 repaint 重绘: display 因为改变元素位置, 会触发 relow 和 repaint, visibility 没有改变其位置, 只会触发 repaint;</li>\n<li>子元素的显示: display 为 none 后子元素无论设置什么属性都会被连同隐藏, visibility 不同, 其子元素可以用 visibility:visible 来显示.</li>\n</ol>\n<h3 id=\"JS\"><a href=\"#JS\" class=\"headerlink\" title=\"JS\"></a>JS</h3><ul>\n<li>cookie 和 session 的区别</li>\n</ul>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"number\">1.</span>cookie存在客户端, session存在服务端</span><br><span class=\"line\"><span class=\"number\">2.</span>session依赖session id, 而session id存于cookie, 如果禁用cookie, session也会失效. 除非在url里加session id验证</span><br><span class=\"line\"><span class=\"number\">3.</span>session存放在服务器的文件里, cookie存于浏览器</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>NodeJS 的优缺点</li>\n</ul>\n<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">优点：</span><br><span class=\"line\">1. 高并发（最重要的优点）</span><br><span class=\"line\"></span><br><span class=\"line\">2. 适合I/O密集型应用</span><br><span class=\"line\"></span><br><span class=\"line\">缺点：</span><br><span class=\"line\">1. 不适合CPU密集型应用；CPU密集型应用给Node带来的挑战主要是：由于JavaScript单线程的原因，如果有长时间运行的计算（比如大循环），将会导致CPU时间片不能释放，使得后续I/O无法发起；</span><br><span class=\"line\"></span><br><span class=\"line\">解决方案：分解大型运算任务为多个小任务，使得运算能够适时释放，不阻塞I/O调用的发起；</span><br><span class=\"line\"></span><br><span class=\"line\">2. 只支持单核<span class=\"selector-tag\">CPU</span>，不能充分利用<span class=\"selector-tag\">CPU</span></span><br><span class=\"line\"></span><br><span class=\"line\">3. 可靠性低，一旦代码某个环节崩溃，整个系统都崩溃</span><br><span class=\"line\"></span><br><span class=\"line\">原因：单进程，单线程</span><br><span class=\"line\"></span><br><span class=\"line\">解决方案：</span><br><span class=\"line\">（1）<span class=\"selector-tag\">Nnigx</span>反向代理，负载均衡，开多个进程，绑定多个端口；</span><br><span class=\"line\"></span><br><span class=\"line\">（2）开多个进程监听同一个端口，使用<span class=\"selector-tag\">cluster</span>模块；</span><br><span class=\"line\"></span><br><span class=\"line\">4. 开源组件库质量参差不齐，更新快，向下不兼容</span><br><span class=\"line\"></span><br><span class=\"line\">5. <span class=\"selector-tag\">Debug</span>不方便，错误没有<span class=\"selector-tag\">stack</span> <span class=\"selector-tag\">trace</span></span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>js 对象的深度克隆代码实现</li>\n</ul>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">clone</span>(<span class=\"params\">Obj</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> buf;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (Obj <span class=\"keyword\">instanceof</span> <span class=\"built_in\">Array</span>) &#123;</span><br><span class=\"line\">    buf = []; <span class=\"comment\">// 创建一个空的数组</span></span><br><span class=\"line\">    <span class=\"keyword\">var</span> i = Obj.length;</span><br><span class=\"line\">    <span class=\"keyword\">while</span> (i--) &#123;</span><br><span class=\"line\">      buf[i] = clone(Obj[i]);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> buf;</span><br><span class=\"line\">  &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (Obj <span class=\"keyword\">instanceof</span> <span class=\"built_in\">Object</span>) &#123;</span><br><span class=\"line\">    buf = &#123;&#125;; <span class=\"comment\">// 创建一个空对象</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">var</span> k <span class=\"keyword\">in</span> Obj) &#123;</span><br><span class=\"line\">      <span class=\"comment\">// 为这个对象添加新的属性</span></span><br><span class=\"line\">      buf[k] = clone(Obj[k]);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> buf;</span><br><span class=\"line\">  &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> Obj;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>js 对象的深度克隆代码实现 (2)</li>\n</ul>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">deepCopy</span>(<span class=\"params\">p, c</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> c = c || &#123;&#125;;</span><br><span class=\"line\">  <span class=\"keyword\">for</span> (<span class=\"keyword\">var</span> i <span class=\"keyword\">in</span> p) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (<span class=\"keyword\">typeof</span> p[i] === <span class=\"string\">\"object\"</span>) &#123;</span><br><span class=\"line\">      c[i] = p[i].constructor === <span class=\"built_in\">Array</span> ? [] : &#123;&#125;;</span><br><span class=\"line\">      deepCopy(p[i], c[i]);</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">      c[i] = p[i];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> c;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>js 操作获取和设置 cookie</li>\n</ul>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/*cookie的三种操作：读取，写入，删除*/</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> CookieUtil = &#123;</span><br><span class=\"line\">  <span class=\"keyword\">get</span>: function(name) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> cookieName = <span class=\"built_in\">encodeURIComponent</span>(name) + <span class=\"string\">\"=\"</span>,</span><br><span class=\"line\">      cookieStart = <span class=\"built_in\">document</span>.cookie.indexOf(cookieName),</span><br><span class=\"line\">      cookieValue = <span class=\"literal\">null</span>;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (cookieStart &gt; <span class=\"number\">-1</span>) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">var</span> cookieEnd = <span class=\"built_in\">document</span>.cookie.indexOf(<span class=\"string\">\";\"</span>, cookieStart);</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (cookieEnd == <span class=\"number\">-1</span>) &#123;</span><br><span class=\"line\">        cookieEnd = <span class=\"built_in\">document</span>.cookie.length;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      cookieValue = <span class=\"built_in\">decodeURIComponent</span>(</span><br><span class=\"line\">        <span class=\"built_in\">document</span>.cookie.substring(cookieStart + cookieName.length, cookieEnd)</span><br><span class=\"line\">      );</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> cookieValue;</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  <span class=\"keyword\">set</span>: function(name, value, expires, path, domain, secure) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> cookieText = <span class=\"built_in\">encodeURIComponent</span>(name) + <span class=\"string\">\"=\"</span> + <span class=\"built_in\">encodeURIComponent</span>(value);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (expires <span class=\"keyword\">instanceof</span> <span class=\"built_in\">Date</span>) &#123;</span><br><span class=\"line\">      cookieText += <span class=\"string\">\";expires=\"</span> + expires.toGMTString();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (path) &#123;</span><br><span class=\"line\">      cookieText += <span class=\"string\">\";path=\"</span> + path;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (domain) &#123;</span><br><span class=\"line\">      cookieText += <span class=\"string\">\";domain=\"</span> + domain;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (secure) &#123;</span><br><span class=\"line\">      cookieText += <span class=\"string\">\";secure\"</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"built_in\">document</span>.cookie = cookieText;</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  unset: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">name, path, domain, secure</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.set(name, <span class=\"string\">\"\"</span>, <span class=\"keyword\">new</span> <span class=\"built_in\">Date</span>(<span class=\"number\">0</span>), path, domain, secure);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li><p>介绍一下你对浏览器内核的理解？<br>主要分成两部分：渲染引擎(layout engineer 或 Rendering Engine)和 JS 引擎。<br>渲染引擎：负责取得网页的内容（HTML、XML、图像等等）、整理讯息（例如加入 CSS 等），以及计算网页的显示方式，然后会输出至显示器或打印机。浏览器的内核的不同对于网页的语法解释会有不同，所以渲染的效果也不相同。所有网页浏览器、电子邮件客户端以及其它需要编辑、显示网络内容的应用程序都需要内核。<br>JS 引擎则：解析和执行 javascript 来实现网页的动态效果。<br>最开始渲染引擎和 JS 引擎并没有区分的很明确，后来 JS 引擎越来越独立，内核就倾向于只指渲染引擎。</p>\n</li>\n<li><p>常见浏览器内核</p>\n</li>\n</ul>\n<ol>\n<li>Trident 内核: ie</li>\n<li>Gecko 内核: ff</li>\n<li>Presto 内核: Opera7 及以上, 现 O 内核为 Blink</li>\n<li>Webkit 内核: Safari, Chrome, 现 C 内核为 Blink</li>\n</ol>\n<ul>\n<li>xss 和 csrf</li>\n</ul>\n<ol>\n<li>xss(cross site-scripting)跨站脚本攻击, 在被攻击者的浏览器中执行脚本, 采集被攻击者数据. 如盗用 cookie; 以被攻击者的身份执行操作</li>\n<li>csrf 跨站请求伪造. 造成 csrf 需要两步, 第一登录受信任网站 a, 在本地生成 cookie, 第二不登出 a 的情况下访问危险网站 b.</li>\n</ol>\n<ul>\n<li>String.prototype.replace()用法. 注意不会改变原字符串, 而是返回新字符串.</li>\n</ul>\n<ol>\n<li>str.replace(regexp|substr, newStr)</li>\n<li>str.replace(regexp|substr, function)</li>\n</ol>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// substr</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> str = <span class=\"string\">\"ac\"</span>;</span><br><span class=\"line\">str.replace(<span class=\"string\">\"a\"</span>, <span class=\"string\">\"b\"</span>); <span class=\"comment\">// 'bc'</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 1.</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> str = <span class=\"string\">\"Twas the night before Xmas...\"</span>;</span><br><span class=\"line\"><span class=\"keyword\">var</span> newstr = str.replace(<span class=\"regexp\">/xmas/i</span>, <span class=\"string\">\"Christmas\"</span>);</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(newstr); <span class=\"comment\">// Twas the night before Christmas...</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 2.</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">styleHyphenFormat</span>(<span class=\"params\">propertyName</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">upperToHyphenLower</span>(<span class=\"params\">match</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"string\">\"-\"</span> + match.toLowerCase();</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> propertyName.replace(<span class=\"regexp\">/[A-Z]/g</span>, upperToHyphenLower);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">styleHyphenFormat(<span class=\"string\">\"borderTop\"</span>); <span class=\"comment\">// border-top</span></span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>JavaScript 的定义<br>JavaScript 是一种专门为与网页交互而设计的脚本语言。有下列三部分组成</li>\n</ul>\n<ol>\n<li>ECMAScript，提供核心语言功能</li>\n<li>文档对象模型（DOM），提供访问与操作网页内容的方法与接口</li>\n<li>浏览器对象模型（BOM），提供与浏览器交互的方法与接口</li>\n</ol>\n<ul>\n<li><p>javascript 的 typeof 返回哪些数据类型<br>Object(对象, null) number string function boolean underfind (es6 symbol);</p>\n</li>\n<li><p>ajax 请求的时候 get 和 post 方式的区别?</p>\n</li>\n</ul>\n<ol>\n<li>get 方法放在 url 后面, 不能大于 2kb, post 方法放在 http 消息的实体内容发送</li>\n<li>安全问题, get 安全性低, post 安全性高</li>\n</ol>\n<ul>\n<li><p>图片懒加载原理<br>页面加载后只让文档可视区内的图片显示，其它不显示，随着用户对页面的滚动，判断其区域位置，生成 img 标签，让到可视区的图片加载出来</p>\n</li>\n<li><p>谈谈 This 对象的理解</p>\n</li>\n</ul>\n<ol>\n<li>this 是 js 的一个关键字, 随着函数使用场合不同, this 的值会发生变化.</li>\n<li>但是有一个总原则, 那就是 this 指的是调用函数的那个对象.</li>\n<li>this 一般情况下: 是全局对象 Global. 作为方法调用, 那么 this 就是指这个对象</li>\n</ol>\n<ul>\n<li><p>JSONP 原理<br>ajax 请求受同源策略影响，不允许进行跨域请求，而 script 标签 src 属性中的链接却可以访问跨域的 js 脚本，利用这个特性，服务端不再返回 JSON 格式的数据，而是返回一段调用某个函数的 js 代码，在 src 中进行了调用，这样实现了跨域。</p>\n</li>\n<li><p>ajax 的过程是怎样的</p>\n</li>\n</ul>\n<ol>\n<li>创建 XMLHttpRequest 对象,也就是创建一个异步调用对象</li>\n<li>创建一个新的 HTTP 请求,并指定该 HTTP 请求的方法、URL 及验证信息</li>\n<li>设置响应 HTTP 请求状态变化的函数</li>\n<li>发送 HTTP 请求</li>\n<li>获取异步调用返回的数据</li>\n<li>使用 JavaScript 和 DOM 实现局部刷新</li>\n</ol>\n<ul>\n<li>详解单页面路由的几种实现原理</li>\n</ul>\n<ol>\n<li>url 完全不动型. 这一种的情况是 url 完全不动, 即你的页面怎么改变, 怎么跳转 url 都不会改变, 这种情况的原理就是纯 ajax 拿到页面后替换原页面中的元素.</li>\n<li>带 hash(#)型. 这种类型的优点就是刷新页面, 页面也不会丢. 通过监听 hash(#)的变化来执行 js 代码, 从而实现页面的改变. 主要需要用到 hashchange 事件.</li>\n</ol>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">window</span>.addEventListener(<span class=\"string\">'hashchange'</span>, () =&gt; &#123;</span><br><span class=\"line\">  <span class=\"comment\">// 改变节点</span></span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n\n<ol start=\"3\">\n<li>无 hash(#)型. 这种类型是通过 html5 的最新 history api 来实现的能正常的回退前进. url 和普通的 url 一样, 但缺点就是一刷新页面页面就会丢失.</li>\n</ol>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">主要需要用到history.pushState,</span><br><span class=\"line\">history.replaceState, <span class=\"comment\">// 不会记录到历史栈</span></span><br><span class=\"line\">history.state,</span><br><span class=\"line\"><span class=\"built_in\">window</span>.onpopstate事件.</span><br><span class=\"line\"><span class=\"built_in\">window</span>.addEventListener(<span class=\"string\">'popstate'</span>, () =&gt; &#123;</span><br><span class=\"line\">  <span class=\"comment\">// 更新节点</span></span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>js 跨域的实现方法原理</li>\n</ul>\n<ol>\n<li>通过 jsonp. 有个 a.html 页面, 假设这个 json 数据地址是<a href=\"http://example.com/data.php\" target=\"_blank\" rel=\"noopener\">http://example.com/data.php</a></li>\n</ol>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// a.html</span></span><br><span class=\"line\">&lt;script&gt;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">doSomething</span> (<span class=\"params\">jsondata</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">// 处理获得的data数据</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\">&lt;<span class=\"regexp\">/script&gt;</span></span><br><span class=\"line\"><span class=\"regexp\">&lt;script src='http:/</span><span class=\"regexp\">/example.com/</span>data.php?callback=doSomething<span class=\"string\">'&gt;&lt;/script&gt;</span></span><br><span class=\"line\"><span class=\"string\">// 也可以是php文件返回一个js函数的调用, 如 echo '</span>doSomething(...)<span class=\"string\">', 这样就不用在url写callback</span></span><br><span class=\"line\"><span class=\"string\">// jsonp跨域缺点: 只支持get请求, 安全隐患, 必须双方都受信任.</span></span><br></pre></td></tr></table></figure>\n\n<ol start=\"2\">\n<li>通过修改 document.domain 来跨子域. 比如，有一个页面, 它的地址是<a href=\"http://www.example.com/a.html\" target=\"_blank\" rel=\"noopener\">http://www.example.com/a.html</a>, 在这个页面里面有一个 iframe, 它的 src 是<a href=\"http://example.com/b.html\" target=\"_blank\" rel=\"noopener\">http://example.com/b.html</a>.</li>\n</ol>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// a.html与它里面的iframe框架是不同域的, 无法通过在页面中书写js代码来获取iframe中的东西</span></span><br><span class=\"line\">&lt;script&gt;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">onLoad</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> iframe = <span class=\"built_in\">document</span>.getElementById(<span class=\"string\">'iframe'</span>);</span><br><span class=\"line\">  <span class=\"keyword\">var</span> win = iframe.contentWindow;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> doc = win.document;  <span class=\"comment\">// 获取不到iframe里的document对象</span></span><br><span class=\"line\">  <span class=\"keyword\">var</span> name = win.name;     <span class=\"comment\">// 获取不到</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\">&lt;<span class=\"regexp\">/script&gt;</span></span><br><span class=\"line\"><span class=\"regexp\">&lt;iframe id='iframe' src='http:/</span><span class=\"regexp\">/example.com/</span>b.html<span class=\"string\">' onload = '</span>onLoad()<span class=\"string\">'&gt;&lt;/iframe&gt;</span></span><br></pre></td></tr></table></figure>\n\n<p>这时候, 只要把<a href=\"http://www.example.com/a.html和http://example.com/b.html的document.domain设成相同的\" target=\"_blank\" rel=\"noopener\">http://www.example.com/a.html和http://example.com/b.html的document.domain设成相同的</a>. document.domain 只能往自身或更低一级的域. eg: a.b.example.com 可以设成 a.b.example.com、b.example.com、example.com 中的任意一个, 不能设 c.a.b.example.com.</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// a.html</span></span><br><span class=\"line\">&lt;iframe id=<span class=\"string\">'iframe'</span> src=<span class=\"string\">'http://example.com/b.html'</span> onload = <span class=\"string\">'onLoad()'</span>&gt;<span class=\"xml\"><span class=\"tag\">&lt;/<span class=\"name\">iframe</span>&gt;</span></span></span><br><span class=\"line\">&lt;script&gt;</span><br><span class=\"line\"><span class=\"built_in\">document</span>.domain = <span class=\"string\">'example.com'</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">onLoad</span>(<span class=\"params\"></span>) </span>&#123; ... &#125;</span><br><span class=\"line\">&lt;<span class=\"regexp\">/script&gt;</span></span><br><span class=\"line\"><span class=\"regexp\"></span></span><br><span class=\"line\"><span class=\"regexp\">/</span><span class=\"regexp\">/ b.html</span></span><br><span class=\"line\"><span class=\"regexp\">&lt;script&gt;</span></span><br><span class=\"line\"><span class=\"regexp\">document.domain = 'example.com'</span></span><br><span class=\"line\"><span class=\"regexp\">&lt;/</span>script&gt;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//domain缺点: 安全性, 当一个页面被攻击后, 另一个有安全隐患; 如果有多个iframe, 就要设置成大家都相同的domain</span></span><br></pre></td></tr></table></figure>\n\n<ol start=\"3\">\n<li>window.name. 把需要的值替换成 window.name 的值. 如 <a href=\"http://www.example.com/a.html\" target=\"_blank\" rel=\"noopener\">www.example.com/a.html</a>, 需要 <a href=\"http://www.cnblogs.com/data.html\" target=\"_blank\" rel=\"noopener\">www.cnblogs.com/data.html</a> 里的数据, 需要 iframe 充当中间人, 来获取 data.HTML 的数据, a.html 再去获取 iframe 获取到的数据, 这里注意 a.html 和 iframe 需要同源即可</li>\n</ol>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">getData</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> iframe = <span class=\"built_in\">document</span>.getElementById(<span class=\"string\">'iframe'</span>);</span><br><span class=\"line\">  iframe.onload = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> data = iframe.contentWindow.name;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(data);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  iframe.src = <span class=\"string\">'http://www.example.com/b.html'</span>; <span class=\"comment\">// 与a.html同源</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\">&lt;iframe id=<span class=\"string\">'iframe'</span> src = <span class=\"string\">'http://www.cnblogs.com/data.html'</span> style=<span class=\"string\">'display:none'</span> onload = getData() &gt;<span class=\"xml\"><span class=\"tag\">&lt;/<span class=\"name\">iframe</span>&gt;</span></span></span><br><span class=\"line\"><span class=\"comment\">// window.name缺点: window.name的值是字符串形式, 最大只能2M左右</span></span><br></pre></td></tr></table></figure>\n\n<ol start=\"4\">\n<li>HTML5 的 window.postMessage(message,targetOrigin)方法. 可以使用它来向其它的 window 对象发送消息, 无论这个 window 对象是属于同源或不同源. 该方法的第一个参数 message 为要发送的消息, 类型只能为字符串; 第二个参数 targetOrigin 用来限定接收消息的那个 window 对象所在的域, 如果不想限定域, 可以使用通配符 *</li>\n</ol>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// a.html</span></span><br><span class=\"line\">&lt;script&gt;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">onLoad</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> iframe = <span class=\"built_in\">document</span>.getElementById(<span class=\"string\">'iframe'</span>);</span><br><span class=\"line\">  <span class=\"keyword\">var</span> win = iframe.contentWindow;</span><br><span class=\"line\">  win.postMessage(<span class=\"string\">'hello world'</span>, *);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">&lt;<span class=\"regexp\">/script&gt;</span></span><br><span class=\"line\"><span class=\"regexp\">&lt;iframe id='iframe' src='http:/</span><span class=\"regexp\">/www.example.com/</span>b.html<span class=\"string\">' onload = onLoad() &gt;&lt;/iframe&gt;</span></span><br><span class=\"line\"><span class=\"string\"></span></span><br><span class=\"line\"><span class=\"string\">// b.html</span></span><br><span class=\"line\"><span class=\"string\">&lt;script&gt;</span></span><br><span class=\"line\"><span class=\"string\">window.onmessage = function (e) &#123;</span></span><br><span class=\"line\"><span class=\"string\">  e = e || event;</span></span><br><span class=\"line\"><span class=\"string\">  console.log(e.data)  // hello world</span></span><br><span class=\"line\"><span class=\"string\">&#125;</span></span><br><span class=\"line\"><span class=\"string\">&lt;/script&gt;</span></span><br><span class=\"line\"><span class=\"string\">// h5方法缺点: IE6、IE7不支持</span></span><br></pre></td></tr></table></figure>\n\n<ol start=\"5\">\n<li>服务端的方法 http 请求包含 Access-Control-Allow-Origin.</li>\n</ol>\n<ul>\n<li><p>因为引用计数产生的内存泄漏，在 ES6 中的解决办法是什么？<br>ES6 考虑到了这一点，推出了两种新的数据结构：WeakSet 和 WeakMap。它们对于值的引用都是不计入垃圾回收机制的，所以名字里面才会有一个”Weak”，表示这是弱引用。</p>\n</li>\n<li><p>js 中基本类型在内存中存储方式是什么，引用类型的存储方式是什么<br>基本类型在内存中占据固定大小的空间, 因此变量和值都存在栈中, 引用类型的存储方式是栈中存变量和堆内存地址, 堆里面是引用类型. 原因是因为引用类型是可扩展的, 内存可大可小, 内存不能给每一个引用类型都开一个新的空间, 采用指针引用科学很多.</p>\n</li>\n<li><p>渐进增强和优雅降级<br>渐进增强（Progressive Enhancement）：一开始就针对低版本浏览器进行构建页面，完成基本的功能，然后再针对高级浏览器进行效果、交互、追加功能达到更好的体验。<br>优雅降级（Graceful Degradation）：一开始就构建站点的完整功能，然后针对浏览器测试和修复。比如一开始使用 CSS3 的特性构建了一个应用，然后逐步针对各大浏览器进行 hack 使其可以在低版本浏览器上正常浏览。</p>\n</li>\n<li><p>手写一个 jsonp</p>\n</li>\n</ul>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">window, document</span>) </span>&#123;</span><br><span class=\"line\"><span class=\"meta\">  \"use strict\"</span>;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> jsonp = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">url, data, callback</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 1.将传入的data数据转化为url字符串形式</span></span><br><span class=\"line\">    <span class=\"comment\">// &#123;id:1,name:'zhangsan'&#125; =&gt; id=1&amp;name=zhangsan</span></span><br><span class=\"line\">    <span class=\"keyword\">var</span> dataString = url.indexof(<span class=\"string\">\"?\"</span>) == <span class=\"number\">-1</span> ? <span class=\"string\">\"?\"</span> : <span class=\"string\">\"&amp;\"</span>;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">var</span> key <span class=\"keyword\">in</span> data) &#123;</span><br><span class=\"line\">      dataString += key + <span class=\"string\">\"=\"</span> + data[key] + <span class=\"string\">\"&amp;\"</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 2 处理url中的回调函数</span></span><br><span class=\"line\">    <span class=\"comment\">// cbFuncName回调函数的名字 ：my_json_cb_名字的前缀 + 随机数（把小数点去掉）</span></span><br><span class=\"line\">    <span class=\"keyword\">var</span> cbFuncName =</span><br><span class=\"line\">      <span class=\"string\">\"my_json_cb_\"</span> +</span><br><span class=\"line\">      <span class=\"built_in\">Math</span>.random()</span><br><span class=\"line\">        .toString()</span><br><span class=\"line\">        .replace(<span class=\"string\">\".\"</span>, <span class=\"string\">\"\"</span>);</span><br><span class=\"line\">    dataString += <span class=\"string\">\"callback=\"</span> + cbFuncName;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 3.创建一个script标签并插入到页面中</span></span><br><span class=\"line\">    <span class=\"keyword\">var</span> scriptEle = <span class=\"built_in\">document</span>.createElement(<span class=\"string\">\"script\"</span>);</span><br><span class=\"line\">    scriptEle.src = url + dataString;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 4.挂载回调函数</span></span><br><span class=\"line\">    <span class=\"built_in\">window</span>[cbFuncName] = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">data</span>) </span>&#123;</span><br><span class=\"line\">      callback(data);</span><br><span class=\"line\">      <span class=\"comment\">// 处理完回调函数的数据之后，删除jsonp的script标签</span></span><br><span class=\"line\">      <span class=\"built_in\">document</span>.body.removeChild(scriptEle);</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 5.append到页面中</span></span><br><span class=\"line\">    <span class=\"built_in\">document</span>.body.appendChild(scriptEle);</span><br><span class=\"line\">  &#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// 因为jsonp是一个私有函数外部不能调用，所有jsonp函数作文window对象的一个方法，供外部调用</span></span><br><span class=\"line\">  <span class=\"built_in\">window</span>.$jsonp = jsonp;</span><br><span class=\"line\">&#125;)(<span class=\"built_in\">window</span>, <span class=\"built_in\">document</span>);</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"VUE\"><a href=\"#VUE\" class=\"headerlink\" title=\"VUE\"></a>VUE</h3><ul>\n<li><p>Vue 双向数据绑定的实现<br>vue 中有一个 observer 来观察所有的属性的变化, 一旦有变化, 就会发给 watcher, 然后 watcher 来告诉编译器 complie 来改变数值</p>\n</li>\n<li><p>vue 和其他两个框架的区别</p>\n</li>\n</ul>\n<ol>\n<li>vue 更轻量级, gzip 后大小只有 20+k, react 有 40+k, angular 有 50+k. 移动端 vue 更适合</li>\n<li>vue 学习曲线平稳, angular 入门较难, 概念多, 因为其思想很多沿用后端技术, react 需要学很多, 附带全家桶.</li>\n<li>vue 吸收另外两家之长, 既有 angular 的指令, 也有 react 的组件化思想.</li>\n</ol>\n<ul>\n<li>vue.js 的核心思想</li>\n</ul>\n<ol>\n<li>数据驱动</li>\n<li>组件化</li>\n</ol>\n<ul>\n<li><p>数据响应原理<br>有一个数据 a.b,在 vue 对象实例化过程中，会给 a,b 通过 ES5 的 defineProperty()方法，添加 getter 和 setter 方法，同时 vue.js 会对模板做编译，解析生成一个指令对象，比如 v-text 指令，每个指令对象都会关联一个 watcher，当对指令对象求值时，就会触发 getter，并将依赖收集到 watcher 中；当再次改变 a.b 值时，就会触发 setter 方法，会通知到对应关联的 watcher,watcher 则再次对 a.b 求值，计算对比新旧值，当值改变时，watcher 会通知到指令，调用指令的 update 方法，由于指令是对 dom 的封装，所以会调用原生 dom 的方法，去更新视图。</p>\n</li>\n<li><p>vue-loader 是什么？使用它的用途有哪些？<br>解析.vue 文件的一个加载器，跟 template/js/style 转换成 js 模块。<br>用途：js 可以写 es6、style 样式可以 scss 或 less、template 可以加 jade 等</p>\n</li>\n<li><p>vue 生命周期总共有几个阶段？<br>它可以总共分为 8 个阶段：创建前/后, 载入前/后,更新前/后,销毁前/销毁后</p>\n</li>\n<li><p>简单描述每个周期具体适合哪些场景？<br>生命周期钩子的一些使用方法：<br>beforecreate : 可以在这加个 loading 事件，在加载实例时触发<br>created : 初始化完成时的事件写在这里，如在这结束 loading 事件，异步请求也适宜在这里调用<br>mounted : 挂载元素，获取到 DOM 节点<br>updated : 如果对数据统一处理，在这里写上相应函数<br>beforeDestroy : 可以做一个确认停止事件的确认框<br>nextTick : 更新数据后立即操作 dom</p>\n</li>\n</ul>\n<h3 id=\"移动端-bug\"><a href=\"#移动端-bug\" class=\"headerlink\" title=\"移动端 bug\"></a>移动端 bug</h3><ul>\n<li>fixed 遮罩滚动穿透问题</li>\n</ul>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 1.touchmove + preventDefault</span></span><br><span class=\"line\">mask.addEventListener(<span class=\"string\">'touchmove'</span>, (e) &#123;</span><br><span class=\"line\">  e.preventDefault()</span><br><span class=\"line\">&#125;, <span class=\"literal\">false</span>)</span><br><span class=\"line\"><span class=\"comment\">// 缺点, 当弹出层需要滚动时也会被阻止</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 2.position +js保存滚动条位置</span></span><br><span class=\"line\"><span class=\"comment\">// css</span></span><br><span class=\"line\">.mask &#123;</span><br><span class=\"line\">  position: fixed;</span><br><span class=\"line\">  width: <span class=\"number\">100</span>%;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// js</span></span><br><span class=\"line\"><span class=\"comment\">// 遮罩开启时保存当前滚动位置, 关闭时还原之前滚动位置</span></span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>移动设备忽略将页面中的数字识别为电话号码的方法<br>在 head 里面加一个</li>\n</ul>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">meta</span> <span class=\"attr\">name</span>=<span class=\"string\">\"format-detection\"</span> <span class=\"attr\">content</span>=<span class=\"string\">\"telephone=no\"</span> /&gt;</span></span><br></pre></td></tr></table></figure>\n\n<p>即可, 响应的还可以有 email=no 让邮箱不可点击.</p>\n<ul>\n<li>上下拉动滚动条时卡顿、慢</li>\n</ul>\n<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-tag\">body</span> &#123;</span><br><span class=\"line\">  <span class=\"attribute\">-webkit-overflow-scrolling</span>: touch;</span><br><span class=\"line\">  <span class=\"attribute\">overflow-scrolling</span>: touch;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>禁止复制、选中文本</li>\n</ul>\n<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-tag\">element</span> &#123;</span><br><span class=\"line\">  <span class=\"attribute\">-webkit-user-select</span>: none;</span><br><span class=\"line\">  <span class=\"attribute\">-moz-user-select</span>: none;</span><br><span class=\"line\">  <span class=\"attribute\">-khtml-user-select</span>: none;</span><br><span class=\"line\">  <span class=\"attribute\">user-select</span>: none;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"计网\"><a href=\"#计网\" class=\"headerlink\" title=\"计网\"></a>计网</h3><ul>\n<li>在浏览器中输入 URL 并回车后都发生了什么?</li>\n</ul>\n<ol>\n<li>解析 URL</li>\n<li>DNS 解析</li>\n<li>浏览器与网站建立 TCP 连接（三次握手）</li>\n<li>请求和传输数据</li>\n<li>浏览器渲染页面</li>\n</ol>\n<ul>\n<li><p>http 强缓存和协商缓存<br>所谓的强缓存就是本地缓存. 浏览器第一次请求时, 一定是强缓存, 返回状态码 200; 第二次请求时, 会先获取该资源缓存的 header 信息(cache-control, expires; cache-control 与 expires 同时存在的话，cache-control 的优先级高于 expires), 两者都符合成立的话就不去服务器请求, 直接拿本地的缓存. 如果上面两个不成立, 就会发送请求到服务器(Etag/if-none-match, Last-modified/if-modified-since; Last-Modified 与 ETag 是可以一起使用的，服务器会优先验证 ETag，一致的情况下，才会继续比对 Last-Modified，最后才决定是否返回 304。), 由服务器根据请求中的相关 header 信息来对比结果是否协商缓存成立, 二者如果有一个和服务器上的不一致, 那就重新返回资源, 如果都没变化则返回 304 not modified, 浏览器收到 304 后, 从本地缓存中加载资源.</p>\n</li>\n<li><p>HTTP2 与 1.1 区别</p>\n</li>\n</ul>\n<ol>\n<li>HTTP2.0 采用二进制格式而非文本格式（二进制解析更加高效，错误更少）</li>\n<li>HTTP2 是完全的多路复用（能同时传输多个请求和响应）</li>\n<li>使用报头压缩，降低了开销</li>\n<li>可以让服务器主动把响应推送到客户端</li>\n</ol>\n<ul>\n<li><p>HTTP1.0 与 1.1 区别<br>HTTP 1.0 规定浏览器与服务器只保持短暂的连接，浏览器的每次请求都需要与服务器建立一个 TCP 连接，服务器完成请求处理后立即断开 TCP 连接，服务器不跟踪每个客户也不记录过去的请求。但是，这也造成了一些性能上的缺陷，例如，一个包含有许多图像的网页文件中并没有包含真正的图像数据内容，而只是指明了这些图像的 URL 地址，当 WEB 浏览器访问这个网页文件时，浏览器首先要发出针对该网页文件的请求，当浏览器解析 WEB 服务器返回的该网页文档中的 HTML 内容时，发现其中的<img>图像标签后，浏览器将根据<img>标签中的 src 属性所指定的 URL 地址再次向服务器发出下载图像数据的请求<br>HTTP 1.1 支持持久连接（connection 默认 keep-alive），在一个 TCP 连接上可以传送多个 HTTP 请求和响应，减少了建立和关闭连接的消耗和延迟。一个包含有许多图像的网页文件的多个请求和应答可以在一个连接中传输，但每个单独的网页文件的请求和应答仍然需要使用各自的连接。  在 HTTP1.0 和 HTTP1.1 协议中都有对长连接的支持。其中 HTTP1.0 需要在 request 中增加”Connection： keep-alive“ header 才能够支持，而 HTTP1.1 默认支持.<br>HTTP 1.1 还允许客户端不用等待上一次请求结果返回，就可以发出下一次请求（流水线处理），但服务器端必须按照接收到客户端请求的先后顺序依次回送响应结果，以保证客户端能够区分出每次请求的响应内容，这样也显著地减少了整个下载过程所需要的时间。</p>\n</li>\n<li><p>HTTP 与 HTTPS<br>HTTP 协议传输的数据都是未加密的，也就是明文的，因此使用 HTTP 协议传输隐私信息非常不安全，为了保证这些隐私数据能加密传输，于是网景公司设计了 SSL（Secure Sockets Layer）协议用于对 HTTP 协议传输的数据进行加密，从而就诞生了 HTTPS。简单来说，HTTPS 协议是由 SSL+HTTP 协议构建的可进行加密传输、身份认证的网络协议，要比 http 协议安全。HTTPS 使用不同于 HTTP 协议的默认端口及一个加密、身份验证层（HTTP 与 TCP 之间）<br>　　 HTTPS 和 HTTP 的区别主要如下：<br>　　 1、https 协议需要到 ca 申请证书，一般免费证书较少，因而需要一定费用。<br>　　 2、http 是超文本传输协议，信息是明文传输，https 则是具有安全性的 ssl 加密传输协议。<br>　　 3、http 和 https 使用的是完全不同的连接方式，用的端口也不一样，前者是 80，后者是 443。<br>　　 4、http 的连接很简单，是无状态的；HTTPS 协议是由 SSL+HTTP 协议构建的可进行加密传输、身份认证的网络协议，比 http 协议安全。</p>\n</li>\n</ul>\n<p>虽然说 HTTPS 有很大的优势，但其相对来说，还是存在不足之处的：<br>　　（1）HTTPS 协议握手阶段比较费时，会使页面的加载时间延长近 50%，增加 10%到 20%的耗电；<br>　　（2）HTTPS 连接缓存不如 HTTP 高效，会增加数据开销和功耗，甚至已有的安全措施也会因此而受到影响；<br>　　（3）SSL 证书需要钱，功能越强大的证书费用越高，个人网站、小网站没有必要一般不会用。<br>　 （4）SSL 证书通常需要绑定 IP，不能在同一 IP 上绑定多个域名，IPv4 资源不可能支撑这个消耗。<br>　　（5）HTTPS 协议的加密范围也比较有限，在黑客攻击、拒绝服务攻击、服务器劫持等方面几乎起不到什么作用。最关键的，SSL 证书的信用链体系并不安全，特别是在某些国家可以控制 CA 根证书的情况下，中间人攻击一样可行。</p>\n<p>客户端在使用 HTTPS 方式与 Web 服务器通信时有以下几个步骤，如图所示。（先非对称，在对称）<br>　　（1）客户使用 https 的 URL 访问 Web 服务器，要求与 Web 服务器建立 SSL 连接。<br>　　（2）Web 服务器收到客户端请求后，会将网站的证书信息（证书中包含公钥）传送一份给客户端。<br>　　（3）客户端的浏览器与 Web 服务器开始协商 SSL 连接的安全等级，也就是信息加密的等级。<br>　　（4）客户端的浏览器根据双方同意的安全等级，建立会话密钥，然后利用网站的公钥将会话密钥加密，并传送给网站。<br>　　（5）Web 服务器利用自己的私钥解密出会话密钥。<br>（6）Web 服务器利用会话密钥加密与客户端之间的通信。</p>\n<h3 id=\"数据结构\"><a href=\"#数据结构\" class=\"headerlink\" title=\"数据结构\"></a>数据结构</h3><ul>\n<li><p>两个队列实现一个栈<br>A 队列作为主队列, B 队列. 判断 A 队列长度是否为 1, 如果是直接出队列. 如果不是, 出(长度-1)队列到 B 队列里, 然后最后一个出队列, 依次列推</p>\n</li>\n<li><p>两个栈实现一个队列<br>入栈都给 A 栈, 要出栈时判断 B 栈是否为空, 为空, 将 A 栈全部 pop 后, push 到 B 栈, 然后 B 栈顺序 pop. 如果不为空, 将 B 栈里的先 pop.</p>\n</li>\n<li><p>有哪些数据结构<br>图, 树, 线性, 集合.</p>\n</li>\n</ul>\n<h3 id=\"操作系统\"><a href=\"#操作系统\" class=\"headerlink\" title=\"操作系统\"></a>操作系统</h3><ul>\n<li>线程和进程的区别和联系<br>线程是 CPU 调度的一个基本单位; 进程是资源分配的基本单位.<br>两者的联系: 进程和线程都是操作系统所运行的程序运行的基本单元.<br>区别：<br>（1）进程具有独立的空间地址，一个进程崩溃后，在保护模式下不会对其它进程产生影响。<br>（2）线程只是一个进程的不同执行路径，线程有自己的堆栈和局部变量，但线程之间没有单独的地址空间，一个线程死掉就等于整个进程死掉。</li>\n</ul>"}],"PostAsset":[{"_id":"source/_posts/基于Inquirer实现命令行文件新增/code_5.png","slug":"code_5.png","post":"cl5sb8gf7000sxq0rzm0013kc","modified":1,"renderable":0},{"_id":"source/_posts/基于Inquirer实现命令行文件新增/result_2.png","slug":"result_2.png","post":"cl5sb8gf7000sxq0rzm0013kc","modified":1,"renderable":0},{"_id":"source/_posts/基于Inquirer实现命令行文件新增/example_2.png","slug":"example_2.png","post":"cl5sb8gf7000sxq0rzm0013kc","modified":1,"renderable":0},{"_id":"source/_posts/2022年书单推荐/design.jpeg","post":"cl5sb8gew0008xq0rfxwqiapv","slug":"design.jpeg","modified":1,"renderable":1},{"_id":"source/_posts/我认为的Vue官方文档重点-2/2_transition.jpg","post":"cl5sb8gf90011xq0rhgi0otnb","slug":"2_transition.jpg","modified":1,"renderable":1},{"_id":"source/_posts/图片格式选择/1.png","post":"cl5sb8gf6000qxq0rljs57mqn","slug":"1.png","modified":1,"renderable":1},{"_id":"source/_posts/图片格式选择/2.png","slug":"2.png","post":"cl5sb8gf6000qxq0rljs57mqn","modified":1,"renderable":0},{"_id":"source/_posts/2021年书单推荐/design_pattern.image","slug":"design_pattern.image","post":"cl5sb8ger0005xq0r35jnfjw3","modified":1,"renderable":0},{"_id":"source/_posts/2021年书单推荐/head_first.jpeg","post":"cl5sb8ger0005xq0r35jnfjw3","slug":"head_first.jpeg","modified":1,"renderable":1},{"_id":"source/_posts/2021年书单推荐/regexp.jpeg","post":"cl5sb8ger0005xq0r35jnfjw3","slug":"regexp.jpeg","modified":1,"renderable":1},{"_id":"source/_posts/2021年书单推荐/svg.jpeg","post":"cl5sb8ger0005xq0r35jnfjw3","slug":"svg.jpeg","modified":1,"renderable":1},{"_id":"source/_posts/关于Grid布局的使用指南/grid-area.jpg","post":"cl5sb8gf4000mxq0ru1vwu3b6","slug":"grid-area.jpg","modified":1,"renderable":1},{"_id":"source/_posts/关于Grid布局的使用指南/grid-gap.jpg","post":"cl5sb8gf4000mxq0ru1vwu3b6","slug":"grid-gap.jpg","modified":1,"renderable":1},{"_id":"source/_posts/关于Grid布局的使用指南/grid-template-areas.jpg","post":"cl5sb8gf4000mxq0ru1vwu3b6","slug":"grid-template-areas.jpg","modified":1,"renderable":1},{"_id":"source/_posts/关于Grid布局的使用指南/grid-template_auto.jpg","post":"cl5sb8gf4000mxq0ru1vwu3b6","slug":"grid-template_auto.jpg","modified":1,"renderable":1},{"_id":"source/_posts/关于Grid布局的使用指南/grid-with-gap.jpg","post":"cl5sb8gf4000mxq0ru1vwu3b6","slug":"grid-with-gap.jpg","modified":1,"renderable":1},{"_id":"source/_posts/关于Grid布局的使用指南/origin.jpg","post":"cl5sb8gf4000mxq0ru1vwu3b6","slug":"origin.jpg","modified":1,"renderable":1},{"_id":"source/_posts/关于Flex布局的使用指南/1_space-around.jpg","post":"cl5sb8gf4000kxq0rhp7xemuk","slug":"1_space-around.jpg","modified":1,"renderable":1},{"_id":"source/_posts/关于Flex布局的使用指南/1_space-between.jpg","post":"cl5sb8gf4000kxq0rhp7xemuk","slug":"1_space-between.jpg","modified":1,"renderable":1},{"_id":"source/_posts/关于Flex布局的使用指南/2_baseline.jpg","post":"cl5sb8gf4000kxq0rhp7xemuk","slug":"2_baseline.jpg","modified":1,"renderable":1},{"_id":"source/_posts/关于Flex布局的使用指南/2_flex-start.jpg","post":"cl5sb8gf4000kxq0rhp7xemuk","slug":"2_flex-start.jpg","modified":1,"renderable":1},{"_id":"source/_posts/关于Flex布局的使用指南/3_space-around.jpg","post":"cl5sb8gf4000kxq0rhp7xemuk","slug":"3_space-around.jpg","modified":1,"renderable":1},{"_id":"source/_posts/关于Flex布局的使用指南/3_stretch.jpg","post":"cl5sb8gf4000kxq0rhp7xemuk","slug":"3_stretch.jpg","modified":1,"renderable":1},{"_id":"source/_posts/关于Flex布局的使用指南/4_flex-grow.jpg","post":"cl5sb8gf4000kxq0rhp7xemuk","slug":"4_flex-grow.jpg","modified":1,"renderable":1},{"_id":"source/_posts/关于Flex布局的使用指南/5_flex-shrink.jpg","post":"cl5sb8gf4000kxq0rhp7xemuk","slug":"5_flex-shrink.jpg","modified":1,"renderable":1},{"_id":"source/_posts/关于Flex布局的使用指南/6_align-self.jpg","post":"cl5sb8gf4000kxq0rhp7xemuk","slug":"6_align-self.jpg","modified":1,"renderable":1},{"_id":"source/_posts/GC-垃圾回收/10.png","slug":"10.png","post":"cl5sb8gg4002vxq0r185a81dv","modified":1,"renderable":0},{"_id":"source/_posts/基于Inquirer实现命令行文件新增/Inquirer_icon.png","post":"cl5sb8gf7000sxq0rzm0013kc","slug":"Inquirer_icon.png","modified":1,"renderable":1},{"_id":"source/_posts/基于Inquirer实现命令行文件新增/code_1.png","post":"cl5sb8gf7000sxq0rzm0013kc","slug":"code_1.png","modified":1,"renderable":1},{"_id":"source/_posts/基于Inquirer实现命令行文件新增/code_2.png","post":"cl5sb8gf7000sxq0rzm0013kc","slug":"code_2.png","modified":1,"renderable":1},{"_id":"source/_posts/基于Inquirer实现命令行文件新增/code_3.png","post":"cl5sb8gf7000sxq0rzm0013kc","slug":"code_3.png","modified":1,"renderable":1},{"_id":"source/_posts/基于Inquirer实现命令行文件新增/code_4.png","post":"cl5sb8gf7000sxq0rzm0013kc","slug":"code_4.png","modified":1,"renderable":1},{"_id":"source/_posts/基于Inquirer实现命令行文件新增/example_1.png","post":"cl5sb8gf7000sxq0rzm0013kc","slug":"example_1.png","modified":1,"renderable":1},{"_id":"source/_posts/基于Inquirer实现命令行文件新增/result.png","post":"cl5sb8gf7000sxq0rzm0013kc","slug":"result.png","modified":1,"renderable":1},{"_id":"source/_posts/基于Inquirer实现命令行文件新增/situation_1.png","post":"cl5sb8gf7000sxq0rzm0013kc","slug":"situation_1.png","modified":1,"renderable":1},{"_id":"source/_posts/基于Inquirer实现命令行文件新增/situation_2.png","post":"cl5sb8gf7000sxq0rzm0013kc","slug":"situation_2.png","modified":1,"renderable":1},{"_id":"source/_posts/基于Inquirer实现命令行文件新增/situation_3.png","post":"cl5sb8gf7000sxq0rzm0013kc","slug":"situation_3.png","modified":1,"renderable":1},{"_id":"source/_posts/GC-垃圾回收/9.png","slug":"9.png","post":"cl5sb8gg4002vxq0r185a81dv","modified":1,"renderable":0},{"_id":"source/_posts/vscode-extension初探/activation_event_1.png","post":"cl5sb8gf2000fxq0re1z8zwbb","slug":"activation_event_1.png","modified":1,"renderable":1},{"_id":"source/_posts/vscode-extension初探/activation_event_2.png","post":"cl5sb8gf2000fxq0re1z8zwbb","slug":"activation_event_2.png","modified":1,"renderable":1},{"_id":"source/_posts/vscode-extension初探/activation_event_3.png","post":"cl5sb8gf2000fxq0re1z8zwbb","slug":"activation_event_3.png","modified":1,"renderable":1},{"_id":"source/_posts/vscode-extension初探/cli-builded.png","post":"cl5sb8gf2000fxq0re1z8zwbb","slug":"cli-builded.png","modified":1,"renderable":1},{"_id":"source/_posts/vscode-extension初探/cli.png","slug":"cli.png","post":"cl5sb8gf2000fxq0re1z8zwbb","modified":1,"renderable":0},{"_id":"source/_posts/vscode-extension初探/contribution_points.png","post":"cl5sb8gf2000fxq0re1z8zwbb","slug":"contribution_points.png","modified":1,"renderable":1},{"_id":"source/_posts/vscode-extension初探/contribution_points_2.png","post":"cl5sb8gf2000fxq0re1z8zwbb","slug":"contribution_points_2.png","modified":1,"renderable":1},{"_id":"source/_posts/vscode-extension初探/contribution_points_3.png","post":"cl5sb8gf2000fxq0re1z8zwbb","slug":"contribution_points_3.png","modified":1,"renderable":1},{"_id":"source/_posts/vscode-extension初探/contribution_points_4.png","post":"cl5sb8gf2000fxq0re1z8zwbb","slug":"contribution_points_4.png","modified":1,"renderable":1},{"_id":"source/_posts/vscode-extension初探/dap.png","post":"cl5sb8gf2000fxq0re1z8zwbb","slug":"dap.png","modified":1,"renderable":1},{"_id":"source/_posts/vscode-extension初探/local_setup.gif","slug":"local_setup.gif","post":"cl5sb8gf2000fxq0re1z8zwbb","modified":1,"renderable":0},{"_id":"source/_posts/vscode-extension初探/lsp.png","slug":"lsp.png","post":"cl5sb8gf2000fxq0re1z8zwbb","modified":1,"renderable":0},{"_id":"source/_posts/vscode-extension初探/marketplace.png","post":"cl5sb8gf2000fxq0re1z8zwbb","slug":"marketplace.png","modified":1,"renderable":1},{"_id":"source/_posts/vscode-extension初探/paperang-pomodoro.gif","slug":"paperang-pomodoro.gif","post":"cl5sb8gf2000fxq0re1z8zwbb","modified":1,"renderable":0},{"_id":"source/_posts/vscode-extension初探/paperang-theme.gif","post":"cl5sb8gf2000fxq0re1z8zwbb","slug":"paperang-theme.gif","modified":1,"renderable":1},{"_id":"source/_posts/vscode-extension初探/vscode.png","post":"cl5sb8gf2000fxq0re1z8zwbb","slug":"vscode.png","modified":1,"renderable":1},{"_id":"source/_posts/console命令大全/assert_1.jpg","post":"cl5sb8gez000axq0r56outezj","slug":"assert_1.jpg","modified":1,"renderable":1},{"_id":"source/_posts/console命令大全/assert_2.jpg","post":"cl5sb8gez000axq0r56outezj","slug":"assert_2.jpg","modified":1,"renderable":1},{"_id":"source/_posts/console命令大全/count_1.jpg","post":"cl5sb8gez000axq0r56outezj","slug":"count_1.jpg","modified":1,"renderable":1},{"_id":"source/_posts/console命令大全/dir_1.jpg","post":"cl5sb8gez000axq0r56outezj","slug":"dir_1.jpg","modified":1,"renderable":1},{"_id":"source/_posts/console命令大全/dir_2.jpg","post":"cl5sb8gez000axq0r56outezj","slug":"dir_2.jpg","modified":1,"renderable":1},{"_id":"source/_posts/console命令大全/dir_3.jpg","post":"cl5sb8gez000axq0r56outezj","slug":"dir_3.jpg","modified":1,"renderable":1},{"_id":"source/_posts/console命令大全/group_1.jpg","post":"cl5sb8gez000axq0r56outezj","slug":"group_1.jpg","modified":1,"renderable":1},{"_id":"source/_posts/console命令大全/group_2.jpg","post":"cl5sb8gez000axq0r56outezj","slug":"group_2.jpg","modified":1,"renderable":1},{"_id":"source/_posts/console命令大全/log_1.jpg","post":"cl5sb8gez000axq0r56outezj","slug":"log_1.jpg","modified":1,"renderable":1},{"_id":"source/_posts/console命令大全/log_2.jpg","post":"cl5sb8gez000axq0r56outezj","slug":"log_2.jpg","modified":1,"renderable":1},{"_id":"source/_posts/console命令大全/log_3.jpg","post":"cl5sb8gez000axq0r56outezj","slug":"log_3.jpg","modified":1,"renderable":1},{"_id":"source/_posts/console命令大全/log_4.jpg","post":"cl5sb8gez000axq0r56outezj","slug":"log_4.jpg","modified":1,"renderable":1},{"_id":"source/_posts/console命令大全/log_5.jpg","post":"cl5sb8gez000axq0r56outezj","slug":"log_5.jpg","modified":1,"renderable":1},{"_id":"source/_posts/console命令大全/table_1.jpg","post":"cl5sb8gez000axq0r56outezj","slug":"table_1.jpg","modified":1,"renderable":1},{"_id":"source/_posts/console命令大全/table_2.jpg","post":"cl5sb8gez000axq0r56outezj","slug":"table_2.jpg","modified":1,"renderable":1},{"_id":"source/_posts/console命令大全/table_3.jpg","post":"cl5sb8gez000axq0r56outezj","slug":"table_3.jpg","modified":1,"renderable":1},{"_id":"source/_posts/console命令大全/time_1.jpg","post":"cl5sb8gez000axq0r56outezj","slug":"time_1.jpg","modified":1,"renderable":1},{"_id":"source/_posts/console命令大全/trace_1.jpg","post":"cl5sb8gez000axq0r56outezj","slug":"trace_1.jpg","modified":1,"renderable":1},{"_id":"source/_posts/indexedDB浅析/compatibility.png","post":"cl5sb8gg6002yxq0rc3rkq0f1","slug":"compatibility.png","modified":1,"renderable":1},{"_id":"source/_posts/indexedDB浅析/indexedDB_object.png","post":"cl5sb8gg6002yxq0rc3rkq0f1","slug":"indexedDB_object.png","modified":1,"renderable":1},{"_id":"source/_posts/我认为的Vue官方文档重点-1/1_newPropertyHaventGetterAndSetter.jpg","post":"cl5sb8gg70031xq0rdpqa70pe","slug":"1_newPropertyHaventGetterAndSetter.jpg","modified":1,"renderable":1},{"_id":"source/_posts/我认为的Vue官方文档重点-1/1_textarea_1.jpg","post":"cl5sb8gg70031xq0rdpqa70pe","slug":"1_textarea_1.jpg","modified":1,"renderable":1},{"_id":"source/_posts/我认为的Vue官方文档重点-1/1_textarea_2.jpg","post":"cl5sb8gg70031xq0rdpqa70pe","slug":"1_textarea_2.jpg","modified":1,"renderable":1},{"_id":"source/_posts/我认为的Vue官方文档重点-1/2_vHtmlUsage.jpg","post":"cl5sb8gg70031xq0rdpqa70pe","slug":"2_vHtmlUsage.jpg","modified":1,"renderable":1},{"_id":"source/_posts/我认为的Vue官方文档重点-1/3_template_code.jpg","post":"cl5sb8gg70031xq0rdpqa70pe","slug":"3_template_code.jpg","modified":1,"renderable":1},{"_id":"source/_posts/我认为的Vue官方文档重点-1/3_template_show.jpg","post":"cl5sb8gg70031xq0rdpqa70pe","slug":"3_template_show.jpg","modified":1,"renderable":1},{"_id":"source/_posts/GC-垃圾回收/1.png","slug":"1.png","post":"cl5sb8gg4002vxq0r185a81dv","modified":1,"renderable":0},{"_id":"source/_posts/GC-垃圾回收/11.png","post":"cl5sb8gg4002vxq0r185a81dv","slug":"11.png","modified":1,"renderable":1},{"_id":"source/_posts/GC-垃圾回收/2.png","slug":"2.png","post":"cl5sb8gg4002vxq0r185a81dv","modified":1,"renderable":0},{"_id":"source/_posts/GC-垃圾回收/3.png","slug":"3.png","post":"cl5sb8gg4002vxq0r185a81dv","modified":1,"renderable":0},{"_id":"source/_posts/GC-垃圾回收/4.png","slug":"4.png","post":"cl5sb8gg4002vxq0r185a81dv","modified":1,"renderable":0},{"_id":"source/_posts/GC-垃圾回收/5.png","slug":"5.png","post":"cl5sb8gg4002vxq0r185a81dv","modified":1,"renderable":0},{"_id":"source/_posts/GC-垃圾回收/6.png","slug":"6.png","post":"cl5sb8gg4002vxq0r185a81dv","modified":1,"renderable":0},{"_id":"source/_posts/GC-垃圾回收/7.png","post":"cl5sb8gg4002vxq0r185a81dv","slug":"7.png","modified":1,"renderable":1},{"_id":"source/_posts/GC-垃圾回收/8.png","post":"cl5sb8gg4002vxq0r185a81dv","slug":"8.png","modified":1,"renderable":1},{"_id":"source/_posts/算法核心框架整理-1/bubble_1.png","post":"cl5sb8gg90033xq0ra9m0qbt6","slug":"bubble_1.png","modified":1,"renderable":1},{"_id":"source/_posts/算法核心框架整理-1/bubble_2.png","post":"cl5sb8gg90033xq0ra9m0qbt6","slug":"bubble_2.png","modified":1,"renderable":1},{"_id":"source/_posts/算法核心框架整理-1/bubble_3.png","post":"cl5sb8gg90033xq0ra9m0qbt6","slug":"bubble_3.png","modified":1,"renderable":1},{"_id":"source/_posts/算法核心框架整理-1/bucket_1.png","post":"cl5sb8gg90033xq0ra9m0qbt6","slug":"bucket_1.png","modified":1,"renderable":1},{"_id":"source/_posts/算法核心框架整理-1/counting_1.png","post":"cl5sb8gg90033xq0ra9m0qbt6","slug":"counting_1.png","modified":1,"renderable":1},{"_id":"source/_posts/算法核心框架整理-1/heap_1.png","post":"cl5sb8gg90033xq0ra9m0qbt6","slug":"heap_1.png","modified":1,"renderable":1},{"_id":"source/_posts/算法核心框架整理-1/insertion_1.png","post":"cl5sb8gg90033xq0ra9m0qbt6","slug":"insertion_1.png","modified":1,"renderable":1},{"_id":"source/_posts/算法核心框架整理-1/merge_1.png","post":"cl5sb8gg90033xq0ra9m0qbt6","slug":"merge_1.png","modified":1,"renderable":1},{"_id":"source/_posts/算法核心框架整理-1/quick_1.png","post":"cl5sb8gg90033xq0ra9m0qbt6","slug":"quick_1.png","modified":1,"renderable":1},{"_id":"source/_posts/算法核心框架整理-1/radix_1.png","post":"cl5sb8gg90033xq0ra9m0qbt6","slug":"radix_1.png","modified":1,"renderable":1},{"_id":"source/_posts/算法核心框架整理-1/selection_1.png","post":"cl5sb8gg90033xq0ra9m0qbt6","slug":"selection_1.png","modified":1,"renderable":1},{"_id":"source/_posts/算法核心框架整理-1/shell_1.png","post":"cl5sb8gg90033xq0ra9m0qbt6","slug":"shell_1.png","modified":1,"renderable":1},{"_id":"source/_posts/算法核心框架整理-1/summary.png","slug":"summary.png","post":"cl5sb8gg90033xq0ra9m0qbt6","modified":1,"renderable":0},{"_id":"source/_posts/算法核心框架整理-1/type.png","post":"cl5sb8gg90033xq0ra9m0qbt6","slug":"type.png","modified":1,"renderable":1}],"PostCategory":[],"PostTag":[{"post_id":"cl5sb8geo0004xq0r6wb76mp9","tag_id":"cl5sb8gem0002xq0rdg08l97z","_id":"cl5sb8gew0007xq0r3o3k1sjm"},{"post_id":"cl5sb8geb0000xq0rclfhtgai","tag_id":"cl5sb8gem0002xq0rdg08l97z","_id":"cl5sb8gez0009xq0rinl4nntq"},{"post_id":"cl5sb8ger0005xq0r35jnfjw3","tag_id":"cl5sb8gem0002xq0rdg08l97z","_id":"cl5sb8gf2000cxq0rz5j5la37"},{"post_id":"cl5sb8gew0008xq0rfxwqiapv","tag_id":"cl5sb8gem0002xq0rdg08l97z","_id":"cl5sb8gf2000exq0rcu6r94a7"},{"post_id":"cl5sb8gek0001xq0rijzaekk2","tag_id":"cl5sb8gem0002xq0rdg08l97z","_id":"cl5sb8gf3000hxq0rpyzqhf5z"},{"post_id":"cl5sb8gen0003xq0r00sqt5ev","tag_id":"cl5sb8gem0002xq0rdg08l97z","_id":"cl5sb8gf4000jxq0rmyu93qxh"},{"post_id":"cl5sb8gez000axq0r56outezj","tag_id":"cl5sb8gf3000gxq0rkhotz4hx","_id":"cl5sb8gf5000nxq0r98q0i5nu"},{"post_id":"cl5sb8gf2000dxq0r6j36tklv","tag_id":"cl5sb8gf4000lxq0rfp749sqb","_id":"cl5sb8gf6000rxq0rgpi1htn1"},{"post_id":"cl5sb8gf5000oxq0rt7xpd2ig","tag_id":"cl5sb8gem0002xq0rdg08l97z","_id":"cl5sb8gf7000txq0ru3qjg1p2"},{"post_id":"cl5sb8gf6000qxq0rljs57mqn","tag_id":"cl5sb8gf3000gxq0rkhotz4hx","_id":"cl5sb8gf8000wxq0r3dg1glxw"},{"post_id":"cl5sb8gf2000fxq0re1z8zwbb","tag_id":"cl5sb8gf3000gxq0rkhotz4hx","_id":"cl5sb8gf90010xq0rm2gu4y2p"},{"post_id":"cl5sb8gf2000fxq0re1z8zwbb","tag_id":"cl5sb8gf7000uxq0rtedffj76","_id":"cl5sb8gfa0012xq0rae3t8zcn"},{"post_id":"cl5sb8gf3000ixq0r9opmppcl","tag_id":"cl5sb8gf9000yxq0rr4jtmjvy","_id":"cl5sb8gfb0015xq0rdpyc9mfl"},{"post_id":"cl5sb8gfa0013xq0rgwjnhq01","tag_id":"cl5sb8gf4000lxq0rfp749sqb","_id":"cl5sb8gfc0017xq0rsri7jf4l"},{"post_id":"cl5sb8gfb0016xq0riy2rg05y","tag_id":"cl5sb8gf9000yxq0rr4jtmjvy","_id":"cl5sb8gfd001axq0rc08t89av"},{"post_id":"cl5sb8gfb0016xq0riy2rg05y","tag_id":"cl5sb8gf3000gxq0rkhotz4hx","_id":"cl5sb8gfe001cxq0rr0e3k7t5"},{"post_id":"cl5sb8gf4000kxq0rhp7xemuk","tag_id":"cl5sb8gf9000yxq0rr4jtmjvy","_id":"cl5sb8gff001fxq0rpsfpti3z"},{"post_id":"cl5sb8gf4000kxq0rhp7xemuk","tag_id":"cl5sb8gf3000gxq0rkhotz4hx","_id":"cl5sb8gff001hxq0rw2c91p8k"},{"post_id":"cl5sb8gf4000mxq0ru1vwu3b6","tag_id":"cl5sb8gf9000yxq0rr4jtmjvy","_id":"cl5sb8gfg001kxq0rl164axiq"},{"post_id":"cl5sb8gf4000mxq0ru1vwu3b6","tag_id":"cl5sb8gf3000gxq0rkhotz4hx","_id":"cl5sb8gfh001mxq0rszb1raja"},{"post_id":"cl5sb8gff001gxq0r96402acc","tag_id":"cl5sb8gf9000yxq0rr4jtmjvy","_id":"cl5sb8gfh001pxq0rc6pkm465"},{"post_id":"cl5sb8gff001gxq0r96402acc","tag_id":"cl5sb8gf3000gxq0rkhotz4hx","_id":"cl5sb8gfi001rxq0rt7ra19xg"},{"post_id":"cl5sb8gf7000sxq0rzm0013kc","tag_id":"cl5sb8gf3000gxq0rkhotz4hx","_id":"cl5sb8gfj001uxq0rgrgn7lid"},{"post_id":"cl5sb8gf7000sxq0rzm0013kc","tag_id":"cl5sb8gfe001exq0r23ylxepj","_id":"cl5sb8gfk001wxq0rcsmn77zp"},{"post_id":"cl5sb8gff001ixq0rzbveqhl9","tag_id":"cl5sb8gf3000gxq0rkhotz4hx","_id":"cl5sb8gfk001xxq0rkft0u119"},{"post_id":"cl5sb8gff001ixq0rzbveqhl9","tag_id":"cl5sb8gfe001exq0r23ylxepj","_id":"cl5sb8gfl001zxq0rft2s4tis"},{"post_id":"cl5sb8gfg001lxq0rq8uupfb4","tag_id":"cl5sb8gf9000yxq0rr4jtmjvy","_id":"cl5sb8gfl0020xq0rk0nzlw5n"},{"post_id":"cl5sb8gfg001lxq0rq8uupfb4","tag_id":"cl5sb8gf3000gxq0rkhotz4hx","_id":"cl5sb8gfl0022xq0rwogy2k1m"},{"post_id":"cl5sb8gf7000vxq0rfhpx7c4j","tag_id":"cl5sb8gfg001jxq0rbtgyq57f","_id":"cl5sb8gfl0023xq0rs1fbexly"},{"post_id":"cl5sb8gf7000vxq0rfhpx7c4j","tag_id":"cl5sb8gf3000gxq0rkhotz4hx","_id":"cl5sb8gfl0025xq0r7k23ou0j"},{"post_id":"cl5sb8gfh001nxq0rsz7wnx6q","tag_id":"cl5sb8gf9000yxq0rr4jtmjvy","_id":"cl5sb8gfl0026xq0rz3p66xx1"},{"post_id":"cl5sb8gfh001nxq0rsz7wnx6q","tag_id":"cl5sb8gf3000gxq0rkhotz4hx","_id":"cl5sb8gfm0028xq0rmy4jrpoj"},{"post_id":"cl5sb8gfi001qxq0rpte47eqg","tag_id":"cl5sb8gf9000yxq0rr4jtmjvy","_id":"cl5sb8gfm0029xq0rhhaxxa6z"},{"post_id":"cl5sb8gfi001qxq0rpte47eqg","tag_id":"cl5sb8gf3000gxq0rkhotz4hx","_id":"cl5sb8gfm002bxq0r5h537m6z"},{"post_id":"cl5sb8gfi001sxq0ryjyv32yu","tag_id":"cl5sb8gf9000yxq0rr4jtmjvy","_id":"cl5sb8gfm002cxq0r88j79ecm"},{"post_id":"cl5sb8gfi001sxq0ryjyv32yu","tag_id":"cl5sb8gf3000gxq0rkhotz4hx","_id":"cl5sb8gfn002dxq0rjturpjbm"},{"post_id":"cl5sb8gfj001vxq0rv7ro2ev9","tag_id":"cl5sb8gf9000yxq0rr4jtmjvy","_id":"cl5sb8gfn002exq0r8o9fdiny"},{"post_id":"cl5sb8gfj001vxq0rv7ro2ev9","tag_id":"cl5sb8gf3000gxq0rkhotz4hx","_id":"cl5sb8gfn002fxq0r0h26dyrz"},{"post_id":"cl5sb8gf8000xxq0rkp8fld5z","tag_id":"cl5sb8gfh001oxq0rv1tr3xpz","_id":"cl5sb8gfn002gxq0rxpet5kru"},{"post_id":"cl5sb8gf8000xxq0rkp8fld5z","tag_id":"cl5sb8gfj001txq0rhaf2a8o0","_id":"cl5sb8gfn002hxq0rasa5gilc"},{"post_id":"cl5sb8gf9000zxq0rhu8h0goy","tag_id":"cl5sb8gf3000gxq0rkhotz4hx","_id":"cl5sb8gfn002ixq0ra4xpviuw"},{"post_id":"cl5sb8gf9000zxq0rhu8h0goy","tag_id":"cl5sb8gfe001exq0r23ylxepj","_id":"cl5sb8gfn002jxq0rf72b6vpy"},{"post_id":"cl5sb8gf90011xq0rhgi0otnb","tag_id":"cl5sb8gfl0021xq0rm5vobm6o","_id":"cl5sb8gfn002kxq0rlfhebczp"},{"post_id":"cl5sb8gf90011xq0rhgi0otnb","tag_id":"cl5sb8gf3000gxq0rkhotz4hx","_id":"cl5sb8gfn002lxq0rk37ptayj"},{"post_id":"cl5sb8gfc0018xq0rra113umn","tag_id":"cl5sb8gf3000gxq0rkhotz4hx","_id":"cl5sb8gfn002mxq0r807qd2v5"},{"post_id":"cl5sb8gfc0018xq0rra113umn","tag_id":"cl5sb8gfe001exq0r23ylxepj","_id":"cl5sb8gfn002nxq0rr6m0xeon"},{"post_id":"cl5sb8gfd001bxq0r0t9sza3s","tag_id":"cl5sb8gfl0021xq0rm5vobm6o","_id":"cl5sb8gfn002oxq0rjtnk4gd2"},{"post_id":"cl5sb8gfd001bxq0r0t9sza3s","tag_id":"cl5sb8gf3000gxq0rkhotz4hx","_id":"cl5sb8gfn002pxq0r6o5ks4qs"},{"post_id":"cl5sb8gfe001dxq0rghzxiv7k","tag_id":"cl5sb8gfl0021xq0rm5vobm6o","_id":"cl5sb8gfn002qxq0rjckx6cvc"},{"post_id":"cl5sb8gfe001dxq0rghzxiv7k","tag_id":"cl5sb8gf3000gxq0rkhotz4hx","_id":"cl5sb8gfn002rxq0raq1b3y0y"},{"post_id":"cl5sb8gg4002vxq0r185a81dv","tag_id":"cl5sb8gfe001exq0r23ylxepj","_id":"cl5sb8gg5002xxq0rh5k64mfj"},{"post_id":"cl5sb8gg1002sxq0raqlax616","tag_id":"cl5sb8gg4002uxq0rvzut96l2","_id":"cl5sb8gg70030xq0r9i1gyq4b"},{"post_id":"cl5sb8gg6002yxq0rc3rkq0f1","tag_id":"cl5sb8gf3000gxq0rkhotz4hx","_id":"cl5sb8gg90032xq0ryoukwjfu"},{"post_id":"cl5sb8gg6002yxq0rc3rkq0f1","tag_id":"cl5sb8gfe001exq0r23ylxepj","_id":"cl5sb8ggb0035xq0rp3ac25vg"},{"post_id":"cl5sb8gg70031xq0rdpqa70pe","tag_id":"cl5sb8gfl0021xq0rm5vobm6o","_id":"cl5sb8ggc0036xq0rgpm58wlp"},{"post_id":"cl5sb8gg70031xq0rdpqa70pe","tag_id":"cl5sb8gf3000gxq0rkhotz4hx","_id":"cl5sb8ggc0037xq0rgslsjhrf"},{"post_id":"cl5sb8gg3002txq0rdy25p1y3","tag_id":"cl5sb8gf3000gxq0rkhotz4hx","_id":"cl5sb8ggc0038xq0r0sz0xir9"},{"post_id":"cl5sb8gg3002txq0rdy25p1y3","tag_id":"cl5sb8gem0002xq0rdg08l97z","_id":"cl5sb8ggc0039xq0rg49xkxuh"},{"post_id":"cl5sb8gg3002txq0rdy25p1y3","tag_id":"cl5sb8gg6002zxq0rc8i46n3k","_id":"cl5sb8ggc003axq0rvaufub9k"},{"post_id":"cl5sb8gg90033xq0ra9m0qbt6","tag_id":"cl5sb8gg4002uxq0rvzut96l2","_id":"cl5sb8ggd003bxq0r7de021si"},{"post_id":"cl5sb8gg5002wxq0rq9i4vqf6","tag_id":"cl5sb8gga0034xq0r2pj2ezf0","_id":"cl5sb8ggd003cxq0r225qr3vp"},{"post_id":"cl5sb8gha003dxq0r4hip8tp3","tag_id":"cl5sb8gg6002zxq0rc8i46n3k","_id":"cl5sb8ghd003exq0rd5x1yyr9"},{"post_id":"cl5sb8gha003dxq0r4hip8tp3","tag_id":"cl5sb8gf3000gxq0rkhotz4hx","_id":"cl5sb8ghl003fxq0rqzhzlhsu"}],"Tag":[{"name":"随笔","_id":"cl5sb8gem0002xq0rdg08l97z"},{"name":"前端","_id":"cl5sb8gf3000gxq0rkhotz4hx"},{"name":"HEXO","_id":"cl5sb8gf4000lxq0rfp749sqb"},{"name":"vscode","_id":"cl5sb8gf7000uxq0rtedffj76"},{"name":"CSS","_id":"cl5sb8gf9000yxq0rr4jtmjvy"},{"name":"JS","_id":"cl5sb8gfe001exq0r23ylxepj"},{"name":"小程序","_id":"cl5sb8gfg001jxq0rbtgyq57f"},{"name":"JAVA","_id":"cl5sb8gfh001oxq0rv1tr3xpz"},{"name":"后端","_id":"cl5sb8gfj001txq0rhaf2a8o0"},{"name":"VUE","_id":"cl5sb8gfl0021xq0rm5vobm6o"},{"name":"算法","_id":"cl5sb8gg4002uxq0rvzut96l2"},{"name":"面试","_id":"cl5sb8gg6002zxq0rc8i46n3k"},{"name":"JSON","_id":"cl5sb8gga0034xq0r2pj2ezf0"}]}}